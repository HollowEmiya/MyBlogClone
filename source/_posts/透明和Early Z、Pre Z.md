---
title: 透明和earlyZ
date: 2022-05-31 20:52:39
tags: 
typora-root-url: ./..
---
  
白天和群友吹水，发现自己对于透明测试和透明混合，包括earlyZ和PreZ理解不够，所以记录一下，方便自己复习巩固。
  
<!--more-->
  
# 透明和Early Z、Pre Z
  
## Early Z
  
提到Early Z就不得不提深度测试，深度测试简单来说就是解决物体前后遮挡的一直技术。  
具体就不展开了，根据物体的深度信息与深度缓存区的深度信息进行对比，决定该像素是否绘制，如深度更小即该像素更靠前就覆写深度信息。
  
深度测试有一个问题就是如果已经绘制的像素被遮挡了，那么我们只能舍弃，但是之前绘制被遮挡像素的工作就白做了，造成了资源的消耗，那么为了解决或者说减少这种问题，就有了提前深度测试Early Z，来解决过度不必要的片元着色计算。
  
<img src="/imgs/透明和Early Z、Pre Z/渲染流程.png" alt="来源百人计划">
  
Early Z将在片元着色器前一个阶段进行，进行Early Z会直接进行深度判断，不进行计算直接进行舍弃(*在Early Z不仅判断深度通常也会写入深度*)，这样就节省了不必要计算量，通常Early Z由硬件进行，并且Early Z还可以添加模板测试。
  
### Early Z失效
  
* 开启Alpha Test 或者手动丢弃片元等操作，如clip  
  因为Early Z也会写入深度，如果深度较浅的像素在shader中被丢弃了，后续的像素如果深度大于该像素，就都被舍弃了，但是我们在alpha test中本应该仍对后续的片元进行透明度测试，所以由于Early Z我们没有得到预期的结果。( Alpha Test 中如果透明度 alpha 越低表示越透明，当达到我们要的阈值就舍弃该片元达到透明的效果 )
  
* 手动修改GPU插值得到的深度值  
  和上述情况类似。
  
* 开启透明混合(Alpha Blend)  
  这里是针对关闭深度写入(`ZWrite Off`)的Alpha Blend
  
* 关闭深度测试(Depth Test)  
  就是关闭了深度测试，因为Early Z也是一种深度测试，自然无法进行。
  
**如果从远向近渲染Early Z就白做了，因为所渲染的片元都可以通过测试，但是后续还是会被舍弃，并没有节省不必要的计算**
  
### 高效利用
  
可以用CPU对物体从近到远排序就可最大利用，但是如果场景过于复杂性能消耗就很大而且严格的从近道远很难应用批处理这种优化手段。
  
## Z PrePass
  
### 使用两个Pass：
  
* 在第一个Pass(Prepass)仅仅只写入深度，关闭颜色写入，我们就可以得到场景的物体深度信息。
  
* 在第二个Pass中关闭深度写入，并且深度比较设置为相等，这样基于第一个Pass的深度信息我们就能得到想要的效果。 
  
#### 问题
  
动态批处理问题：因为运用多个pass所以无法运用动态批处理。  
所以会进一步带来Draw Call问题，运用了Z-Prepass会导致Draw Call增加，会造成一定的性能损失。
  
### 提前分离PrePass
  
仍然使用两个Pass，但是是两个Shader
  
* 将原来用以深度信息的Pass(Z-Prepass)单独作为一个Shader，用此Shader对整个场景的Opaque物体进行一次渲染，得到深度信息。
  
* 而原本的材质只保留第二个Pass，但是依旧需要关闭深度写入，并且将深度比较函数设置为相等。
  
Z-Prepass也通常用于透明混合，解决了透明物体前后错误的问题，因为透明混合往往要关闭深度写入；但是这样看不到物体背面，如果想要背面，我们可以**先渲染背面剔除正面，再渲染正面剔除背面**，这样就可以正常混合。
  
### 谨慎使用Z-Prepass
  
是否使用Z-Prepass要视我们的场景而定，如果场景overdraw过多又不能很好的进行远近排序，那么Z-Prepass带来的优化效果会比overdraw的消耗小很多，所以使用与否也需要我们来权衡，也是很依赖经验的过程。
  
## 透明
  
### 两种透明方式
  
* 透明度测试(alpha test): 一般会根据alpha通道的值即透明度进行片元的剔除，不满足条件便直接舍弃，通过则按正常片元处理，所以透明度测试**不需要关闭深度写入，由于直接舍弃所以展现出来的效果很极端。
  
  ```  
  // 剔除片元  
  fixed4 frag(v2f i) : SV_Target  
  {  
      fixed4 col = tex2D(_MainTex, i.uv);  
      clip(col.a - _CutOff)  
  }  
  ```
  
* 透明度混合(alpha blend): 这个是我们在现实世界看到的透明效果，一般会根据片元的透明度，透明度混合需要我们关闭深度写入，因为我们需要根据颜色缓存区中的颜色来进行混合，**如果不关闭深度写入假如在一个透明物体背后有一个不透明物体，就会导致在后面的不透明物体被剔除**，我们想要的本应该能透过透明物体观察到不透明物体。同时如果开启深度写入，透明物体如果有🍌的情况，会造成原本能被看见物体因为object level的排序被剔除的问题。
  
#### 关于透明混合渲染顺序
  
因为我们在透明混合中关闭了深度写入，破坏了深度缓存工作机制，所以渲染顺序十分重要。在关闭深度写入后对于深度缓存区就是只读的状态，假设我们的场景中有一个透明物体在前、不透明物体之后。
  
<div style="margin:;width:30%"><img src="/imgs/透明和Early Z、Pre Z/BT.jpg" alt="一个透明物体在前、不透明物体之后"></div>
  
如果先渲染不透明物体，再渲染透明物体，看起来效果很正常。
  
<div style="margin:right;width:30%"><img src="/imgs/透明和Early Z、Pre Z/TB.jpg" alt="先渲染透明物体，再渲染不透明物体"></div>
  
但是如果先渲染透明物体，再渲染不透明物体我们就会看到场景中不透明物体部分被剔除了。
  
所以在应用透明技术时，要格外注意渲染顺序。通常我们的渲染顺序是：  
1、正常渲染所有不透明物体，保持深度测试和深度写入；  
2、把透明物体按从远及近的顺序渲染，**开启深度测试，但是要关闭深度写入**。  
      有个问题是我们怎样界定物体的先后，这个和深度测试需要做区分，深度测试是针对像素的，而我们渲染是一个物体一个物体这样进行绘制的，我们需要的绘制顺序是针对物体而言的。很多时候我们场景中的物体不是有着绝对明确的前后关系，而会有着交错的关系。我们很难确定一个点来明确物体合适的前后关系，解决问题的方法通常是使用分割网格，并且为了减少错误尽量保持模型为凸多边形，并进行合理的子模型划分。
  
<div style="margin:auto;width:30%"><img src="imgs/透明和Early Z、Pre Z/qh.jpg" alt="前后关系"></div>
  
#### 开启深度写入的半透明
  
这种方法往往是针对一个半透明物体内部前后关系错误的问题，就会用到我们介绍的Z-prePass，注意我们现在在渲染透明物体其他不透明物体已经绘制过了，换句话说缓存中已经有颜色我们是做混合，在第一个pass中写入透明物体的深度值，在第二个根据深度信息进行透明混合的渲染，这样就可以得到前后关系正确的半透明效果。(但是看不到透明物体的背面)
  
#### 双面透明
  
对于透明物体只能观测到正面的问题，我们可以用一个Pass先渲染背面剔除正面，然后再用一个Pass渲染正面剔除背面，这种情况只需关闭深度写入的透明混合即可，不需要上面的Z-prepass，我之前老是有些分不清。
  
透明和early z就先写到这吧，做一些复习用所以只概述了技术的大体思路，没有贴什么代码和具体细节，其实我GitHub上有，不过懒得贴了(  
关于透明物体顺序问题还有OIT技术。  