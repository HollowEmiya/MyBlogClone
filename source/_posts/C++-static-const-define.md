---
title: C++之static,const,define
date: 2022-05-02 13:11:42
tags: 

---
  
在C++中有几个看上去不同，一想却有几分相同，但细究的确不同的修饰符，这里记述一下关于static,const,define这几个小伙子。
  
<!--more-->
  
# static
  
## 静态数据的存储
  
> 全局(静态)存储区：(狗屎机翻说的都不是人话)  
>   
> 分为DATA段与BSS段。  
> DATA段(全局初始化区): 存放初始化的全局变量和静态变量。  
> BSS段(全局未初始化区): 存放未初始化的全局变量和静态变量。  
> 程序结束时全局存储器自动释放，BSS段会在程序执行前被系统自动清0，即未初始化的全局变量和静态变量在程序执行之前已经为0。  
> 在**静态数据区的变量会在程序开始时，就完成初始化，也是唯一的一次初始化**。
  
### static对于变量
  
**1.局部变量**
  
在局部变量前加上关键字`static`，其将被定义为局部静态变量。
  
内存位置: 静态存储区  
初始化: 局部的静态变量只被初始化一次  
作用域: 作用域仍为局部作用域，数据仍在局部可见，定义它的函数或者语句块结束的时候，作用域随之结束。
  
> 当`static`作用于局部变量时，改变了其存储位置，从栈转存到静态存储区，也改变了生存周期，在离开作用域后变量没有被销毁，仍存储在内存中，只是保留了原有的可见性，即没改变作用域，在程序结束后释放其占用的内存。
  
**2.全局变量**
  
在全局变量上作用，其变为全局静态变量。
  
内存位置: 静态存储区；  
初始化: 未经初始化的全局变量自动初始化为0；  
作用域: 全局静态变量作用于当前文件，即在声明他的文件外是不可见的，只能在本文件中使用。
  
>  全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。但二者区别在于非静态全局变量作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的 **(在其他源文件中使用时加上`extern`关键字重新声明即可)**。而静态全局变量反而限制了其作用域，即限定为定义该变量的源文件中有效，在同一源程序中的其他源文件中无法使用。
  
### static对于函数
  
修饰普通函数，表明函数的作用范围，仅仅在定义该函数的文件内才能使用。在多人开发过程中可以使用这个技巧，把函数作用域同上述的全局变量一样，限制在该文件内，防止和他人函数重名。
  
### static对于类
  
**1.成员变量**
  
用`static`修饰类的数据成员，使其成为**类的全局变量**，被所有类的对象共享，**包括派生类的对象！**  
因此`static`成员必须在类外进行初始化，而不能在构造函数内进行初始化，不过也可以使用`const`修饰`static`数据成员在类内初始化。
  
```cpp  
class MyClass  
{  
public:  
    static int staticNum;  
    MyClass();  
    ~MyClass();      
}
  
int MyClass::staticNum = 1;  
```
  
**2.成员函数**
  
用`static`修饰成员函数，使整个类只存在一份这个函数，所有对象共享，**不含`this`指针**。  
静态成员是可以独立访问的，无需创建任何实例就能调用。
  
**不可以同时用`const`和`static`修饰*成员函数*。**
  
# const
  
* 限定变量不可修改。
  
* 限定成员函数不能修改任何数据成员。
  
## const 和 指针
  
* 指向常量的指针
  
```cpp  
// 第一种  
int a = 2;  
int b = 4;  
int const *p;  
const int *p = &a;  
cout<<"a:"<<*p<<endl;    // 2  
a++;  
cout<<"a:"<<**p<<endl;    // 3  
p = &b;  
cout<<"b:"<<*p<<endl;  
```
  
`const int *p`和`int const *p`一样，`const`修饰`int`，在`p`看来`a`是常量，所以不能用`(*p)++`修改数据，但是可以`a++`修改，因为`a`实际就是普通变量，只是`cont int *p`一厢情愿罢了。
  
* 指针常量
  
```cpp  
int a = 2;  
int b = 4;  
int* const p = &a;  
cout << "a:" << *p << endl;    // 2  
a++;                           // 3  
(*p)++;                        // 4  
cout << "a:" << *p << endl;    // 4  
```
  
`int* const` 的 `const` 修饰 `int*`，表示**该指针是常量，初始化后无法修改**，但是**其指向对象可以修改**。`p` 指向的是 `int` 类型，不是`const int` 类型，`const int* const` 才是指向 `const int` 类型。
  
# static和const可以同时修饰成员函数吗？
  
不可以，C++编译器在实现`const`的成员函数时，为了确保该函数不能修改类的实例状态，会在函数中添加一个隐式的参数`const this*`。但当一个成员为`static`时，该函数是没有`this`指针的，就是说`const`和`static`冲突了，相互矛盾。  
`static`是表示该函数只作用在类型的静态变量上，与类的实例没有关系；  
`const`是确保函数不能修改实例的状态，与类型的静态变量没有关系。  
二者一个脱离实例，一个保护实例。
  
## const 和 #define 定义常量的区别
  
* 编译器处理方式不同:  
  define: 是“编译时”的概念，在预处理阶段进行替换。  
  const: 是“运行时”的概念，在编译阶段确定其值
  
* 类型检查:   
  define: 无类型，不进行类型安全检查，可能会产生  
  const:  有数据类型，编译时会检查
  
* 内存空间:  
  define: 不分配内存，给出立即数，使用几次就进行几次替换，内存中会有多个拷贝，消耗大。  
  const: 在静态存储区分配空间，程序运行中在内存中仅有一次拷贝。
  
* 函数参数:   
  宏定义不能作为参数传递给函数。  
  const常量可以在函数的参数列表中出现。
  
* 在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储和读内存的操作，效率高。
  
* define宏替换只做替换，不做表达式计算。
  
# typedef 与 #define 的区别
  
## typedef
  
`typedef`即类型定义的意思，就是给已有类型起别名。可以简化那些繁琐的类型名；也可以一定程度忽视不同平台的差异，不同平台见只需要修改`typedef`即可。
  
## #define
  
`#define`为宏定义语句，就是文本替换
  
## 区别
  
* `typedef`关键字在编译阶段有效，由于是在编译阶段，因此`typedef`有类型检查的功能。`#define`是宏定义，发生在预处理阶段，即编译之前，只是简单的字符替换，没有进行任何检查。
  
* `#define`没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而`typedef`有自己的定义域。
  
* 对指针操作不同: 
  
```cpp  
typedef int * pint  
#define PINT int *
  
int i1 = 2, i2 = 3, i3 = 4;
  
const pint p1 = &i1;    // p1不可更改，相当于 int* const  
const PINT p2 = &i2;    // p2可以修改，因为就是 const int *  
PINT const p3 = &i3;    // p3本身不可以修改，就是 int * const  
```
  
相关链接：  
[C++头文件，预处理详解 - lulipro - 博客园](https://www.cnblogs.com/lulipro/p/5976601.html)  
[C++中的static](https://zhuanlan.zhihu.com/p/152046509)  