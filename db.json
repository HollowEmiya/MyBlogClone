{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"source/imgs/C++-sort-浅识/sort.png","path":"imgs/C++-sort-浅识/sort.png","modified":0,"renderable":0},{"_id":"source/imgs/C++-sort-浅识/题目-1677565078882-1.png","path":"imgs/C++-sort-浅识/题目-1677565078882-1.png","modified":0,"renderable":0},{"_id":"source/imgs/C++RAII/35.png","path":"imgs/C++RAII/35.png","modified":0,"renderable":0},{"_id":"source/imgs/CMake Note/Qt5Error.png","path":"imgs/CMake Note/Qt5Error.png","modified":0,"renderable":0},{"_id":"source/imgs/Hexo主题变更/Fluid_Config.png","path":"imgs/Hexo主题变更/Fluid_Config.png","modified":0,"renderable":0},{"_id":"source/imgs/CMake Note/Qt5CannotFound.png","path":"imgs/CMake Note/Qt5CannotFound.png","modified":0,"renderable":0},{"_id":"source/imgs/Hexo主题变更/Shiki&Tsukihime.png","path":"imgs/Hexo主题变更/Shiki&Tsukihime.png","modified":0,"renderable":0},{"_id":"source/imgs/Hexo主题变更/deskt.png","path":"imgs/Hexo主题变更/deskt.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/AnisoSphere2.png","path":"imgs/LearnPBR/AnisoSphere2.png","modified":0,"renderable":0},{"_id":"source/imgs/Hexo主题变更/pandoc1-1.png","path":"imgs/Hexo主题变更/pandoc1-1.png","modified":0,"renderable":0},{"_id":"source/imgs/Hexo主题变更/pandoc1.png","path":"imgs/Hexo主题变更/pandoc1.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/BRDF.svg","path":"imgs/LearnPBR/BRDF.svg","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/G.png","path":"imgs/LearnPBR/G.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/IBLCubemap.png","path":"imgs/LearnPBR/IBLCubemap.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/Kulla-Conty.png","path":"imgs/LearnPBR/Kulla-Conty.png","modified":0,"renderable":0},{"_id":"source/imgs/Hexo主题变更/web.png","path":"imgs/Hexo主题变更/web.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/Radiance.png","path":"imgs/LearnPBR/Radiance.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/boban.jpg","path":"imgs/LearnPBR/boban.jpg","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/chart2.png","path":"imgs/LearnPBR/chart2.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/chart1.png","path":"imgs/LearnPBR/chart1.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/fresnel.png","path":"imgs/LearnPBR/fresnel.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/chart3.png","path":"imgs/LearnPBR/chart3.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/ggx.png","path":"imgs/LearnPBR/ggx.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/ibl1.png","path":"imgs/LearnPBR/ibl1.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/ibl2.png","path":"imgs/LearnPBR/ibl2.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/iblAlpha.png","path":"imgs/LearnPBR/iblAlpha.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/metallic.png","path":"imgs/LearnPBR/metallic.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/microfacet.png","path":"imgs/LearnPBR/microfacet.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/output.PNG","path":"imgs/LearnPBR/output.PNG","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/output2.PNG","path":"imgs/LearnPBR/output2.PNG","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/output4-1.PNG","path":"imgs/LearnPBR/output4-1.PNG","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/output3.PNG","path":"imgs/LearnPBR/output3.PNG","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/pbr.png","path":"imgs/LearnPBR/pbr.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/poban.jpg","path":"imgs/LearnPBR/poban.jpg","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/roughness.png","path":"imgs/LearnPBR/roughness.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/reflect.png","path":"imgs/LearnPBR/reflect.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/roughness2.png","path":"imgs/LearnPBR/roughness2.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/sample.png","path":"imgs/LearnPBR/sample.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/ueReference.png","path":"imgs/LearnPBR/ueReference.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/specular.png","path":"imgs/LearnPBR/specular.png","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/uecode1.png","path":"imgs/LearnPBR/uecode1.png","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/2022.6.15.jpg","path":"imgs/MoyuPics/2022.6.15.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/20221114EyeCue.jpg","path":"imgs/MoyuPics/20221114EyeCue.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/22-6-22.jpg","path":"imgs/MoyuPics/22-6-22.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/220630jo.jpg","path":"imgs/MoyuPics/220630jo.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/220702CF.jpg","path":"imgs/MoyuPics/220702CF.jpg","modified":0,"renderable":0},{"_id":"source/imgs/LearnPBR/uecode2.png","path":"imgs/LearnPBR/uecode2.png","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/220702P2.jpg","path":"imgs/MoyuPics/220702P2.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/220702P1.jpg","path":"imgs/MoyuPics/220702P1.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/220702P4.jpg","path":"imgs/MoyuPics/220702P4.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/220702光头.jpg","path":"imgs/MoyuPics/220702光头.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/220702P3.jpg","path":"imgs/MoyuPics/220702P3.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/5.29.jpg","path":"imgs/MoyuPics/5.29.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/617e.jpg","path":"imgs/MoyuPics/617e.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/5.30.jpg","path":"imgs/MoyuPics/5.30.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/617w.jpg","path":"imgs/MoyuPics/617w.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/617m.jpg","path":"imgs/MoyuPics/617m.jpg","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/eye614.jpg","path":"imgs/MoyuPics/eye614.jpg","modified":0,"renderable":0},{"_id":"source/imgs/VisualStudioPro/Vs1.png","path":"imgs/VisualStudioPro/Vs1.png","modified":0,"renderable":0},{"_id":"source/imgs/VisualStudioPro/Vs2.png","path":"imgs/VisualStudioPro/Vs2.png","modified":0,"renderable":0},{"_id":"source/imgs/一些数学推导/重心坐标1.png","path":"imgs/一些数学推导/重心坐标1.png","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/starve.jpg","path":"imgs/MoyuPics/starve.jpg","modified":0,"renderable":0},{"_id":"source/imgs/一些数学推导/重心坐标2.png","path":"imgs/一些数学推导/重心坐标2.png","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/卷发5.26.jpg","path":"imgs/MoyuPics/卷发5.26.jpg","modified":0,"renderable":0},{"_id":"source/imgs/ZumaGame/question.png","path":"imgs/ZumaGame/question.png","modified":0,"renderable":0},{"_id":"source/imgs/PBR/BSDF.png","path":"imgs/PBR/BSDF.png","modified":0,"renderable":0},{"_id":"source/imgs/MoyuPics/边缘.jpg","path":"imgs/MoyuPics/边缘.jpg","modified":0,"renderable":0},{"_id":"source/imgs/PBR/jihe.png","path":"imgs/PBR/jihe.png","modified":0,"renderable":0},{"_id":"source/imgs/PBR/math3.png","path":"imgs/PBR/math3.png","modified":0,"renderable":0},{"_id":"source/imgs/PBR/math2.png","path":"imgs/PBR/math2.png","modified":0,"renderable":0},{"_id":"source/imgs/PBR/math4.png","path":"imgs/PBR/math4.png","modified":0,"renderable":0},{"_id":"source/imgs/PBR/math1.png","path":"imgs/PBR/math1.png","modified":0,"renderable":0},{"_id":"source/imgs/PBR/math5.png","path":"imgs/PBR/math5.png","modified":0,"renderable":0},{"_id":"source/imgs/PBR/math6.png","path":"imgs/PBR/math6.png","modified":0,"renderable":0},{"_id":"source/imgs/PBR/math7.png","path":"imgs/PBR/math7.png","modified":0,"renderable":0},{"_id":"source/imgs/PBR/phong.png","path":"imgs/PBR/phong.png","modified":0,"renderable":0},{"_id":"source/imgs/关于SRP Batcher/OldMaterial.jpg","path":"imgs/关于SRP Batcher/OldMaterial.jpg","modified":0,"renderable":0},{"_id":"source/imgs/PBR/几何遮蔽.png","path":"imgs/PBR/几何遮蔽.png","modified":0,"renderable":0},{"_id":"source/imgs/关于SRP Batcher/SRPPerObject.jpg","path":"imgs/关于SRP Batcher/SRPPerObject.jpg","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/DirectionLight.png","path":"imgs/大气散射/DirectionLight.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/InScattering.PNG","path":"imgs/大气散射/InScattering.PNG","modified":0,"renderable":0},{"_id":"source/imgs/关于SRP Batcher/SRPPipeline2.jpg","path":"imgs/关于SRP Batcher/SRPPipeline2.jpg","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/OutScattering.png","path":"imgs/大气散射/OutScattering.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/OutScattering2.PNG","path":"imgs/大气散射/OutScattering2.PNG","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/NumericalIntegration.png","path":"imgs/大气散射/NumericalIntegration.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/RayleighScattering.png","path":"imgs/大气散射/RayleighScattering.png","modified":0,"renderable":0},{"_id":"source/imgs/关于SRP Batcher/SRPPipeline.jpg","path":"imgs/关于SRP Batcher/SRPPipeline.jpg","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/Res01.png","path":"imgs/大气散射/Res01.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/Res02.png","path":"imgs/大气散射/Res02.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/Res03.png","path":"imgs/大气散射/Res03.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/ScatteringFunc.png","path":"imgs/大气散射/ScatteringFunc.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/SingleScattering.PNG","path":"imgs/大气散射/SingleScattering.PNG","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/Trasmittance2.png","path":"imgs/大气散射/Trasmittance2.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/Trasmittance.png","path":"imgs/大气散射/Trasmittance.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/chart.png","path":"imgs/大气散射/chart.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/chart2.png","path":"imgs/大气散射/chart2.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/height.png","path":"imgs/大气散射/height.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/math.png","path":"imgs/大气散射/math.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/4x4Matrix.png","path":"imgs/SpringBoss/4x4Matrix.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/4x4Rn.png","path":"imgs/SpringBoss/4x4Rn.png","modified":0,"renderable":0},{"_id":"source/imgs/大气散射/math2.png","path":"imgs/大气散射/math2.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/C_ambient.png","path":"imgs/SpringBoss/C_ambient.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/BlinnPhong.png","path":"imgs/SpringBoss/BlinnPhong.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/C_diffuse.png","path":"imgs/SpringBoss/C_diffuse.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/C_emissive.png","path":"imgs/SpringBoss/C_emissive.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/LeftRight.png","path":"imgs/SpringBoss/LeftRight.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/ModelCol.png","path":"imgs/SpringBoss/ModelCol.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/Mview.png","path":"imgs/SpringBoss/Mview.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/ModelRow.png","path":"imgs/SpringBoss/ModelRow.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/NormalLightEyeRef.png","path":"imgs/SpringBoss/NormalLightEyeRef.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/PhongSpecular.png","path":"imgs/SpringBoss/PhongSpecular.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/Polar.png","path":"imgs/SpringBoss/Polar.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/RayPointSpe.png","path":"imgs/SpringBoss/RayPointSpe.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/RefEqu.png","path":"imgs/SpringBoss/RefEqu.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/Rview.png","path":"imgs/SpringBoss/Rview.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/cameraETG.png","path":"imgs/SpringBoss/cameraETG.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/colMHC.png","path":"imgs/SpringBoss/colMHC.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/cameraXYZ.png","path":"imgs/SpringBoss/cameraXYZ.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/colMHCT.png","path":"imgs/SpringBoss/colMHCT.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/columnMatrix.png","path":"imgs/SpringBoss/columnMatrix.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/orthM.png","path":"imgs/SpringBoss/orthM.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/posE.png","path":"imgs/SpringBoss/posE.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/rotationX.png","path":"imgs/SpringBoss/rotationX.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/rotationY.png","path":"imgs/SpringBoss/rotationY.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/rotationZ.png","path":"imgs/SpringBoss/rotationZ.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/rowMatrix.png","path":"imgs/SpringBoss/rowMatrix.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/rowMatrixHC.png","path":"imgs/SpringBoss/rowMatrixHC.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/rowMatrixHCT.png","path":"imgs/SpringBoss/rowMatrixHCT.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/scale.png","path":"imgs/SpringBoss/scale.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/transform.png","path":"imgs/SpringBoss/transform.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/translate.png","path":"imgs/SpringBoss/translate.png","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/unityUpdate.jpg","path":"imgs/SpringBoss/unityUpdate.jpg","modified":0,"renderable":0},{"_id":"source/imgs/包围盒与物体碰撞/AABB&OBB.jfif","path":"imgs/包围盒与物体碰撞/AABB&OBB.jfif","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/viewT.png","path":"imgs/SpringBoss/viewT.png","modified":0,"renderable":0},{"_id":"source/imgs/常见设计模式/Proxy.jpg","path":"imgs/常见设计模式/Proxy.jpg","modified":0,"renderable":0},{"_id":"source/imgs/SpringBoss/viewMatrixMyNote.png","path":"imgs/SpringBoss/viewMatrixMyNote.png","modified":0,"renderable":0},{"_id":"source/imgs/常见设计模式/StrategyUML.png","path":"imgs/常见设计模式/StrategyUML.png","modified":0,"renderable":0},{"_id":"source/imgs/每日Emo小短句/F1SZC9}W}_XEA5S]5FCJM3.png","path":"imgs/每日Emo小短句/F1SZC9}W}_XEA5S]5FCJM3.png","modified":0,"renderable":0},{"_id":"source/imgs/读刘盆子传/zzpbzb.JPG","path":"imgs/读刘盆子传/zzpbzb.JPG","modified":0,"renderable":0},{"_id":"source/imgs/水面模拟/InterstellarSeaWave.png","path":"imgs/水面模拟/InterstellarSeaWave.png","modified":0,"renderable":0},{"_id":"source/imgs/水面模拟/directionWave.png","path":"imgs/水面模拟/directionWave.png","modified":0,"renderable":0},{"_id":"source/imgs/水面模拟/kWave.png","path":"imgs/水面模拟/kWave.png","modified":0,"renderable":0},{"_id":"source/imgs/水面模拟/waveNV1.png","path":"imgs/水面模拟/waveNV1.png","modified":0,"renderable":0},{"_id":"source/imgs/水面模拟/waveNV2.png","path":"imgs/水面模拟/waveNV2.png","modified":0,"renderable":0},{"_id":"source/imgs/水面模拟/waveparameters.png","path":"imgs/水面模拟/waveparameters.png","modified":0,"renderable":0},{"_id":"source/imgs/透明和Early Z、Pre Z/BT.jpg","path":"imgs/透明和Early Z、Pre Z/BT.jpg","modified":0,"renderable":0},{"_id":"source/imgs/透明和Early Z、Pre Z/TB.jpg","path":"imgs/透明和Early Z、Pre Z/TB.jpg","modified":0,"renderable":0},{"_id":"source/imgs/透明和Early Z、Pre Z/qh.jpg","path":"imgs/透明和Early Z、Pre Z/qh.jpg","modified":0,"renderable":0},{"_id":"source/imgs/透明和Early Z、Pre Z/先透后不.jpg","path":"imgs/透明和Early Z、Pre Z/先透后不.jpg","modified":0,"renderable":0},{"_id":"source/imgs/透明和Early Z、Pre Z/先不后透.jpg","path":"imgs/透明和Early Z、Pre Z/先不后透.jpg","modified":0,"renderable":0},{"_id":"source/imgs/透明和Early Z、Pre Z/渲染流程.png","path":"imgs/透明和Early Z、Pre Z/渲染流程.png","modified":0,"renderable":0},{"_id":"source/imgs/C++/虚继承.jpg","path":"imgs/C++/虚继承.jpg","modified":0,"renderable":0},{"_id":"themes/fluid/source/js/umami-view.js","path":"js/umami-view.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/C++-Smart-pointers.md","hash":"365f14942e66dd2fe9e4fd60480e2e5a15863d59","modified":1755013204825},{"_id":"source/_posts/C++-sort-浅识.md","hash":"fb0432995a14e553cb987f1ed2755f5f607f5ba4","modified":1755013198025},{"_id":"source/_posts/C++-static-const-define.md","hash":"feb5f339c5d1102bf50c9bf87a7326f777a0eacb","modified":1755013212567},{"_id":"source/_posts/C++11之function和lambda.md","hash":"b51280e7ac4269bf4f1933d0b1604e3aa5e4a430","modified":1705219988470},{"_id":"source/_posts/C++11之多线程.md","hash":"688f9105ba7ecc3d15f118752e12936608a13c97","modified":1705219988471},{"_id":"source/_posts/C++RAII.md","hash":"ac7c0192290e071b2635cb85fcb97bb16810f7aa","modified":1705219988471},{"_id":"source/_posts/Dissolve-in-Unity.md","hash":"e1dec56df367b49b6a229f53472bc69b06140aaa","modified":1755013329128},{"_id":"source/_posts/Hexo主题更改.md","hash":"2bdf7e2b785eeb566ac40bedd0fea7f5303df774","modified":1755013335778},{"_id":"source/_posts/GPU Driven And Hierarchical Z-Buffer.md","hash":"cc40c74be8bcb164b94b572f1c608b6a6a0f4639","modified":1740329563882},{"_id":"source/_posts/LearnPBR.md","hash":"076fbfae74a12a4795a028aa5196fa4207bf4721","modified":1714912824632},{"_id":"source/_posts/MoyuPics.md","hash":"a537bc84d0931ec6d5e421614ff6eec7c110b1de","modified":1705219988473},{"_id":"source/_posts/New-Start.md","hash":"eb971f1a757979d62d0a5fdd4f038235fa002aea","modified":1705219988473},{"_id":"source/_posts/PBR.md","hash":"161f3cc850db4e3287e7a79255436519bf8b8be3","modified":1705219988473},{"_id":"source/_posts/SpringBoss.md","hash":"1892c9705eeb806755cd3bd857fd398dc22df283","modified":1755013358344},{"_id":"source/_posts/VisualStudioPro.md","hash":"e07b9e8c1c2754db6d58661758fbe272fedf79bf","modified":1705219988474},{"_id":"source/_posts/一些配置环境教程.md","hash":"7e75e79f688be7dacc154747f071ead7034d0eb4","modified":1705219988474},{"_id":"source/_posts/关于SRP Batcher.md","hash":"a7fe19fb79c6f2f6412411a29186588f5cf01560","modified":1740329576986},{"_id":"source/_posts/关于透视矫正插值.md","hash":"671f7f29d2e4f8dbdc333e128f6ab4eb2921be5c","modified":1755281675274},{"_id":"source/_posts/刀光特效.md","hash":"eed8497ef6110411ae23b84cb2adb968770ac10e","modified":1755281668576},{"_id":"source/_posts/包围盒与物体碰撞.md","hash":"e9f738f58964bb865d47d9e9c974d406d3af8ede","modified":1705219988474},{"_id":"source/_posts/大气散射.md","hash":"f884b661148c0ac8b17eea66e3c8c4d0c47117c0","modified":1714191190762},{"_id":"source/_posts/排序算法.md","hash":"1ee7a69e3fb46822aa5eacdc11a7cc68ba8c646a","modified":1755013320824},{"_id":"source/_posts/常见设计模式.md","hash":"de4880b7cbba31f96818c65bc950d7ceec510a09","modified":1705219988474},{"_id":"source/_posts/球谐函数.md","hash":"2594723bc6921b4fc191aae001eb10ec94c8af41","modified":1705219988475},{"_id":"source/_drafts/AlgorithmNote.md","hash":"26c6a46c62fd39aec0a680d9503dd8170d00cfba","modified":1705219988468},{"_id":"source/_drafts/C++-Threading.md","hash":"b2be6e7d4c8ffcdaaad083bfd19479db52a3a702","modified":1705219988469},{"_id":"source/_drafts/C++VectorPush_back.md","hash":"3adaa1005f4974a99e86634e4d8d9310ff20a81e","modified":1705219988469},{"_id":"source/_posts/紧急说明.md","hash":"73dab8100b5094dbcdbd22b201aa2bc1b973d633","modified":1755013307065},{"_id":"source/_posts/读刘盆子传.md","hash":"8352e5899bbd08d176490cfbb0086f8d49e5bd08","modified":1714190391832},{"_id":"source/_drafts/Lua学习.md","hash":"f3f04bafa229fd1b49d975d93686c574fe99f83c","modified":1705219988469},{"_id":"source/_drafts/C++多线程.md","hash":"0fc897b251b86b563e3731cb2b8ff1a4296cedab","modified":1705219988469},{"_id":"source/_posts/透明和Early Z、Pre Z.md","hash":"a4d9ba1a5ace12ec9f42e974849b219cca4eaa35","modified":1705219988476},{"_id":"source/_drafts/SubsurfaceScattering.md","hash":"e753e57463c65a46995bbc56e1b932a171522e97","modified":1714826897010},{"_id":"source/_drafts/ZumaGame.md","hash":"9ba4403dd1008325b8bb38d99c46b2e69ea381fe","modified":1705219988469},{"_id":"source/_drafts/八股复习2.md","hash":"3ccc2742b5eccb32c84c1dd9022cf78eb227c5df","modified":1716370998681},{"_id":"source/_drafts/动态修改Volume.md","hash":"409eed70fcb326ae9b75dfe360080fd9b096ea5d","modified":1714643697899},{"_id":"source/imgs/C++-sort-浅识/sort.png","hash":"1e98b2e440af9e4fec4983ebb3aded02dccab811","modified":1705219988476},{"_id":"source/_drafts/求救信.md","hash":"816a416fcfd7fc74c5dbd5ee150453220d5bdea1","modified":1755013304202},{"_id":"source/imgs/C++-sort-浅识/题目-1677565078882-1.png","hash":"fd098cbe2a8c4920ac974178c5069b436f46f4a1","modified":1705219988477},{"_id":"source/_drafts/水面模拟.md","hash":"150e97674d1ca17fbb34925e24f3d87182fc495b","modified":1716317657867},{"_id":"source/imgs/Hexo主题变更/deskt.png","hash":"ce678ce0bce3a20a630256eea85a3372b1303c0b","modified":1705219988503},{"_id":"source/imgs/LearnPBR/BRDF.svg","hash":"e624dccc3d2847b7a7f86fd5631a7d9b8d495307","modified":1714545414126},{"_id":"source/imgs/LearnPBR/G.png","hash":"184fc82773788ea759a27b8df6c96174767fc9ea","modified":1714545546753},{"_id":"source/imgs/LearnPBR/Kulla-Conty.png","hash":"8672e4f0121ef74e6775600f3a9d89d487c61e85","modified":1714545579931},{"_id":"source/imgs/LearnPBR/Radiance.png","hash":"729cb9d779af4a80753706b919bb13b3abfe4fdd","modified":1714545361413},{"_id":"source/imgs/LearnPBR/boban.jpg","hash":"9e956b2bece758255fd66c2a62c1f590587ee4b9","modified":1714545773626},{"_id":"source/imgs/LearnPBR/fresnel.png","hash":"743f76858069071b5e6136e9170a43e9c4a441f8","modified":1714545499774},{"_id":"source/imgs/LearnPBR/chart3.png","hash":"c542bc6124361bec929f5538705f88fcd5141d64","modified":1714545522382},{"_id":"source/imgs/LearnPBR/ggx.png","hash":"9caab93ef2347915403d6318d6834516b7158fd7","modified":1714545464288},{"_id":"source/imgs/LearnPBR/ibl1.png","hash":"3281b4638a081b0ff0373734ff0cac04343045dd","modified":1714545659733},{"_id":"source/imgs/LearnPBR/ibl2.png","hash":"e1cd91dfa78f1a1bdc0548e13fc864dec8893d89","modified":1714545680633},{"_id":"source/imgs/LearnPBR/microfacet.png","hash":"088d8593cfc7370b840cfbb40042cd1855f0f3b7","modified":1714545207191},{"_id":"source/imgs/LearnPBR/metallic.png","hash":"14c33a7f6e2c2d9181050e19c5fecca9260b520f","modified":1714545093660},{"_id":"source/imgs/LearnPBR/poban.jpg","hash":"29ec1a22ff21c02b087c90b3bf804e520d78ec8a","modified":1714545794861},{"_id":"source/imgs/LearnPBR/roughness.png","hash":"38fb7b2e6c644375db9e4561acc872bd6faa6852","modified":1714544996046},{"_id":"source/imgs/LearnPBR/reflect.png","hash":"57ecb740483cd9586ede66de0cfc798b69f42374","modified":1714545243804},{"_id":"source/imgs/LearnPBR/roughness2.png","hash":"1a0090fa102e65a84edcf517f066c1340f7d87b6","modified":1714545006668},{"_id":"source/imgs/LearnPBR/sample.png","hash":"a5991cf63fb9c83126a49ec2a0ab8d5c6861ed85","modified":1714545860692},{"_id":"source/imgs/LearnPBR/uecode1.png","hash":"c7604a8df7efec434581083f809ac0e351ed3ba7","modified":1714545841367},{"_id":"source/imgs/LearnPBR/uecode2.png","hash":"d27c55061b2470b690f8f1e33dfdf6159b0067f3","modified":1714545880657},{"_id":"source/imgs/VisualStudioPro/Vs2.png","hash":"2b233d41de28a0bebf8df9fc9443e3910cdf277d","modified":1705219988615},{"_id":"source/imgs/PBR/jihe.png","hash":"7d34abb52d9da4204a0c3f8a752e8f82b4b07a3d","modified":1705219988597},{"_id":"source/imgs/PBR/math3.png","hash":"f4447c6af98a75fe78ec25b081d8c3bf3fe823b4","modified":1705219988598},{"_id":"source/imgs/PBR/math2.png","hash":"39803c9b63af774368f3573b8c18e3c9f03f9206","modified":1705219988597},{"_id":"source/imgs/PBR/math4.png","hash":"9c6ad0d80d9d6740d9edd8ff273952659a3b0ee8","modified":1705219988598},{"_id":"source/imgs/PBR/math1.png","hash":"c20d184db8fa21033a89e35fe97fced3e92b0595","modified":1705219988597},{"_id":"source/imgs/PBR/math5.png","hash":"5929c3a9e33ca0b7e9ac24bd2a4bbbc1d8a1d5a9","modified":1705219988598},{"_id":"source/imgs/PBR/math6.png","hash":"35df98d0f9c402632031a590d0793f094f5ac9f8","modified":1705219988598},{"_id":"source/imgs/关于SRP Batcher/OldMaterial.jpg","hash":"628491e6faf5616f8a50f89aafcb60b93ad8ba94","modified":1740292442996},{"_id":"source/imgs/PBR/phong.png","hash":"31d91c5bad11dc298e74915ee86a653b5fab887d","modified":1705219988599},{"_id":"source/imgs/PBR/math7.png","hash":"c4cccf1c369a314b134d0ab9cd081d4c50aab9db","modified":1705219988599},{"_id":"source/imgs/PBR/几何遮蔽.png","hash":"b97b722ea36f82c6e68a362ba9feb1ca04d738fe","modified":1705219988599},{"_id":"source/imgs/大气散射/DirectionLight.png","hash":"b2810aa4b0423addd86111de756d8bd087016e4c","modified":1714190662182},{"_id":"source/imgs/关于SRP Batcher/SRPPipeline2.jpg","hash":"330721075551d711d324ed0cfa792b860785fead","modified":1740296911222},{"_id":"source/imgs/大气散射/OutScattering.png","hash":"b0b1b89753085878808817cbddd42600c6ee67c8","modified":1714190112661},{"_id":"source/imgs/大气散射/InScattering.PNG","hash":"66bceae2be44176ffb0f2146c304f58cf0fbef4a","modified":1714190132675},{"_id":"source/imgs/关于SRP Batcher/SRPPipeline.jpg","hash":"3e34ff01b718d4545f58e2d8db0f13895f6a0dc5","modified":1740293073061},{"_id":"source/imgs/大气散射/OutScattering2.PNG","hash":"ef30ab442655037e95ce0ada474d9a5fb2a9c8b8","modified":1714190137439},{"_id":"source/imgs/大气散射/NumericalIntegration.png","hash":"2f64ea53a79568e97e8234031a90fe87f1020be2","modified":1714190626635},{"_id":"source/imgs/大气散射/RayleighScattering.png","hash":"be8e64c44166d73198cdcca556b034fc13d2da6f","modified":1714190711807},{"_id":"source/imgs/大气散射/ScatteringFunc.png","hash":"66bceae2be44176ffb0f2146c304f58cf0fbef4a","modified":1714190588895},{"_id":"source/imgs/大气散射/Trasmittance2.png","hash":"d63cad83faf1b5312a82db226920d0fd696822b4","modified":1714190911032},{"_id":"source/imgs/大气散射/SingleScattering.PNG","hash":"b97392a5d4724c0a75c275405924d88d0edbc50e","modified":1714190126316},{"_id":"source/imgs/大气散射/Trasmittance.png","hash":"c7db0aa771b2bfc9a965f0c6778ebc6d04f93744","modified":1714190547900},{"_id":"source/imgs/SpringBoss/4x4Matrix.png","hash":"3fd4e2fc82e4a6b3163857529aa235ac246b8f26","modified":1705219988600},{"_id":"source/imgs/SpringBoss/4x4Rn.png","hash":"ffa992a382c70cb1378f3a15b19d9258155257c3","modified":1705219988600},{"_id":"source/imgs/大气散射/height.png","hash":"d388b44d9dab887372e7ccb7aa0413fbd713a23b","modified":1714190834393},{"_id":"source/imgs/大气散射/chart2.png","hash":"48872806a0e7efe4677bfe634a45551990cd3668","modified":1714190781404},{"_id":"source/imgs/大气散射/math.png","hash":"5d4c9e62de392084c07625f3712442041fa2e80b","modified":1714190956643},{"_id":"source/imgs/SpringBoss/C_ambient.png","hash":"3e82e9882b334607cd550821afb7aec8641c3903","modified":1705219988600},{"_id":"source/imgs/大气散射/math2.png","hash":"7acdf00665b199561cf6bf1ee8ddd0f0c81b26df","modified":1714190984479},{"_id":"source/imgs/SpringBoss/BlinnPhong.png","hash":"dd823449031987e821b787cabc81128d6e925b8a","modified":1705219988600},{"_id":"source/imgs/SpringBoss/C_diffuse.png","hash":"1ed03a8650488adb1ffa7cecaacbf58c36c78fb9","modified":1705219988601},{"_id":"source/imgs/SpringBoss/C_emissive.png","hash":"49e0a589d9aea640ed1bc8e1f1040933e5ae4bfe","modified":1705219988601},{"_id":"source/imgs/SpringBoss/ModelCol.png","hash":"bdc540d72dd7496d2726651fdbfb143ad06feda7","modified":1705219988602},{"_id":"source/imgs/SpringBoss/Mview.png","hash":"54b69ecafa3bc651ed42b46e755fa3cfca4999f9","modified":1705219988602},{"_id":"source/imgs/SpringBoss/ModelRow.png","hash":"6dc6f9f2d843bf6f9fcabc049600e12b5a0ac579","modified":1705219988602},{"_id":"source/imgs/SpringBoss/NormalLightEyeRef.png","hash":"80cf7daf120bbf99fe7645a48a93bca77732442e","modified":1705219988602},{"_id":"source/imgs/SpringBoss/PhongSpecular.png","hash":"c6ce23b28f0f7131263612461f5f44ce6f709a7a","modified":1705219988603},{"_id":"source/imgs/SpringBoss/Polar.png","hash":"f55ff9c68aabcdea414f7315361de2d695194ec8","modified":1705219988603},{"_id":"source/imgs/SpringBoss/RefEqu.png","hash":"8d7be77f52294ce9400dc4c8e4ff2e013d818e66","modified":1705219988606},{"_id":"source/imgs/SpringBoss/cameraETG.png","hash":"d10aa1458e8781cf85adfa6e247847d20600d5ed","modified":1705219988607},{"_id":"source/imgs/SpringBoss/Rview.png","hash":"e2106ad47777d5acb2b1f8cbf77a7e7b3f3cb254","modified":1705219988607},{"_id":"source/imgs/SpringBoss/colMHC.png","hash":"0ed0079cc4011046756098d26ae48103b6671627","modified":1705219988608},{"_id":"source/imgs/SpringBoss/cameraXYZ.png","hash":"612ee64521ce46954dddc565f5fe6ae8071b3263","modified":1705219988607},{"_id":"source/imgs/SpringBoss/columnMatrix.png","hash":"a01a60ff48b25b458035001c46c0b998697013a5","modified":1705219988608},{"_id":"source/imgs/SpringBoss/colMHCT.png","hash":"ab8a93bb19fbec878d86edcd038e54074b128c22","modified":1705219988608},{"_id":"source/imgs/SpringBoss/posE.png","hash":"8551a9196342c55cdffec5a382a726b360d732ad","modified":1705219988608},{"_id":"source/imgs/SpringBoss/rotationY.png","hash":"ada6371b2eb6c5b5a30675e94af7f7c3c168629f","modified":1705219988609},{"_id":"source/imgs/SpringBoss/rotationX.png","hash":"bf608427338ec57ce10584a3e77b433561b9c950","modified":1705219988608},{"_id":"source/imgs/SpringBoss/orthM.png","hash":"3b0a02a8fd4f695d7719cdb8dc9e93a6c50813ce","modified":1705219988608},{"_id":"source/imgs/SpringBoss/rotationZ.png","hash":"2985968c615593179a93e750ec963f2e5a52b82f","modified":1705219988609},{"_id":"source/imgs/SpringBoss/rowMatrix.png","hash":"cc90fe6d2fb8a53b4f44c4190a829f7e546fb87a","modified":1705219988609},{"_id":"source/imgs/SpringBoss/rowMatrixHC.png","hash":"b8d516c5bd5087fbe6002ee795e6e822aff16c53","modified":1705219988609},{"_id":"source/imgs/SpringBoss/rowMatrixHCT.png","hash":"af944b7c2f6235658cf9865e1d70b8c91c80f932","modified":1705219988609},{"_id":"source/imgs/SpringBoss/scale.png","hash":"afd601a8cc7555d5ba68757a5676bd605877f123","modified":1705219988610},{"_id":"source/imgs/SpringBoss/transform.png","hash":"755d166b6b08aa4161204caf827b1ae8edeac13c","modified":1705219988610},{"_id":"source/imgs/包围盒与物体碰撞/AABB&OBB.jfif","hash":"8135e91baf26756b94481198c745b4272123f5ad","modified":1705219988619},{"_id":"source/imgs/SpringBoss/translate.png","hash":"6153efc0d346eca2a764b1cb443f6a46899f0abb","modified":1705219988610},{"_id":"source/imgs/常见设计模式/Proxy.jpg","hash":"5b37f39492f7b6fbc699bdca799695ba0d3a5862","modified":1705219988620},{"_id":"source/imgs/常见设计模式/StrategyUML.png","hash":"ae1cb99b96e4cbc40dc055efb84c122aff3dc3b6","modified":1705219988620},{"_id":"source/imgs/每日Emo小短句/F1SZC9}W}_XEA5S]5FCJM3.png","hash":"fbd5f9f57f1bc5b65ed0222b6e83f9ea76ae7291","modified":1705219988620},{"_id":"source/imgs/读刘盆子传/zzpbzb.JPG","hash":"09e8f7117f94d04e752b89f43a123f5f8eaf9d6f","modified":1690618508000},{"_id":"source/imgs/SpringBoss/viewT.png","hash":"13d332f4876820813ccbbebc81ed11edc4db09b0","modified":1705219988614},{"_id":"source/_posts/CMake Note.md","hash":"26c18b65fbe314c6e428d1a598ef9c9524574bfd","modified":1705219988472},{"_id":"source/_posts/每日Emo小短句.md","hash":"072d402dfde101ee1794b5400954221f0ae5e035","modified":1755013315576},{"_id":"source/imgs/LearnPBR/chart2.png","hash":"7907f0b67282b617e3fb5045a66dc655916c3d4d","modified":1714545282941},{"_id":"source/imgs/VisualStudioPro/Vs1.png","hash":"98f8021c0b5f57a1cc73c8c23cf0db684c943489","modified":1705219988614},{"_id":"source/imgs/ZumaGame/question.png","hash":"7814be7c181db4a56211bdb782c85ceabb565065","modified":1705219988616},{"_id":"source/imgs/大气散射/chart.png","hash":"dd56e543fa8564373c3629a169521ef0e0651fc4","modified":1714190739583},{"_id":"source/imgs/SpringBoss/LeftRight.png","hash":"1809ddd8f4f26cd3e4686bb172603d770a53afdd","modified":1705219988601},{"_id":"source/imgs/水面模拟/kWave.png","hash":"17ceb1027fbaa273931cef7888268f45b48c09fd","modified":1715343966109},{"_id":"source/imgs/水面模拟/waveparameters.png","hash":"0bdefd1bdb555f838568994d181a3d49a5c31e61","modified":1715246448796},{"_id":"source/imgs/透明和Early Z、Pre Z/渲染流程.png","hash":"493eedf2d44193de84f5b4ba7fe0367c2ec32c96","modified":1705219988637},{"_id":"source/imgs/CMake Note/Qt5Error.png","hash":"6f3eecd2908d2a6f6f6cdcf7660ae53c4ea3d7b3","modified":1705219988481},{"_id":"source/imgs/CMake Note/Qt5CannotFound.png","hash":"e3320ca0784cf8514546681de34a3ad32dd14b79","modified":1705219988481},{"_id":"source/imgs/LearnPBR/IBLCubemap.png","hash":"57f6ad06b65cbb5e7d3b8f4a5823acf20aaa08a6","modified":1714545717191},{"_id":"source/imgs/LearnPBR/iblAlpha.png","hash":"e0b61a95f8cf99d8db90e49ae285a37b29012cb4","modified":1714545746011},{"_id":"source/imgs/LearnPBR/specular.png","hash":"ad4f9d5b6a550225235dfabbd1e7fb37fe513771","modified":1714545166199},{"_id":"source/imgs/MoyuPics/220702CF.jpg","hash":"f4c24aa422dc7e94514e19e59615e2c462aa1b57","modified":1705219988534},{"_id":"source/imgs/MoyuPics/220702光头.jpg","hash":"92e658ef92bc424286b0f361797d3236102d1752","modified":1705219988556},{"_id":"source/imgs/MoyuPics/617e.jpg","hash":"9253e03c9feaa3fc1c5aa0a73414b13d3e65e67e","modified":1705219988574},{"_id":"source/imgs/MoyuPics/617w.jpg","hash":"2350821fcaf3a169095f1674f37519a6723ffe41","modified":1705219988576},{"_id":"source/imgs/MoyuPics/617m.jpg","hash":"f89af4331c5f424f8c1374e30ffbc6116eed7bf4","modified":1705219988575},{"_id":"source/imgs/一些数学推导/重心坐标2.png","hash":"11d0554775060f01f44f084cfe523d698264ef26","modified":1705219988619},{"_id":"source/imgs/PBR/BSDF.png","hash":"4bb6cba63f29f8717a42481be42989805e6a052a","modified":1705219988596},{"_id":"source/imgs/关于SRP Batcher/SRPPerObject.jpg","hash":"3c9015c3cae14212827d749e41e76aaf924b9f92","modified":1740297048846},{"_id":"source/imgs/SpringBoss/unityUpdate.jpg","hash":"2268bcac016ea682abeadd2e6a64ec8bd274cb51","modified":1705219988611},{"_id":"source/imgs/水面模拟/directionWave.png","hash":"0d18bc7bfc4826672796b0a38296d2145f70680a","modified":1715357692809},{"_id":"source/imgs/LearnPBR/chart1.png","hash":"c2d301897cd3dd965053268426ec05cde1a93a47","modified":1714545270599},{"_id":"source/imgs/LearnPBR/ueReference.png","hash":"9ce930092ec1276d0a2f96b3c30b624a74e02514","modified":1714545822810},{"_id":"source/imgs/MoyuPics/220630jo.jpg","hash":"7eb2ba317578bce0ff63244f006cc5b46c433ed7","modified":1705219988532},{"_id":"source/imgs/一些数学推导/重心坐标1.png","hash":"41dfb571e5d79d80947ccd0f709577dd9a044001","modified":1705219988618},{"_id":"source/imgs/Hexo主题变更/Fluid_Config.png","hash":"c93486316a51e01cc18e198d8f71b975bb3a66c0","modified":1705219988483},{"_id":"source/imgs/Hexo主题变更/pandoc1-1.png","hash":"3e707b4c554689512b9e36780b09ad7a4590a1cd","modified":1705219988505},{"_id":"source/imgs/大气散射/Res01.png","hash":"fdc6e8e2c4ab082520832ab874433b9ff97fd69a","modified":1714191144263},{"_id":"source/imgs/SpringBoss/viewMatrixMyNote.png","hash":"aecfd9b0e22f92692543ccb3b48e91144f6923cc","modified":1705219988613},{"_id":"source/imgs/C++RAII/35.png","hash":"efdf5bedd807741e6cc5bd168a8a553c887ef34c","modified":1705219988480},{"_id":"source/imgs/大气散射/Res02.png","hash":"da6b4ba864e3b440c89d7fb9a2eccd2f907cda80","modified":1714191152040},{"_id":"source/imgs/Hexo主题变更/web.png","hash":"0b4be6b987a6fe1300d7dcf4a3f86f961dfd6379","modified":1705219988510},{"_id":"source/imgs/大气散射/Res03.png","hash":"7d2b880076c9eca3e02c87f1eda72b4bab56bb9f","modified":1714191163849},{"_id":"source/imgs/Hexo主题变更/pandoc1.png","hash":"2c28e956b833dcb986e7cc443eda1dc0d57b1279","modified":1705219988507},{"_id":"source/imgs/LearnPBR/output.PNG","hash":"4c96f7488b330de426afdf290b91e71f3862c8a4","modified":1714544945909},{"_id":"source/imgs/LearnPBR/output2.PNG","hash":"801660a91c7743e338eb2d8b7e6f0ae54986bdd0","modified":1714545605514},{"_id":"source/imgs/LearnPBR/output4-1.PNG","hash":"f5d20d4024532ee37201f4851c7ec1da5ae6309c","modified":1714545950279},{"_id":"source/imgs/LearnPBR/output3.PNG","hash":"99492da9ca6e26fba71d8352cfa8ce6c4cae3b6c","modified":1714545910732},{"_id":"source/imgs/SpringBoss/RayPointSpe.png","hash":"21a414d78f788a43c271cb9455205e980dea1073","modified":1705219988606},{"_id":"source/imgs/LearnPBR/AnisoSphere2.png","hash":"26ac710bbb647f4242423db9f09caabb6206521f","modified":1714545955579},{"_id":"source/imgs/MoyuPics/20221114EyeCue.jpg","hash":"263a4f853f7509fd93fa1151741a4ffea27c75e9","modified":1705219988518},{"_id":"source/imgs/水面模拟/waveNV1.png","hash":"e3c1613cc9c1676788978104ce3c340c671fd783","modified":1715690005084},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1705221256971},{"_id":"source/imgs/透明和Early Z、Pre Z/BT.jpg","hash":"7b8c4f4948f75d25fd53db4bdc9f0a55ea7fa955","modified":1705219988623},{"_id":"source/imgs/透明和Early Z、Pre Z/先不后透.jpg","hash":"5955822c6296a65668120207625dc587c85dce38","modified":1705219988634},{"_id":"themes/fluid/.eslintrc","hash":"3df89453e1f63051fafc90f16a8d83951050e316","modified":1705221256943},{"_id":"themes/fluid/.editorconfig","hash":"b595159772f3ee1ef5e6780ce307270e741cb309","modified":1705221256943},{"_id":"themes/fluid/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1705221256943},{"_id":"themes/fluid/README.md","hash":"2b9ea893e28189026b77cd542519b65479dfd0fb","modified":1755529428460},{"_id":"themes/fluid/.gitignore","hash":"9ede98b8d9dca802f82f651afb3b0366d69f05f1","modified":1705221256945},{"_id":"themes/fluid/README_en.md","hash":"a0085f00367cff7c694bfe7a83646ea4f75db7bf","modified":1755529428461},{"_id":"themes/fluid/LICENSE","hash":"511e49f0bd8282a0d002c527474da8e1e5add393","modified":1705221256946},{"_id":"themes/fluid/languages/de.yml","hash":"f814263ded504cb4c50a8b66157bdd71f553be1b","modified":1755529428462},{"_id":"themes/fluid/package.json","hash":"fd6756866314aaf4b15d734a83b85aa09aa0b5ed","modified":1755529428469},{"_id":"themes/fluid/_config.yml","hash":"3701f2dc9ee152d11e20e8209c91d3ca5d7b1d8f","modified":1755529428462},{"_id":"themes/fluid/languages/en.yml","hash":"415e3403182e1282386f28b9d61343f147519163","modified":1755529428462},{"_id":"themes/fluid/languages/es.yml","hash":"0ad94ddf1ca868a67b5b84aed257a30572962210","modified":1755529428463},{"_id":"themes/fluid/layout/404.ejs","hash":"c49974dcbda02fe720498398e9778826335459c0","modified":1705221256948},{"_id":"themes/fluid/languages/ja.yml","hash":"65a90f294f6c73245e8250e87d124630ad10b389","modified":1755529428463},{"_id":"themes/fluid/languages/ru.yml","hash":"998112b384b574e0e29c6ea16e4c1ebce1c15a4c","modified":1755529428464},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"497b3dea5058f718da225a7a443e916da895ea10","modified":1755529428464},{"_id":"themes/fluid/layout/about.ejs","hash":"2f3ea36713f0fa91d8d61d39fcf9e584372de818","modified":1755529428469},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"05418d0bca261de386872be65027bf4498758788","modified":1755529428464},{"_id":"themes/fluid/languages/eo.yml","hash":"314b97a7e68093328675acfd308d839b1d772ac9","modified":1755529428463},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"ded0621e63b1f8b241be21f6e9b52d4f36edbcd0","modified":1755529428465},{"_id":"themes/fluid/layout/index.ejs","hash":"dde1f6a27c8d09c38850a691089937f181b6c035","modified":1705221256957},{"_id":"themes/fluid/layout/archive.ejs","hash":"c524ce76747042ec2f9ed8d5025f80e01b462b3b","modified":1705221256957},{"_id":"themes/fluid/layout/layout.ejs","hash":"d4ffeb7eff398dea154340794bd277f75ddeedef","modified":1705221256957},{"_id":"themes/fluid/layout/category.ejs","hash":"264f68cbf826787e683a30e1377c56c0895c7386","modified":1705221256957},{"_id":"themes/fluid/layout/page.ejs","hash":"8ba210724c023d45a4564415762f3da299bd1d0e","modified":1705221256958},{"_id":"themes/fluid/layout/categories.ejs","hash":"838a68e210bddfca6d4ba070e1e2f1ca53cb7d06","modified":1705221256957},{"_id":"themes/fluid/layout/post.ejs","hash":"c8da695dc1b01b715909ae6f1052ccaebdf9db4c","modified":1705221256958},{"_id":"themes/fluid/layout/links.ejs","hash":"fbed4b3d1e475b3de9d8ce05362abcc658a53408","modified":1705221256957},{"_id":"themes/fluid/layout/tags.ejs","hash":"b7c1a6d8fc1097fc16d2300260297013cb692153","modified":1705221256958},{"_id":"themes/fluid/.github/workflows/cr.yaml","hash":"fc31c7c6692424af1e08cd5e273a5a5814f9c577","modified":1705221256945},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"7d7c1e5a1da6b4f7be6685beb4798ec76d5efd31","modified":1705221256944},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"fea63a9a5c3befd8783705eed09adf1b596a6203","modified":1705221256944},{"_id":"themes/fluid/layout/tag.ejs","hash":"e87fc58829ea214ac16e8e4f13cd5c389133697b","modified":1705221256958},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"bdbdb66da69ab7353b546f02150a6792f4787975","modified":1705221256945},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"5cc30e7b6e7b77c8b40b182ba02a5d93d37d2fc2","modified":1705221256944},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"7db378613df2b7d13e8c428c006399a879a4a852","modified":1705221256944},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"dcdbe1698a6ee61f741c29ef560f859f66ffa32c","modified":1705221256945},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"78c34e32746041f23678669bbadfbede15e4c6d2","modified":1705221256948},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"102213e5d6790d060c0e26b4a3a7ec744d753c52","modified":1705221256944},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"07e24578c25fcaca94618fd86569887dadf7a276","modified":1705221256945},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"0c14869e15f7dc615c8353765569644238f38f2d","modified":1705221256949},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"508254a648d8597e62e4012c8beab44bfa82e904","modified":1705221256948},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"1ce9094faec6204949cdaf604aaf9200787e4218","modified":1705221256949},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"6bb3335b5486d4bee2ed42f8bef57903066bc234","modified":1755529428466},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"901280e6fb3194c30542751d04f27e78b42d3c6f","modified":1755529428466},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"a0bcbbfc34efaef3b23c6b531e7f3201f2eab2dd","modified":1755529428467},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"3668304d08c48b68d532532921a12069a2736150","modified":1705221256952},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"b5cd435b27f090939b6051bef41a38a3376044ac","modified":1705221256953},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0d443f23c459787338917900f50fec1c8b3b3bdd","modified":1705221256953},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"89fc9f663a1091911b79ab9697c09446d16184f9","modified":1705221256956},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"3d30c722b9e24c33577d6fab822628841fadf992","modified":1705221256960},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"2340a576635b16fd2456b3494f5afe89cd7764db","modified":1705221256960},{"_id":"themes/fluid/scripts/events/index.js","hash":"6c3b24207e4ea3ae4edeb715af40ef23711b92b9","modified":1705221256959},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"3550976efc94500284795f13485f5a1765fc120b","modified":1705221256961},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"57a0f61242d9ce2bd2c51b2f84193f6dc1377ef9","modified":1705221256956},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"33427308ca29f1d76336c83e704571c9de75df02","modified":1705221256961},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"67637461e3f94f9e9675369eb7ff015355d9ec54","modified":1705221256960},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"14a207a7d4e329382ab5d4e1da1ef85ff043daba","modified":1705221256961},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"96af7e55fdbe0819bacc554ecbfe42375a088df6","modified":1705221256961},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"3fb72d3c2224c32d861a6e8a85e78a8b67e6a244","modified":1705221256961},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"f9821f7789ea6f069977a8c642aa5ccb6d19077c","modified":1705221256962},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bc9ba08d1d871394ee1c3a1cc2f21dc343f515a","modified":1705221256961},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"49b2c6449d7be35739c6cfea3cab4e790580983a","modified":1705221256962},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"9219d59c51930c7a82fcde918d6efbc5aa572ea2","modified":1705221256962},{"_id":"themes/fluid/scripts/tags/button.js","hash":"e1d0caed12e7cd9a35cf64272c41854b2901a58f","modified":1705221256963},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"1ff4ea054f2c735dfaccb0be90f1708a2a750bc8","modified":1755529428469},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"3b67d50050158423c8fa47f1de6aedcfe916637b","modified":1705221256962},{"_id":"themes/fluid/scripts/tags/fold.js","hash":"a93e2603021ad38714e870399767bea24e7cbe3e","modified":1705221256963},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"f57be245e6e7228673e1dec3a3477e731492c5c1","modified":1705221256962},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"f713ddb6c8018ec7b96d3567057f1f932609beea","modified":1705221256962},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"cc176cc1d7e7cc28cedf8397ae748c691d140be2","modified":1705221256963},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"37f90bd4e35ce49457dc2a348b9f66e0b242c014","modified":1705221256964},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"0bb33314aa5cfe326ab9bb14b545e343e4db4193","modified":1705221256962},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"dbfe59fde77d87b1d7d0c46480a2a729010988eb","modified":1705221256963},{"_id":"themes/fluid/scripts/tags/label.js","hash":"6c5916d86c63795c7e910bf614b0e7ece5073702","modified":1705221256963},{"_id":"themes/fluid/scripts/utils/crypto.js","hash":"474b00a57f43dbe7bc2876d637ece4214d016c06","modified":1705221256964},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e300ec4ee6c63464859ab000e987bf8dd7db4025","modified":1705221256964},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"c74d7aed425d20f2fa096f386a9521b67b9ab269","modified":1705221256971},{"_id":"themes/fluid/source/css/gitalk.css","hash":"1fe60b2ab1d704f5a4f55e700dca5b8785fb390e","modified":1705221256971},{"_id":"themes/fluid/scripts/utils/object.js","hash":"3e03b534e2e92a6e17567b006d7e3eaad4b37598","modified":1705221256964},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"dbdb10b23fcd3928e86a4cb46fa3455e060b4aa0","modified":1705221256964},{"_id":"themes/fluid/source/css/highlight.styl","hash":"57ce8b8f95ab1f40612a9dce1793de5ab9b4bbfc","modified":1705221256972},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"a5d70005913ab03cea0a0dc601097628b4dbd5a8","modified":1705221256964},{"_id":"themes/fluid/source/js/boot.js","hash":"33bb7c8255d2e3c93a1bea8c9221399b3a868a63","modified":1705221256974},{"_id":"themes/fluid/source/css/main.styl","hash":"9e9171325bb7148c11ceee283d00c137c8a1c5c5","modified":1705221256972},{"_id":"themes/fluid/source/js/color-schema.js","hash":"e7addcc88eb73dec4a9a8641a4bb68966a38a65d","modified":1755529428472},{"_id":"themes/fluid/source/js/leancloud.js","hash":"e9ad1b5659f0af867174687daa0ecf4375e40b75","modified":1705221256975},{"_id":"themes/fluid/source/js/events.js","hash":"3efd602cdb694902d6e74c4eb1e5bd70120ac5b1","modified":1755529428472},{"_id":"themes/fluid/source/js/local-search.js","hash":"491021125d2579e841c83f36d3ab790d1eab9d1e","modified":1705221256975},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"67f6250f98b36a6599ea982d11cbb060c5ffb92a","modified":1705221256975},{"_id":"themes/fluid/source/js/plugins.js","hash":"753c2cf95f2659fef80277b895f4da10c8888c72","modified":1705221256976},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1705221256972},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1705221256976},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1705221256973},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1705221256974},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1705221256974},{"_id":"themes/fluid/source/js/utils.js","hash":"9d0423db40a787f3b19968205b9ed92a848c9153","modified":1705221256976},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"0c410ef79785897c8de3da333b057a2936fd569b","modified":1705221256949},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"79ec17eec6e15076c685688e740230e92c66efa9","modified":1705221256949},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"d400e5721af28cefecaf50b46c82dcdde4cda4a8","modified":1705221256949},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"1e93ca89777e4beb0f0e5cb70e03aab48e958542","modified":1705221256949},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"66995ec9dab10ed35c2a775010c447113c6848d4","modified":1705221256950},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"7f04e5c22821bb94da791973d9c6692b03bac81d","modified":1705221256950},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"938eb60413ae8af83ffeaba4d85df88387cdd5be","modified":1705221256951},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"bcceafab01fe695c59951d939f7cef502f3d7b48","modified":1705221256951},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"45c879768b40ba56af62e18ad54bffbf73a6f3a1","modified":1705221256951},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"d7bcc183fc31af643e7835b13da10fe2ab8614ce","modified":1705221256951},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"77d0c9df31a22ed8a3e341637bde4165a11a7ce9","modified":1705221256952},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"df6bae1a93827991049f7a33f6a69681c60eab0e","modified":1755529428466},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"ef04d4fc3f26588ae9d8712938d648304fc05455","modified":1705221256951},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"31208a0db986ba864f756a8ec806b7d254440f9b","modified":1705221256959},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"9b1934c61dc78622a07da554413f6ad31854576d","modified":1705221256959},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"a84d8dcb44f5f6289ef09db4d02ab14de72c2c87","modified":1705221256953},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"047bece1db5cdf96cb78a44c6420ce3e92e6a9ca","modified":1755529428467},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"e5219b14410066bf8ab491379aca797304b4a914","modified":1705221256953},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da987411ae4a4e6896a9b8af1fce6209192af28e","modified":1705221256959},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"d103e4bf612b2445bb136712d57b81e784a313e2","modified":1705221256959},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"ec6bf395ccad3dd41f29dc0080aeabf413e30fd9","modified":1705221256960},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"171697018fd384fce0834875ca94b91f16564cac","modified":1705221256965},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"92123b7280695b4ac6650f5e1d7fa0d772c71f5b","modified":1705221256959},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"9ea66cf79f1e4356b6b402bc3dc5fb55c9862f1f","modified":1705221256971},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"c9696633f77dd8055e900497469f9e64eca4d97f","modified":1705221256960},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"551ffae43844925beb099c85a9e6d8d9fcbf8086","modified":1705221256955},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"046979dbd8cdabd21d89f9c1d8f1bb3f2fd06d6f","modified":1705221256965},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"26905d5862b1531ebcc175af15178dabeecc81c8","modified":1755529428468},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"73827074db4e0fc3d52c51a76285df87aa5e5a7f","modified":1755529428468},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"db4ecdcc762bb1b1bae5060f0baa6115174779ff","modified":1705221256956},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"f0cb813cd03642c9b68cff8b6669f73a61dd10f8","modified":1705221256955},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"2507cdad08f61cf8c1d9b0ca7f4f1dc8c4e5841b","modified":1705221256956},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"1b1eb4c8e163a5d909e86da76ef778948e0e0b77","modified":1705221256956},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"f8fe8e58b83f627db82c0dbeb663389efc33c1c6","modified":1755529428467},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"92c062cf55457b6549497244d09ec34e9c0c95c2","modified":1705221256971},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"8a4ea62c46f9a75c94096a27b2d3f5c10a2f82e5","modified":1705221256954},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"03c7c69fbb1754fdccfa18671aac23b8637b869e","modified":1705221256954},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"3900e54ade140e0e49c571a1955f0b1f3a59b281","modified":1705221256954},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"018cab52ff696a6c78ebc01e10237a90a0c33603","modified":1705221256954},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"502b99e19e496825df7032ca2b0b1a95ebb2b357","modified":1705221256954},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"d0f06fb482e3a8f9a53dfd94c4e4a65a43f1ff34","modified":1705221256954},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"110e45e2d3433178f00f482adc863110f90c46d6","modified":1705221256954},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"42850952e8f5858497fe774c2aff87b6563ab01e","modified":1705221256955},{"_id":"themes/fluid/layout/_partials/plugins/moment.ejs","hash":"acc72c3284fe906a4505132c3d9a4720d80e6fcb","modified":1705221256955},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"8ba5fb6a8ced1de6f7893184bf12f4021fe22595","modified":1705221256966},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"cd255079553985722ee80fb1833f6507dde52194","modified":1705221256968},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"e3846fb429f6732bd15fde40f7c28b3492d786c8","modified":1705221256966},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"66d5b045c0e54001d3c98c5901d72590fe08acc4","modified":1705221256968},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"f35415bd86b5c26fbc71728048d9e1481263554f","modified":1705221256969},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"47c1df255aa552ad71ef3e57deca46530a8f2802","modified":1705221256955},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"96c3bb95dea4b3d3ecd20b810a674bfcef04870c","modified":1705221256968},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"4263f7b930e6b57e13295d17fd3745a9e5c52494","modified":1705221256969},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"d3aeb7bf22d52d7dde59b292090ef8b46943718a","modified":1705221256969},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"bac20c8fb20276b08972df5ecc7a5850a72393f4","modified":1705221256969},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"1fc96d09d52d9502e84e4e2a8d482ea45e8b81ea","modified":1705221256970},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"d3ef491fd449d89a1b95801dee788a5d9bec4320","modified":1705221256970},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"31c64c3fae4a0fc4747d8afeb72f7a9667c5326c","modified":1705221256970},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"d73cccb65eaa804910884df17442e34736b3f4fb","modified":1705221256970},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"2d12f23b46d0ce07ae810bc4f5635c490a098fa4","modified":1705221256970},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"6a35a450bd0a12f68fd92aac3f88b23475a98d46","modified":1755529428471},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"58a7f8f2baea2d58cf5f7edfc91314ee5d7156ca","modified":1705221256968},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"571bd018e914bd0f7c5f89df874b5937937e5fa6","modified":1705221256969},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"26d65475b1c52a61115044db8883df6739c3a473","modified":1705221256966},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"1068d71721baeed76bf0176f9b964d36b5764c9f","modified":1705221256966},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"29e9b72cfda2f2baf9cf2597fcd7f9e66303a9bd","modified":1705221256971},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"80301db38e448e40e88bb34d0128628b0809b243","modified":1705221256966},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"3ac1eb36e124adef607775aa505386d5680960e2","modified":1705221256967},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"417a7388b39c0203178b0032e151febd66a0e9f3","modified":1705221256967},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"e6f5921ff9009c1853e7db30c482bc1682433ed9","modified":1705221256967},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"41935973a66c14ab2bea0539d4b1f15c62534fa4","modified":1705221256967},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"88c3c2d99a097142a87eeec0c7c65a3789f25117","modified":1755529428470},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"48799d3148ef6493be0e05897c635124e9b05d03","modified":1705221256967},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"8fad325e411bc83c8ebdc4115015477eed5f60da","modified":1705221256967},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"f4ae7cbf2f10f459de7864f8e642553b587df889","modified":1705221256967},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"0ca6171ce262339e0e36cfea0978b554d87ae7fc","modified":1705221256967},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4dbbbb1a2508a72bc04680552d7ebbea0eed0fe","modified":1705221256968},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"5defef321e3e933fe84f3f2ca481c88f55381fb0","modified":1705221256968},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"1f4e678d7219815ab62de1b92ec75e021247f90b","modified":1705221256968},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"04447d3b673be84a1af1dc57933a3c41dd7c0cfe","modified":1705221256967},{"_id":"source/imgs/透明和Early Z、Pre Z/TB.jpg","hash":"e0bebace4d63053fa02a9bbf71f9d56e8ea32a0f","modified":1705219988626},{"_id":"source/imgs/透明和Early Z、Pre Z/先透后不.jpg","hash":"f27ff79245ccf80f0ec6ee2d74f432284795adab","modified":1705219988637},{"_id":"source/imgs/LearnPBR/pbr.png","hash":"dd26d721c367005792b4994d6bad2920a4b79f73","modified":1714560680826},{"_id":"source/imgs/MoyuPics/220702P2.jpg","hash":"b392c9f2e57933fa8b128302855b029c62162de5","modified":1705219988543},{"_id":"source/imgs/MoyuPics/starve.jpg","hash":"285c20b141847f64534abeb907d595bf9da5e830","modified":1705219988584},{"_id":"source/imgs/水面模拟/waveNV2.png","hash":"a5f9e1596d7ce79db0fa0e91e1f170c4047d16e9","modified":1715690797009},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1705221256973},{"_id":"source/imgs/MoyuPics/5.29.jpg","hash":"e84289113108441d66a62b64b66d94ae8abd0066","modified":1705219988560},{"_id":"source/imgs/MoyuPics/卷发5.26.jpg","hash":"5da2767eee241e9471e1a71fa414851a9cc1dd4b","modified":1705219988589},{"_id":"source/imgs/MoyuPics/边缘.jpg","hash":"86afd87e71970936abda0ae9f84458716078cb35","modified":1705219988595},{"_id":"source/imgs/水面模拟/InterstellarSeaWave.png","hash":"395911d4586a5a067230640a85e9b43157cc40c0","modified":1715339672393},{"_id":"source/imgs/MoyuPics/2022.6.15.jpg","hash":"b2cdd27640c14773a59ba730677123c9ecbcb7b8","modified":1705219988514},{"_id":"source/imgs/MoyuPics/220702P4.jpg","hash":"3d52054b7badde9fe74e0cd63039cb991f97ed75","modified":1705219988555},{"_id":"source/imgs/MoyuPics/220702P3.jpg","hash":"596f3a124cdd24f14a3774b6f4f43e41248c8e8b","modified":1705219988550},{"_id":"source/imgs/透明和Early Z、Pre Z/qh.jpg","hash":"5af98f78727891438a0bb3cf61012f285acdfff8","modified":1705219988631},{"_id":"source/imgs/MoyuPics/220702P1.jpg","hash":"3d1ddc3db94157b562439cf758634416ca5e4150","modified":1705219988540},{"_id":"source/imgs/MoyuPics/eye614.jpg","hash":"82d024ba93a520d7dc480539d0d1e66d485be049","modified":1705219988581},{"_id":"source/imgs/MoyuPics/5.30.jpg","hash":"5ff77b129f3a1eca791b0319097e3e3f78196367","modified":1705219988572},{"_id":"source/imgs/MoyuPics/22-6-22.jpg","hash":"ad9389e3cc02ad6c20feb79da0959b3f0569e31d","modified":1705219988531},{"_id":"source/imgs/Hexo主题变更/Shiki&Tsukihime.png","hash":"73d69c5d263146ef2402d9ec170b0d83ec5292fa","modified":1705219988502},{"_id":"public/local-search.xml","hash":"3fc575478c5c80ea2f72be421766047180292903","modified":1755529369819},{"_id":"public/2025/02/23/GPU Driven And Hierarchical Z-Buffer/index.html","hash":"9d371e42e2b9abdf78b2346b428ba9f03ff83492","modified":1755529442177},{"_id":"public/2025/02/22/关于SRP Batcher/index.html","hash":"8f338360a434afa0361e13c4503a5b09535af57e","modified":1755529442177},{"_id":"public/2024/05/01/刀光特效/index.html","hash":"51303dbdb1b3ec66c125faf8e85c18ccfbeb7ca2","modified":1755529442177},{"_id":"public/2024/04/14/关于透视矫正插值/index.html","hash":"8114e0da5070aec907d26f8866d1277dcbe94cbc","modified":1755529442177},{"_id":"public/2024/01/13/Hexo主题更改/index.html","hash":"aabc116c8c43dec12a2ceb1be76d75fe034a90f5","modified":1755529442177},{"_id":"public/2023/11/14/LearnPBR/index.html","hash":"7934639064271d232ac992f33073d9282adaee28","modified":1755529442177},{"_id":"public/2023/11/05/大气散射/index.html","hash":"867eebd745b36d859bd898afc0a635ecd95b358d","modified":1755529442177},{"_id":"public/2023/08/28/VisualStudioPro/index.html","hash":"2ed884244baff3db4d61a5906d946a2228a241e3","modified":1755529442177},{"_id":"public/2023/08/21/C++11之多线程/index.html","hash":"13a2167c28b97041367d69b49c0fcc89936be620","modified":1755529442177},{"_id":"public/2023/05/01/C++11之function和lambda/index.html","hash":"e18b86083fb8ca84dc70c8ce0d56d47a65b892e8","modified":1755529442177},{"_id":"public/2023/04/16/一些配置环境教程/index.html","hash":"236681abc081b52a7f5c1b5e03f0e077abd4a62a","modified":1755529442177},{"_id":"public/2023/04/11/球谐函数/index.html","hash":"2337d57e95ef88ff743594757188f9a863968297","modified":1755529442177},{"_id":"public/2023/04/10/常见设计模式/index.html","hash":"08571835b40ee35b93ff8c8a1d5810dc864edfb5","modified":1755529442177},{"_id":"public/2023/03/10/CMake Note/index.html","hash":"35bbaaa1f05a0f3919bc83754ff550e947619d3a","modified":1755529442177},{"_id":"public/2023/03/04/SpringBoss/index.html","hash":"db302cb3f99195b1a0f93703ebe9ca3fe843dba8","modified":1755529442177},{"_id":"public/2023/02/27/包围盒与物体碰撞/index.html","hash":"9eba585c9e82ca19b040b880aec7d859ee2b4b14","modified":1755529442177},{"_id":"public/2023/02/13/排序算法/index.html","hash":"2f04213fe80006b08a900e780e8a56dfe6d5c07b","modified":1755529442177},{"_id":"public/2022/06/17/PBR/index.html","hash":"d9e3798176c4f293f84cb30e62c6876d85559910","modified":1755529442177},{"_id":"public/2022/05/31/透明和Early Z、Pre Z/index.html","hash":"d2c105da8b70e85f660eba2dda039c5bf97c940e","modified":1755529442177},{"_id":"public/2022/05/03/C++-sort-浅识/index.html","hash":"c0673e5501dab879cf14a723a406bc473c9ffa21","modified":1755529442177},{"_id":"public/2022/05/02/C++-static-const-define/index.html","hash":"ab785cc30ae5f9876f7bbeefc5191a315f4028d0","modified":1755529442177},{"_id":"public/2022/04/13/C++-Smart-pointers/index.html","hash":"3e6ba4a4d5760a9ca02a595065d684825feaad5e","modified":1755529442177},{"_id":"public/2022/04/09/Dissolve-in-Unity/index.html","hash":"2081ab0d83a049ca70236931ec5281fbc4bf1c09","modified":1755529442177},{"_id":"public/2022/04/08/New-Start/index.html","hash":"1b4fb13b45edee4e7423fa33ccca47fe4eb29de2","modified":1755529442177},{"_id":"public/2022/04/01/C++RAII/index.html","hash":"c1e4774d56edb6a649c2bccf6866b6a35e8cc4f8","modified":1755529442177},{"_id":"public/2022/04/01/MoyuPics/index.html","hash":"efabf7bc542b0616a0a7291a6563808e110166a3","modified":1755529442177},{"_id":"public/2022/01/01/紧急说明/index.html","hash":"ae87945dd33498bbccced27d3f8d4fb3f42ff063","modified":1755529442177},{"_id":"public/2020/04/16/读刘盆子传/index.html","hash":"169e74f5777803a277a938f75dcbfbf8fb9f7a6c","modified":1755529442177},{"_id":"public/2020/04/10/每日Emo小短句/index.html","hash":"ef1fc9aaae0edfa4ecb45bd82cdd8b6bdca9bcdc","modified":1755529442177},{"_id":"public/archives/index.html","hash":"2f552401b2ce8f4205c9db26e6a16f1a196eb13c","modified":1755529442177},{"_id":"public/archives/page/2/index.html","hash":"caf5d0f99feab423a60aa82aaf2ce80c4c6b3716","modified":1755529442177},{"_id":"public/archives/page/3/index.html","hash":"0a5757a55d1bd2097aa0c9687e1e61894579aaef","modified":1755529442177},{"_id":"public/archives/2020/04/index.html","hash":"c6aedcc7f8fa60252b4e6ed956e4e4cc73836d5b","modified":1755529442177},{"_id":"public/archives/2020/index.html","hash":"db4e45f14c0390c41191bbac9530a5e8bd357790","modified":1755529442177},{"_id":"public/archives/2022/index.html","hash":"428ea963007432c622d70527f7d391b82cc899df","modified":1755529442177},{"_id":"public/archives/2022/01/index.html","hash":"9c6253574f43084437422be92784d9fbeb82c5a8","modified":1755529442177},{"_id":"public/archives/2022/04/index.html","hash":"0481b79cac6647a8742e1b8e4a4264f3d5342497","modified":1755529442177},{"_id":"public/archives/2022/05/index.html","hash":"58a8a84657b0bd8ff05fd3963d70fdd84d681aed","modified":1755529442177},{"_id":"public/archives/2022/06/index.html","hash":"d8e1d4ca1d69c9621792b7d89c88d74279310e7a","modified":1755529442177},{"_id":"public/archives/2023/index.html","hash":"5f79d6173c9c545b488f3eea5caf4ab7df53812c","modified":1755529442177},{"_id":"public/archives/2023/page/2/index.html","hash":"cd1fc111dff88b3b8bbf41369317e63d71484e93","modified":1755529442177},{"_id":"public/archives/2023/02/index.html","hash":"fe7bbf8788910dc99cfef81214b6c9aad1460ed9","modified":1755529442177},{"_id":"public/archives/2023/03/index.html","hash":"b4b11f5911c092c35ef5f6be8389587698d84842","modified":1755529442177},{"_id":"public/archives/2023/04/index.html","hash":"f431f36afb75b4cbc5ee549988e0aadb74907ee6","modified":1755529442177},{"_id":"public/archives/2023/05/index.html","hash":"7b79c8610cdfcd9b21475e222444758d38613577","modified":1755529442177},{"_id":"public/archives/2023/08/index.html","hash":"3d87444e91a48c97ca14c265008ad50a5eb3b935","modified":1755529442177},{"_id":"public/archives/2024/index.html","hash":"4d2728ca02288b0bd5b71453bf162206e3d64de9","modified":1755529442177},{"_id":"public/archives/2023/11/index.html","hash":"27d60a8529605a3f98dc867e847709b30b2ed900","modified":1755529442177},{"_id":"public/archives/2024/01/index.html","hash":"57add715c7c644f7c8b7f4ed72724fbbb0c7ee39","modified":1755529442177},{"_id":"public/archives/2024/04/index.html","hash":"060a81ba49b7335371544d4aa8dda919e67ae0be","modified":1755529442177},{"_id":"public/archives/2024/05/index.html","hash":"13054957e79de55e1fd757a4e89f9330c995cdab","modified":1755529442177},{"_id":"public/archives/2025/index.html","hash":"209ae81a748e4ae16191bab13fca70ba3b94eeb5","modified":1755529442177},{"_id":"public/archives/2025/02/index.html","hash":"4586a27215e9c5591f8e0f5fc0a48c988290476f","modified":1755529442177},{"_id":"public/index.html","hash":"aae9e217c2a5caa978984ca0d9af38c130746d53","modified":1755529442177},{"_id":"public/page/2/index.html","hash":"dc1b0d08213e84be6b5e7b5b48fbad5845b00499","modified":1755529442177},{"_id":"public/page/3/index.html","hash":"1d8b83f2eb2cadca41d2d00515141f1cb71f78cc","modified":1755529442177},{"_id":"public/tags/图形学/index.html","hash":"bec53f808adbff342b2a42dd4ac0d99d3059faca","modified":1755529442177},{"_id":"public/tags/渲染/index.html","hash":"c35598418dc65f2a28ffb2cd6c495eda6003e7b1","modified":1755529442177},{"_id":"public/tags/Hexo/index.html","hash":"cc19c89669d05e9d73817c1c799c30e64cd5ea83","modified":1755529442177},{"_id":"public/tags/主题变更/index.html","hash":"3cc7baadf351dee64440cf5764b8d7889190428c","modified":1755529442177},{"_id":"public/tags/Unity/index.html","hash":"143e9148016bb736a73d3e9e8aece7612707ecc4","modified":1755529442177},{"_id":"public/tags/特效/index.html","hash":"f57b81dd41897431593fdded64b65c88df48d5c5","modified":1755529442177},{"_id":"public/404.html","hash":"d976f6f576b8fcf369e23207a3df8470a32c6a86","modified":1755529442177},{"_id":"public/tags/算法/index.html","hash":"0ed4cd6eb97a5fd89fb7a8ac5e068cd8c5e0ef67","modified":1755529442177},{"_id":"public/tags/文学/index.html","hash":"6f97b2bd6cb456d64837e8842c88222ce8fd328a","modified":1755529442177},{"_id":"public/tags/index.html","hash":"e955c89d6a3eb86a89f29242a98a241819d3a8d2","modified":1755529442177},{"_id":"public/categories/index.html","hash":"979b99d5a45bbec38e90f1cccdd7f48cf1a2be1f","modified":1755529442177},{"_id":"public/links/index.html","hash":"df953a4b379bba86e7cfa2f5e9d1a3b6089bb8b3","modified":1755529442177},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1755013486890},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1755013486890},{"_id":"public/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1755013486890},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1755013486890},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1755013486890},{"_id":"public/imgs/C++-sort-浅识/题目-1677565078882-1.png","hash":"fd098cbe2a8c4920ac974178c5069b436f46f4a1","modified":1755013486890},{"_id":"public/imgs/C++-sort-浅识/sort.png","hash":"1e98b2e440af9e4fec4983ebb3aded02dccab811","modified":1755013486890},{"_id":"public/imgs/LearnPBR/BRDF.svg","hash":"e624dccc3d2847b7a7f86fd5631a7d9b8d495307","modified":1755013486890},{"_id":"public/imgs/Hexo主题变更/deskt.png","hash":"ce678ce0bce3a20a630256eea85a3372b1303c0b","modified":1755013486890},{"_id":"public/imgs/LearnPBR/G.png","hash":"184fc82773788ea759a27b8df6c96174767fc9ea","modified":1755013486890},{"_id":"public/imgs/LearnPBR/Kulla-Conty.png","hash":"8672e4f0121ef74e6775600f3a9d89d487c61e85","modified":1755013486890},{"_id":"public/imgs/LearnPBR/Radiance.png","hash":"729cb9d779af4a80753706b919bb13b3abfe4fdd","modified":1755013486890},{"_id":"public/imgs/LearnPBR/boban.jpg","hash":"9e956b2bece758255fd66c2a62c1f590587ee4b9","modified":1755013486890},{"_id":"public/imgs/LearnPBR/chart3.png","hash":"c542bc6124361bec929f5538705f88fcd5141d64","modified":1755013486890},{"_id":"public/imgs/LearnPBR/fresnel.png","hash":"743f76858069071b5e6136e9170a43e9c4a441f8","modified":1755013486890},{"_id":"public/imgs/LearnPBR/ibl1.png","hash":"3281b4638a081b0ff0373734ff0cac04343045dd","modified":1755013486890},{"_id":"public/imgs/LearnPBR/ibl2.png","hash":"e1cd91dfa78f1a1bdc0548e13fc864dec8893d89","modified":1755013486890},{"_id":"public/imgs/LearnPBR/ggx.png","hash":"9caab93ef2347915403d6318d6834516b7158fd7","modified":1755013486890},{"_id":"public/imgs/LearnPBR/microfacet.png","hash":"088d8593cfc7370b840cfbb40042cd1855f0f3b7","modified":1755013486890},{"_id":"public/imgs/LearnPBR/metallic.png","hash":"14c33a7f6e2c2d9181050e19c5fecca9260b520f","modified":1755013486890},{"_id":"public/imgs/LearnPBR/poban.jpg","hash":"29ec1a22ff21c02b087c90b3bf804e520d78ec8a","modified":1755013486890},{"_id":"public/imgs/LearnPBR/roughness.png","hash":"38fb7b2e6c644375db9e4561acc872bd6faa6852","modified":1755013486890},{"_id":"public/imgs/LearnPBR/reflect.png","hash":"57ecb740483cd9586ede66de0cfc798b69f42374","modified":1755013486890},{"_id":"public/imgs/LearnPBR/sample.png","hash":"a5991cf63fb9c83126a49ec2a0ab8d5c6861ed85","modified":1755013486890},{"_id":"public/imgs/LearnPBR/roughness2.png","hash":"1a0090fa102e65a84edcf517f066c1340f7d87b6","modified":1755013486890},{"_id":"public/imgs/LearnPBR/uecode1.png","hash":"c7604a8df7efec434581083f809ac0e351ed3ba7","modified":1755013486890},{"_id":"public/imgs/LearnPBR/uecode2.png","hash":"d27c55061b2470b690f8f1e33dfdf6159b0067f3","modified":1755013486890},{"_id":"public/imgs/VisualStudioPro/Vs2.png","hash":"2b233d41de28a0bebf8df9fc9443e3910cdf277d","modified":1755013486890},{"_id":"public/imgs/PBR/math4.png","hash":"9c6ad0d80d9d6740d9edd8ff273952659a3b0ee8","modified":1755013486890},{"_id":"public/imgs/PBR/math2.png","hash":"39803c9b63af774368f3573b8c18e3c9f03f9206","modified":1755013486890},{"_id":"public/imgs/PBR/jihe.png","hash":"7d34abb52d9da4204a0c3f8a752e8f82b4b07a3d","modified":1755013486890},{"_id":"public/imgs/PBR/math1.png","hash":"c20d184db8fa21033a89e35fe97fced3e92b0595","modified":1755013486890},{"_id":"public/imgs/PBR/math3.png","hash":"f4447c6af98a75fe78ec25b081d8c3bf3fe823b4","modified":1755013486890},{"_id":"public/imgs/PBR/math5.png","hash":"5929c3a9e33ca0b7e9ac24bd2a4bbbc1d8a1d5a9","modified":1755013486890},{"_id":"public/imgs/PBR/phong.png","hash":"31d91c5bad11dc298e74915ee86a653b5fab887d","modified":1755013486890},{"_id":"public/imgs/PBR/math6.png","hash":"35df98d0f9c402632031a590d0793f094f5ac9f8","modified":1755013486890},{"_id":"public/imgs/PBR/math7.png","hash":"c4cccf1c369a314b134d0ab9cd081d4c50aab9db","modified":1755013486890},{"_id":"public/imgs/关于SRP Batcher/OldMaterial.jpg","hash":"628491e6faf5616f8a50f89aafcb60b93ad8ba94","modified":1755013486890},{"_id":"public/imgs/PBR/几何遮蔽.png","hash":"b97b722ea36f82c6e68a362ba9feb1ca04d738fe","modified":1755013486890},{"_id":"public/imgs/关于SRP Batcher/SRPPipeline.jpg","hash":"3e34ff01b718d4545f58e2d8db0f13895f6a0dc5","modified":1755013486890},{"_id":"public/imgs/大气散射/DirectionLight.png","hash":"b2810aa4b0423addd86111de756d8bd087016e4c","modified":1755013486890},{"_id":"public/imgs/大气散射/InScattering.PNG","hash":"66bceae2be44176ffb0f2146c304f58cf0fbef4a","modified":1755013486890},{"_id":"public/imgs/关于SRP Batcher/SRPPipeline2.jpg","hash":"330721075551d711d324ed0cfa792b860785fead","modified":1755013486890},{"_id":"public/imgs/大气散射/OutScattering2.PNG","hash":"ef30ab442655037e95ce0ada474d9a5fb2a9c8b8","modified":1755013486890},{"_id":"public/imgs/大气散射/OutScattering.png","hash":"b0b1b89753085878808817cbddd42600c6ee67c8","modified":1755013486890},{"_id":"public/imgs/大气散射/NumericalIntegration.png","hash":"2f64ea53a79568e97e8234031a90fe87f1020be2","modified":1755013486890},{"_id":"public/imgs/大气散射/RayleighScattering.png","hash":"be8e64c44166d73198cdcca556b034fc13d2da6f","modified":1755013486890},{"_id":"public/imgs/大气散射/SingleScattering.PNG","hash":"b97392a5d4724c0a75c275405924d88d0edbc50e","modified":1755013486890},{"_id":"public/imgs/大气散射/ScatteringFunc.png","hash":"66bceae2be44176ffb0f2146c304f58cf0fbef4a","modified":1755013486890},{"_id":"public/imgs/大气散射/Trasmittance2.png","hash":"d63cad83faf1b5312a82db226920d0fd696822b4","modified":1755013486890},{"_id":"public/imgs/大气散射/Trasmittance.png","hash":"c7db0aa771b2bfc9a965f0c6778ebc6d04f93744","modified":1755013486890},{"_id":"public/imgs/大气散射/chart2.png","hash":"48872806a0e7efe4677bfe634a45551990cd3668","modified":1755013486890},{"_id":"public/imgs/大气散射/height.png","hash":"d388b44d9dab887372e7ccb7aa0413fbd713a23b","modified":1755013486890},{"_id":"public/imgs/SpringBoss/4x4Matrix.png","hash":"3fd4e2fc82e4a6b3163857529aa235ac246b8f26","modified":1755013486890},{"_id":"public/imgs/SpringBoss/4x4Rn.png","hash":"ffa992a382c70cb1378f3a15b19d9258155257c3","modified":1755013486890},{"_id":"public/imgs/SpringBoss/C_ambient.png","hash":"3e82e9882b334607cd550821afb7aec8641c3903","modified":1755013486890},{"_id":"public/imgs/SpringBoss/BlinnPhong.png","hash":"dd823449031987e821b787cabc81128d6e925b8a","modified":1755013486890},{"_id":"public/imgs/大气散射/math2.png","hash":"7acdf00665b199561cf6bf1ee8ddd0f0c81b26df","modified":1755013486890},{"_id":"public/imgs/大气散射/math.png","hash":"5d4c9e62de392084c07625f3712442041fa2e80b","modified":1755013486890},{"_id":"public/imgs/SpringBoss/C_diffuse.png","hash":"1ed03a8650488adb1ffa7cecaacbf58c36c78fb9","modified":1755013486890},{"_id":"public/imgs/SpringBoss/ModelCol.png","hash":"bdc540d72dd7496d2726651fdbfb143ad06feda7","modified":1755013486890},{"_id":"public/imgs/SpringBoss/C_emissive.png","hash":"49e0a589d9aea640ed1bc8e1f1040933e5ae4bfe","modified":1755013486890},{"_id":"public/imgs/SpringBoss/Mview.png","hash":"54b69ecafa3bc651ed42b46e755fa3cfca4999f9","modified":1755013486890},{"_id":"public/imgs/SpringBoss/ModelRow.png","hash":"6dc6f9f2d843bf6f9fcabc049600e12b5a0ac579","modified":1755013486890},{"_id":"public/imgs/SpringBoss/PhongSpecular.png","hash":"c6ce23b28f0f7131263612461f5f44ce6f709a7a","modified":1755013486890},{"_id":"public/imgs/SpringBoss/NormalLightEyeRef.png","hash":"80cf7daf120bbf99fe7645a48a93bca77732442e","modified":1755013486890},{"_id":"public/imgs/SpringBoss/Polar.png","hash":"f55ff9c68aabcdea414f7315361de2d695194ec8","modified":1755013486890},{"_id":"public/imgs/SpringBoss/Rview.png","hash":"e2106ad47777d5acb2b1f8cbf77a7e7b3f3cb254","modified":1755013486890},{"_id":"public/imgs/SpringBoss/cameraETG.png","hash":"d10aa1458e8781cf85adfa6e247847d20600d5ed","modified":1755013486890},{"_id":"public/imgs/SpringBoss/colMHC.png","hash":"0ed0079cc4011046756098d26ae48103b6671627","modified":1755013486890},{"_id":"public/imgs/SpringBoss/RefEqu.png","hash":"8d7be77f52294ce9400dc4c8e4ff2e013d818e66","modified":1755013486890},{"_id":"public/imgs/SpringBoss/cameraXYZ.png","hash":"612ee64521ce46954dddc565f5fe6ae8071b3263","modified":1755013486890},{"_id":"public/imgs/SpringBoss/colMHCT.png","hash":"ab8a93bb19fbec878d86edcd038e54074b128c22","modified":1755013486890},{"_id":"public/imgs/SpringBoss/posE.png","hash":"8551a9196342c55cdffec5a382a726b360d732ad","modified":1755013486890},{"_id":"public/imgs/SpringBoss/columnMatrix.png","hash":"a01a60ff48b25b458035001c46c0b998697013a5","modified":1755013486890},{"_id":"public/imgs/SpringBoss/rotationX.png","hash":"bf608427338ec57ce10584a3e77b433561b9c950","modified":1755013486890},{"_id":"public/imgs/SpringBoss/orthM.png","hash":"3b0a02a8fd4f695d7719cdb8dc9e93a6c50813ce","modified":1755013486890},{"_id":"public/imgs/SpringBoss/rotationZ.png","hash":"2985968c615593179a93e750ec963f2e5a52b82f","modified":1755013486890},{"_id":"public/imgs/SpringBoss/rowMatrixHC.png","hash":"b8d516c5bd5087fbe6002ee795e6e822aff16c53","modified":1755013486890},{"_id":"public/imgs/SpringBoss/rotationY.png","hash":"ada6371b2eb6c5b5a30675e94af7f7c3c168629f","modified":1755013486890},{"_id":"public/imgs/SpringBoss/rowMatrix.png","hash":"cc90fe6d2fb8a53b4f44c4190a829f7e546fb87a","modified":1755013486890},{"_id":"public/imgs/SpringBoss/rowMatrixHCT.png","hash":"af944b7c2f6235658cf9865e1d70b8c91c80f932","modified":1755013486890},{"_id":"public/imgs/SpringBoss/scale.png","hash":"afd601a8cc7555d5ba68757a5676bd605877f123","modified":1755013486890},{"_id":"public/imgs/SpringBoss/translate.png","hash":"6153efc0d346eca2a764b1cb443f6a46899f0abb","modified":1755013486890},{"_id":"public/imgs/SpringBoss/transform.png","hash":"755d166b6b08aa4161204caf827b1ae8edeac13c","modified":1755013486890},{"_id":"public/imgs/包围盒与物体碰撞/AABB&OBB.jfif","hash":"8135e91baf26756b94481198c745b4272123f5ad","modified":1755013486890},{"_id":"public/imgs/常见设计模式/Proxy.jpg","hash":"5b37f39492f7b6fbc699bdca799695ba0d3a5862","modified":1755013486890},{"_id":"public/imgs/读刘盆子传/zzpbzb.JPG","hash":"09e8f7117f94d04e752b89f43a123f5f8eaf9d6f","modified":1755013486890},{"_id":"public/imgs/常见设计模式/StrategyUML.png","hash":"ae1cb99b96e4cbc40dc055efb84c122aff3dc3b6","modified":1755013486890},{"_id":"public/imgs/每日Emo小短句/F1SZC9}W}_XEA5S]5FCJM3.png","hash":"fbd5f9f57f1bc5b65ed0222b6e83f9ea76ae7291","modified":1755013486890},{"_id":"public/imgs/SpringBoss/viewT.png","hash":"13d332f4876820813ccbbebc81ed11edc4db09b0","modified":1755013486890},{"_id":"public/imgs/LearnPBR/chart2.png","hash":"7907f0b67282b617e3fb5045a66dc655916c3d4d","modified":1755013486890},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1755013486890},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1755013486890},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1755013486890},{"_id":"public/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1755529442177},{"_id":"public/css/main.css","hash":"7d7590cfe0261084ad357d5f51cb14d13db826d8","modified":1755013486890},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1755013486890},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1755013486890},{"_id":"public/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1755529442177},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1755013486890},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1755013486890},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1755013486890},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1755013486890},{"_id":"public/imgs/VisualStudioPro/Vs1.png","hash":"98f8021c0b5f57a1cc73c8c23cf0db684c943489","modified":1755013486890},{"_id":"public/imgs/ZumaGame/question.png","hash":"7814be7c181db4a56211bdb782c85ceabb565065","modified":1755013486890},{"_id":"public/imgs/大气散射/chart.png","hash":"dd56e543fa8564373c3629a169521ef0e0651fc4","modified":1755013486890},{"_id":"public/imgs/SpringBoss/LeftRight.png","hash":"1809ddd8f4f26cd3e4686bb172603d770a53afdd","modified":1755013486890},{"_id":"public/imgs/水面模拟/kWave.png","hash":"17ceb1027fbaa273931cef7888268f45b48c09fd","modified":1755013486890},{"_id":"public/imgs/水面模拟/waveparameters.png","hash":"0bdefd1bdb555f838568994d181a3d49a5c31e61","modified":1755013486890},{"_id":"public/imgs/透明和Early Z、Pre Z/渲染流程.png","hash":"493eedf2d44193de84f5b4ba7fe0367c2ec32c96","modified":1755013486890},{"_id":"public/imgs/CMake Note/Qt5Error.png","hash":"6f3eecd2908d2a6f6f6cdcf7660ae53c4ea3d7b3","modified":1755013486890},{"_id":"public/imgs/CMake Note/Qt5CannotFound.png","hash":"e3320ca0784cf8514546681de34a3ad32dd14b79","modified":1755013486890},{"_id":"public/imgs/LearnPBR/IBLCubemap.png","hash":"57f6ad06b65cbb5e7d3b8f4a5823acf20aaa08a6","modified":1755013486890},{"_id":"public/imgs/LearnPBR/iblAlpha.png","hash":"e0b61a95f8cf99d8db90e49ae285a37b29012cb4","modified":1755013486890},{"_id":"public/imgs/LearnPBR/specular.png","hash":"ad4f9d5b6a550225235dfabbd1e7fb37fe513771","modified":1755013486890},{"_id":"public/imgs/MoyuPics/220702CF.jpg","hash":"f4c24aa422dc7e94514e19e59615e2c462aa1b57","modified":1755013486890},{"_id":"public/imgs/MoyuPics/617e.jpg","hash":"9253e03c9feaa3fc1c5aa0a73414b13d3e65e67e","modified":1755013486890},{"_id":"public/imgs/MoyuPics/220702光头.jpg","hash":"92e658ef92bc424286b0f361797d3236102d1752","modified":1755013486890},{"_id":"public/imgs/MoyuPics/617m.jpg","hash":"f89af4331c5f424f8c1374e30ffbc6116eed7bf4","modified":1755013486890},{"_id":"public/imgs/MoyuPics/617w.jpg","hash":"2350821fcaf3a169095f1674f37519a6723ffe41","modified":1755013486890},{"_id":"public/imgs/一些数学推导/重心坐标2.png","hash":"11d0554775060f01f44f084cfe523d698264ef26","modified":1755013486890},{"_id":"public/imgs/关于SRP Batcher/SRPPerObject.jpg","hash":"3c9015c3cae14212827d749e41e76aaf924b9f92","modified":1755013486890},{"_id":"public/imgs/PBR/BSDF.png","hash":"4bb6cba63f29f8717a42481be42989805e6a052a","modified":1755013486890},{"_id":"public/imgs/SpringBoss/unityUpdate.jpg","hash":"2268bcac016ea682abeadd2e6a64ec8bd274cb51","modified":1755013486890},{"_id":"public/imgs/水面模拟/directionWave.png","hash":"0d18bc7bfc4826672796b0a38296d2145f70680a","modified":1755013486890},{"_id":"public/imgs/LearnPBR/chart1.png","hash":"c2d301897cd3dd965053268426ec05cde1a93a47","modified":1755013486890},{"_id":"public/imgs/LearnPBR/ueReference.png","hash":"9ce930092ec1276d0a2f96b3c30b624a74e02514","modified":1755013486890},{"_id":"public/imgs/MoyuPics/220630jo.jpg","hash":"7eb2ba317578bce0ff63244f006cc5b46c433ed7","modified":1755013486890},{"_id":"public/imgs/一些数学推导/重心坐标1.png","hash":"41dfb571e5d79d80947ccd0f709577dd9a044001","modified":1755013486890},{"_id":"public/imgs/Hexo主题变更/Fluid_Config.png","hash":"c93486316a51e01cc18e198d8f71b975bb3a66c0","modified":1755013486890},{"_id":"public/imgs/Hexo主题变更/pandoc1-1.png","hash":"3e707b4c554689512b9e36780b09ad7a4590a1cd","modified":1755013486890},{"_id":"public/imgs/大气散射/Res01.png","hash":"fdc6e8e2c4ab082520832ab874433b9ff97fd69a","modified":1755013486890},{"_id":"public/imgs/SpringBoss/viewMatrixMyNote.png","hash":"aecfd9b0e22f92692543ccb3b48e91144f6923cc","modified":1755013486890},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1755013486890},{"_id":"public/imgs/C++RAII/35.png","hash":"efdf5bedd807741e6cc5bd168a8a553c887ef34c","modified":1755013486890},{"_id":"public/imgs/大气散射/Res02.png","hash":"da6b4ba864e3b440c89d7fb9a2eccd2f907cda80","modified":1755013486890},{"_id":"public/imgs/Hexo主题变更/web.png","hash":"0b4be6b987a6fe1300d7dcf4a3f86f961dfd6379","modified":1755013486890},{"_id":"public/imgs/大气散射/Res03.png","hash":"7d2b880076c9eca3e02c87f1eda72b4bab56bb9f","modified":1755013486890},{"_id":"public/imgs/Hexo主题变更/pandoc1.png","hash":"2c28e956b833dcb986e7cc443eda1dc0d57b1279","modified":1755013486890},{"_id":"public/imgs/LearnPBR/output2.PNG","hash":"801660a91c7743e338eb2d8b7e6f0ae54986bdd0","modified":1755013486890},{"_id":"public/imgs/LearnPBR/output4-1.PNG","hash":"f5d20d4024532ee37201f4851c7ec1da5ae6309c","modified":1755013486890},{"_id":"public/imgs/LearnPBR/output.PNG","hash":"4c96f7488b330de426afdf290b91e71f3862c8a4","modified":1755013486890},{"_id":"public/imgs/LearnPBR/output3.PNG","hash":"99492da9ca6e26fba71d8352cfa8ce6c4cae3b6c","modified":1755013486890},{"_id":"public/imgs/SpringBoss/RayPointSpe.png","hash":"21a414d78f788a43c271cb9455205e980dea1073","modified":1755013486890},{"_id":"public/imgs/LearnPBR/AnisoSphere2.png","hash":"26ac710bbb647f4242423db9f09caabb6206521f","modified":1755013486890},{"_id":"public/imgs/MoyuPics/20221114EyeCue.jpg","hash":"263a4f853f7509fd93fa1151741a4ffea27c75e9","modified":1755013486890},{"_id":"public/imgs/水面模拟/waveNV1.png","hash":"e3c1613cc9c1676788978104ce3c340c671fd783","modified":1755013486890},{"_id":"public/imgs/透明和Early Z、Pre Z/BT.jpg","hash":"7b8c4f4948f75d25fd53db4bdc9f0a55ea7fa955","modified":1755013486890},{"_id":"public/imgs/透明和Early Z、Pre Z/先不后透.jpg","hash":"5955822c6296a65668120207625dc587c85dce38","modified":1755013486890},{"_id":"public/imgs/透明和Early Z、Pre Z/TB.jpg","hash":"e0bebace4d63053fa02a9bbf71f9d56e8ea32a0f","modified":1755013486890},{"_id":"public/imgs/LearnPBR/pbr.png","hash":"dd26d721c367005792b4994d6bad2920a4b79f73","modified":1755013486890},{"_id":"public/imgs/透明和Early Z、Pre Z/先透后不.jpg","hash":"f27ff79245ccf80f0ec6ee2d74f432284795adab","modified":1755013486890},{"_id":"public/imgs/MoyuPics/220702P2.jpg","hash":"b392c9f2e57933fa8b128302855b029c62162de5","modified":1755013486890},{"_id":"public/imgs/MoyuPics/starve.jpg","hash":"285c20b141847f64534abeb907d595bf9da5e830","modified":1755013486890},{"_id":"public/imgs/水面模拟/waveNV2.png","hash":"a5f9e1596d7ce79db0fa0e91e1f170c4047d16e9","modified":1755013486890},{"_id":"public/imgs/MoyuPics/5.29.jpg","hash":"e84289113108441d66a62b64b66d94ae8abd0066","modified":1755013486890},{"_id":"public/imgs/MoyuPics/卷发5.26.jpg","hash":"5da2767eee241e9471e1a71fa414851a9cc1dd4b","modified":1755013486890},{"_id":"public/imgs/MoyuPics/边缘.jpg","hash":"86afd87e71970936abda0ae9f84458716078cb35","modified":1755013486890},{"_id":"public/imgs/水面模拟/InterstellarSeaWave.png","hash":"395911d4586a5a067230640a85e9b43157cc40c0","modified":1755013486890},{"_id":"public/imgs/MoyuPics/2022.6.15.jpg","hash":"b2cdd27640c14773a59ba730677123c9ecbcb7b8","modified":1755013486890},{"_id":"public/imgs/MoyuPics/220702P4.jpg","hash":"3d52054b7badde9fe74e0cd63039cb991f97ed75","modified":1755013486890},{"_id":"public/imgs/MoyuPics/220702P3.jpg","hash":"596f3a124cdd24f14a3774b6f4f43e41248c8e8b","modified":1755013486890},{"_id":"public/imgs/透明和Early Z、Pre Z/qh.jpg","hash":"5af98f78727891438a0bb3cf61012f285acdfff8","modified":1755013486890},{"_id":"public/imgs/MoyuPics/220702P1.jpg","hash":"3d1ddc3db94157b562439cf758634416ca5e4150","modified":1755013486890},{"_id":"public/imgs/MoyuPics/eye614.jpg","hash":"82d024ba93a520d7dc480539d0d1e66d485be049","modified":1755013486890},{"_id":"public/imgs/MoyuPics/5.30.jpg","hash":"5ff77b129f3a1eca791b0319097e3e3f78196367","modified":1755013486890},{"_id":"public/imgs/MoyuPics/22-6-22.jpg","hash":"ad9389e3cc02ad6c20feb79da0959b3f0569e31d","modified":1755013486890},{"_id":"public/imgs/Hexo主题变更/Shiki&Tsukihime.png","hash":"73d69c5d263146ef2402d9ec170b0d83ec5292fa","modified":1755013486890},{"_id":"source/_posts/C++Note_1.md","hash":"72724ad94420a6eab7357c7e8204113a1d544937","modified":1755451735569},{"_id":"source/imgs/C++/虚继承.jpg","hash":"a8138709340ee3b0307c7f720bc30afab2ddf4fc","modified":1755280936500},{"_id":"public/2025/08/16/C++Note_1/index.html","hash":"784ac636ddad7bebba842a2c7980a4d113191666","modified":1755529442177},{"_id":"public/archives/2025/08/index.html","hash":"777638ffa12ba278eda20c2cc07a8fb197c97f53","modified":1755529442177},{"_id":"public/tags/C/index.html","hash":"b913401e324f50f2544f926c8fb954ebadcd6074","modified":1755529442177},{"_id":"public/imgs/C++/虚继承.jpg","hash":"a8138709340ee3b0307c7f720bc30afab2ddf4fc","modified":1755281079916},{"_id":"source/_posts/Dog Philosophers.md","hash":"f4416e1902296a5eeca0182ba07efab7286284c9","modified":1755420893026},{"_id":"public/2025/08/17/Dog Philosophers/index.html","hash":"f0ce573f05edb69e96a4d08c2722c403249618e8","modified":1755529442177},{"_id":"public/archives/page/4/index.html","hash":"777f9c566174a4ee8086620c005e8ca08dfea376","modified":1755529442177},{"_id":"public/page/4/index.html","hash":"83cd4159494f0615ece37b9d5eb8f7b7c60c36ae","modified":1755529442177},{"_id":"public/tags/哲学/index.html","hash":"b69d429e31ab188eb77d6b95707adebbcdd992c2","modified":1755529442177},{"_id":"public/tags/犬儒主义/index.html","hash":"babf0cdeea1f2a586d197c8e70d1346306b81465","modified":1755529442177},{"_id":"themes/fluid/source/js/umami-view.js","hash":"370ab30ab88c596d85327dbd7db3bafd49489fdd","modified":1755529428472},{"_id":"public/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1755529442177}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"C++-sort-浅识","date":"2022-05-03T05:44:28.000Z","typora-root-url":"./..","_content":"\n今天在做题时候发现自己对于C++自定义排序方法`sort` 和 `stable_sort` 的理解一直有问题。\n\n<!--more-->\n\n先说最粗暴简单的理解: **`sort` 和 `stable_sort` 定义了我们希望的\"<\"比较，就是把我们认为小的放在前面**。\n\n# 题目\n\n<img src=\"/imgs/C++-sort-浅识/题目-1677565078882-1.png\"/>\n\n代码: \n\n```cpp  \nvector<string> reorderLogFiles(vector<string>& logs) {  \n    stable_sort(logs.begin(), logs.end(), [&](const string& log1, const string& log2) {  \n        int pos1 = log1.find_first_of(' ');  \n        int pos2 = log2.find_first_of(' ');  \n        bool isDigit1 = isdigit(log1[pos1 + 1]);  \n        bool isDigit2 = isdigit(log2[pos2 + 1]);  \n        if (isDigit1 && isDigit2)  \n        {  \n            return false;        // 我的问题  \n        }  \n        if (!isDigit1 && !isDigit2)  \n        {  \n            string str1 = log1.substr(pos1);  \n            string str2 = log2.substr(pos2);  \n            if (str1 != str2)  \n                return str1 < str2;  \n            return log1 < log2;  \n        }  \n        return isDigit1 ? false : true;  \n        });  \n    return logs;  \n}  \n```\n\n我的问题就是出现在数字log的处理部分:\n\n先说说一开始的**错误理解**: `s1`和 `s2` 作为两个比较对象传入，`s1` 在 `s2` 前面，如果返回值为 `true`，不做修改；如果返回值为 `false`，二者交换位置。 \n\n嘿，这看上去完全就是很合理的嘛，因为依照我们的经验来看就是这样，**然而**实际却相去甚远。\n\n## 我的反思\n\n<img src=\"/imgs/C++-sort-浅识/sort.png\"/>\n\n这是在说什么呢？就是说我们自定义的 `sort` 其实实现的是 `<` 比较。  \n关于返回值的理解就是，如果返回值为 `true` 就是 `s1 < s2`，那么返回值为 `false`就很好解释了，利用一点离散知识, `!<` 就是 `>=` 。\n\n> 如果对于离散有疑问，那换一个简单粗暴的说法：  \n> true: 就是 s1 < s2  \n>   \n> 那么， s1 = s2 和 s1 > s2 就都是 false\n\n# 总结\n\n我需要纠正的是 `sort` 函数注重的是 `cmp` 而不是 `swap`，就是只是实现比较谁更“小”，而不是他们的位置关系。\n\n相关链接:  \n=======\n---\ntitle: C++-sort-浅识\ndate: 2022-05-03 13:44:28\ntags: \ntypora-root-url: ./..\n---\n\n今天在做题时候发现自己对于C++自定义排序方法`sort` 和 `stable_sort` 的理解一直有问题。\n\n<!--more-->\n\n先说最粗暴简单的理解: **`sort` 和 `stable_sort` 定义了我们希望的\"<\"比较，就是把我们认为小的放在前面**。\n\n# 题目\n\n<img src=\"/imgs/C++-sort-浅识/题目-1677565078882-1.png\"/>\n\n代码: \n\n```cpp  \nvector<string> reorderLogFiles(vector<string>& logs) {  \n    stable_sort(logs.begin(), logs.end(), [&](const string& log1, const string& log2) {  \n        int pos1 = log1.find_first_of(' ');  \n        int pos2 = log2.find_first_of(' ');  \n        bool isDigit1 = isdigit(log1[pos1 + 1]);  \n        bool isDigit2 = isdigit(log2[pos2 + 1]);  \n        if (isDigit1 && isDigit2)  \n        {  \n            return false;        // 我的问题  \n        }  \n        if (!isDigit1 && !isDigit2)  \n        {  \n            string str1 = log1.substr(pos1);  \n            string str2 = log2.substr(pos2);  \n            if (str1 != str2)  \n                return str1 < str2;  \n            return log1 < log2;  \n        }  \n        return isDigit1 ? false : true;  \n        });  \n    return logs;  \n}  \n```\n\n我的问题就是出现在数字log的处理部分:\n\n先说说一开始的**错误理解**: `s1`和 `s2` 作为两个比较对象传入，`s1` 在 `s2` 前面，如果返回值为 `true`，不做修改；如果返回值为 `false`，二者交换位置。 \n\n嘿，这看上去完全就是很合理的嘛，因为依照我们的经验来看就是这样，**然而**实际却相去甚远。\n\n## 我的反思\n\n<img src=\"/imgs/C++-sort-浅识/sort.png\"/>\n\n这是在说什么呢？就是说我们自定义的 `sort` 其实实现的是 `<` 比较。  \n关于返回值的理解就是，如果返回值为 `true` 就是 `s1 < s2`，那么返回值为 `false`就很好解释了，利用一点离散知识, `!<` 就是 `>=` 。\n\n> 如果对于离散有疑问，那换一个简单粗暴的说法：  \n> true: 就是 s1 < s2  \n>   \n> 那么， s1 = s2 和 s1 > s2 就都是 false\n\n# 总结\n\n我需要纠正的是 `sort` 函数注重的是 `cmp` 而不是 `swap`，就是只是实现比较谁更“小”，而不是他们的位置关系。\n\n相关链接:  \n>>>>>>> e8dca420d7048ad9484cd8252ef496504eab0a20\n[Why must std::sort compare function return false when arguments are equal?](https://stackoverflow.com/questions/45929474/why-must-stdsort-compare-function-return-false-when-arguments-are-equal)  ","source":"_posts/C++-sort-浅识.md","raw":"---\ntitle: C++-sort-浅识\ndate: 2022-05-03 13:44:28\ntags: \ntypora-root-url: ./..\n---\n\n今天在做题时候发现自己对于C++自定义排序方法`sort` 和 `stable_sort` 的理解一直有问题。\n\n<!--more-->\n\n先说最粗暴简单的理解: **`sort` 和 `stable_sort` 定义了我们希望的\"<\"比较，就是把我们认为小的放在前面**。\n\n# 题目\n\n<img src=\"/imgs/C++-sort-浅识/题目-1677565078882-1.png\"/>\n\n代码: \n\n```cpp  \nvector<string> reorderLogFiles(vector<string>& logs) {  \n    stable_sort(logs.begin(), logs.end(), [&](const string& log1, const string& log2) {  \n        int pos1 = log1.find_first_of(' ');  \n        int pos2 = log2.find_first_of(' ');  \n        bool isDigit1 = isdigit(log1[pos1 + 1]);  \n        bool isDigit2 = isdigit(log2[pos2 + 1]);  \n        if (isDigit1 && isDigit2)  \n        {  \n            return false;        // 我的问题  \n        }  \n        if (!isDigit1 && !isDigit2)  \n        {  \n            string str1 = log1.substr(pos1);  \n            string str2 = log2.substr(pos2);  \n            if (str1 != str2)  \n                return str1 < str2;  \n            return log1 < log2;  \n        }  \n        return isDigit1 ? false : true;  \n        });  \n    return logs;  \n}  \n```\n\n我的问题就是出现在数字log的处理部分:\n\n先说说一开始的**错误理解**: `s1`和 `s2` 作为两个比较对象传入，`s1` 在 `s2` 前面，如果返回值为 `true`，不做修改；如果返回值为 `false`，二者交换位置。 \n\n嘿，这看上去完全就是很合理的嘛，因为依照我们的经验来看就是这样，**然而**实际却相去甚远。\n\n## 我的反思\n\n<img src=\"/imgs/C++-sort-浅识/sort.png\"/>\n\n这是在说什么呢？就是说我们自定义的 `sort` 其实实现的是 `<` 比较。  \n关于返回值的理解就是，如果返回值为 `true` 就是 `s1 < s2`，那么返回值为 `false`就很好解释了，利用一点离散知识, `!<` 就是 `>=` 。\n\n> 如果对于离散有疑问，那换一个简单粗暴的说法：  \n> true: 就是 s1 < s2  \n>   \n> 那么， s1 = s2 和 s1 > s2 就都是 false\n\n# 总结\n\n我需要纠正的是 `sort` 函数注重的是 `cmp` 而不是 `swap`，就是只是实现比较谁更“小”，而不是他们的位置关系。\n\n相关链接:  \n=======\n---\ntitle: C++-sort-浅识\ndate: 2022-05-03 13:44:28\ntags: \ntypora-root-url: ./..\n---\n\n今天在做题时候发现自己对于C++自定义排序方法`sort` 和 `stable_sort` 的理解一直有问题。\n\n<!--more-->\n\n先说最粗暴简单的理解: **`sort` 和 `stable_sort` 定义了我们希望的\"<\"比较，就是把我们认为小的放在前面**。\n\n# 题目\n\n<img src=\"/imgs/C++-sort-浅识/题目-1677565078882-1.png\"/>\n\n代码: \n\n```cpp  \nvector<string> reorderLogFiles(vector<string>& logs) {  \n    stable_sort(logs.begin(), logs.end(), [&](const string& log1, const string& log2) {  \n        int pos1 = log1.find_first_of(' ');  \n        int pos2 = log2.find_first_of(' ');  \n        bool isDigit1 = isdigit(log1[pos1 + 1]);  \n        bool isDigit2 = isdigit(log2[pos2 + 1]);  \n        if (isDigit1 && isDigit2)  \n        {  \n            return false;        // 我的问题  \n        }  \n        if (!isDigit1 && !isDigit2)  \n        {  \n            string str1 = log1.substr(pos1);  \n            string str2 = log2.substr(pos2);  \n            if (str1 != str2)  \n                return str1 < str2;  \n            return log1 < log2;  \n        }  \n        return isDigit1 ? false : true;  \n        });  \n    return logs;  \n}  \n```\n\n我的问题就是出现在数字log的处理部分:\n\n先说说一开始的**错误理解**: `s1`和 `s2` 作为两个比较对象传入，`s1` 在 `s2` 前面，如果返回值为 `true`，不做修改；如果返回值为 `false`，二者交换位置。 \n\n嘿，这看上去完全就是很合理的嘛，因为依照我们的经验来看就是这样，**然而**实际却相去甚远。\n\n## 我的反思\n\n<img src=\"/imgs/C++-sort-浅识/sort.png\"/>\n\n这是在说什么呢？就是说我们自定义的 `sort` 其实实现的是 `<` 比较。  \n关于返回值的理解就是，如果返回值为 `true` 就是 `s1 < s2`，那么返回值为 `false`就很好解释了，利用一点离散知识, `!<` 就是 `>=` 。\n\n> 如果对于离散有疑问，那换一个简单粗暴的说法：  \n> true: 就是 s1 < s2  \n>   \n> 那么， s1 = s2 和 s1 > s2 就都是 false\n\n# 总结\n\n我需要纠正的是 `sort` 函数注重的是 `cmp` 而不是 `swap`，就是只是实现比较谁更“小”，而不是他们的位置关系。\n\n相关链接:  \n>>>>>>> e8dca420d7048ad9484cd8252ef496504eab0a20\n[Why must std::sort compare function return false when arguments are equal?](https://stackoverflow.com/questions/45929474/why-must-stdsort-compare-function-return-false-when-arguments-are-equal)  ","slug":"C++-sort-浅识","published":1,"updated":"2025-08-12T15:39:58.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppthu0000bkbwc3lc0myh","content":"<p>今天在做题时候发现自己对于C++自定义排序方法<code>sort</code> 和\r\n<code>stable_sort</code> 的理解一直有问题。</p>\r\n<span id=\"more\"></span>\r\n<p>先说最粗暴简单的理解: <strong><code>sort</code> 和\r\n<code>stable_sort</code>\r\n定义了我们希望的\"&lt;\"比较，就是把我们认为小的放在前面</strong>。</p>\r\n<h1 id=\"题目\">题目</h1>\r\n<p><img src=\"/imgs/C++-sort-浅识/题目-1677565078882-1.png\"/></p>\r\n<p>代码:</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">vector&lt;string&gt; <span class=\"hljs-title\">reorderLogFiles</span><span class=\"hljs-params\">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;  <br>    <span class=\"hljs-built_in\">stable_sort</span>(logs.<span class=\"hljs-built_in\">begin</span>(), logs.<span class=\"hljs-built_in\">end</span>(), [&amp;](<span class=\"hljs-type\">const</span> string&amp; log1, <span class=\"hljs-type\">const</span> string&amp; log2) &#123;  <br>        <span class=\"hljs-type\">int</span> pos1 = log1.<span class=\"hljs-built_in\">find_first_of</span>(<span class=\"hljs-string\">&#x27; &#x27;</span>);  <br>        <span class=\"hljs-type\">int</span> pos2 = log2.<span class=\"hljs-built_in\">find_first_of</span>(<span class=\"hljs-string\">&#x27; &#x27;</span>);  <br>        <span class=\"hljs-type\">bool</span> isDigit1 = <span class=\"hljs-built_in\">isdigit</span>(log1[pos1 + <span class=\"hljs-number\">1</span>]);  <br>        <span class=\"hljs-type\">bool</span> isDigit2 = <span class=\"hljs-built_in\">isdigit</span>(log2[pos2 + <span class=\"hljs-number\">1</span>]);  <br>        <span class=\"hljs-keyword\">if</span> (isDigit1 &amp;&amp; isDigit2)  <br>        &#123;  <br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;        <span class=\"hljs-comment\">// 我的问题  </span><br>        &#125;  <br>        <span class=\"hljs-keyword\">if</span> (!isDigit1 &amp;&amp; !isDigit2)  <br>        &#123;  <br>            string str1 = log1.<span class=\"hljs-built_in\">substr</span>(pos1);  <br>            string str2 = log2.<span class=\"hljs-built_in\">substr</span>(pos2);  <br>            <span class=\"hljs-keyword\">if</span> (str1 != str2)  <br>                <span class=\"hljs-keyword\">return</span> str1 &lt; str2;  <br>            <span class=\"hljs-keyword\">return</span> log1 &lt; log2;  <br>        &#125;  <br>        <span class=\"hljs-keyword\">return</span> isDigit1 ? <span class=\"hljs-literal\">false</span> : <span class=\"hljs-literal\">true</span>;  <br>        &#125;);  <br>    <span class=\"hljs-keyword\">return</span> logs;  <br>&#125;  <br></code></pre></td></tr></table></figure>\r\n<p>我的问题就是出现在数字log的处理部分:</p>\r\n<p>先说说一开始的<strong>错误理解</strong>: <code>s1</code>和\r\n<code>s2</code> 作为两个比较对象传入，<code>s1</code> 在 <code>s2</code>\r\n前面，如果返回值为 <code>true</code>，不做修改；如果返回值为\r\n<code>false</code>，二者交换位置。</p>\r\n<p>嘿，这看上去完全就是很合理的嘛，因为依照我们的经验来看就是这样，<strong>然而</strong>实际却相去甚远。</p>\r\n<h2 id=\"我的反思\">我的反思</h2>\r\n<p><img src=\"/imgs/C++-sort-浅识/sort.png\"/></p>\r\n<p>这是在说什么呢？就是说我们自定义的 <code>sort</code> 其实实现的是\r\n<code>&lt;</code> 比较。<br />\r\n关于返回值的理解就是，如果返回值为 <code>true</code> 就是\r\n<code>s1 &lt; s2</code>，那么返回值为\r\n<code>false</code>就很好解释了，利用一点离散知识, <code>!&lt;</code>\r\n就是 <code>&gt;=</code> 。</p>\r\n<blockquote>\r\n<p>如果对于离散有疑问，那换一个简单粗暴的说法：<br />\r\ntrue: 就是 s1 &lt; s2</p>\r\n<p>那么， s1 = s2 和 s1 &gt; s2 就都是 false</p>\r\n</blockquote>\r\n<h1 id=\"总结\">总结</h1>\r\n<p>我需要纠正的是 <code>sort</code> 函数注重的是 <code>cmp</code> 而不是\r\n<code>swap</code>，就是只是实现比较谁更“小”，而不是他们的位置关系。</p>\r\n<h1 id=\"相关链接\">相关链接:</h1>\r\n<p>今天在做题时候发现自己对于C++自定义排序方法<code>sort</code> 和\r\n<code>stable_sort</code> 的理解一直有问题。</p>\r\n<!--more-->\r\n<p>先说最粗暴简单的理解: <strong><code>sort</code> 和\r\n<code>stable_sort</code>\r\n定义了我们希望的\"&lt;\"比较，就是把我们认为小的放在前面</strong>。</p>\r\n<h1 id=\"题目-1\">题目</h1>\r\n<p><img src=\"/imgs/C++-sort-浅识/题目-1677565078882-1.png\"/></p>\r\n<p>代码:</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">vector&lt;string&gt; <span class=\"hljs-title\">reorderLogFiles</span><span class=\"hljs-params\">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;  <br>    <span class=\"hljs-built_in\">stable_sort</span>(logs.<span class=\"hljs-built_in\">begin</span>(), logs.<span class=\"hljs-built_in\">end</span>(), [&amp;](<span class=\"hljs-type\">const</span> string&amp; log1, <span class=\"hljs-type\">const</span> string&amp; log2) &#123;  <br>        <span class=\"hljs-type\">int</span> pos1 = log1.<span class=\"hljs-built_in\">find_first_of</span>(<span class=\"hljs-string\">&#x27; &#x27;</span>);  <br>        <span class=\"hljs-type\">int</span> pos2 = log2.<span class=\"hljs-built_in\">find_first_of</span>(<span class=\"hljs-string\">&#x27; &#x27;</span>);  <br>        <span class=\"hljs-type\">bool</span> isDigit1 = <span class=\"hljs-built_in\">isdigit</span>(log1[pos1 + <span class=\"hljs-number\">1</span>]);  <br>        <span class=\"hljs-type\">bool</span> isDigit2 = <span class=\"hljs-built_in\">isdigit</span>(log2[pos2 + <span class=\"hljs-number\">1</span>]);  <br>        <span class=\"hljs-keyword\">if</span> (isDigit1 &amp;&amp; isDigit2)  <br>        &#123;  <br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;        <span class=\"hljs-comment\">// 我的问题  </span><br>        &#125;  <br>        <span class=\"hljs-keyword\">if</span> (!isDigit1 &amp;&amp; !isDigit2)  <br>        &#123;  <br>            string str1 = log1.<span class=\"hljs-built_in\">substr</span>(pos1);  <br>            string str2 = log2.<span class=\"hljs-built_in\">substr</span>(pos2);  <br>            <span class=\"hljs-keyword\">if</span> (str1 != str2)  <br>                <span class=\"hljs-keyword\">return</span> str1 &lt; str2;  <br>            <span class=\"hljs-keyword\">return</span> log1 &lt; log2;  <br>        &#125;  <br>        <span class=\"hljs-keyword\">return</span> isDigit1 ? <span class=\"hljs-literal\">false</span> : <span class=\"hljs-literal\">true</span>;  <br>        &#125;);  <br>    <span class=\"hljs-keyword\">return</span> logs;  <br>&#125;  <br></code></pre></td></tr></table></figure>\r\n<p>我的问题就是出现在数字log的处理部分:</p>\r\n<p>先说说一开始的<strong>错误理解</strong>: <code>s1</code>和\r\n<code>s2</code> 作为两个比较对象传入，<code>s1</code> 在 <code>s2</code>\r\n前面，如果返回值为 <code>true</code>，不做修改；如果返回值为\r\n<code>false</code>，二者交换位置。</p>\r\n<p>嘿，这看上去完全就是很合理的嘛，因为依照我们的经验来看就是这样，<strong>然而</strong>实际却相去甚远。</p>\r\n<h2 id=\"我的反思-1\">我的反思</h2>\r\n<p><img src=\"/imgs/C++-sort-浅识/sort.png\"/></p>\r\n<p>这是在说什么呢？就是说我们自定义的 <code>sort</code> 其实实现的是\r\n<code>&lt;</code> 比较。<br />\r\n关于返回值的理解就是，如果返回值为 <code>true</code> 就是\r\n<code>s1 &lt; s2</code>，那么返回值为\r\n<code>false</code>就很好解释了，利用一点离散知识, <code>!&lt;</code>\r\n就是 <code>&gt;=</code> 。</p>\r\n<blockquote>\r\n<p>如果对于离散有疑问，那换一个简单粗暴的说法：<br />\r\ntrue: 就是 s1 &lt; s2</p>\r\n<p>那么， s1 = s2 和 s1 &gt; s2 就都是 false</p>\r\n</blockquote>\r\n<h1 id=\"总结-1\">总结</h1>\r\n<p>我需要纠正的是 <code>sort</code> 函数注重的是 <code>cmp</code> 而不是\r\n<code>swap</code>，就是只是实现比较谁更“小”，而不是他们的位置关系。</p>\r\n<p>相关链接:<br />\r\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; e8dca420d7048ad9484cd8252ef496504eab0a20 <a\r\nhref=\"https://stackoverflow.com/questions/45929474/why-must-stdsort-compare-function-return-false-when-arguments-are-equal\">Why\r\nmust std::sort compare function return false when arguments are\r\nequal?</a></p>\r\n","site":{"data":{}},"excerpt":"<p>今天在做题时候发现自己对于C++自定义排序方法<code>sort</code> 和\r\n<code>stable_sort</code> 的理解一直有问题。</p>","more":"<p>先说最粗暴简单的理解: <strong><code>sort</code> 和\r\n<code>stable_sort</code>\r\n定义了我们希望的\"&lt;\"比较，就是把我们认为小的放在前面</strong>。</p>\r\n<h1 id=\"题目\">题目</h1>\r\n<p><img src=\"/imgs/C++-sort-浅识/题目-1677565078882-1.png\"/></p>\r\n<p>代码:</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">vector&lt;string&gt; <span class=\"hljs-title\">reorderLogFiles</span><span class=\"hljs-params\">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;  <br>    <span class=\"hljs-built_in\">stable_sort</span>(logs.<span class=\"hljs-built_in\">begin</span>(), logs.<span class=\"hljs-built_in\">end</span>(), [&amp;](<span class=\"hljs-type\">const</span> string&amp; log1, <span class=\"hljs-type\">const</span> string&amp; log2) &#123;  <br>        <span class=\"hljs-type\">int</span> pos1 = log1.<span class=\"hljs-built_in\">find_first_of</span>(<span class=\"hljs-string\">&#x27; &#x27;</span>);  <br>        <span class=\"hljs-type\">int</span> pos2 = log2.<span class=\"hljs-built_in\">find_first_of</span>(<span class=\"hljs-string\">&#x27; &#x27;</span>);  <br>        <span class=\"hljs-type\">bool</span> isDigit1 = <span class=\"hljs-built_in\">isdigit</span>(log1[pos1 + <span class=\"hljs-number\">1</span>]);  <br>        <span class=\"hljs-type\">bool</span> isDigit2 = <span class=\"hljs-built_in\">isdigit</span>(log2[pos2 + <span class=\"hljs-number\">1</span>]);  <br>        <span class=\"hljs-keyword\">if</span> (isDigit1 &amp;&amp; isDigit2)  <br>        &#123;  <br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;        <span class=\"hljs-comment\">// 我的问题  </span><br>        &#125;  <br>        <span class=\"hljs-keyword\">if</span> (!isDigit1 &amp;&amp; !isDigit2)  <br>        &#123;  <br>            string str1 = log1.<span class=\"hljs-built_in\">substr</span>(pos1);  <br>            string str2 = log2.<span class=\"hljs-built_in\">substr</span>(pos2);  <br>            <span class=\"hljs-keyword\">if</span> (str1 != str2)  <br>                <span class=\"hljs-keyword\">return</span> str1 &lt; str2;  <br>            <span class=\"hljs-keyword\">return</span> log1 &lt; log2;  <br>        &#125;  <br>        <span class=\"hljs-keyword\">return</span> isDigit1 ? <span class=\"hljs-literal\">false</span> : <span class=\"hljs-literal\">true</span>;  <br>        &#125;);  <br>    <span class=\"hljs-keyword\">return</span> logs;  <br>&#125;  <br></code></pre></td></tr></table></figure>\r\n<p>我的问题就是出现在数字log的处理部分:</p>\r\n<p>先说说一开始的<strong>错误理解</strong>: <code>s1</code>和\r\n<code>s2</code> 作为两个比较对象传入，<code>s1</code> 在 <code>s2</code>\r\n前面，如果返回值为 <code>true</code>，不做修改；如果返回值为\r\n<code>false</code>，二者交换位置。</p>\r\n<p>嘿，这看上去完全就是很合理的嘛，因为依照我们的经验来看就是这样，<strong>然而</strong>实际却相去甚远。</p>\r\n<h2 id=\"我的反思\">我的反思</h2>\r\n<p><img src=\"/imgs/C++-sort-浅识/sort.png\"/></p>\r\n<p>这是在说什么呢？就是说我们自定义的 <code>sort</code> 其实实现的是\r\n<code>&lt;</code> 比较。<br />\r\n关于返回值的理解就是，如果返回值为 <code>true</code> 就是\r\n<code>s1 &lt; s2</code>，那么返回值为\r\n<code>false</code>就很好解释了，利用一点离散知识, <code>!&lt;</code>\r\n就是 <code>&gt;=</code> 。</p>\r\n<blockquote>\r\n<p>如果对于离散有疑问，那换一个简单粗暴的说法：<br />\r\ntrue: 就是 s1 &lt; s2</p>\r\n<p>那么， s1 = s2 和 s1 &gt; s2 就都是 false</p>\r\n</blockquote>\r\n<h1 id=\"总结\">总结</h1>\r\n<p>我需要纠正的是 <code>sort</code> 函数注重的是 <code>cmp</code> 而不是\r\n<code>swap</code>，就是只是实现比较谁更“小”，而不是他们的位置关系。</p>\r\n<h1 id=\"相关链接\">相关链接:</h1>\r\n<p>今天在做题时候发现自己对于C++自定义排序方法<code>sort</code> 和\r\n<code>stable_sort</code> 的理解一直有问题。</p>\r\n<!--more-->\r\n<p>先说最粗暴简单的理解: <strong><code>sort</code> 和\r\n<code>stable_sort</code>\r\n定义了我们希望的\"&lt;\"比较，就是把我们认为小的放在前面</strong>。</p>\r\n<h1 id=\"题目-1\">题目</h1>\r\n<p><img src=\"/imgs/C++-sort-浅识/题目-1677565078882-1.png\"/></p>\r\n<p>代码:</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">vector&lt;string&gt; <span class=\"hljs-title\">reorderLogFiles</span><span class=\"hljs-params\">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;  <br>    <span class=\"hljs-built_in\">stable_sort</span>(logs.<span class=\"hljs-built_in\">begin</span>(), logs.<span class=\"hljs-built_in\">end</span>(), [&amp;](<span class=\"hljs-type\">const</span> string&amp; log1, <span class=\"hljs-type\">const</span> string&amp; log2) &#123;  <br>        <span class=\"hljs-type\">int</span> pos1 = log1.<span class=\"hljs-built_in\">find_first_of</span>(<span class=\"hljs-string\">&#x27; &#x27;</span>);  <br>        <span class=\"hljs-type\">int</span> pos2 = log2.<span class=\"hljs-built_in\">find_first_of</span>(<span class=\"hljs-string\">&#x27; &#x27;</span>);  <br>        <span class=\"hljs-type\">bool</span> isDigit1 = <span class=\"hljs-built_in\">isdigit</span>(log1[pos1 + <span class=\"hljs-number\">1</span>]);  <br>        <span class=\"hljs-type\">bool</span> isDigit2 = <span class=\"hljs-built_in\">isdigit</span>(log2[pos2 + <span class=\"hljs-number\">1</span>]);  <br>        <span class=\"hljs-keyword\">if</span> (isDigit1 &amp;&amp; isDigit2)  <br>        &#123;  <br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;        <span class=\"hljs-comment\">// 我的问题  </span><br>        &#125;  <br>        <span class=\"hljs-keyword\">if</span> (!isDigit1 &amp;&amp; !isDigit2)  <br>        &#123;  <br>            string str1 = log1.<span class=\"hljs-built_in\">substr</span>(pos1);  <br>            string str2 = log2.<span class=\"hljs-built_in\">substr</span>(pos2);  <br>            <span class=\"hljs-keyword\">if</span> (str1 != str2)  <br>                <span class=\"hljs-keyword\">return</span> str1 &lt; str2;  <br>            <span class=\"hljs-keyword\">return</span> log1 &lt; log2;  <br>        &#125;  <br>        <span class=\"hljs-keyword\">return</span> isDigit1 ? <span class=\"hljs-literal\">false</span> : <span class=\"hljs-literal\">true</span>;  <br>        &#125;);  <br>    <span class=\"hljs-keyword\">return</span> logs;  <br>&#125;  <br></code></pre></td></tr></table></figure>\r\n<p>我的问题就是出现在数字log的处理部分:</p>\r\n<p>先说说一开始的<strong>错误理解</strong>: <code>s1</code>和\r\n<code>s2</code> 作为两个比较对象传入，<code>s1</code> 在 <code>s2</code>\r\n前面，如果返回值为 <code>true</code>，不做修改；如果返回值为\r\n<code>false</code>，二者交换位置。</p>\r\n<p>嘿，这看上去完全就是很合理的嘛，因为依照我们的经验来看就是这样，<strong>然而</strong>实际却相去甚远。</p>\r\n<h2 id=\"我的反思-1\">我的反思</h2>\r\n<p><img src=\"/imgs/C++-sort-浅识/sort.png\"/></p>\r\n<p>这是在说什么呢？就是说我们自定义的 <code>sort</code> 其实实现的是\r\n<code>&lt;</code> 比较。<br />\r\n关于返回值的理解就是，如果返回值为 <code>true</code> 就是\r\n<code>s1 &lt; s2</code>，那么返回值为\r\n<code>false</code>就很好解释了，利用一点离散知识, <code>!&lt;</code>\r\n就是 <code>&gt;=</code> 。</p>\r\n<blockquote>\r\n<p>如果对于离散有疑问，那换一个简单粗暴的说法：<br />\r\ntrue: 就是 s1 &lt; s2</p>\r\n<p>那么， s1 = s2 和 s1 &gt; s2 就都是 false</p>\r\n</blockquote>\r\n<h1 id=\"总结-1\">总结</h1>\r\n<p>我需要纠正的是 <code>sort</code> 函数注重的是 <code>cmp</code> 而不是\r\n<code>swap</code>，就是只是实现比较谁更“小”，而不是他们的位置关系。</p>\r\n<p>相关链接:<br />\r\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; e8dca420d7048ad9484cd8252ef496504eab0a20 <a\r\nhref=\"https://stackoverflow.com/questions/45929474/why-must-stdsort-compare-function-return-false-when-arguments-are-equal\">Why\r\nmust std::sort compare function return false when arguments are\r\nequal?</a></p>"},{"title":"C++智能指针、RAII、Block(To Be Continued)","date":"2022-04-13T03:14:05.000Z","_content":"\n# C++ : 智能指针(Smart Pointers)\n\n现代c++编程中，标准库中包含了**智能指针**，这些指针用于确保程序不会出现内存和资源泄露，并切具有异常安全。\n\n<!--more-->\n\n## 对象生存期和资源管理(RAII)\n\n*在我们学习智能指针前了解RAII是很有必要的。*\n\n众所周知，与托管语言不同，C++没有自动**垃圾回收**。RAII是一个在程序运行是释放**堆内存**和其他资源的内部进程。C++程序将获取的所有资源返还给操作系统，但是如果释放未使用的内存失败，就会造成**内存泄露**的现象，在进程退出前，其他程序将无法使用被泄露的内存。\n\n现代C++通过声明**堆栈**(Stack)上的对象来尽可能避免使用**堆内存**(Heap)，如果资源对于**堆栈**(Stack)而言过于庞大，则该资源应归**对象**(Object)所有。并且在对象初始化时，获取其拥有的资源。在对象的析构函数中释放资源，拥有该资源的对象本身应是在堆栈上被声明的。这个*对象拥有资源*的原则就是RAII(Resource acquisition is initialization.)\n\n> Resource 资源  \n>   \n> acquisition 获取  \n>   \n> initialization 初始化\n\n当资源所属的堆栈对象超出作用范围，会自动调用其析构函数，这样一来，C++中的垃圾回收和对象的生存周期便密不可分，而且具有确定性。资源将总是能在程序的已知点释放，我们可以控制该点，只有C++这种确定的析构函数形式，才能平等地处理内存和非内存的资源。\n\n### 为什么要提RAII？\n\n因为在对象拥有内存资源时，我们要在析构函数中将其对应地释放，如：\n\n    class widget  \n    {  \n    private:  \n        int* data;  \n    public:  \n        widget(const int size) { data = new int[size]; } // acquire  \n        ~widget() { delete[] data; } // release  \n        void do_something() {}  \n    };\n    \n    void functionUsingWidget() {  \n        widget w(1000000);   // lifetime automatically tied to enclosing scope  \n                            // constructs w, including the w.data member  \n        w.do_something();\n    \n    } // automatic destruction and deallocation for w and w.data\n\n`int *data`是内存的资源，我们在析构函数中要对应的`delete`掉，而自C++11起有一种更好的写法，就是**使用智能指针**。智能指针会处理它自身所拥有的内存的**分配**和**删除**，而且使用智能指针就无需在类里显示析构`widget`函数。\n\n    #include <memory>  \n    class widget  \n    {  \n    private:  \n        std::unique_ptr<int> data;  \n    public:  \n        widget(const int size) { data = std::make_unique<int>(size); }  \n        void do_something() {}  \n    };\n    \n    void functionUsingWidget() {  \n        widget w(1000000);   // lifetime automatically tied to enclosing scope  \n                    // constructs w, including the w.data gadget member  \n        // ...  \n        w.do_something();  \n        // ...  \n    } // automatic destruction and deallocation for w and w.data\n\n> 通过使用智能指针进行内存分配，可以消除内存泄漏的可能性。 此模型适用于其他资源，例如文件句柄或套接字。\n\nC++ 的设计可确保对象在超出范围时被销毁。 也就是说，当块(Block)以构造相反的顺序退出时，它们将被销毁。 销毁对象时，将按特定顺序销毁其基项和成员。 在全局范围内在任何块之外声明的对象都可能会导致问题。 如果全局对象的构造函数引发异常，则调试可能很困难。\n\n> block是一个对象，这个对象里包含了要执行的代码片段以及一些状态信息。  \n>   \n> block是一片具有以下特性的内联代码片段集合:  \n> 可以像函数一样有类型参数；  \n> 可以声明或推算出一个返回类型；  \n> 可以访问和block定义在同一个词法范围里的变量（即Status）；  \n> 可以修改同一个词法范围里的变量；  \n> 同一个词法范围的block之间可以共享变量和变量的修改结果；  \n> 当栈被摧毁后，栈里的block依旧可以保持状态信息；\n\n#### 什么是句柄\n\n> 1.句柄就是一个标识符，只要获得对象的句柄，我们就可以对对象进行任意的操作。  \n>   \n> 2.句柄不是指针，操作系统用句柄可以找到一块内存，这个句柄可能是标识符，map的key，也可能是指针，看操作系统怎么处理的了。fd算是在某种程度上替代句柄吧；Linux 有相应机制，但没有统一的句柄类型，各种类型的系统资源由各自的类型来标识，由各自的接口操作。  \n>   \n> 3.在操作系统层面上，文件操作也有类似于FILE的一个概念，在Linux里，这叫做文件描述符fd(File Descriptor)，而在Windows里，叫做句柄(Handle)(以下在没有歧义的时候统称为句柄)。用户通过某个函数打开文件以获得句柄，此后用户操纵文件皆通过该句柄进行。\n\n## 智能指针\n\n智能指针是std命名空间定义的，其对于RAII编程至关重要。此习惯用法主要目的是确保**资源获取**和**对象初始化**同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。\n\n实际情况中，RAII的主要原则就是将任何**堆分配资源** *(例如，动态分配的内存或系统对象句柄)* 的所有权授予**堆栈分配的对象**，该对象的析构函数包含用于删除或释放资源的代码以及任何关联的清理代码。\n\n大多数情况下，初始化原始指针或资源句柄指向实际资源时，会立即将指针传递给智能指针。在现代C++中，原始指针仅仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的`Helper`函数中。\n\n原始指针和智能指针对比：\n\n    void UseRawPointer(){  \n        Song* pSong = new Song(L\"Rock Rill\", L\"Rock Rill\");  \n        ......  \n        // dont forget to delete  \n        delete pSong;  \n    }\n\n\n​    \n​    void UseSmartPointer(){  \n​        unique_ptr<Song> song2(new Song(L\"Rock Rill\", L\"Rock Rill\"));  \n​        ......  \n​        wstring s = song2->duration_;  \n​        ...  \n​    }// song2 is deleted automatically here\n\n如上所述，智能指针是我们在堆栈(Stack)上声明的类模板，并可通过使用指向某个堆(Heap)分配的对象的原始指针进行初始化。在初始化智能指针后，它将拥有那个原始指针。这意味着智能指针将负责删除原始指针指定的内存。智能指针析构函数包括了删除的调用(the call to delete)，并且由于智能指针是在堆栈(Stack)上声明的，当智能指针超出范围时，即便堆栈上空的某个位置引发异常，也会调用其析构函数。\n\n使用指针操作(`->`和`*`)访问封装指针，智能指针类将重载这些运算符以返回封装的原始指针。\n\nC++智能指针思路类似于**在语言(如，C#、Java)中创建对象的过程**：创建对象后让系统负责在正确的时间将其删除。不同之处在于，单独的垃圾回收器不在后台运行；按照标准C++范围规则对内存进行管理，以便运行时环境更快速、更有效率。\n\n**注意：要始终在单独的代码行上创建智能指针，而万万不可在参数列表内创建智能指针，这样就不会由于某些参数列表分配规则而发生轻微资源泄露的现象。**\n\n`unique_ptr`封装指向大型对象的指针示例：\n\n    class LargeObject{  \n        public:  \n            void DoSomething(){}  \n    };\n    \n    void ProcessLargeObject(const LargeObject& lo){}  \n    void SmartPointerDemo(){  \n        // Creat the Object and Pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n          \n        // Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Pass a reference to a method  \n        ProcessLargeObject(*pLarge);  \n    }// pLarge is deleted automatically when function block goes out of scope.\n\n上述例子展示了如何使用智能指针执行以下关键步骤。\n\n    1.将智能指针声明为一个自动(局部)变量。(不在智能指针自身上使用`new`或`malloc`表达式)。即`std::unique_ptr<LargeObject> pLarge(new LargeObject());`而不是传统的原始指针：`LargeObject* pLarge = new LargeObject();`，`new LargeObject()`就是new表达式。\n\n也就是说智能指针要直接初始化。\n\n    2.在类型参数中，指定封装指针的指向类型。即`std::unique_ptr<LargeObject> pLarge(new LargeObject());`的`<LargeObject>`。\n\n    3.将原始指针传递到智能指针构造函数中的新对象。(某些实用工具函数或智能指针构造函数可为我们执行此操作。)上例中的智能指针构造函数即是。\n\n    4.使用`->`和`*`访问对象。\n\n    5.允许智能指针删除对象。\n\n智能指针的设计原则是在内存和性能上尽可能高效。例如，`unique_ptr` 中的*唯一数据成员*是**封装的指针**。 这意味着，`unique_ptr` 与该指针的大小完全相同，不是四个字节就是八个字节。 使用重载 * 和 -> 运算符的智能指针访问封装的指针并不比直接访问原始指针慢得多。\n\n**智能指针具有其自己的成员函数**，这些函数通过使用 `.` 表示法进行访问。 例如，某些C++ 标准库智能指针具有释放指针所有权的重置成员函数。 如果我们想要在智能指针超出范围之前**释放其内存**将很有用，如以下示例所示：\n\n    void SmartPointerDemo2()  \n    {  \n        // Create the object and pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n    \n        //Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Free the memory before we exit function block.  \n        pLarge.reset();\n    \n        // Do some other work...\n    \n    }\n\n**智能指针通常提供直接访问原始指针的方法。** \n\n C + + 标准库智能指针具有 `get` 用于此目的的成员函数，并且 `CComPtr` 具有公共 `p` 类成员。 通过提供对基础指针的直接访问，你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。\n\n    void SmartPointerDemo4()  \n    {  \n        // Create the object and pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n    \n        //Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Pass raw pointer to a legacy API  \n        LegacyLargeObjectFunction(pLarge.get());    \n    }\n\n## 智能指针的类型\n\n### C++标准库智能指针\n\n> 使用这些智能指针作为将指针封装为纯旧 C++ 对象 (POCO) 的首选项。  \n>   \n> plain old C++ object\n\n* `unique_ptr`\n  \n  只允许基础指针的一个所有者。除非我们确信需要`shared_ptr`，否则使用该指针作为*POCO的默认选项*。**可以移到新所有者，但不能复制或共享**。替换已经舍弃的`auto_ptr`。和`boost::scoped_ptr`相比，`unique_ptr`小巧且高效。大小仅为一个指针，而且支持右值引用，以便从C++标准库集合中快速插入和检索。\n  \n* `shared_ptr`\n  \n  采用引用计数的智能指针，如果我们想要将一个原始指针分配给多个所有者(例如，从容器返回了指针副本又想保留原始指针时)，就可以使用该指针。直到所有`shared_ptr`所有者超出了范围或者放弃了所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。\n  \n* `weak_ptr`\n  \n  结合`shared_ptr`使用的特例智能指针。`weak_ptr`提供对一个或者多个`shared_ptr`实例拥有的对象的访问，但是不参与引用计数。如果我们想要观察某个对象但是不需要其保持活跃状态，可以使用该实例。在某些情况下，需要断开`shared_ptr`实例间的循环引用。\n  \n=======\n---\ntitle: C++智能指针、RAII、Block(To Be Continued)\ndate: 2022-04-13 11:14:05\ntags:\n\n---\n\n# C++ : 智能指针(Smart Pointers)\n\n现代c++编程中，标准库中包含了**智能指针**，这些指针用于确保程序不会出现内存和资源泄露，并切具有异常安全。\n\n<!--more-->\n\n## 对象生存期和资源管理(RAII)\n\n*在我们学习智能指针前了解RAII是很有必要的。*\n\n众所周知，与托管语言不同，C++没有自动**垃圾回收**。RAII是一个在程序运行是释放**堆内存**和其他资源的内部进程。C++程序将获取的所有资源返还给操作系统，但是如果释放未使用的内存失败，就会造成**内存泄露**的现象，在进程退出前，其他程序将无法使用被泄露的内存。\n\n现代C++通过声明**堆栈**(Stack)上的对象来尽可能避免使用**堆内存**(Heap)，如果资源对于**堆栈**(Stack)而言过于庞大，则该资源应归**对象**(Object)所有。并且在对象初始化时，获取其拥有的资源。在对象的析构函数中释放资源，拥有该资源的对象本身应是在堆栈上被声明的。这个*对象拥有资源*的原则就是RAII(Resource acquisition is initialization.)\n\n> Resource 资源  \n>   \n> acquisition 获取  \n>   \n> initialization 初始化\n\n当资源所属的堆栈对象超出作用范围，会自动调用其析构函数，这样一来，C++中的垃圾回收和对象的生存周期便密不可分，而且具有确定性。资源将总是能在程序的已知点释放，我们可以控制该点，只有C++这种确定的析构函数形式，才能平等地处理内存和非内存的资源。\n\n### 为什么要提RAII？\n\n因为在对象拥有内存资源时，我们要在析构函数中将其对应地释放，如：\n\n    class widget  \n    {  \n    private:  \n        int* data;  \n    public:  \n        widget(const int size) { data = new int[size]; } // acquire  \n        ~widget() { delete[] data; } // release  \n        void do_something() {}  \n    };\n    \n    void functionUsingWidget() {  \n        widget w(1000000);   // lifetime automatically tied to enclosing scope  \n                            // constructs w, including the w.data member  \n        w.do_something();\n    \n    } // automatic destruction and deallocation for w and w.data\n\n`int *data`是内存的资源，我们在析构函数中要对应的`delete`掉，而自C++11起有一种更好的写法，就是**使用智能指针**。智能指针会处理它自身所拥有的内存的**分配**和**删除**，而且使用智能指针就无需在类里显示析构`widget`函数。\n\n    #include <memory>  \n    class widget  \n    {  \n    private:  \n        std::unique_ptr<int> data;  \n    public:  \n        widget(const int size) { data = std::make_unique<int>(size); }  \n        void do_something() {}  \n    };\n    \n    void functionUsingWidget() {  \n        widget w(1000000);   // lifetime automatically tied to enclosing scope  \n                    // constructs w, including the w.data gadget member  \n        // ...  \n        w.do_something();  \n        // ...  \n    } // automatic destruction and deallocation for w and w.data\n\n> 通过使用智能指针进行内存分配，可以消除内存泄漏的可能性。 此模型适用于其他资源，例如文件句柄或套接字。\n\nC++ 的设计可确保对象在超出范围时被销毁。 也就是说，当块(Block)以构造相反的顺序退出时，它们将被销毁。 销毁对象时，将按特定顺序销毁其基项和成员。 在全局范围内在任何块之外声明的对象都可能会导致问题。 如果全局对象的构造函数引发异常，则调试可能很困难。\n\n> block是一个对象，这个对象里包含了要执行的代码片段以及一些状态信息。  \n>   \n> block是一片具有以下特性的内联代码片段集合:  \n> 可以像函数一样有类型参数；  \n> 可以声明或推算出一个返回类型；  \n> 可以访问和block定义在同一个词法范围里的变量（即Status）；  \n> 可以修改同一个词法范围里的变量；  \n> 同一个词法范围的block之间可以共享变量和变量的修改结果；  \n> 当栈被摧毁后，栈里的block依旧可以保持状态信息；\n\n#### 什么是句柄\n\n> 1.句柄就是一个标识符，只要获得对象的句柄，我们就可以对对象进行任意的操作。  \n>   \n> 2.句柄不是指针，操作系统用句柄可以找到一块内存，这个句柄可能是标识符，map的key，也可能是指针，看操作系统怎么处理的了。fd算是在某种程度上替代句柄吧；Linux 有相应机制，但没有统一的句柄类型，各种类型的系统资源由各自的类型来标识，由各自的接口操作。  \n>   \n> 3.在操作系统层面上，文件操作也有类似于FILE的一个概念，在Linux里，这叫做文件描述符fd(File Descriptor)，而在Windows里，叫做句柄(Handle)(以下在没有歧义的时候统称为句柄)。用户通过某个函数打开文件以获得句柄，此后用户操纵文件皆通过该句柄进行。\n\n## 智能指针\n\n智能指针是std命名空间定义的，其对于RAII编程至关重要。此习惯用法主要目的是确保**资源获取**和**对象初始化**同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。\n\n实际情况中，RAII的主要原则就是将任何**堆分配资源** *(例如，动态分配的内存或系统对象句柄)* 的所有权授予**堆栈分配的对象**，该对象的析构函数包含用于删除或释放资源的代码以及任何关联的清理代码。\n\n大多数情况下，初始化原始指针或资源句柄指向实际资源时，会立即将指针传递给智能指针。在现代C++中，原始指针仅仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的`Helper`函数中。\n\n原始指针和智能指针对比：\n\n    void UseRawPointer(){  \n        Song* pSong = new Song(L\"Rock Rill\", L\"Rock Rill\");  \n        ......  \n        // dont forget to delete  \n        delete pSong;  \n    }\n\n\n​    \n​    void UseSmartPointer(){  \n​        unique_ptr<Song> song2(new Song(L\"Rock Rill\", L\"Rock Rill\"));  \n​        ......  \n​        wstring s = song2->duration_;  \n​        ...  \n​    }// song2 is deleted automatically here\n\n如上所述，智能指针是我们在堆栈(Stack)上声明的类模板，并可通过使用指向某个堆(Heap)分配的对象的原始指针进行初始化。在初始化智能指针后，它将拥有那个原始指针。这意味着智能指针将负责删除原始指针指定的内存。智能指针析构函数包括了删除的调用(the call to delete)，并且由于智能指针是在堆栈(Stack)上声明的，当智能指针超出范围时，即便堆栈上空的某个位置引发异常，也会调用其析构函数。\n\n使用指针操作(`->`和`*`)访问封装指针，智能指针类将重载这些运算符以返回封装的原始指针。\n\nC++智能指针思路类似于**在语言(如，C#、Java)中创建对象的过程**：创建对象后让系统负责在正确的时间将其删除。不同之处在于，单独的垃圾回收器不在后台运行；按照标准C++范围规则对内存进行管理，以便运行时环境更快速、更有效率。\n\n**注意：要始终在单独的代码行上创建智能指针，而万万不可在参数列表内创建智能指针，这样就不会由于某些参数列表分配规则而发生轻微资源泄露的现象。**\n\n`unique_ptr`封装指向大型对象的指针示例：\n\n    class LargeObject{  \n        public:  \n            void DoSomething(){}  \n    };\n    \n    void ProcessLargeObject(const LargeObject& lo){}  \n    void SmartPointerDemo(){  \n        // Creat the Object and Pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n          \n        // Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Pass a reference to a method  \n        ProcessLargeObject(*pLarge);  \n    }// pLarge is deleted automatically when function block goes out of scope.\n\n上述例子展示了如何使用智能指针执行以下关键步骤。\n\n    1.将智能指针声明为一个自动(局部)变量。(不在智能指针自身上使用`new`或`malloc`表达式)。即`std::unique_ptr<LargeObject> pLarge(new LargeObject());`而不是传统的原始指针：`LargeObject* pLarge = new LargeObject();`，`new LargeObject()`就是new表达式。\n\n也就是说智能指针要直接初始化。\n\n    2.在类型参数中，指定封装指针的指向类型。即`std::unique_ptr<LargeObject> pLarge(new LargeObject());`的`<LargeObject>`。\n\n    3.将原始指针传递到智能指针构造函数中的新对象。(某些实用工具函数或智能指针构造函数可为我们执行此操作。)上例中的智能指针构造函数即是。\n\n    4.使用`->`和`*`访问对象。\n\n    5.允许智能指针删除对象。\n\n智能指针的设计原则是在内存和性能上尽可能高效。例如，`unique_ptr` 中的*唯一数据成员*是**封装的指针**。 这意味着，`unique_ptr` 与该指针的大小完全相同，不是四个字节就是八个字节。 使用重载 * 和 -> 运算符的智能指针访问封装的指针并不比直接访问原始指针慢得多。\n\n**智能指针具有其自己的成员函数**，这些函数通过使用 `.` 表示法进行访问。 例如，某些C++ 标准库智能指针具有释放指针所有权的重置成员函数。 如果我们想要在智能指针超出范围之前**释放其内存**将很有用，如以下示例所示：\n\n    void SmartPointerDemo2()  \n    {  \n        // Create the object and pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n    \n        //Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Free the memory before we exit function block.  \n        pLarge.reset();\n    \n        // Do some other work...\n    \n    }\n\n**智能指针通常提供直接访问原始指针的方法。** \n\n C + + 标准库智能指针具有 `get` 用于此目的的成员函数，并且 `CComPtr` 具有公共 `p` 类成员。 通过提供对基础指针的直接访问，你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。\n\n    void SmartPointerDemo4()  \n    {  \n        // Create the object and pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n    \n        //Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Pass raw pointer to a legacy API  \n        LegacyLargeObjectFunction(pLarge.get());    \n    }\n\n## 智能指针的类型\n\n### C++标准库智能指针\n\n> 使用这些智能指针作为将指针封装为纯旧 C++ 对象 (POCO) 的首选项。  \n>   \n> plain old C++ object\n\n* `unique_ptr`\n  \n  只允许基础指针的一个所有者。除非我们确信需要`shared_ptr`，否则使用该指针作为*POCO的默认选项*。**可以移到新所有者，但不能复制或共享**。替换已经舍弃的`auto_ptr`。和`boost::scoped_ptr`相比，`unique_ptr`小巧且高效。大小仅为一个指针，而且支持右值引用，以便从C++标准库集合中快速插入和检索。\n  \n* `shared_ptr`\n  \n  采用引用计数的智能指针，如果我们想要将一个原始指针分配给多个所有者(例如，从容器返回了指针副本又想保留原始指针时)，就可以使用该指针。直到所有`shared_ptr`所有者超出了范围或者放弃了所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。\n  \n* `weak_ptr`\n  \n  结合`shared_ptr`使用的特例智能指针。`weak_ptr`提供对一个或者多个`shared_ptr`实例拥有的对象的访问，但是不参与引用计数。如果我们想要观察某个对象但是不需要其保持活跃状态，可以使用该实例。在某些情况下，需要断开`shared_ptr`实例间的循环引用。\n  \n>>>>>>> e8dca420d7048ad9484cd8252ef496504eab0a20\n*智能指针还和COM有关，等待后续的学习补充.……*  ","source":"_posts/C++-Smart-pointers.md","raw":"---\ntitle: C++智能指针、RAII、Block(To Be Continued)\ndate: 2022-04-13 11:14:05\ntags:\n\n---\n\n# C++ : 智能指针(Smart Pointers)\n\n现代c++编程中，标准库中包含了**智能指针**，这些指针用于确保程序不会出现内存和资源泄露，并切具有异常安全。\n\n<!--more-->\n\n## 对象生存期和资源管理(RAII)\n\n*在我们学习智能指针前了解RAII是很有必要的。*\n\n众所周知，与托管语言不同，C++没有自动**垃圾回收**。RAII是一个在程序运行是释放**堆内存**和其他资源的内部进程。C++程序将获取的所有资源返还给操作系统，但是如果释放未使用的内存失败，就会造成**内存泄露**的现象，在进程退出前，其他程序将无法使用被泄露的内存。\n\n现代C++通过声明**堆栈**(Stack)上的对象来尽可能避免使用**堆内存**(Heap)，如果资源对于**堆栈**(Stack)而言过于庞大，则该资源应归**对象**(Object)所有。并且在对象初始化时，获取其拥有的资源。在对象的析构函数中释放资源，拥有该资源的对象本身应是在堆栈上被声明的。这个*对象拥有资源*的原则就是RAII(Resource acquisition is initialization.)\n\n> Resource 资源  \n>   \n> acquisition 获取  \n>   \n> initialization 初始化\n\n当资源所属的堆栈对象超出作用范围，会自动调用其析构函数，这样一来，C++中的垃圾回收和对象的生存周期便密不可分，而且具有确定性。资源将总是能在程序的已知点释放，我们可以控制该点，只有C++这种确定的析构函数形式，才能平等地处理内存和非内存的资源。\n\n### 为什么要提RAII？\n\n因为在对象拥有内存资源时，我们要在析构函数中将其对应地释放，如：\n\n    class widget  \n    {  \n    private:  \n        int* data;  \n    public:  \n        widget(const int size) { data = new int[size]; } // acquire  \n        ~widget() { delete[] data; } // release  \n        void do_something() {}  \n    };\n    \n    void functionUsingWidget() {  \n        widget w(1000000);   // lifetime automatically tied to enclosing scope  \n                            // constructs w, including the w.data member  \n        w.do_something();\n    \n    } // automatic destruction and deallocation for w and w.data\n\n`int *data`是内存的资源，我们在析构函数中要对应的`delete`掉，而自C++11起有一种更好的写法，就是**使用智能指针**。智能指针会处理它自身所拥有的内存的**分配**和**删除**，而且使用智能指针就无需在类里显示析构`widget`函数。\n\n    #include <memory>  \n    class widget  \n    {  \n    private:  \n        std::unique_ptr<int> data;  \n    public:  \n        widget(const int size) { data = std::make_unique<int>(size); }  \n        void do_something() {}  \n    };\n    \n    void functionUsingWidget() {  \n        widget w(1000000);   // lifetime automatically tied to enclosing scope  \n                    // constructs w, including the w.data gadget member  \n        // ...  \n        w.do_something();  \n        // ...  \n    } // automatic destruction and deallocation for w and w.data\n\n> 通过使用智能指针进行内存分配，可以消除内存泄漏的可能性。 此模型适用于其他资源，例如文件句柄或套接字。\n\nC++ 的设计可确保对象在超出范围时被销毁。 也就是说，当块(Block)以构造相反的顺序退出时，它们将被销毁。 销毁对象时，将按特定顺序销毁其基项和成员。 在全局范围内在任何块之外声明的对象都可能会导致问题。 如果全局对象的构造函数引发异常，则调试可能很困难。\n\n> block是一个对象，这个对象里包含了要执行的代码片段以及一些状态信息。  \n>   \n> block是一片具有以下特性的内联代码片段集合:  \n> 可以像函数一样有类型参数；  \n> 可以声明或推算出一个返回类型；  \n> 可以访问和block定义在同一个词法范围里的变量（即Status）；  \n> 可以修改同一个词法范围里的变量；  \n> 同一个词法范围的block之间可以共享变量和变量的修改结果；  \n> 当栈被摧毁后，栈里的block依旧可以保持状态信息；\n\n#### 什么是句柄\n\n> 1.句柄就是一个标识符，只要获得对象的句柄，我们就可以对对象进行任意的操作。  \n>   \n> 2.句柄不是指针，操作系统用句柄可以找到一块内存，这个句柄可能是标识符，map的key，也可能是指针，看操作系统怎么处理的了。fd算是在某种程度上替代句柄吧；Linux 有相应机制，但没有统一的句柄类型，各种类型的系统资源由各自的类型来标识，由各自的接口操作。  \n>   \n> 3.在操作系统层面上，文件操作也有类似于FILE的一个概念，在Linux里，这叫做文件描述符fd(File Descriptor)，而在Windows里，叫做句柄(Handle)(以下在没有歧义的时候统称为句柄)。用户通过某个函数打开文件以获得句柄，此后用户操纵文件皆通过该句柄进行。\n\n## 智能指针\n\n智能指针是std命名空间定义的，其对于RAII编程至关重要。此习惯用法主要目的是确保**资源获取**和**对象初始化**同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。\n\n实际情况中，RAII的主要原则就是将任何**堆分配资源** *(例如，动态分配的内存或系统对象句柄)* 的所有权授予**堆栈分配的对象**，该对象的析构函数包含用于删除或释放资源的代码以及任何关联的清理代码。\n\n大多数情况下，初始化原始指针或资源句柄指向实际资源时，会立即将指针传递给智能指针。在现代C++中，原始指针仅仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的`Helper`函数中。\n\n原始指针和智能指针对比：\n\n    void UseRawPointer(){  \n        Song* pSong = new Song(L\"Rock Rill\", L\"Rock Rill\");  \n        ......  \n        // dont forget to delete  \n        delete pSong;  \n    }\n\n\n​    \n​    void UseSmartPointer(){  \n​        unique_ptr<Song> song2(new Song(L\"Rock Rill\", L\"Rock Rill\"));  \n​        ......  \n​        wstring s = song2->duration_;  \n​        ...  \n​    }// song2 is deleted automatically here\n\n如上所述，智能指针是我们在堆栈(Stack)上声明的类模板，并可通过使用指向某个堆(Heap)分配的对象的原始指针进行初始化。在初始化智能指针后，它将拥有那个原始指针。这意味着智能指针将负责删除原始指针指定的内存。智能指针析构函数包括了删除的调用(the call to delete)，并且由于智能指针是在堆栈(Stack)上声明的，当智能指针超出范围时，即便堆栈上空的某个位置引发异常，也会调用其析构函数。\n\n使用指针操作(`->`和`*`)访问封装指针，智能指针类将重载这些运算符以返回封装的原始指针。\n\nC++智能指针思路类似于**在语言(如，C#、Java)中创建对象的过程**：创建对象后让系统负责在正确的时间将其删除。不同之处在于，单独的垃圾回收器不在后台运行；按照标准C++范围规则对内存进行管理，以便运行时环境更快速、更有效率。\n\n**注意：要始终在单独的代码行上创建智能指针，而万万不可在参数列表内创建智能指针，这样就不会由于某些参数列表分配规则而发生轻微资源泄露的现象。**\n\n`unique_ptr`封装指向大型对象的指针示例：\n\n    class LargeObject{  \n        public:  \n            void DoSomething(){}  \n    };\n    \n    void ProcessLargeObject(const LargeObject& lo){}  \n    void SmartPointerDemo(){  \n        // Creat the Object and Pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n          \n        // Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Pass a reference to a method  \n        ProcessLargeObject(*pLarge);  \n    }// pLarge is deleted automatically when function block goes out of scope.\n\n上述例子展示了如何使用智能指针执行以下关键步骤。\n\n    1.将智能指针声明为一个自动(局部)变量。(不在智能指针自身上使用`new`或`malloc`表达式)。即`std::unique_ptr<LargeObject> pLarge(new LargeObject());`而不是传统的原始指针：`LargeObject* pLarge = new LargeObject();`，`new LargeObject()`就是new表达式。\n\n也就是说智能指针要直接初始化。\n\n    2.在类型参数中，指定封装指针的指向类型。即`std::unique_ptr<LargeObject> pLarge(new LargeObject());`的`<LargeObject>`。\n\n    3.将原始指针传递到智能指针构造函数中的新对象。(某些实用工具函数或智能指针构造函数可为我们执行此操作。)上例中的智能指针构造函数即是。\n\n    4.使用`->`和`*`访问对象。\n\n    5.允许智能指针删除对象。\n\n智能指针的设计原则是在内存和性能上尽可能高效。例如，`unique_ptr` 中的*唯一数据成员*是**封装的指针**。 这意味着，`unique_ptr` 与该指针的大小完全相同，不是四个字节就是八个字节。 使用重载 * 和 -> 运算符的智能指针访问封装的指针并不比直接访问原始指针慢得多。\n\n**智能指针具有其自己的成员函数**，这些函数通过使用 `.` 表示法进行访问。 例如，某些C++ 标准库智能指针具有释放指针所有权的重置成员函数。 如果我们想要在智能指针超出范围之前**释放其内存**将很有用，如以下示例所示：\n\n    void SmartPointerDemo2()  \n    {  \n        // Create the object and pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n    \n        //Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Free the memory before we exit function block.  \n        pLarge.reset();\n    \n        // Do some other work...\n    \n    }\n\n**智能指针通常提供直接访问原始指针的方法。** \n\n C + + 标准库智能指针具有 `get` 用于此目的的成员函数，并且 `CComPtr` 具有公共 `p` 类成员。 通过提供对基础指针的直接访问，你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。\n\n    void SmartPointerDemo4()  \n    {  \n        // Create the object and pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n    \n        //Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Pass raw pointer to a legacy API  \n        LegacyLargeObjectFunction(pLarge.get());    \n    }\n\n## 智能指针的类型\n\n### C++标准库智能指针\n\n> 使用这些智能指针作为将指针封装为纯旧 C++ 对象 (POCO) 的首选项。  \n>   \n> plain old C++ object\n\n* `unique_ptr`\n  \n  只允许基础指针的一个所有者。除非我们确信需要`shared_ptr`，否则使用该指针作为*POCO的默认选项*。**可以移到新所有者，但不能复制或共享**。替换已经舍弃的`auto_ptr`。和`boost::scoped_ptr`相比，`unique_ptr`小巧且高效。大小仅为一个指针，而且支持右值引用，以便从C++标准库集合中快速插入和检索。\n  \n* `shared_ptr`\n  \n  采用引用计数的智能指针，如果我们想要将一个原始指针分配给多个所有者(例如，从容器返回了指针副本又想保留原始指针时)，就可以使用该指针。直到所有`shared_ptr`所有者超出了范围或者放弃了所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。\n  \n* `weak_ptr`\n  \n  结合`shared_ptr`使用的特例智能指针。`weak_ptr`提供对一个或者多个`shared_ptr`实例拥有的对象的访问，但是不参与引用计数。如果我们想要观察某个对象但是不需要其保持活跃状态，可以使用该实例。在某些情况下，需要断开`shared_ptr`实例间的循环引用。\n  \n=======\n---\ntitle: C++智能指针、RAII、Block(To Be Continued)\ndate: 2022-04-13 11:14:05\ntags:\n\n---\n\n# C++ : 智能指针(Smart Pointers)\n\n现代c++编程中，标准库中包含了**智能指针**，这些指针用于确保程序不会出现内存和资源泄露，并切具有异常安全。\n\n<!--more-->\n\n## 对象生存期和资源管理(RAII)\n\n*在我们学习智能指针前了解RAII是很有必要的。*\n\n众所周知，与托管语言不同，C++没有自动**垃圾回收**。RAII是一个在程序运行是释放**堆内存**和其他资源的内部进程。C++程序将获取的所有资源返还给操作系统，但是如果释放未使用的内存失败，就会造成**内存泄露**的现象，在进程退出前，其他程序将无法使用被泄露的内存。\n\n现代C++通过声明**堆栈**(Stack)上的对象来尽可能避免使用**堆内存**(Heap)，如果资源对于**堆栈**(Stack)而言过于庞大，则该资源应归**对象**(Object)所有。并且在对象初始化时，获取其拥有的资源。在对象的析构函数中释放资源，拥有该资源的对象本身应是在堆栈上被声明的。这个*对象拥有资源*的原则就是RAII(Resource acquisition is initialization.)\n\n> Resource 资源  \n>   \n> acquisition 获取  \n>   \n> initialization 初始化\n\n当资源所属的堆栈对象超出作用范围，会自动调用其析构函数，这样一来，C++中的垃圾回收和对象的生存周期便密不可分，而且具有确定性。资源将总是能在程序的已知点释放，我们可以控制该点，只有C++这种确定的析构函数形式，才能平等地处理内存和非内存的资源。\n\n### 为什么要提RAII？\n\n因为在对象拥有内存资源时，我们要在析构函数中将其对应地释放，如：\n\n    class widget  \n    {  \n    private:  \n        int* data;  \n    public:  \n        widget(const int size) { data = new int[size]; } // acquire  \n        ~widget() { delete[] data; } // release  \n        void do_something() {}  \n    };\n    \n    void functionUsingWidget() {  \n        widget w(1000000);   // lifetime automatically tied to enclosing scope  \n                            // constructs w, including the w.data member  \n        w.do_something();\n    \n    } // automatic destruction and deallocation for w and w.data\n\n`int *data`是内存的资源，我们在析构函数中要对应的`delete`掉，而自C++11起有一种更好的写法，就是**使用智能指针**。智能指针会处理它自身所拥有的内存的**分配**和**删除**，而且使用智能指针就无需在类里显示析构`widget`函数。\n\n    #include <memory>  \n    class widget  \n    {  \n    private:  \n        std::unique_ptr<int> data;  \n    public:  \n        widget(const int size) { data = std::make_unique<int>(size); }  \n        void do_something() {}  \n    };\n    \n    void functionUsingWidget() {  \n        widget w(1000000);   // lifetime automatically tied to enclosing scope  \n                    // constructs w, including the w.data gadget member  \n        // ...  \n        w.do_something();  \n        // ...  \n    } // automatic destruction and deallocation for w and w.data\n\n> 通过使用智能指针进行内存分配，可以消除内存泄漏的可能性。 此模型适用于其他资源，例如文件句柄或套接字。\n\nC++ 的设计可确保对象在超出范围时被销毁。 也就是说，当块(Block)以构造相反的顺序退出时，它们将被销毁。 销毁对象时，将按特定顺序销毁其基项和成员。 在全局范围内在任何块之外声明的对象都可能会导致问题。 如果全局对象的构造函数引发异常，则调试可能很困难。\n\n> block是一个对象，这个对象里包含了要执行的代码片段以及一些状态信息。  \n>   \n> block是一片具有以下特性的内联代码片段集合:  \n> 可以像函数一样有类型参数；  \n> 可以声明或推算出一个返回类型；  \n> 可以访问和block定义在同一个词法范围里的变量（即Status）；  \n> 可以修改同一个词法范围里的变量；  \n> 同一个词法范围的block之间可以共享变量和变量的修改结果；  \n> 当栈被摧毁后，栈里的block依旧可以保持状态信息；\n\n#### 什么是句柄\n\n> 1.句柄就是一个标识符，只要获得对象的句柄，我们就可以对对象进行任意的操作。  \n>   \n> 2.句柄不是指针，操作系统用句柄可以找到一块内存，这个句柄可能是标识符，map的key，也可能是指针，看操作系统怎么处理的了。fd算是在某种程度上替代句柄吧；Linux 有相应机制，但没有统一的句柄类型，各种类型的系统资源由各自的类型来标识，由各自的接口操作。  \n>   \n> 3.在操作系统层面上，文件操作也有类似于FILE的一个概念，在Linux里，这叫做文件描述符fd(File Descriptor)，而在Windows里，叫做句柄(Handle)(以下在没有歧义的时候统称为句柄)。用户通过某个函数打开文件以获得句柄，此后用户操纵文件皆通过该句柄进行。\n\n## 智能指针\n\n智能指针是std命名空间定义的，其对于RAII编程至关重要。此习惯用法主要目的是确保**资源获取**和**对象初始化**同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。\n\n实际情况中，RAII的主要原则就是将任何**堆分配资源** *(例如，动态分配的内存或系统对象句柄)* 的所有权授予**堆栈分配的对象**，该对象的析构函数包含用于删除或释放资源的代码以及任何关联的清理代码。\n\n大多数情况下，初始化原始指针或资源句柄指向实际资源时，会立即将指针传递给智能指针。在现代C++中，原始指针仅仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的`Helper`函数中。\n\n原始指针和智能指针对比：\n\n    void UseRawPointer(){  \n        Song* pSong = new Song(L\"Rock Rill\", L\"Rock Rill\");  \n        ......  \n        // dont forget to delete  \n        delete pSong;  \n    }\n\n\n​    \n​    void UseSmartPointer(){  \n​        unique_ptr<Song> song2(new Song(L\"Rock Rill\", L\"Rock Rill\"));  \n​        ......  \n​        wstring s = song2->duration_;  \n​        ...  \n​    }// song2 is deleted automatically here\n\n如上所述，智能指针是我们在堆栈(Stack)上声明的类模板，并可通过使用指向某个堆(Heap)分配的对象的原始指针进行初始化。在初始化智能指针后，它将拥有那个原始指针。这意味着智能指针将负责删除原始指针指定的内存。智能指针析构函数包括了删除的调用(the call to delete)，并且由于智能指针是在堆栈(Stack)上声明的，当智能指针超出范围时，即便堆栈上空的某个位置引发异常，也会调用其析构函数。\n\n使用指针操作(`->`和`*`)访问封装指针，智能指针类将重载这些运算符以返回封装的原始指针。\n\nC++智能指针思路类似于**在语言(如，C#、Java)中创建对象的过程**：创建对象后让系统负责在正确的时间将其删除。不同之处在于，单独的垃圾回收器不在后台运行；按照标准C++范围规则对内存进行管理，以便运行时环境更快速、更有效率。\n\n**注意：要始终在单独的代码行上创建智能指针，而万万不可在参数列表内创建智能指针，这样就不会由于某些参数列表分配规则而发生轻微资源泄露的现象。**\n\n`unique_ptr`封装指向大型对象的指针示例：\n\n    class LargeObject{  \n        public:  \n            void DoSomething(){}  \n    };\n    \n    void ProcessLargeObject(const LargeObject& lo){}  \n    void SmartPointerDemo(){  \n        // Creat the Object and Pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n          \n        // Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Pass a reference to a method  \n        ProcessLargeObject(*pLarge);  \n    }// pLarge is deleted automatically when function block goes out of scope.\n\n上述例子展示了如何使用智能指针执行以下关键步骤。\n\n    1.将智能指针声明为一个自动(局部)变量。(不在智能指针自身上使用`new`或`malloc`表达式)。即`std::unique_ptr<LargeObject> pLarge(new LargeObject());`而不是传统的原始指针：`LargeObject* pLarge = new LargeObject();`，`new LargeObject()`就是new表达式。\n\n也就是说智能指针要直接初始化。\n\n    2.在类型参数中，指定封装指针的指向类型。即`std::unique_ptr<LargeObject> pLarge(new LargeObject());`的`<LargeObject>`。\n\n    3.将原始指针传递到智能指针构造函数中的新对象。(某些实用工具函数或智能指针构造函数可为我们执行此操作。)上例中的智能指针构造函数即是。\n\n    4.使用`->`和`*`访问对象。\n\n    5.允许智能指针删除对象。\n\n智能指针的设计原则是在内存和性能上尽可能高效。例如，`unique_ptr` 中的*唯一数据成员*是**封装的指针**。 这意味着，`unique_ptr` 与该指针的大小完全相同，不是四个字节就是八个字节。 使用重载 * 和 -> 运算符的智能指针访问封装的指针并不比直接访问原始指针慢得多。\n\n**智能指针具有其自己的成员函数**，这些函数通过使用 `.` 表示法进行访问。 例如，某些C++ 标准库智能指针具有释放指针所有权的重置成员函数。 如果我们想要在智能指针超出范围之前**释放其内存**将很有用，如以下示例所示：\n\n    void SmartPointerDemo2()  \n    {  \n        // Create the object and pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n    \n        //Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Free the memory before we exit function block.  \n        pLarge.reset();\n    \n        // Do some other work...\n    \n    }\n\n**智能指针通常提供直接访问原始指针的方法。** \n\n C + + 标准库智能指针具有 `get` 用于此目的的成员函数，并且 `CComPtr` 具有公共 `p` 类成员。 通过提供对基础指针的直接访问，你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。\n\n    void SmartPointerDemo4()  \n    {  \n        // Create the object and pass it to a smart pointer  \n        std::unique_ptr<LargeObject> pLarge(new LargeObject());\n    \n        //Call a method on the object  \n        pLarge->DoSomething();\n    \n        // Pass raw pointer to a legacy API  \n        LegacyLargeObjectFunction(pLarge.get());    \n    }\n\n## 智能指针的类型\n\n### C++标准库智能指针\n\n> 使用这些智能指针作为将指针封装为纯旧 C++ 对象 (POCO) 的首选项。  \n>   \n> plain old C++ object\n\n* `unique_ptr`\n  \n  只允许基础指针的一个所有者。除非我们确信需要`shared_ptr`，否则使用该指针作为*POCO的默认选项*。**可以移到新所有者，但不能复制或共享**。替换已经舍弃的`auto_ptr`。和`boost::scoped_ptr`相比，`unique_ptr`小巧且高效。大小仅为一个指针，而且支持右值引用，以便从C++标准库集合中快速插入和检索。\n  \n* `shared_ptr`\n  \n  采用引用计数的智能指针，如果我们想要将一个原始指针分配给多个所有者(例如，从容器返回了指针副本又想保留原始指针时)，就可以使用该指针。直到所有`shared_ptr`所有者超出了范围或者放弃了所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。\n  \n* `weak_ptr`\n  \n  结合`shared_ptr`使用的特例智能指针。`weak_ptr`提供对一个或者多个`shared_ptr`实例拥有的对象的访问，但是不参与引用计数。如果我们想要观察某个对象但是不需要其保持活跃状态，可以使用该实例。在某些情况下，需要断开`shared_ptr`实例间的循环引用。\n  \n>>>>>>> e8dca420d7048ad9484cd8252ef496504eab0a20\n*智能指针还和COM有关，等待后续的学习补充.……*  ","slug":"C++-Smart-pointers","published":1,"updated":"2025-08-12T15:40:04.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppthx0001bkbw8daoabqv","content":"<h1 id=\"c-智能指针smart-pointers\">C++ : 智能指针(Smart Pointers)</h1>\r\n<p>现代c++编程中，标准库中包含了<strong>智能指针</strong>，这些指针用于确保程序不会出现内存和资源泄露，并切具有异常安全。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"对象生存期和资源管理raii\">对象生存期和资源管理(RAII)</h2>\r\n<p><em>在我们学习智能指针前了解RAII是很有必要的。</em></p>\r\n<p>众所周知，与托管语言不同，C++没有自动<strong>垃圾回收</strong>。RAII是一个在程序运行是释放<strong>堆内存</strong>和其他资源的内部进程。C++程序将获取的所有资源返还给操作系统，但是如果释放未使用的内存失败，就会造成<strong>内存泄露</strong>的现象，在进程退出前，其他程序将无法使用被泄露的内存。</p>\r\n<p>现代C++通过声明<strong>堆栈</strong>(Stack)上的对象来尽可能避免使用<strong>堆内存</strong>(Heap)，如果资源对于<strong>堆栈</strong>(Stack)而言过于庞大，则该资源应归<strong>对象</strong>(Object)所有。并且在对象初始化时，获取其拥有的资源。在对象的析构函数中释放资源，拥有该资源的对象本身应是在堆栈上被声明的。这个<em>对象拥有资源</em>的原则就是RAII(Resource\r\nacquisition is initialization.)</p>\r\n<blockquote>\r\n<p>Resource 资源</p>\r\n<p>acquisition 获取</p>\r\n<p>initialization 初始化</p>\r\n</blockquote>\r\n<p>当资源所属的堆栈对象超出作用范围，会自动调用其析构函数，这样一来，C++中的垃圾回收和对象的生存周期便密不可分，而且具有确定性。资源将总是能在程序的已知点释放，我们可以控制该点，只有C++这种确定的析构函数形式，才能平等地处理内存和非内存的资源。</p>\r\n<h3 id=\"为什么要提raii\">为什么要提RAII？</h3>\r\n<p>因为在对象拥有内存资源时，我们要在析构函数中将其对应地释放，如：</p>\r\n<pre><code class=\"hljs\">class widget  \r\n&#123;  \r\nprivate:  \r\n    int* data;  \r\npublic:  \r\n    widget(const int size) &#123; data = new int[size]; &#125; // acquire  \r\n    ~widget() &#123; delete[] data; &#125; // release  \r\n    void do_something() &#123;&#125;  \r\n&#125;;\r\n\r\nvoid functionUsingWidget() &#123;  \r\n    widget w(1000000);   // lifetime automatically tied to enclosing scope  \r\n                        // constructs w, including the w.data member  \r\n    w.do_something();\r\n\r\n&#125; // automatic destruction and deallocation for w and w.data</code></pre>\r\n<p><code>int *data</code>是内存的资源，我们在析构函数中要对应的<code>delete</code>掉，而自C++11起有一种更好的写法，就是<strong>使用智能指针</strong>。智能指针会处理它自身所拥有的内存的<strong>分配</strong>和<strong>删除</strong>，而且使用智能指针就无需在类里显示析构<code>widget</code>函数。</p>\r\n<pre><code class=\"hljs\">#include &lt;memory&gt;  \r\nclass widget  \r\n&#123;  \r\nprivate:  \r\n    std::unique_ptr&lt;int&gt; data;  \r\npublic:  \r\n    widget(const int size) &#123; data = std::make_unique&lt;int&gt;(size); &#125;  \r\n    void do_something() &#123;&#125;  \r\n&#125;;\r\n\r\nvoid functionUsingWidget() &#123;  \r\n    widget w(1000000);   // lifetime automatically tied to enclosing scope  \r\n                // constructs w, including the w.data gadget member  \r\n    // ...  \r\n    w.do_something();  \r\n    // ...  \r\n&#125; // automatic destruction and deallocation for w and w.data</code></pre>\r\n<blockquote>\r\n<p>通过使用智能指针进行内存分配，可以消除内存泄漏的可能性。\r\n此模型适用于其他资源，例如文件句柄或套接字。</p>\r\n</blockquote>\r\n<p>C++ 的设计可确保对象在超出范围时被销毁。\r\n也就是说，当块(Block)以构造相反的顺序退出时，它们将被销毁。\r\n销毁对象时，将按特定顺序销毁其基项和成员。\r\n在全局范围内在任何块之外声明的对象都可能会导致问题。\r\n如果全局对象的构造函数引发异常，则调试可能很困难。</p>\r\n<blockquote>\r\n<p>block是一个对象，这个对象里包含了要执行的代码片段以及一些状态信息。</p>\r\n<p>block是一片具有以下特性的内联代码片段集合:<br />\r\n可以像函数一样有类型参数；<br />\r\n可以声明或推算出一个返回类型；<br />\r\n可以访问和block定义在同一个词法范围里的变量（即Status）；<br />\r\n可以修改同一个词法范围里的变量；<br />\r\n同一个词法范围的block之间可以共享变量和变量的修改结果；<br />\r\n当栈被摧毁后，栈里的block依旧可以保持状态信息；</p>\r\n</blockquote>\r\n<h4 id=\"什么是句柄\">什么是句柄</h4>\r\n<blockquote>\r\n<p>1.句柄就是一个标识符，只要获得对象的句柄，我们就可以对对象进行任意的操作。</p>\r\n<p>2.句柄不是指针，操作系统用句柄可以找到一块内存，这个句柄可能是标识符，map的key，也可能是指针，看操作系统怎么处理的了。fd算是在某种程度上替代句柄吧；Linux\r\n有相应机制，但没有统一的句柄类型，各种类型的系统资源由各自的类型来标识，由各自的接口操作。</p>\r\n<p>3.在操作系统层面上，文件操作也有类似于FILE的一个概念，在Linux里，这叫做文件描述符fd(File\r\nDescriptor)，而在Windows里，叫做句柄(Handle)(以下在没有歧义的时候统称为句柄)。用户通过某个函数打开文件以获得句柄，此后用户操纵文件皆通过该句柄进行。</p>\r\n</blockquote>\r\n<h2 id=\"智能指针\">智能指针</h2>\r\n<p>智能指针是std命名空间定义的，其对于RAII编程至关重要。此习惯用法主要目的是确保<strong>资源获取</strong>和<strong>对象初始化</strong>同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。</p>\r\n<p>实际情况中，RAII的主要原则就是将任何<strong>堆分配资源</strong>\r\n<em>(例如，动态分配的内存或系统对象句柄)</em>\r\n的所有权授予<strong>堆栈分配的对象</strong>，该对象的析构函数包含用于删除或释放资源的代码以及任何关联的清理代码。</p>\r\n<p>大多数情况下，初始化原始指针或资源句柄指向实际资源时，会立即将指针传递给智能指针。在现代C++中，原始指针仅仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的<code>Helper</code>函数中。</p>\r\n<p>原始指针和智能指针对比：</p>\r\n<pre><code class=\"hljs\">void UseRawPointer()&#123;  \r\n    Song* pSong = new Song(L&quot;Rock Rill&quot;, L&quot;Rock Rill&quot;);  \r\n    ......  \r\n    // dont forget to delete  \r\n    delete pSong;  \r\n&#125;</code></pre>\r\n<p>​<br />\r\n​void UseSmartPointer(){<br />\r\n​unique_ptr<Song> song2(new Song(L\"Rock Rill\", L\"Rock Rill\"));<br />\r\n​    ......<br />\r\n​    wstring s = song2-&gt;duration_;<br />\r\n​    ...<br />\r\n​}// song2 is deleted automatically here</p>\r\n<p>如上所述，智能指针是我们在堆栈(Stack)上声明的类模板，并可通过使用指向某个堆(Heap)分配的对象的原始指针进行初始化。在初始化智能指针后，它将拥有那个原始指针。这意味着智能指针将负责删除原始指针指定的内存。智能指针析构函数包括了删除的调用(the\r\ncall to\r\ndelete)，并且由于智能指针是在堆栈(Stack)上声明的，当智能指针超出范围时，即便堆栈上空的某个位置引发异常，也会调用其析构函数。</p>\r\n<p>使用指针操作(<code>-&gt;</code>和<code>*</code>)访问封装指针，智能指针类将重载这些运算符以返回封装的原始指针。</p>\r\n<p>C++智能指针思路类似于<strong>在语言(如，C#、Java)中创建对象的过程</strong>：创建对象后让系统负责在正确的时间将其删除。不同之处在于，单独的垃圾回收器不在后台运行；按照标准C++范围规则对内存进行管理，以便运行时环境更快速、更有效率。</p>\r\n<p><strong>注意：要始终在单独的代码行上创建智能指针，而万万不可在参数列表内创建智能指针，这样就不会由于某些参数列表分配规则而发生轻微资源泄露的现象。</strong></p>\r\n<p><code>unique_ptr</code>封装指向大型对象的指针示例：</p>\r\n<pre><code class=\"hljs\">class LargeObject&#123;  \r\n    public:  \r\n        void DoSomething()&#123;&#125;  \r\n&#125;;\r\n\r\nvoid ProcessLargeObject(const LargeObject&amp; lo)&#123;&#125;  \r\nvoid SmartPointerDemo()&#123;  \r\n    // Creat the Object and Pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n      \r\n    // Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Pass a reference to a method  \r\n    ProcessLargeObject(*pLarge);  \r\n&#125;// pLarge is deleted automatically when function block goes out of scope.</code></pre>\r\n<p>上述例子展示了如何使用智能指针执行以下关键步骤。</p>\r\n<p>    1.将智能指针声明为一个自动(局部)变量。(不在智能指针自身上使用<code>new</code>或<code>malloc</code>表达式)。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>而不是传统的原始指针：<code>LargeObject* pLarge = new LargeObject();</code>，<code>new LargeObject()</code>就是new表达式。</p>\r\n<p>也就是说智能指针要直接初始化。</p>\r\n<p>    2.在类型参数中，指定封装指针的指向类型。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>的<code>&lt;LargeObject&gt;</code>。</p>\r\n<p>    3.将原始指针传递到智能指针构造函数中的新对象。(某些实用工具函数或智能指针构造函数可为我们执行此操作。)上例中的智能指针构造函数即是。</p>\r\n<p>    4.使用<code>-&gt;</code>和<code>*</code>访问对象。</p>\r\n<p>    5.允许智能指针删除对象。</p>\r\n<p>智能指针的设计原则是在内存和性能上尽可能高效。例如，<code>unique_ptr</code> 中的<em>唯一数据成员</em>是<strong>封装的指针</strong>。\r\n这意味着，<code>unique_ptr</code> 与该指针的大小完全相同，不是四个字节就是八个字节。\r\n使用重载 * 和 -&gt;\r\n运算符的智能指针访问封装的指针并不比直接访问原始指针慢得多。</p>\r\n<p><strong>智能指针具有其自己的成员函数</strong>，这些函数通过使用\r\n<code>.</code> 表示法进行访问。 例如，某些C++\r\n标准库智能指针具有释放指针所有权的重置成员函数。\r\n如果我们想要在智能指针超出范围之前<strong>释放其内存</strong>将很有用，如以下示例所示：</p>\r\n<pre><code class=\"hljs\">void SmartPointerDemo2()  \r\n&#123;  \r\n    // Create the object and pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n\r\n    //Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Free the memory before we exit function block.  \r\n    pLarge.reset();\r\n\r\n    // Do some other work...\r\n\r\n&#125;</code></pre>\r\n<p><strong>智能指针通常提供直接访问原始指针的方法。</strong></p>\r\n<p>C + + 标准库智能指针具有 <code>get</code> 用于此目的的成员函数，并且\r\n<code>CComPtr</code> 具有公共 <code>p</code> 类成员。\r\n通过提供对基础指针的直接访问，你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。</p>\r\n<pre><code class=\"hljs\">void SmartPointerDemo4()  \r\n&#123;  \r\n    // Create the object and pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n\r\n    //Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Pass raw pointer to a legacy API  \r\n    LegacyLargeObjectFunction(pLarge.get());    \r\n&#125;</code></pre>\r\n<h2 id=\"智能指针的类型\">智能指针的类型</h2>\r\n<h3 id=\"c标准库智能指针\">C++标准库智能指针</h3>\r\n<blockquote>\r\n<p>使用这些智能指针作为将指针封装为纯旧 C++ 对象 (POCO) 的首选项。</p>\r\n<p>plain old C++ object</p>\r\n</blockquote>\r\n<ul>\r\n<li><p><code>unique_ptr</code></p>\r\n<p>只允许基础指针的一个所有者。除非我们确信需要<code>shared_ptr</code>，否则使用该指针作为<em>POCO的默认选项</em>。<strong>可以移到新所有者，但不能复制或共享</strong>。替换已经舍弃的<code>auto_ptr</code>。和<code>boost::scoped_ptr</code>相比，<code>unique_ptr</code>小巧且高效。大小仅为一个指针，而且支持右值引用，以便从C++标准库集合中快速插入和检索。</p></li>\r\n<li><p><code>shared_ptr</code></p>\r\n<p>采用引用计数的智能指针，如果我们想要将一个原始指针分配给多个所有者(例如，从容器返回了指针副本又想保留原始指针时)，就可以使用该指针。直到所有<code>shared_ptr</code>所有者超出了范围或者放弃了所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。</p></li>\r\n<li><p><code>weak_ptr</code></p>\r\n<p>结合<code>shared_ptr</code>使用的特例智能指针。<code>weak_ptr</code>提供对一个或者多个<code>shared_ptr</code>实例拥有的对象的访问，但是不参与引用计数。如果我们想要观察某个对象但是不需要其保持活跃状态，可以使用该实例。在某些情况下，需要断开<code>shared_ptr</code>实例间的循环引用。</p></li>\r\n</ul>\r\n<h2 id=\"section\">=======</h2>\r\n<p>title: C++智能指针、RAII、Block(To Be Continued) date: 2022-04-13\r\n11:14:05 tags:</p>\r\n<hr />\r\n<h1 id=\"c-智能指针smart-pointers-1\">C++ : 智能指针(Smart Pointers)</h1>\r\n<p>现代c++编程中，标准库中包含了<strong>智能指针</strong>，这些指针用于确保程序不会出现内存和资源泄露，并切具有异常安全。</p>\r\n<!--more-->\r\n<h2 id=\"对象生存期和资源管理raii-1\">对象生存期和资源管理(RAII)</h2>\r\n<p><em>在我们学习智能指针前了解RAII是很有必要的。</em></p>\r\n<p>众所周知，与托管语言不同，C++没有自动<strong>垃圾回收</strong>。RAII是一个在程序运行是释放<strong>堆内存</strong>和其他资源的内部进程。C++程序将获取的所有资源返还给操作系统，但是如果释放未使用的内存失败，就会造成<strong>内存泄露</strong>的现象，在进程退出前，其他程序将无法使用被泄露的内存。</p>\r\n<p>现代C++通过声明<strong>堆栈</strong>(Stack)上的对象来尽可能避免使用<strong>堆内存</strong>(Heap)，如果资源对于<strong>堆栈</strong>(Stack)而言过于庞大，则该资源应归<strong>对象</strong>(Object)所有。并且在对象初始化时，获取其拥有的资源。在对象的析构函数中释放资源，拥有该资源的对象本身应是在堆栈上被声明的。这个<em>对象拥有资源</em>的原则就是RAII(Resource\r\nacquisition is initialization.)</p>\r\n<blockquote>\r\n<p>Resource 资源</p>\r\n<p>acquisition 获取</p>\r\n<p>initialization 初始化</p>\r\n</blockquote>\r\n<p>当资源所属的堆栈对象超出作用范围，会自动调用其析构函数，这样一来，C++中的垃圾回收和对象的生存周期便密不可分，而且具有确定性。资源将总是能在程序的已知点释放，我们可以控制该点，只有C++这种确定的析构函数形式，才能平等地处理内存和非内存的资源。</p>\r\n<h3 id=\"为什么要提raii-1\">为什么要提RAII？</h3>\r\n<p>因为在对象拥有内存资源时，我们要在析构函数中将其对应地释放，如：</p>\r\n<pre><code class=\"hljs\">class widget  \r\n&#123;  \r\nprivate:  \r\n    int* data;  \r\npublic:  \r\n    widget(const int size) &#123; data = new int[size]; &#125; // acquire  \r\n    ~widget() &#123; delete[] data; &#125; // release  \r\n    void do_something() &#123;&#125;  \r\n&#125;;\r\n\r\nvoid functionUsingWidget() &#123;  \r\n    widget w(1000000);   // lifetime automatically tied to enclosing scope  \r\n                        // constructs w, including the w.data member  \r\n    w.do_something();\r\n\r\n&#125; // automatic destruction and deallocation for w and w.data</code></pre>\r\n<p><code>int *data</code>是内存的资源，我们在析构函数中要对应的<code>delete</code>掉，而自C++11起有一种更好的写法，就是<strong>使用智能指针</strong>。智能指针会处理它自身所拥有的内存的<strong>分配</strong>和<strong>删除</strong>，而且使用智能指针就无需在类里显示析构<code>widget</code>函数。</p>\r\n<pre><code class=\"hljs\">#include &lt;memory&gt;  \r\nclass widget  \r\n&#123;  \r\nprivate:  \r\n    std::unique_ptr&lt;int&gt; data;  \r\npublic:  \r\n    widget(const int size) &#123; data = std::make_unique&lt;int&gt;(size); &#125;  \r\n    void do_something() &#123;&#125;  \r\n&#125;;\r\n\r\nvoid functionUsingWidget() &#123;  \r\n    widget w(1000000);   // lifetime automatically tied to enclosing scope  \r\n                // constructs w, including the w.data gadget member  \r\n    // ...  \r\n    w.do_something();  \r\n    // ...  \r\n&#125; // automatic destruction and deallocation for w and w.data</code></pre>\r\n<blockquote>\r\n<p>通过使用智能指针进行内存分配，可以消除内存泄漏的可能性。\r\n此模型适用于其他资源，例如文件句柄或套接字。</p>\r\n</blockquote>\r\n<p>C++ 的设计可确保对象在超出范围时被销毁。\r\n也就是说，当块(Block)以构造相反的顺序退出时，它们将被销毁。\r\n销毁对象时，将按特定顺序销毁其基项和成员。\r\n在全局范围内在任何块之外声明的对象都可能会导致问题。\r\n如果全局对象的构造函数引发异常，则调试可能很困难。</p>\r\n<blockquote>\r\n<p>block是一个对象，这个对象里包含了要执行的代码片段以及一些状态信息。</p>\r\n<p>block是一片具有以下特性的内联代码片段集合:<br />\r\n可以像函数一样有类型参数；<br />\r\n可以声明或推算出一个返回类型；<br />\r\n可以访问和block定义在同一个词法范围里的变量（即Status）；<br />\r\n可以修改同一个词法范围里的变量；<br />\r\n同一个词法范围的block之间可以共享变量和变量的修改结果；<br />\r\n当栈被摧毁后，栈里的block依旧可以保持状态信息；</p>\r\n</blockquote>\r\n<h4 id=\"什么是句柄-1\">什么是句柄</h4>\r\n<blockquote>\r\n<p>1.句柄就是一个标识符，只要获得对象的句柄，我们就可以对对象进行任意的操作。</p>\r\n<p>2.句柄不是指针，操作系统用句柄可以找到一块内存，这个句柄可能是标识符，map的key，也可能是指针，看操作系统怎么处理的了。fd算是在某种程度上替代句柄吧；Linux\r\n有相应机制，但没有统一的句柄类型，各种类型的系统资源由各自的类型来标识，由各自的接口操作。</p>\r\n<p>3.在操作系统层面上，文件操作也有类似于FILE的一个概念，在Linux里，这叫做文件描述符fd(File\r\nDescriptor)，而在Windows里，叫做句柄(Handle)(以下在没有歧义的时候统称为句柄)。用户通过某个函数打开文件以获得句柄，此后用户操纵文件皆通过该句柄进行。</p>\r\n</blockquote>\r\n<h2 id=\"智能指针-1\">智能指针</h2>\r\n<p>智能指针是std命名空间定义的，其对于RAII编程至关重要。此习惯用法主要目的是确保<strong>资源获取</strong>和<strong>对象初始化</strong>同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。</p>\r\n<p>实际情况中，RAII的主要原则就是将任何<strong>堆分配资源</strong>\r\n<em>(例如，动态分配的内存或系统对象句柄)</em>\r\n的所有权授予<strong>堆栈分配的对象</strong>，该对象的析构函数包含用于删除或释放资源的代码以及任何关联的清理代码。</p>\r\n<p>大多数情况下，初始化原始指针或资源句柄指向实际资源时，会立即将指针传递给智能指针。在现代C++中，原始指针仅仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的<code>Helper</code>函数中。</p>\r\n<p>原始指针和智能指针对比：</p>\r\n<pre><code class=\"hljs\">void UseRawPointer()&#123;  \r\n    Song* pSong = new Song(L&quot;Rock Rill&quot;, L&quot;Rock Rill&quot;);  \r\n    ......  \r\n    // dont forget to delete  \r\n    delete pSong;  \r\n&#125;</code></pre>\r\n<p>​<br />\r\n​void UseSmartPointer(){<br />\r\n​unique_ptr<Song> song2(new Song(L\"Rock Rill\", L\"Rock Rill\"));<br />\r\n​    ......<br />\r\n​    wstring s = song2-&gt;duration_;<br />\r\n​    ...<br />\r\n​}// song2 is deleted automatically here</p>\r\n<p>如上所述，智能指针是我们在堆栈(Stack)上声明的类模板，并可通过使用指向某个堆(Heap)分配的对象的原始指针进行初始化。在初始化智能指针后，它将拥有那个原始指针。这意味着智能指针将负责删除原始指针指定的内存。智能指针析构函数包括了删除的调用(the\r\ncall to\r\ndelete)，并且由于智能指针是在堆栈(Stack)上声明的，当智能指针超出范围时，即便堆栈上空的某个位置引发异常，也会调用其析构函数。</p>\r\n<p>使用指针操作(<code>-&gt;</code>和<code>*</code>)访问封装指针，智能指针类将重载这些运算符以返回封装的原始指针。</p>\r\n<p>C++智能指针思路类似于<strong>在语言(如，C#、Java)中创建对象的过程</strong>：创建对象后让系统负责在正确的时间将其删除。不同之处在于，单独的垃圾回收器不在后台运行；按照标准C++范围规则对内存进行管理，以便运行时环境更快速、更有效率。</p>\r\n<p><strong>注意：要始终在单独的代码行上创建智能指针，而万万不可在参数列表内创建智能指针，这样就不会由于某些参数列表分配规则而发生轻微资源泄露的现象。</strong></p>\r\n<p><code>unique_ptr</code>封装指向大型对象的指针示例：</p>\r\n<pre><code class=\"hljs\">class LargeObject&#123;  \r\n    public:  \r\n        void DoSomething()&#123;&#125;  \r\n&#125;;\r\n\r\nvoid ProcessLargeObject(const LargeObject&amp; lo)&#123;&#125;  \r\nvoid SmartPointerDemo()&#123;  \r\n    // Creat the Object and Pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n      \r\n    // Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Pass a reference to a method  \r\n    ProcessLargeObject(*pLarge);  \r\n&#125;// pLarge is deleted automatically when function block goes out of scope.</code></pre>\r\n<p>上述例子展示了如何使用智能指针执行以下关键步骤。</p>\r\n<p>    1.将智能指针声明为一个自动(局部)变量。(不在智能指针自身上使用<code>new</code>或<code>malloc</code>表达式)。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>而不是传统的原始指针：<code>LargeObject* pLarge = new LargeObject();</code>，<code>new LargeObject()</code>就是new表达式。</p>\r\n<p>也就是说智能指针要直接初始化。</p>\r\n<p>    2.在类型参数中，指定封装指针的指向类型。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>的<code>&lt;LargeObject&gt;</code>。</p>\r\n<p>    3.将原始指针传递到智能指针构造函数中的新对象。(某些实用工具函数或智能指针构造函数可为我们执行此操作。)上例中的智能指针构造函数即是。</p>\r\n<p>    4.使用<code>-&gt;</code>和<code>*</code>访问对象。</p>\r\n<p>    5.允许智能指针删除对象。</p>\r\n<p>智能指针的设计原则是在内存和性能上尽可能高效。例如，<code>unique_ptr</code> 中的<em>唯一数据成员</em>是<strong>封装的指针</strong>。\r\n这意味着，<code>unique_ptr</code> 与该指针的大小完全相同，不是四个字节就是八个字节。\r\n使用重载 * 和 -&gt;\r\n运算符的智能指针访问封装的指针并不比直接访问原始指针慢得多。</p>\r\n<p><strong>智能指针具有其自己的成员函数</strong>，这些函数通过使用\r\n<code>.</code> 表示法进行访问。 例如，某些C++\r\n标准库智能指针具有释放指针所有权的重置成员函数。\r\n如果我们想要在智能指针超出范围之前<strong>释放其内存</strong>将很有用，如以下示例所示：</p>\r\n<pre><code class=\"hljs\">void SmartPointerDemo2()  \r\n&#123;  \r\n    // Create the object and pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n\r\n    //Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Free the memory before we exit function block.  \r\n    pLarge.reset();\r\n\r\n    // Do some other work...\r\n\r\n&#125;</code></pre>\r\n<p><strong>智能指针通常提供直接访问原始指针的方法。</strong></p>\r\n<p>C + + 标准库智能指针具有 <code>get</code> 用于此目的的成员函数，并且\r\n<code>CComPtr</code> 具有公共 <code>p</code> 类成员。\r\n通过提供对基础指针的直接访问，你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。</p>\r\n<pre><code class=\"hljs\">void SmartPointerDemo4()  \r\n&#123;  \r\n    // Create the object and pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n\r\n    //Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Pass raw pointer to a legacy API  \r\n    LegacyLargeObjectFunction(pLarge.get());    \r\n&#125;</code></pre>\r\n<h2 id=\"智能指针的类型-1\">智能指针的类型</h2>\r\n<h3 id=\"c标准库智能指针-1\">C++标准库智能指针</h3>\r\n<blockquote>\r\n<p>使用这些智能指针作为将指针封装为纯旧 C++ 对象 (POCO) 的首选项。</p>\r\n<p>plain old C++ object</p>\r\n</blockquote>\r\n<ul>\r\n<li><p><code>unique_ptr</code></p>\r\n<p>只允许基础指针的一个所有者。除非我们确信需要<code>shared_ptr</code>，否则使用该指针作为<em>POCO的默认选项</em>。<strong>可以移到新所有者，但不能复制或共享</strong>。替换已经舍弃的<code>auto_ptr</code>。和<code>boost::scoped_ptr</code>相比，<code>unique_ptr</code>小巧且高效。大小仅为一个指针，而且支持右值引用，以便从C++标准库集合中快速插入和检索。</p></li>\r\n<li><p><code>shared_ptr</code></p>\r\n<p>采用引用计数的智能指针，如果我们想要将一个原始指针分配给多个所有者(例如，从容器返回了指针副本又想保留原始指针时)，就可以使用该指针。直到所有<code>shared_ptr</code>所有者超出了范围或者放弃了所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。</p></li>\r\n<li><p><code>weak_ptr</code></p>\r\n<p>结合<code>shared_ptr</code>使用的特例智能指针。<code>weak_ptr</code>提供对一个或者多个<code>shared_ptr</code>实例拥有的对象的访问，但是不参与引用计数。如果我们想要观察某个对象但是不需要其保持活跃状态，可以使用该实例。在某些情况下，需要断开<code>shared_ptr</code>实例间的循环引用。</p></li>\r\n</ul>\r\n<blockquote>\r\n<blockquote>\r\n<blockquote>\r\n<blockquote>\r\n<blockquote>\r\n<blockquote>\r\n<blockquote>\r\n<p>e8dca420d7048ad9484cd8252ef496504eab0a20\r\n<em>智能指针还和COM有关，等待后续的学习补充.……</em></p>\r\n</blockquote>\r\n</blockquote>\r\n</blockquote>\r\n</blockquote>\r\n</blockquote>\r\n</blockquote>\r\n</blockquote>\r\n","site":{"data":{}},"excerpt":"<h1 id=\"c-智能指针smart-pointers\">C++ : 智能指针(Smart Pointers)</h1>\r\n<p>现代c++编程中，标准库中包含了<strong>智能指针</strong>，这些指针用于确保程序不会出现内存和资源泄露，并切具有异常安全。</p>","more":"<h2 id=\"对象生存期和资源管理raii\">对象生存期和资源管理(RAII)</h2>\r\n<p><em>在我们学习智能指针前了解RAII是很有必要的。</em></p>\r\n<p>众所周知，与托管语言不同，C++没有自动<strong>垃圾回收</strong>。RAII是一个在程序运行是释放<strong>堆内存</strong>和其他资源的内部进程。C++程序将获取的所有资源返还给操作系统，但是如果释放未使用的内存失败，就会造成<strong>内存泄露</strong>的现象，在进程退出前，其他程序将无法使用被泄露的内存。</p>\r\n<p>现代C++通过声明<strong>堆栈</strong>(Stack)上的对象来尽可能避免使用<strong>堆内存</strong>(Heap)，如果资源对于<strong>堆栈</strong>(Stack)而言过于庞大，则该资源应归<strong>对象</strong>(Object)所有。并且在对象初始化时，获取其拥有的资源。在对象的析构函数中释放资源，拥有该资源的对象本身应是在堆栈上被声明的。这个<em>对象拥有资源</em>的原则就是RAII(Resource\r\nacquisition is initialization.)</p>\r\n<blockquote>\r\n<p>Resource 资源</p>\r\n<p>acquisition 获取</p>\r\n<p>initialization 初始化</p>\r\n</blockquote>\r\n<p>当资源所属的堆栈对象超出作用范围，会自动调用其析构函数，这样一来，C++中的垃圾回收和对象的生存周期便密不可分，而且具有确定性。资源将总是能在程序的已知点释放，我们可以控制该点，只有C++这种确定的析构函数形式，才能平等地处理内存和非内存的资源。</p>\r\n<h3 id=\"为什么要提raii\">为什么要提RAII？</h3>\r\n<p>因为在对象拥有内存资源时，我们要在析构函数中将其对应地释放，如：</p>\r\n<pre><code>class widget  \r\n&#123;  \r\nprivate:  \r\n    int* data;  \r\npublic:  \r\n    widget(const int size) &#123; data = new int[size]; &#125; // acquire  \r\n    ~widget() &#123; delete[] data; &#125; // release  \r\n    void do_something() &#123;&#125;  \r\n&#125;;\r\n\r\nvoid functionUsingWidget() &#123;  \r\n    widget w(1000000);   // lifetime automatically tied to enclosing scope  \r\n                        // constructs w, including the w.data member  \r\n    w.do_something();\r\n\r\n&#125; // automatic destruction and deallocation for w and w.data</code></pre>\r\n<p><code>int *data</code>是内存的资源，我们在析构函数中要对应的<code>delete</code>掉，而自C++11起有一种更好的写法，就是<strong>使用智能指针</strong>。智能指针会处理它自身所拥有的内存的<strong>分配</strong>和<strong>删除</strong>，而且使用智能指针就无需在类里显示析构<code>widget</code>函数。</p>\r\n<pre><code>#include &lt;memory&gt;  \r\nclass widget  \r\n&#123;  \r\nprivate:  \r\n    std::unique_ptr&lt;int&gt; data;  \r\npublic:  \r\n    widget(const int size) &#123; data = std::make_unique&lt;int&gt;(size); &#125;  \r\n    void do_something() &#123;&#125;  \r\n&#125;;\r\n\r\nvoid functionUsingWidget() &#123;  \r\n    widget w(1000000);   // lifetime automatically tied to enclosing scope  \r\n                // constructs w, including the w.data gadget member  \r\n    // ...  \r\n    w.do_something();  \r\n    // ...  \r\n&#125; // automatic destruction and deallocation for w and w.data</code></pre>\r\n<blockquote>\r\n<p>通过使用智能指针进行内存分配，可以消除内存泄漏的可能性。\r\n此模型适用于其他资源，例如文件句柄或套接字。</p>\r\n</blockquote>\r\n<p>C++ 的设计可确保对象在超出范围时被销毁。\r\n也就是说，当块(Block)以构造相反的顺序退出时，它们将被销毁。\r\n销毁对象时，将按特定顺序销毁其基项和成员。\r\n在全局范围内在任何块之外声明的对象都可能会导致问题。\r\n如果全局对象的构造函数引发异常，则调试可能很困难。</p>\r\n<blockquote>\r\n<p>block是一个对象，这个对象里包含了要执行的代码片段以及一些状态信息。</p>\r\n<p>block是一片具有以下特性的内联代码片段集合:<br />\r\n可以像函数一样有类型参数；<br />\r\n可以声明或推算出一个返回类型；<br />\r\n可以访问和block定义在同一个词法范围里的变量（即Status）；<br />\r\n可以修改同一个词法范围里的变量；<br />\r\n同一个词法范围的block之间可以共享变量和变量的修改结果；<br />\r\n当栈被摧毁后，栈里的block依旧可以保持状态信息；</p>\r\n</blockquote>\r\n<h4 id=\"什么是句柄\">什么是句柄</h4>\r\n<blockquote>\r\n<p>1.句柄就是一个标识符，只要获得对象的句柄，我们就可以对对象进行任意的操作。</p>\r\n<p>2.句柄不是指针，操作系统用句柄可以找到一块内存，这个句柄可能是标识符，map的key，也可能是指针，看操作系统怎么处理的了。fd算是在某种程度上替代句柄吧；Linux\r\n有相应机制，但没有统一的句柄类型，各种类型的系统资源由各自的类型来标识，由各自的接口操作。</p>\r\n<p>3.在操作系统层面上，文件操作也有类似于FILE的一个概念，在Linux里，这叫做文件描述符fd(File\r\nDescriptor)，而在Windows里，叫做句柄(Handle)(以下在没有歧义的时候统称为句柄)。用户通过某个函数打开文件以获得句柄，此后用户操纵文件皆通过该句柄进行。</p>\r\n</blockquote>\r\n<h2 id=\"智能指针\">智能指针</h2>\r\n<p>智能指针是std命名空间定义的，其对于RAII编程至关重要。此习惯用法主要目的是确保<strong>资源获取</strong>和<strong>对象初始化</strong>同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。</p>\r\n<p>实际情况中，RAII的主要原则就是将任何<strong>堆分配资源</strong>\r\n<em>(例如，动态分配的内存或系统对象句柄)</em>\r\n的所有权授予<strong>堆栈分配的对象</strong>，该对象的析构函数包含用于删除或释放资源的代码以及任何关联的清理代码。</p>\r\n<p>大多数情况下，初始化原始指针或资源句柄指向实际资源时，会立即将指针传递给智能指针。在现代C++中，原始指针仅仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的<code>Helper</code>函数中。</p>\r\n<p>原始指针和智能指针对比：</p>\r\n<pre><code>void UseRawPointer()&#123;  \r\n    Song* pSong = new Song(L&quot;Rock Rill&quot;, L&quot;Rock Rill&quot;);  \r\n    ......  \r\n    // dont forget to delete  \r\n    delete pSong;  \r\n&#125;</code></pre>\r\n<p>​<br />\r\n​void UseSmartPointer(){<br />\r\n​unique_ptr<Song> song2(new Song(L\"Rock Rill\", L\"Rock Rill\"));<br />\r\n​    ......<br />\r\n​    wstring s = song2-&gt;duration_;<br />\r\n​    ...<br />\r\n​}// song2 is deleted automatically here</p>\r\n<p>如上所述，智能指针是我们在堆栈(Stack)上声明的类模板，并可通过使用指向某个堆(Heap)分配的对象的原始指针进行初始化。在初始化智能指针后，它将拥有那个原始指针。这意味着智能指针将负责删除原始指针指定的内存。智能指针析构函数包括了删除的调用(the\r\ncall to\r\ndelete)，并且由于智能指针是在堆栈(Stack)上声明的，当智能指针超出范围时，即便堆栈上空的某个位置引发异常，也会调用其析构函数。</p>\r\n<p>使用指针操作(<code>-&gt;</code>和<code>*</code>)访问封装指针，智能指针类将重载这些运算符以返回封装的原始指针。</p>\r\n<p>C++智能指针思路类似于<strong>在语言(如，C#、Java)中创建对象的过程</strong>：创建对象后让系统负责在正确的时间将其删除。不同之处在于，单独的垃圾回收器不在后台运行；按照标准C++范围规则对内存进行管理，以便运行时环境更快速、更有效率。</p>\r\n<p><strong>注意：要始终在单独的代码行上创建智能指针，而万万不可在参数列表内创建智能指针，这样就不会由于某些参数列表分配规则而发生轻微资源泄露的现象。</strong></p>\r\n<p><code>unique_ptr</code>封装指向大型对象的指针示例：</p>\r\n<pre><code>class LargeObject&#123;  \r\n    public:  \r\n        void DoSomething()&#123;&#125;  \r\n&#125;;\r\n\r\nvoid ProcessLargeObject(const LargeObject&amp; lo)&#123;&#125;  \r\nvoid SmartPointerDemo()&#123;  \r\n    // Creat the Object and Pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n      \r\n    // Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Pass a reference to a method  \r\n    ProcessLargeObject(*pLarge);  \r\n&#125;// pLarge is deleted automatically when function block goes out of scope.</code></pre>\r\n<p>上述例子展示了如何使用智能指针执行以下关键步骤。</p>\r\n<p>    1.将智能指针声明为一个自动(局部)变量。(不在智能指针自身上使用<code>new</code>或<code>malloc</code>表达式)。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>而不是传统的原始指针：<code>LargeObject* pLarge = new LargeObject();</code>，<code>new LargeObject()</code>就是new表达式。</p>\r\n<p>也就是说智能指针要直接初始化。</p>\r\n<p>    2.在类型参数中，指定封装指针的指向类型。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>的<code>&lt;LargeObject&gt;</code>。</p>\r\n<p>    3.将原始指针传递到智能指针构造函数中的新对象。(某些实用工具函数或智能指针构造函数可为我们执行此操作。)上例中的智能指针构造函数即是。</p>\r\n<p>    4.使用<code>-&gt;</code>和<code>*</code>访问对象。</p>\r\n<p>    5.允许智能指针删除对象。</p>\r\n<p>智能指针的设计原则是在内存和性能上尽可能高效。例如，<code>unique_ptr</code> 中的<em>唯一数据成员</em>是<strong>封装的指针</strong>。\r\n这意味着，<code>unique_ptr</code> 与该指针的大小完全相同，不是四个字节就是八个字节。\r\n使用重载 * 和 -&gt;\r\n运算符的智能指针访问封装的指针并不比直接访问原始指针慢得多。</p>\r\n<p><strong>智能指针具有其自己的成员函数</strong>，这些函数通过使用\r\n<code>.</code> 表示法进行访问。 例如，某些C++\r\n标准库智能指针具有释放指针所有权的重置成员函数。\r\n如果我们想要在智能指针超出范围之前<strong>释放其内存</strong>将很有用，如以下示例所示：</p>\r\n<pre><code>void SmartPointerDemo2()  \r\n&#123;  \r\n    // Create the object and pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n\r\n    //Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Free the memory before we exit function block.  \r\n    pLarge.reset();\r\n\r\n    // Do some other work...\r\n\r\n&#125;</code></pre>\r\n<p><strong>智能指针通常提供直接访问原始指针的方法。</strong></p>\r\n<p>C + + 标准库智能指针具有 <code>get</code> 用于此目的的成员函数，并且\r\n<code>CComPtr</code> 具有公共 <code>p</code> 类成员。\r\n通过提供对基础指针的直接访问，你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。</p>\r\n<pre><code>void SmartPointerDemo4()  \r\n&#123;  \r\n    // Create the object and pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n\r\n    //Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Pass raw pointer to a legacy API  \r\n    LegacyLargeObjectFunction(pLarge.get());    \r\n&#125;</code></pre>\r\n<h2 id=\"智能指针的类型\">智能指针的类型</h2>\r\n<h3 id=\"c标准库智能指针\">C++标准库智能指针</h3>\r\n<blockquote>\r\n<p>使用这些智能指针作为将指针封装为纯旧 C++ 对象 (POCO) 的首选项。</p>\r\n<p>plain old C++ object</p>\r\n</blockquote>\r\n<ul>\r\n<li><p><code>unique_ptr</code></p>\r\n<p>只允许基础指针的一个所有者。除非我们确信需要<code>shared_ptr</code>，否则使用该指针作为<em>POCO的默认选项</em>。<strong>可以移到新所有者，但不能复制或共享</strong>。替换已经舍弃的<code>auto_ptr</code>。和<code>boost::scoped_ptr</code>相比，<code>unique_ptr</code>小巧且高效。大小仅为一个指针，而且支持右值引用，以便从C++标准库集合中快速插入和检索。</p></li>\r\n<li><p><code>shared_ptr</code></p>\r\n<p>采用引用计数的智能指针，如果我们想要将一个原始指针分配给多个所有者(例如，从容器返回了指针副本又想保留原始指针时)，就可以使用该指针。直到所有<code>shared_ptr</code>所有者超出了范围或者放弃了所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。</p></li>\r\n<li><p><code>weak_ptr</code></p>\r\n<p>结合<code>shared_ptr</code>使用的特例智能指针。<code>weak_ptr</code>提供对一个或者多个<code>shared_ptr</code>实例拥有的对象的访问，但是不参与引用计数。如果我们想要观察某个对象但是不需要其保持活跃状态，可以使用该实例。在某些情况下，需要断开<code>shared_ptr</code>实例间的循环引用。</p></li>\r\n</ul>\r\n<h2 id=\"section\">=======</h2>\r\n<p>title: C++智能指针、RAII、Block(To Be Continued) date: 2022-04-13\r\n11:14:05 tags:</p>\r\n<hr />\r\n<h1 id=\"c-智能指针smart-pointers-1\">C++ : 智能指针(Smart Pointers)</h1>\r\n<p>现代c++编程中，标准库中包含了<strong>智能指针</strong>，这些指针用于确保程序不会出现内存和资源泄露，并切具有异常安全。</p>\r\n<!--more-->\r\n<h2 id=\"对象生存期和资源管理raii-1\">对象生存期和资源管理(RAII)</h2>\r\n<p><em>在我们学习智能指针前了解RAII是很有必要的。</em></p>\r\n<p>众所周知，与托管语言不同，C++没有自动<strong>垃圾回收</strong>。RAII是一个在程序运行是释放<strong>堆内存</strong>和其他资源的内部进程。C++程序将获取的所有资源返还给操作系统，但是如果释放未使用的内存失败，就会造成<strong>内存泄露</strong>的现象，在进程退出前，其他程序将无法使用被泄露的内存。</p>\r\n<p>现代C++通过声明<strong>堆栈</strong>(Stack)上的对象来尽可能避免使用<strong>堆内存</strong>(Heap)，如果资源对于<strong>堆栈</strong>(Stack)而言过于庞大，则该资源应归<strong>对象</strong>(Object)所有。并且在对象初始化时，获取其拥有的资源。在对象的析构函数中释放资源，拥有该资源的对象本身应是在堆栈上被声明的。这个<em>对象拥有资源</em>的原则就是RAII(Resource\r\nacquisition is initialization.)</p>\r\n<blockquote>\r\n<p>Resource 资源</p>\r\n<p>acquisition 获取</p>\r\n<p>initialization 初始化</p>\r\n</blockquote>\r\n<p>当资源所属的堆栈对象超出作用范围，会自动调用其析构函数，这样一来，C++中的垃圾回收和对象的生存周期便密不可分，而且具有确定性。资源将总是能在程序的已知点释放，我们可以控制该点，只有C++这种确定的析构函数形式，才能平等地处理内存和非内存的资源。</p>\r\n<h3 id=\"为什么要提raii-1\">为什么要提RAII？</h3>\r\n<p>因为在对象拥有内存资源时，我们要在析构函数中将其对应地释放，如：</p>\r\n<pre><code>class widget  \r\n&#123;  \r\nprivate:  \r\n    int* data;  \r\npublic:  \r\n    widget(const int size) &#123; data = new int[size]; &#125; // acquire  \r\n    ~widget() &#123; delete[] data; &#125; // release  \r\n    void do_something() &#123;&#125;  \r\n&#125;;\r\n\r\nvoid functionUsingWidget() &#123;  \r\n    widget w(1000000);   // lifetime automatically tied to enclosing scope  \r\n                        // constructs w, including the w.data member  \r\n    w.do_something();\r\n\r\n&#125; // automatic destruction and deallocation for w and w.data</code></pre>\r\n<p><code>int *data</code>是内存的资源，我们在析构函数中要对应的<code>delete</code>掉，而自C++11起有一种更好的写法，就是<strong>使用智能指针</strong>。智能指针会处理它自身所拥有的内存的<strong>分配</strong>和<strong>删除</strong>，而且使用智能指针就无需在类里显示析构<code>widget</code>函数。</p>\r\n<pre><code>#include &lt;memory&gt;  \r\nclass widget  \r\n&#123;  \r\nprivate:  \r\n    std::unique_ptr&lt;int&gt; data;  \r\npublic:  \r\n    widget(const int size) &#123; data = std::make_unique&lt;int&gt;(size); &#125;  \r\n    void do_something() &#123;&#125;  \r\n&#125;;\r\n\r\nvoid functionUsingWidget() &#123;  \r\n    widget w(1000000);   // lifetime automatically tied to enclosing scope  \r\n                // constructs w, including the w.data gadget member  \r\n    // ...  \r\n    w.do_something();  \r\n    // ...  \r\n&#125; // automatic destruction and deallocation for w and w.data</code></pre>\r\n<blockquote>\r\n<p>通过使用智能指针进行内存分配，可以消除内存泄漏的可能性。\r\n此模型适用于其他资源，例如文件句柄或套接字。</p>\r\n</blockquote>\r\n<p>C++ 的设计可确保对象在超出范围时被销毁。\r\n也就是说，当块(Block)以构造相反的顺序退出时，它们将被销毁。\r\n销毁对象时，将按特定顺序销毁其基项和成员。\r\n在全局范围内在任何块之外声明的对象都可能会导致问题。\r\n如果全局对象的构造函数引发异常，则调试可能很困难。</p>\r\n<blockquote>\r\n<p>block是一个对象，这个对象里包含了要执行的代码片段以及一些状态信息。</p>\r\n<p>block是一片具有以下特性的内联代码片段集合:<br />\r\n可以像函数一样有类型参数；<br />\r\n可以声明或推算出一个返回类型；<br />\r\n可以访问和block定义在同一个词法范围里的变量（即Status）；<br />\r\n可以修改同一个词法范围里的变量；<br />\r\n同一个词法范围的block之间可以共享变量和变量的修改结果；<br />\r\n当栈被摧毁后，栈里的block依旧可以保持状态信息；</p>\r\n</blockquote>\r\n<h4 id=\"什么是句柄-1\">什么是句柄</h4>\r\n<blockquote>\r\n<p>1.句柄就是一个标识符，只要获得对象的句柄，我们就可以对对象进行任意的操作。</p>\r\n<p>2.句柄不是指针，操作系统用句柄可以找到一块内存，这个句柄可能是标识符，map的key，也可能是指针，看操作系统怎么处理的了。fd算是在某种程度上替代句柄吧；Linux\r\n有相应机制，但没有统一的句柄类型，各种类型的系统资源由各自的类型来标识，由各自的接口操作。</p>\r\n<p>3.在操作系统层面上，文件操作也有类似于FILE的一个概念，在Linux里，这叫做文件描述符fd(File\r\nDescriptor)，而在Windows里，叫做句柄(Handle)(以下在没有歧义的时候统称为句柄)。用户通过某个函数打开文件以获得句柄，此后用户操纵文件皆通过该句柄进行。</p>\r\n</blockquote>\r\n<h2 id=\"智能指针-1\">智能指针</h2>\r\n<p>智能指针是std命名空间定义的，其对于RAII编程至关重要。此习惯用法主要目的是确保<strong>资源获取</strong>和<strong>对象初始化</strong>同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。</p>\r\n<p>实际情况中，RAII的主要原则就是将任何<strong>堆分配资源</strong>\r\n<em>(例如，动态分配的内存或系统对象句柄)</em>\r\n的所有权授予<strong>堆栈分配的对象</strong>，该对象的析构函数包含用于删除或释放资源的代码以及任何关联的清理代码。</p>\r\n<p>大多数情况下，初始化原始指针或资源句柄指向实际资源时，会立即将指针传递给智能指针。在现代C++中，原始指针仅仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的<code>Helper</code>函数中。</p>\r\n<p>原始指针和智能指针对比：</p>\r\n<pre><code>void UseRawPointer()&#123;  \r\n    Song* pSong = new Song(L&quot;Rock Rill&quot;, L&quot;Rock Rill&quot;);  \r\n    ......  \r\n    // dont forget to delete  \r\n    delete pSong;  \r\n&#125;</code></pre>\r\n<p>​<br />\r\n​void UseSmartPointer(){<br />\r\n​unique_ptr<Song> song2(new Song(L\"Rock Rill\", L\"Rock Rill\"));<br />\r\n​    ......<br />\r\n​    wstring s = song2-&gt;duration_;<br />\r\n​    ...<br />\r\n​}// song2 is deleted automatically here</p>\r\n<p>如上所述，智能指针是我们在堆栈(Stack)上声明的类模板，并可通过使用指向某个堆(Heap)分配的对象的原始指针进行初始化。在初始化智能指针后，它将拥有那个原始指针。这意味着智能指针将负责删除原始指针指定的内存。智能指针析构函数包括了删除的调用(the\r\ncall to\r\ndelete)，并且由于智能指针是在堆栈(Stack)上声明的，当智能指针超出范围时，即便堆栈上空的某个位置引发异常，也会调用其析构函数。</p>\r\n<p>使用指针操作(<code>-&gt;</code>和<code>*</code>)访问封装指针，智能指针类将重载这些运算符以返回封装的原始指针。</p>\r\n<p>C++智能指针思路类似于<strong>在语言(如，C#、Java)中创建对象的过程</strong>：创建对象后让系统负责在正确的时间将其删除。不同之处在于，单独的垃圾回收器不在后台运行；按照标准C++范围规则对内存进行管理，以便运行时环境更快速、更有效率。</p>\r\n<p><strong>注意：要始终在单独的代码行上创建智能指针，而万万不可在参数列表内创建智能指针，这样就不会由于某些参数列表分配规则而发生轻微资源泄露的现象。</strong></p>\r\n<p><code>unique_ptr</code>封装指向大型对象的指针示例：</p>\r\n<pre><code>class LargeObject&#123;  \r\n    public:  \r\n        void DoSomething()&#123;&#125;  \r\n&#125;;\r\n\r\nvoid ProcessLargeObject(const LargeObject&amp; lo)&#123;&#125;  \r\nvoid SmartPointerDemo()&#123;  \r\n    // Creat the Object and Pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n      \r\n    // Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Pass a reference to a method  \r\n    ProcessLargeObject(*pLarge);  \r\n&#125;// pLarge is deleted automatically when function block goes out of scope.</code></pre>\r\n<p>上述例子展示了如何使用智能指针执行以下关键步骤。</p>\r\n<p>    1.将智能指针声明为一个自动(局部)变量。(不在智能指针自身上使用<code>new</code>或<code>malloc</code>表达式)。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>而不是传统的原始指针：<code>LargeObject* pLarge = new LargeObject();</code>，<code>new LargeObject()</code>就是new表达式。</p>\r\n<p>也就是说智能指针要直接初始化。</p>\r\n<p>    2.在类型参数中，指定封装指针的指向类型。即<code>std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());</code>的<code>&lt;LargeObject&gt;</code>。</p>\r\n<p>    3.将原始指针传递到智能指针构造函数中的新对象。(某些实用工具函数或智能指针构造函数可为我们执行此操作。)上例中的智能指针构造函数即是。</p>\r\n<p>    4.使用<code>-&gt;</code>和<code>*</code>访问对象。</p>\r\n<p>    5.允许智能指针删除对象。</p>\r\n<p>智能指针的设计原则是在内存和性能上尽可能高效。例如，<code>unique_ptr</code> 中的<em>唯一数据成员</em>是<strong>封装的指针</strong>。\r\n这意味着，<code>unique_ptr</code> 与该指针的大小完全相同，不是四个字节就是八个字节。\r\n使用重载 * 和 -&gt;\r\n运算符的智能指针访问封装的指针并不比直接访问原始指针慢得多。</p>\r\n<p><strong>智能指针具有其自己的成员函数</strong>，这些函数通过使用\r\n<code>.</code> 表示法进行访问。 例如，某些C++\r\n标准库智能指针具有释放指针所有权的重置成员函数。\r\n如果我们想要在智能指针超出范围之前<strong>释放其内存</strong>将很有用，如以下示例所示：</p>\r\n<pre><code>void SmartPointerDemo2()  \r\n&#123;  \r\n    // Create the object and pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n\r\n    //Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Free the memory before we exit function block.  \r\n    pLarge.reset();\r\n\r\n    // Do some other work...\r\n\r\n&#125;</code></pre>\r\n<p><strong>智能指针通常提供直接访问原始指针的方法。</strong></p>\r\n<p>C + + 标准库智能指针具有 <code>get</code> 用于此目的的成员函数，并且\r\n<code>CComPtr</code> 具有公共 <code>p</code> 类成员。\r\n通过提供对基础指针的直接访问，你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。</p>\r\n<pre><code>void SmartPointerDemo4()  \r\n&#123;  \r\n    // Create the object and pass it to a smart pointer  \r\n    std::unique_ptr&lt;LargeObject&gt; pLarge(new LargeObject());\r\n\r\n    //Call a method on the object  \r\n    pLarge-&gt;DoSomething();\r\n\r\n    // Pass raw pointer to a legacy API  \r\n    LegacyLargeObjectFunction(pLarge.get());    \r\n&#125;</code></pre>\r\n<h2 id=\"智能指针的类型-1\">智能指针的类型</h2>\r\n<h3 id=\"c标准库智能指针-1\">C++标准库智能指针</h3>\r\n<blockquote>\r\n<p>使用这些智能指针作为将指针封装为纯旧 C++ 对象 (POCO) 的首选项。</p>\r\n<p>plain old C++ object</p>\r\n</blockquote>\r\n<ul>\r\n<li><p><code>unique_ptr</code></p>\r\n<p>只允许基础指针的一个所有者。除非我们确信需要<code>shared_ptr</code>，否则使用该指针作为<em>POCO的默认选项</em>。<strong>可以移到新所有者，但不能复制或共享</strong>。替换已经舍弃的<code>auto_ptr</code>。和<code>boost::scoped_ptr</code>相比，<code>unique_ptr</code>小巧且高效。大小仅为一个指针，而且支持右值引用，以便从C++标准库集合中快速插入和检索。</p></li>\r\n<li><p><code>shared_ptr</code></p>\r\n<p>采用引用计数的智能指针，如果我们想要将一个原始指针分配给多个所有者(例如，从容器返回了指针副本又想保留原始指针时)，就可以使用该指针。直到所有<code>shared_ptr</code>所有者超出了范围或者放弃了所有权，才会删除原始指针。大小为两个指针：一个用于对象，另一个用于包含引用计数的共享控制块。</p></li>\r\n<li><p><code>weak_ptr</code></p>\r\n<p>结合<code>shared_ptr</code>使用的特例智能指针。<code>weak_ptr</code>提供对一个或者多个<code>shared_ptr</code>实例拥有的对象的访问，但是不参与引用计数。如果我们想要观察某个对象但是不需要其保持活跃状态，可以使用该实例。在某些情况下，需要断开<code>shared_ptr</code>实例间的循环引用。</p></li>\r\n</ul>\r\n<blockquote>\r\n<blockquote>\r\n<blockquote>\r\n<blockquote>\r\n<blockquote>\r\n<blockquote>\r\n<blockquote>\r\n<p>e8dca420d7048ad9484cd8252ef496504eab0a20\r\n<em>智能指针还和COM有关，等待后续的学习补充.……</em></p>\r\n</blockquote>\r\n</blockquote>\r\n</blockquote>\r\n</blockquote>\r\n</blockquote>\r\n</blockquote>\r\n</blockquote>"},{"title":"C++之static,const,define","date":"2022-05-02T05:11:42.000Z","_content":"\n在C++中有几个看上去不同，一想却有几分相同，但细究的确不同的修饰符，这里记述一下关于static,const,define这几个小伙子。\n\n<!--more-->\n\n# static\n\n## 静态数据的存储\n\n> 全局(静态)存储区：(狗屎机翻说的都不是人话)  \n>   \n> 分为DATA段与BSS段。  \n> DATA段(全局初始化区): 存放初始化的全局变量和静态变量。  \n> BSS段(全局未初始化区): 存放未初始化的全局变量和静态变量。  \n> 程序结束时全局存储器自动释放，BSS段会在程序执行前被系统自动清0，即未初始化的全局变量和静态变量在程序执行之前已经为0。  \n> 在**静态数据区的变量会在程序开始时，就完成初始化，也是唯一的一次初始化**。\n\n### static对于变量\n\n**1.局部变量**\n\n在局部变量前加上关键字`static`，其将被定义为局部静态变量。\n\n内存位置: 静态存储区  \n初始化: 局部的静态变量只被初始化一次  \n作用域: 作用域仍为局部作用域，数据仍在局部可见，定义它的函数或者语句块结束的时候，作用域随之结束。\n\n> 当`static`作用于局部变量时，改变了其存储位置，从栈转存到静态存储区，也改变了生存周期，在离开作用域后变量没有被销毁，仍存储在内存中，只是保留了原有的可见性，即没改变作用域，在程序结束后释放其占用的内存。\n\n**2.全局变量**\n\n在全局变量上作用，其变为全局静态变量。\n\n内存位置: 静态存储区；  \n初始化: 未经初始化的全局变量自动初始化为0；  \n作用域: 全局静态变量作用于当前文件，即在声明他的文件外是不可见的，只能在本文件中使用。\n\n>  全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。但二者区别在于非静态全局变量作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的 **(在其他源文件中使用时加上`extern`关键字重新声明即可)**。而静态全局变量反而限制了其作用域，即限定为定义该变量的源文件中有效，在同一源程序中的其他源文件中无法使用。\n\n### static对于函数\n\n修饰普通函数，表明函数的作用范围，仅仅在定义该函数的文件内才能使用。在多人开发过程中可以使用这个技巧，把函数作用域同上述的全局变量一样，限制在该文件内，防止和他人函数重名。\n\n### static对于类\n\n**1.成员变量**\n\n用`static`修饰类的数据成员，使其成为**类的全局变量**，被所有类的对象共享，**包括派生类的对象！**  \n因此`static`成员必须在类外进行初始化，而不能在构造函数内进行初始化，不过也可以使用`const`修饰`static`数据成员在类内初始化。\n\n```cpp  \nclass MyClass  \n{  \npublic:  \n    static int staticNum;  \n    MyClass();  \n    ~MyClass();      \n}\n  \nint MyClass::staticNum = 1;  \n```\n\n**2.成员函数**\n\n用`static`修饰成员函数，使整个类只存在一份这个函数，所有对象共享，**不含`this`指针**。  \n静态成员是可以独立访问的，无需创建任何实例就能调用。\n\n**不可以同时用`const`和`static`修饰*成员函数*。**\n\n# const\n\n* 限定变量不可修改。\n  \n* 限定成员函数不能修改任何数据成员。\n  \n## const 和 指针\n\n* 指向常量的指针\n  \n```cpp  \n// 第一种  \nint a = 2;  \nint b = 4;  \nint const *p;  \nconst int *p = &a;  \ncout<<\"a:\"<<*p<<endl;    // 2  \na++;  \ncout<<\"a:\"<<**p<<endl;    // 3  \np = &b;  \ncout<<\"b:\"<<*p<<endl;  \n```\n\n`const int *p`和`int const *p`一样，`const`修饰`int`，在`p`看来`a`是常量，所以不能用`(*p)++`修改数据，但是可以`a++`修改，因为`a`实际就是普通变量，只是`cont int *p`一厢情愿罢了。\n\n* 指针常量\n  \n```cpp  \nint a = 2;  \nint b = 4;  \nint* const p = &a;  \ncout << \"a:\" << *p << endl;    // 2  \na++;                           // 3  \n(*p)++;                        // 4  \ncout << \"a:\" << *p << endl;    // 4  \n```\n\n`int* const` 的 `const` 修饰 `int*`，表示**该指针是常量，初始化后无法修改**，但是**其指向对象可以修改**。`p` 指向的是 `int` 类型，不是`const int` 类型，`const int* const` 才是指向 `const int` 类型。\n\n# static和const可以同时修饰成员函数吗？\n\n不可以，C++编译器在实现`const`的成员函数时，为了确保该函数不能修改类的实例状态，会在函数中添加一个隐式的参数`const this*`。但当一个成员为`static`时，该函数是没有`this`指针的，就是说`const`和`static`冲突了，相互矛盾。  \n`static`是表示该函数只作用在类型的静态变量上，与类的实例没有关系；  \n`const`是确保函数不能修改实例的状态，与类型的静态变量没有关系。  \n二者一个脱离实例，一个保护实例。\n\n## const 和 #define 定义常量的区别\n\n* 编译器处理方式不同:  \n  define: 是“编译时”的概念，在预处理阶段进行替换。  \n  const: 是“运行时”的概念，在编译阶段确定其值\n  \n* 类型检查:   \n  define: 无类型，不进行类型安全检查，可能会产生  \n  const:  有数据类型，编译时会检查\n  \n* 内存空间:  \n  define: 不分配内存，给出立即数，使用几次就进行几次替换，内存中会有多个拷贝，消耗大。  \n  const: 在静态存储区分配空间，程序运行中在内存中仅有一次拷贝。\n  \n* 函数参数:   \n  宏定义不能作为参数传递给函数。  \n  const常量可以在函数的参数列表中出现。\n  \n* 在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储和读内存的操作，效率高。\n  \n* define宏替换只做替换，不做表达式计算。\n  \n# typedef 与 #define 的区别\n\n## typedef\n\n`typedef`即类型定义的意思，就是给已有类型起别名。可以简化那些繁琐的类型名；也可以一定程度忽视不同平台的差异，不同平台见只需要修改`typedef`即可。\n\n## #define\n\n`#define`为宏定义语句，就是文本替换\n\n## 区别\n\n* `typedef`关键字在编译阶段有效，由于是在编译阶段，因此`typedef`有类型检查的功能。`#define`是宏定义，发生在预处理阶段，即编译之前，只是简单的字符替换，没有进行任何检查。\n  \n* `#define`没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而`typedef`有自己的定义域。\n  \n* 对指针操作不同: \n  \n```cpp  \ntypedef int * pint  \n#define PINT int *\n  \nint i1 = 2, i2 = 3, i3 = 4;\n  \nconst pint p1 = &i1;    // p1不可更改，相当于 int* const  \nconst PINT p2 = &i2;    // p2可以修改，因为就是 const int *  \nPINT const p3 = &i3;    // p3本身不可以修改，就是 int * const  \n```\n\n相关链接：  \n[C++头文件，预处理详解 - lulipro - 博客园](https://www.cnblogs.com/lulipro/p/5976601.html)  \n=======\n---\ntitle: C++之static,const,define\ndate: 2022-05-02 13:11:42\ntags: \n\n---\n\n在C++中有几个看上去不同，一想却有几分相同，但细究的确不同的修饰符，这里记述一下关于static,const,define这几个小伙子。\n\n<!--more-->\n\n# static\n\n## 静态数据的存储\n\n> 全局(静态)存储区：(狗屎机翻说的都不是人话)  \n>   \n> 分为DATA段与BSS段。  \n> DATA段(全局初始化区): 存放初始化的全局变量和静态变量。  \n> BSS段(全局未初始化区): 存放未初始化的全局变量和静态变量。  \n> 程序结束时全局存储器自动释放，BSS段会在程序执行前被系统自动清0，即未初始化的全局变量和静态变量在程序执行之前已经为0。  \n> 在**静态数据区的变量会在程序开始时，就完成初始化，也是唯一的一次初始化**。\n\n### static对于变量\n\n**1.局部变量**\n\n在局部变量前加上关键字`static`，其将被定义为局部静态变量。\n\n内存位置: 静态存储区  \n初始化: 局部的静态变量只被初始化一次  \n作用域: 作用域仍为局部作用域，数据仍在局部可见，定义它的函数或者语句块结束的时候，作用域随之结束。\n\n> 当`static`作用于局部变量时，改变了其存储位置，从栈转存到静态存储区，也改变了生存周期，在离开作用域后变量没有被销毁，仍存储在内存中，只是保留了原有的可见性，即没改变作用域，在程序结束后释放其占用的内存。\n\n**2.全局变量**\n\n在全局变量上作用，其变为全局静态变量。\n\n内存位置: 静态存储区；  \n初始化: 未经初始化的全局变量自动初始化为0；  \n作用域: 全局静态变量作用于当前文件，即在声明他的文件外是不可见的，只能在本文件中使用。\n\n>  全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。但二者区别在于非静态全局变量作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的 **(在其他源文件中使用时加上`extern`关键字重新声明即可)**。而静态全局变量反而限制了其作用域，即限定为定义该变量的源文件中有效，在同一源程序中的其他源文件中无法使用。\n\n### static对于函数\n\n修饰普通函数，表明函数的作用范围，仅仅在定义该函数的文件内才能使用。在多人开发过程中可以使用这个技巧，把函数作用域同上述的全局变量一样，限制在该文件内，防止和他人函数重名。\n\n### static对于类\n\n**1.成员变量**\n\n用`static`修饰类的数据成员，使其成为**类的全局变量**，被所有类的对象共享，**包括派生类的对象！**  \n因此`static`成员必须在类外进行初始化，而不能在构造函数内进行初始化，不过也可以使用`const`修饰`static`数据成员在类内初始化。\n\n```cpp  \nclass MyClass  \n{  \npublic:  \n    static int staticNum;  \n    MyClass();  \n    ~MyClass();      \n}\n  \nint MyClass::staticNum = 1;  \n```\n\n**2.成员函数**\n\n用`static`修饰成员函数，使整个类只存在一份这个函数，所有对象共享，**不含`this`指针**。  \n静态成员是可以独立访问的，无需创建任何实例就能调用。\n\n**不可以同时用`const`和`static`修饰*成员函数*。**\n\n# const\n\n* 限定变量不可修改。\n  \n* 限定成员函数不能修改任何数据成员。\n  \n## const 和 指针\n\n* 指向常量的指针\n  \n```cpp  \n// 第一种  \nint a = 2;  \nint b = 4;  \nint const *p;  \nconst int *p = &a;  \ncout<<\"a:\"<<*p<<endl;    // 2  \na++;  \ncout<<\"a:\"<<**p<<endl;    // 3  \np = &b;  \ncout<<\"b:\"<<*p<<endl;  \n```\n\n`const int *p`和`int const *p`一样，`const`修饰`int`，在`p`看来`a`是常量，所以不能用`(*p)++`修改数据，但是可以`a++`修改，因为`a`实际就是普通变量，只是`cont int *p`一厢情愿罢了。\n\n* 指针常量\n  \n```cpp  \nint a = 2;  \nint b = 4;  \nint* const p = &a;  \ncout << \"a:\" << *p << endl;    // 2  \na++;                           // 3  \n(*p)++;                        // 4  \ncout << \"a:\" << *p << endl;    // 4  \n```\n\n`int* const` 的 `const` 修饰 `int*`，表示**该指针是常量，初始化后无法修改**，但是**其指向对象可以修改**。`p` 指向的是 `int` 类型，不是`const int` 类型，`const int* const` 才是指向 `const int` 类型。\n\n# static和const可以同时修饰成员函数吗？\n\n不可以，C++编译器在实现`const`的成员函数时，为了确保该函数不能修改类的实例状态，会在函数中添加一个隐式的参数`const this*`。但当一个成员为`static`时，该函数是没有`this`指针的，就是说`const`和`static`冲突了，相互矛盾。  \n`static`是表示该函数只作用在类型的静态变量上，与类的实例没有关系；  \n`const`是确保函数不能修改实例的状态，与类型的静态变量没有关系。  \n二者一个脱离实例，一个保护实例。\n\n## const 和 #define 定义常量的区别\n\n* 编译器处理方式不同:  \n  define: 是“编译时”的概念，在预处理阶段进行替换。  \n  const: 是“运行时”的概念，在编译阶段确定其值\n  \n* 类型检查:   \n  define: 无类型，不进行类型安全检查，可能会产生  \n  const:  有数据类型，编译时会检查\n  \n* 内存空间:  \n  define: 不分配内存，给出立即数，使用几次就进行几次替换，内存中会有多个拷贝，消耗大。  \n  const: 在静态存储区分配空间，程序运行中在内存中仅有一次拷贝。\n  \n* 函数参数:   \n  宏定义不能作为参数传递给函数。  \n  const常量可以在函数的参数列表中出现。\n  \n* 在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储和读内存的操作，效率高。\n  \n* define宏替换只做替换，不做表达式计算。\n  \n# typedef 与 #define 的区别\n\n## typedef\n\n`typedef`即类型定义的意思，就是给已有类型起别名。可以简化那些繁琐的类型名；也可以一定程度忽视不同平台的差异，不同平台见只需要修改`typedef`即可。\n\n## #define\n\n`#define`为宏定义语句，就是文本替换\n\n## 区别\n\n* `typedef`关键字在编译阶段有效，由于是在编译阶段，因此`typedef`有类型检查的功能。`#define`是宏定义，发生在预处理阶段，即编译之前，只是简单的字符替换，没有进行任何检查。\n  \n* `#define`没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而`typedef`有自己的定义域。\n  \n* 对指针操作不同: \n  \n```cpp  \ntypedef int * pint  \n#define PINT int *\n  \nint i1 = 2, i2 = 3, i3 = 4;\n  \nconst pint p1 = &i1;    // p1不可更改，相当于 int* const  \nconst PINT p2 = &i2;    // p2可以修改，因为就是 const int *  \nPINT const p3 = &i3;    // p3本身不可以修改，就是 int * const  \n```\n\n相关链接：  \n[C++头文件，预处理详解 - lulipro - 博客园](https://www.cnblogs.com/lulipro/p/5976601.html)  \n>>>>>>> e8dca420d7048ad9484cd8252ef496504eab0a20\n[C++中的static](https://zhuanlan.zhihu.com/p/152046509)  ","source":"_posts/C++-static-const-define.md","raw":"---\ntitle: C++之static,const,define\ndate: 2022-05-02 13:11:42\ntags: \n\n---\n\n在C++中有几个看上去不同，一想却有几分相同，但细究的确不同的修饰符，这里记述一下关于static,const,define这几个小伙子。\n\n<!--more-->\n\n# static\n\n## 静态数据的存储\n\n> 全局(静态)存储区：(狗屎机翻说的都不是人话)  \n>   \n> 分为DATA段与BSS段。  \n> DATA段(全局初始化区): 存放初始化的全局变量和静态变量。  \n> BSS段(全局未初始化区): 存放未初始化的全局变量和静态变量。  \n> 程序结束时全局存储器自动释放，BSS段会在程序执行前被系统自动清0，即未初始化的全局变量和静态变量在程序执行之前已经为0。  \n> 在**静态数据区的变量会在程序开始时，就完成初始化，也是唯一的一次初始化**。\n\n### static对于变量\n\n**1.局部变量**\n\n在局部变量前加上关键字`static`，其将被定义为局部静态变量。\n\n内存位置: 静态存储区  \n初始化: 局部的静态变量只被初始化一次  \n作用域: 作用域仍为局部作用域，数据仍在局部可见，定义它的函数或者语句块结束的时候，作用域随之结束。\n\n> 当`static`作用于局部变量时，改变了其存储位置，从栈转存到静态存储区，也改变了生存周期，在离开作用域后变量没有被销毁，仍存储在内存中，只是保留了原有的可见性，即没改变作用域，在程序结束后释放其占用的内存。\n\n**2.全局变量**\n\n在全局变量上作用，其变为全局静态变量。\n\n内存位置: 静态存储区；  \n初始化: 未经初始化的全局变量自动初始化为0；  \n作用域: 全局静态变量作用于当前文件，即在声明他的文件外是不可见的，只能在本文件中使用。\n\n>  全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。但二者区别在于非静态全局变量作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的 **(在其他源文件中使用时加上`extern`关键字重新声明即可)**。而静态全局变量反而限制了其作用域，即限定为定义该变量的源文件中有效，在同一源程序中的其他源文件中无法使用。\n\n### static对于函数\n\n修饰普通函数，表明函数的作用范围，仅仅在定义该函数的文件内才能使用。在多人开发过程中可以使用这个技巧，把函数作用域同上述的全局变量一样，限制在该文件内，防止和他人函数重名。\n\n### static对于类\n\n**1.成员变量**\n\n用`static`修饰类的数据成员，使其成为**类的全局变量**，被所有类的对象共享，**包括派生类的对象！**  \n因此`static`成员必须在类外进行初始化，而不能在构造函数内进行初始化，不过也可以使用`const`修饰`static`数据成员在类内初始化。\n\n```cpp  \nclass MyClass  \n{  \npublic:  \n    static int staticNum;  \n    MyClass();  \n    ~MyClass();      \n}\n  \nint MyClass::staticNum = 1;  \n```\n\n**2.成员函数**\n\n用`static`修饰成员函数，使整个类只存在一份这个函数，所有对象共享，**不含`this`指针**。  \n静态成员是可以独立访问的，无需创建任何实例就能调用。\n\n**不可以同时用`const`和`static`修饰*成员函数*。**\n\n# const\n\n* 限定变量不可修改。\n  \n* 限定成员函数不能修改任何数据成员。\n  \n## const 和 指针\n\n* 指向常量的指针\n  \n```cpp  \n// 第一种  \nint a = 2;  \nint b = 4;  \nint const *p;  \nconst int *p = &a;  \ncout<<\"a:\"<<*p<<endl;    // 2  \na++;  \ncout<<\"a:\"<<**p<<endl;    // 3  \np = &b;  \ncout<<\"b:\"<<*p<<endl;  \n```\n\n`const int *p`和`int const *p`一样，`const`修饰`int`，在`p`看来`a`是常量，所以不能用`(*p)++`修改数据，但是可以`a++`修改，因为`a`实际就是普通变量，只是`cont int *p`一厢情愿罢了。\n\n* 指针常量\n  \n```cpp  \nint a = 2;  \nint b = 4;  \nint* const p = &a;  \ncout << \"a:\" << *p << endl;    // 2  \na++;                           // 3  \n(*p)++;                        // 4  \ncout << \"a:\" << *p << endl;    // 4  \n```\n\n`int* const` 的 `const` 修饰 `int*`，表示**该指针是常量，初始化后无法修改**，但是**其指向对象可以修改**。`p` 指向的是 `int` 类型，不是`const int` 类型，`const int* const` 才是指向 `const int` 类型。\n\n# static和const可以同时修饰成员函数吗？\n\n不可以，C++编译器在实现`const`的成员函数时，为了确保该函数不能修改类的实例状态，会在函数中添加一个隐式的参数`const this*`。但当一个成员为`static`时，该函数是没有`this`指针的，就是说`const`和`static`冲突了，相互矛盾。  \n`static`是表示该函数只作用在类型的静态变量上，与类的实例没有关系；  \n`const`是确保函数不能修改实例的状态，与类型的静态变量没有关系。  \n二者一个脱离实例，一个保护实例。\n\n## const 和 #define 定义常量的区别\n\n* 编译器处理方式不同:  \n  define: 是“编译时”的概念，在预处理阶段进行替换。  \n  const: 是“运行时”的概念，在编译阶段确定其值\n  \n* 类型检查:   \n  define: 无类型，不进行类型安全检查，可能会产生  \n  const:  有数据类型，编译时会检查\n  \n* 内存空间:  \n  define: 不分配内存，给出立即数，使用几次就进行几次替换，内存中会有多个拷贝，消耗大。  \n  const: 在静态存储区分配空间，程序运行中在内存中仅有一次拷贝。\n  \n* 函数参数:   \n  宏定义不能作为参数传递给函数。  \n  const常量可以在函数的参数列表中出现。\n  \n* 在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储和读内存的操作，效率高。\n  \n* define宏替换只做替换，不做表达式计算。\n  \n# typedef 与 #define 的区别\n\n## typedef\n\n`typedef`即类型定义的意思，就是给已有类型起别名。可以简化那些繁琐的类型名；也可以一定程度忽视不同平台的差异，不同平台见只需要修改`typedef`即可。\n\n## #define\n\n`#define`为宏定义语句，就是文本替换\n\n## 区别\n\n* `typedef`关键字在编译阶段有效，由于是在编译阶段，因此`typedef`有类型检查的功能。`#define`是宏定义，发生在预处理阶段，即编译之前，只是简单的字符替换，没有进行任何检查。\n  \n* `#define`没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而`typedef`有自己的定义域。\n  \n* 对指针操作不同: \n  \n```cpp  \ntypedef int * pint  \n#define PINT int *\n  \nint i1 = 2, i2 = 3, i3 = 4;\n  \nconst pint p1 = &i1;    // p1不可更改，相当于 int* const  \nconst PINT p2 = &i2;    // p2可以修改，因为就是 const int *  \nPINT const p3 = &i3;    // p3本身不可以修改，就是 int * const  \n```\n\n相关链接：  \n[C++头文件，预处理详解 - lulipro - 博客园](https://www.cnblogs.com/lulipro/p/5976601.html)  \n=======\n---\ntitle: C++之static,const,define\ndate: 2022-05-02 13:11:42\ntags: \n\n---\n\n在C++中有几个看上去不同，一想却有几分相同，但细究的确不同的修饰符，这里记述一下关于static,const,define这几个小伙子。\n\n<!--more-->\n\n# static\n\n## 静态数据的存储\n\n> 全局(静态)存储区：(狗屎机翻说的都不是人话)  \n>   \n> 分为DATA段与BSS段。  \n> DATA段(全局初始化区): 存放初始化的全局变量和静态变量。  \n> BSS段(全局未初始化区): 存放未初始化的全局变量和静态变量。  \n> 程序结束时全局存储器自动释放，BSS段会在程序执行前被系统自动清0，即未初始化的全局变量和静态变量在程序执行之前已经为0。  \n> 在**静态数据区的变量会在程序开始时，就完成初始化，也是唯一的一次初始化**。\n\n### static对于变量\n\n**1.局部变量**\n\n在局部变量前加上关键字`static`，其将被定义为局部静态变量。\n\n内存位置: 静态存储区  \n初始化: 局部的静态变量只被初始化一次  \n作用域: 作用域仍为局部作用域，数据仍在局部可见，定义它的函数或者语句块结束的时候，作用域随之结束。\n\n> 当`static`作用于局部变量时，改变了其存储位置，从栈转存到静态存储区，也改变了生存周期，在离开作用域后变量没有被销毁，仍存储在内存中，只是保留了原有的可见性，即没改变作用域，在程序结束后释放其占用的内存。\n\n**2.全局变量**\n\n在全局变量上作用，其变为全局静态变量。\n\n内存位置: 静态存储区；  \n初始化: 未经初始化的全局变量自动初始化为0；  \n作用域: 全局静态变量作用于当前文件，即在声明他的文件外是不可见的，只能在本文件中使用。\n\n>  全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。但二者区别在于非静态全局变量作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的 **(在其他源文件中使用时加上`extern`关键字重新声明即可)**。而静态全局变量反而限制了其作用域，即限定为定义该变量的源文件中有效，在同一源程序中的其他源文件中无法使用。\n\n### static对于函数\n\n修饰普通函数，表明函数的作用范围，仅仅在定义该函数的文件内才能使用。在多人开发过程中可以使用这个技巧，把函数作用域同上述的全局变量一样，限制在该文件内，防止和他人函数重名。\n\n### static对于类\n\n**1.成员变量**\n\n用`static`修饰类的数据成员，使其成为**类的全局变量**，被所有类的对象共享，**包括派生类的对象！**  \n因此`static`成员必须在类外进行初始化，而不能在构造函数内进行初始化，不过也可以使用`const`修饰`static`数据成员在类内初始化。\n\n```cpp  \nclass MyClass  \n{  \npublic:  \n    static int staticNum;  \n    MyClass();  \n    ~MyClass();      \n}\n  \nint MyClass::staticNum = 1;  \n```\n\n**2.成员函数**\n\n用`static`修饰成员函数，使整个类只存在一份这个函数，所有对象共享，**不含`this`指针**。  \n静态成员是可以独立访问的，无需创建任何实例就能调用。\n\n**不可以同时用`const`和`static`修饰*成员函数*。**\n\n# const\n\n* 限定变量不可修改。\n  \n* 限定成员函数不能修改任何数据成员。\n  \n## const 和 指针\n\n* 指向常量的指针\n  \n```cpp  \n// 第一种  \nint a = 2;  \nint b = 4;  \nint const *p;  \nconst int *p = &a;  \ncout<<\"a:\"<<*p<<endl;    // 2  \na++;  \ncout<<\"a:\"<<**p<<endl;    // 3  \np = &b;  \ncout<<\"b:\"<<*p<<endl;  \n```\n\n`const int *p`和`int const *p`一样，`const`修饰`int`，在`p`看来`a`是常量，所以不能用`(*p)++`修改数据，但是可以`a++`修改，因为`a`实际就是普通变量，只是`cont int *p`一厢情愿罢了。\n\n* 指针常量\n  \n```cpp  \nint a = 2;  \nint b = 4;  \nint* const p = &a;  \ncout << \"a:\" << *p << endl;    // 2  \na++;                           // 3  \n(*p)++;                        // 4  \ncout << \"a:\" << *p << endl;    // 4  \n```\n\n`int* const` 的 `const` 修饰 `int*`，表示**该指针是常量，初始化后无法修改**，但是**其指向对象可以修改**。`p` 指向的是 `int` 类型，不是`const int` 类型，`const int* const` 才是指向 `const int` 类型。\n\n# static和const可以同时修饰成员函数吗？\n\n不可以，C++编译器在实现`const`的成员函数时，为了确保该函数不能修改类的实例状态，会在函数中添加一个隐式的参数`const this*`。但当一个成员为`static`时，该函数是没有`this`指针的，就是说`const`和`static`冲突了，相互矛盾。  \n`static`是表示该函数只作用在类型的静态变量上，与类的实例没有关系；  \n`const`是确保函数不能修改实例的状态，与类型的静态变量没有关系。  \n二者一个脱离实例，一个保护实例。\n\n## const 和 #define 定义常量的区别\n\n* 编译器处理方式不同:  \n  define: 是“编译时”的概念，在预处理阶段进行替换。  \n  const: 是“运行时”的概念，在编译阶段确定其值\n  \n* 类型检查:   \n  define: 无类型，不进行类型安全检查，可能会产生  \n  const:  有数据类型，编译时会检查\n  \n* 内存空间:  \n  define: 不分配内存，给出立即数，使用几次就进行几次替换，内存中会有多个拷贝，消耗大。  \n  const: 在静态存储区分配空间，程序运行中在内存中仅有一次拷贝。\n  \n* 函数参数:   \n  宏定义不能作为参数传递给函数。  \n  const常量可以在函数的参数列表中出现。\n  \n* 在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储和读内存的操作，效率高。\n  \n* define宏替换只做替换，不做表达式计算。\n  \n# typedef 与 #define 的区别\n\n## typedef\n\n`typedef`即类型定义的意思，就是给已有类型起别名。可以简化那些繁琐的类型名；也可以一定程度忽视不同平台的差异，不同平台见只需要修改`typedef`即可。\n\n## #define\n\n`#define`为宏定义语句，就是文本替换\n\n## 区别\n\n* `typedef`关键字在编译阶段有效，由于是在编译阶段，因此`typedef`有类型检查的功能。`#define`是宏定义，发生在预处理阶段，即编译之前，只是简单的字符替换，没有进行任何检查。\n  \n* `#define`没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而`typedef`有自己的定义域。\n  \n* 对指针操作不同: \n  \n```cpp  \ntypedef int * pint  \n#define PINT int *\n  \nint i1 = 2, i2 = 3, i3 = 4;\n  \nconst pint p1 = &i1;    // p1不可更改，相当于 int* const  \nconst PINT p2 = &i2;    // p2可以修改，因为就是 const int *  \nPINT const p3 = &i3;    // p3本身不可以修改，就是 int * const  \n```\n\n相关链接：  \n[C++头文件，预处理详解 - lulipro - 博客园](https://www.cnblogs.com/lulipro/p/5976601.html)  \n>>>>>>> e8dca420d7048ad9484cd8252ef496504eab0a20\n[C++中的static](https://zhuanlan.zhihu.com/p/152046509)  ","slug":"C++-static-const-define","published":1,"updated":"2025-08-12T15:40:12.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppthy0002bkbwex0ohfqr","content":"<p>在C++中有几个看上去不同，一想却有几分相同，但细究的确不同的修饰符，这里记述一下关于static,const,define这几个小伙子。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"static\">static</h1>\r\n<h2 id=\"静态数据的存储\">静态数据的存储</h2>\r\n<blockquote>\r\n<p>全局(静态)存储区：(狗屎机翻说的都不是人话)</p>\r\n<p>分为DATA段与BSS段。<br />\r\nDATA段(全局初始化区): 存放初始化的全局变量和静态变量。<br />\r\nBSS段(全局未初始化区): 存放未初始化的全局变量和静态变量。<br />\r\n程序结束时全局存储器自动释放，BSS段会在程序执行前被系统自动清0，即未初始化的全局变量和静态变量在程序执行之前已经为0。<br />\r\n在<strong>静态数据区的变量会在程序开始时，就完成初始化，也是唯一的一次初始化</strong>。</p>\r\n</blockquote>\r\n<h3 id=\"static对于变量\">static对于变量</h3>\r\n<p><strong>1.局部变量</strong></p>\r\n<p>在局部变量前加上关键字<code>static</code>，其将被定义为局部静态变量。</p>\r\n<p>内存位置: 静态存储区<br />\r\n初始化: 局部的静态变量只被初始化一次<br />\r\n作用域:\r\n作用域仍为局部作用域，数据仍在局部可见，定义它的函数或者语句块结束的时候，作用域随之结束。</p>\r\n<blockquote>\r\n<p>当<code>static</code>作用于局部变量时，改变了其存储位置，从栈转存到静态存储区，也改变了生存周期，在离开作用域后变量没有被销毁，仍存储在内存中，只是保留了原有的可见性，即没改变作用域，在程序结束后释放其占用的内存。</p>\r\n</blockquote>\r\n<p><strong>2.全局变量</strong></p>\r\n<p>在全局变量上作用，其变为全局静态变量。</p>\r\n<p>内存位置: 静态存储区；<br />\r\n初始化: 未经初始化的全局变量自动初始化为0；<br />\r\n作用域:\r\n全局静态变量作用于当前文件，即在声明他的文件外是不可见的，只能在本文件中使用。</p>\r\n<blockquote>\r\n<p>全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。但二者区别在于非静态全局变量作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的\r\n<strong>(在其他源文件中使用时加上<code>extern</code>关键字重新声明即可)</strong>。而静态全局变量反而限制了其作用域，即限定为定义该变量的源文件中有效，在同一源程序中的其他源文件中无法使用。</p>\r\n</blockquote>\r\n<h3 id=\"static对于函数\">static对于函数</h3>\r\n<p>修饰普通函数，表明函数的作用范围，仅仅在定义该函数的文件内才能使用。在多人开发过程中可以使用这个技巧，把函数作用域同上述的全局变量一样，限制在该文件内，防止和他人函数重名。</p>\r\n<h3 id=\"static对于类\">static对于类</h3>\r\n<p><strong>1.成员变量</strong></p>\r\n<p>用<code>static</code>修饰类的数据成员，使其成为<strong>类的全局变量</strong>，被所有类的对象共享，<strong>包括派生类的对象！</strong><br />\r\n因此<code>static</code>成员必须在类外进行初始化，而不能在构造函数内进行初始化，不过也可以使用<code>const</code>修饰<code>static</code>数据成员在类内初始化。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span>  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> staticNum;  <br>    <span class=\"hljs-built_in\">MyClass</span>();  <br>    ~<span class=\"hljs-built_in\">MyClass</span>();      <br>&#125;<br>  <br><span class=\"hljs-type\">int</span> MyClass::staticNum = <span class=\"hljs-number\">1</span>;  <br></code></pre></td></tr></table></figure>\r\n<p><strong>2.成员函数</strong></p>\r\n<p>用<code>static</code>修饰成员函数，使整个类只存在一份这个函数，所有对象共享，<strong>不含<code>this</code>指针</strong>。<br />\r\n静态成员是可以独立访问的，无需创建任何实例就能调用。</p>\r\n<p><strong>不可以同时用<code>const</code>和<code>static</code>修饰<em>成员函数</em>。</strong></p>\r\n<h1 id=\"const\">const</h1>\r\n<ul>\r\n<li><p>限定变量不可修改。</p></li>\r\n<li><p>限定成员函数不能修改任何数据成员。</p></li>\r\n</ul>\r\n<h2 id=\"const-和-指针\">const 和 指针</h2>\r\n<ul>\r\n<li>指向常量的指针</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 第一种  </span><br><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">2</span>;  <br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">4</span>;  <br><span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> *p;  <br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p = &amp;a;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;a:&quot;</span>&lt;&lt;*p&lt;&lt;endl;    <span class=\"hljs-comment\">// 2  </span><br>a++;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;a:&quot;</span>&lt;&lt;**p&lt;&lt;endl;    <span class=\"hljs-comment\">// 3  </span><br>p = &amp;b;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;b:&quot;</span>&lt;&lt;*p&lt;&lt;endl;  <br></code></pre></td></tr></table></figure>\r\n<p><code>const int *p</code>和<code>int const *p</code>一样，<code>const</code>修饰<code>int</code>，在<code>p</code>看来<code>a</code>是常量，所以不能用<code>(*p)++</code>修改数据，但是可以<code>a++</code>修改，因为<code>a</code>实际就是普通变量，只是<code>cont int *p</code>一厢情愿罢了。</p>\r\n<ul>\r\n<li>指针常量</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">2</span>;  <br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">4</span>;  <br><span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> p = &amp;a;  <br>cout &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class=\"hljs-comment\">// 2  </span><br>a++;                           <span class=\"hljs-comment\">// 3  </span><br>(*p)++;                        <span class=\"hljs-comment\">// 4  </span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class=\"hljs-comment\">// 4  </span><br></code></pre></td></tr></table></figure>\r\n<p><code>int* const</code> 的 <code>const</code> 修饰\r\n<code>int*</code>，表示<strong>该指针是常量，初始化后无法修改</strong>，但是<strong>其指向对象可以修改</strong>。<code>p</code>\r\n指向的是 <code>int</code> 类型，不是<code>const int</code>\r\n类型，<code>const int* const</code> 才是指向 <code>const int</code>\r\n类型。</p>\r\n<h1\r\nid=\"static和const可以同时修饰成员函数吗\">static和const可以同时修饰成员函数吗？</h1>\r\n<p>不可以，C++编译器在实现<code>const</code>的成员函数时，为了确保该函数不能修改类的实例状态，会在函数中添加一个隐式的参数<code>const this*</code>。但当一个成员为<code>static</code>时，该函数是没有<code>this</code>指针的，就是说<code>const</code>和<code>static</code>冲突了，相互矛盾。<br />\r\n<code>static</code>是表示该函数只作用在类型的静态变量上，与类的实例没有关系；<br />\r\n<code>const</code>是确保函数不能修改实例的状态，与类型的静态变量没有关系。<br />\r\n二者一个脱离实例，一个保护实例。</p>\r\n<h2 id=\"const-和-define-定义常量的区别\">const 和 #define\r\n定义常量的区别</h2>\r\n<ul>\r\n<li><p>编译器处理方式不同:<br />\r\ndefine: 是“编译时”的概念，在预处理阶段进行替换。<br />\r\nconst: 是“运行时”的概念，在编译阶段确定其值</p></li>\r\n<li><p>类型检查:<br />\r\ndefine: 无类型，不进行类型安全检查，可能会产生<br />\r\nconst: 有数据类型，编译时会检查</p></li>\r\n<li><p>内存空间:<br />\r\ndefine:\r\n不分配内存，给出立即数，使用几次就进行几次替换，内存中会有多个拷贝，消耗大。<br />\r\nconst: 在静态存储区分配空间，程序运行中在内存中仅有一次拷贝。</p></li>\r\n<li><p>函数参数:<br />\r\n宏定义不能作为参数传递给函数。<br />\r\nconst常量可以在函数的参数列表中出现。</p></li>\r\n<li><p>在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储和读内存的操作，效率高。</p></li>\r\n<li><p>define宏替换只做替换，不做表达式计算。</p></li>\r\n</ul>\r\n<h1 id=\"typedef-与-define-的区别\">typedef 与 #define 的区别</h1>\r\n<h2 id=\"typedef\">typedef</h2>\r\n<p><code>typedef</code>即类型定义的意思，就是给已有类型起别名。可以简化那些繁琐的类型名；也可以一定程度忽视不同平台的差异，不同平台见只需要修改<code>typedef</code>即可。</p>\r\n<h2 id=\"define\">#define</h2>\r\n<p><code>#define</code>为宏定义语句，就是文本替换</p>\r\n<h2 id=\"区别\">区别</h2>\r\n<ul>\r\n<li><p><code>typedef</code>关键字在编译阶段有效，由于是在编译阶段，因此<code>typedef</code>有类型检查的功能。<code>#define</code>是宏定义，发生在预处理阶段，即编译之前，只是简单的字符替换，没有进行任何检查。</p></li>\r\n<li><p><code>#define</code>没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而<code>typedef</code>有自己的定义域。</p></li>\r\n<li><p>对指针操作不同:</p></li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">int</span> * pint  <br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PINT int *</span><br>  <br><span class=\"hljs-type\">int</span> i1 = <span class=\"hljs-number\">2</span>, i2 = <span class=\"hljs-number\">3</span>, i3 = <span class=\"hljs-number\">4</span>;<br>  <br><span class=\"hljs-type\">const</span> pint p1 = &amp;i1;    <span class=\"hljs-comment\">// p1不可更改，相当于 int* const  </span><br><span class=\"hljs-type\">const</span> PINT p2 = &amp;i2;    <span class=\"hljs-comment\">// p2可以修改，因为就是 const int *  </span><br>PINT <span class=\"hljs-type\">const</span> p3 = &amp;i3;    <span class=\"hljs-comment\">// p3本身不可以修改，就是 int * const  </span><br></code></pre></td></tr></table></figure>\r\n<p>相关链接：<br />\r\n<a\r\nhref=\"https://www.cnblogs.com/lulipro/p/5976601.html\">C++头文件，预处理详解\r\n- lulipro - 博客园</a><br />\r\n======= --- title: C++之static,const,define date: 2022-05-02 13:11:42\r\ntags:</p>\r\n<hr />\r\n<p>在C++中有几个看上去不同，一想却有几分相同，但细究的确不同的修饰符，这里记述一下关于static,const,define这几个小伙子。</p>\r\n<!--more-->\r\n<h1 id=\"static-1\">static</h1>\r\n<h2 id=\"静态数据的存储-1\">静态数据的存储</h2>\r\n<blockquote>\r\n<p>全局(静态)存储区：(狗屎机翻说的都不是人话)</p>\r\n<p>分为DATA段与BSS段。<br />\r\nDATA段(全局初始化区): 存放初始化的全局变量和静态变量。<br />\r\nBSS段(全局未初始化区): 存放未初始化的全局变量和静态变量。<br />\r\n程序结束时全局存储器自动释放，BSS段会在程序执行前被系统自动清0，即未初始化的全局变量和静态变量在程序执行之前已经为0。<br />\r\n在<strong>静态数据区的变量会在程序开始时，就完成初始化，也是唯一的一次初始化</strong>。</p>\r\n</blockquote>\r\n<h3 id=\"static对于变量-1\">static对于变量</h3>\r\n<p><strong>1.局部变量</strong></p>\r\n<p>在局部变量前加上关键字<code>static</code>，其将被定义为局部静态变量。</p>\r\n<p>内存位置: 静态存储区<br />\r\n初始化: 局部的静态变量只被初始化一次<br />\r\n作用域:\r\n作用域仍为局部作用域，数据仍在局部可见，定义它的函数或者语句块结束的时候，作用域随之结束。</p>\r\n<blockquote>\r\n<p>当<code>static</code>作用于局部变量时，改变了其存储位置，从栈转存到静态存储区，也改变了生存周期，在离开作用域后变量没有被销毁，仍存储在内存中，只是保留了原有的可见性，即没改变作用域，在程序结束后释放其占用的内存。</p>\r\n</blockquote>\r\n<p><strong>2.全局变量</strong></p>\r\n<p>在全局变量上作用，其变为全局静态变量。</p>\r\n<p>内存位置: 静态存储区；<br />\r\n初始化: 未经初始化的全局变量自动初始化为0；<br />\r\n作用域:\r\n全局静态变量作用于当前文件，即在声明他的文件外是不可见的，只能在本文件中使用。</p>\r\n<blockquote>\r\n<p>全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。但二者区别在于非静态全局变量作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的\r\n<strong>(在其他源文件中使用时加上<code>extern</code>关键字重新声明即可)</strong>。而静态全局变量反而限制了其作用域，即限定为定义该变量的源文件中有效，在同一源程序中的其他源文件中无法使用。</p>\r\n</blockquote>\r\n<h3 id=\"static对于函数-1\">static对于函数</h3>\r\n<p>修饰普通函数，表明函数的作用范围，仅仅在定义该函数的文件内才能使用。在多人开发过程中可以使用这个技巧，把函数作用域同上述的全局变量一样，限制在该文件内，防止和他人函数重名。</p>\r\n<h3 id=\"static对于类-1\">static对于类</h3>\r\n<p><strong>1.成员变量</strong></p>\r\n<p>用<code>static</code>修饰类的数据成员，使其成为<strong>类的全局变量</strong>，被所有类的对象共享，<strong>包括派生类的对象！</strong><br />\r\n因此<code>static</code>成员必须在类外进行初始化，而不能在构造函数内进行初始化，不过也可以使用<code>const</code>修饰<code>static</code>数据成员在类内初始化。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span>  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> staticNum;  <br>    <span class=\"hljs-built_in\">MyClass</span>();  <br>    ~<span class=\"hljs-built_in\">MyClass</span>();      <br>&#125;<br>  <br><span class=\"hljs-type\">int</span> MyClass::staticNum = <span class=\"hljs-number\">1</span>;  <br></code></pre></td></tr></table></figure>\r\n<p><strong>2.成员函数</strong></p>\r\n<p>用<code>static</code>修饰成员函数，使整个类只存在一份这个函数，所有对象共享，<strong>不含<code>this</code>指针</strong>。<br />\r\n静态成员是可以独立访问的，无需创建任何实例就能调用。</p>\r\n<p><strong>不可以同时用<code>const</code>和<code>static</code>修饰<em>成员函数</em>。</strong></p>\r\n<h1 id=\"const-1\">const</h1>\r\n<ul>\r\n<li><p>限定变量不可修改。</p></li>\r\n<li><p>限定成员函数不能修改任何数据成员。</p></li>\r\n</ul>\r\n<h2 id=\"const-和-指针-1\">const 和 指针</h2>\r\n<ul>\r\n<li>指向常量的指针</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 第一种  </span><br><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">2</span>;  <br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">4</span>;  <br><span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> *p;  <br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p = &amp;a;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;a:&quot;</span>&lt;&lt;*p&lt;&lt;endl;    <span class=\"hljs-comment\">// 2  </span><br>a++;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;a:&quot;</span>&lt;&lt;**p&lt;&lt;endl;    <span class=\"hljs-comment\">// 3  </span><br>p = &amp;b;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;b:&quot;</span>&lt;&lt;*p&lt;&lt;endl;  <br></code></pre></td></tr></table></figure>\r\n<p><code>const int *p</code>和<code>int const *p</code>一样，<code>const</code>修饰<code>int</code>，在<code>p</code>看来<code>a</code>是常量，所以不能用<code>(*p)++</code>修改数据，但是可以<code>a++</code>修改，因为<code>a</code>实际就是普通变量，只是<code>cont int *p</code>一厢情愿罢了。</p>\r\n<ul>\r\n<li>指针常量</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">2</span>;  <br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">4</span>;  <br><span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> p = &amp;a;  <br>cout &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class=\"hljs-comment\">// 2  </span><br>a++;                           <span class=\"hljs-comment\">// 3  </span><br>(*p)++;                        <span class=\"hljs-comment\">// 4  </span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class=\"hljs-comment\">// 4  </span><br></code></pre></td></tr></table></figure>\r\n<p><code>int* const</code> 的 <code>const</code> 修饰\r\n<code>int*</code>，表示<strong>该指针是常量，初始化后无法修改</strong>，但是<strong>其指向对象可以修改</strong>。<code>p</code>\r\n指向的是 <code>int</code> 类型，不是<code>const int</code>\r\n类型，<code>const int* const</code> 才是指向 <code>const int</code>\r\n类型。</p>\r\n<h1\r\nid=\"static和const可以同时修饰成员函数吗-1\">static和const可以同时修饰成员函数吗？</h1>\r\n<p>不可以，C++编译器在实现<code>const</code>的成员函数时，为了确保该函数不能修改类的实例状态，会在函数中添加一个隐式的参数<code>const this*</code>。但当一个成员为<code>static</code>时，该函数是没有<code>this</code>指针的，就是说<code>const</code>和<code>static</code>冲突了，相互矛盾。<br />\r\n<code>static</code>是表示该函数只作用在类型的静态变量上，与类的实例没有关系；<br />\r\n<code>const</code>是确保函数不能修改实例的状态，与类型的静态变量没有关系。<br />\r\n二者一个脱离实例，一个保护实例。</p>\r\n<h2 id=\"const-和-define-定义常量的区别-1\">const 和 #define\r\n定义常量的区别</h2>\r\n<ul>\r\n<li><p>编译器处理方式不同:<br />\r\ndefine: 是“编译时”的概念，在预处理阶段进行替换。<br />\r\nconst: 是“运行时”的概念，在编译阶段确定其值</p></li>\r\n<li><p>类型检查:<br />\r\ndefine: 无类型，不进行类型安全检查，可能会产生<br />\r\nconst: 有数据类型，编译时会检查</p></li>\r\n<li><p>内存空间:<br />\r\ndefine:\r\n不分配内存，给出立即数，使用几次就进行几次替换，内存中会有多个拷贝，消耗大。<br />\r\nconst: 在静态存储区分配空间，程序运行中在内存中仅有一次拷贝。</p></li>\r\n<li><p>函数参数:<br />\r\n宏定义不能作为参数传递给函数。<br />\r\nconst常量可以在函数的参数列表中出现。</p></li>\r\n<li><p>在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储和读内存的操作，效率高。</p></li>\r\n<li><p>define宏替换只做替换，不做表达式计算。</p></li>\r\n</ul>\r\n<h1 id=\"typedef-与-define-的区别-1\">typedef 与 #define 的区别</h1>\r\n<h2 id=\"typedef-1\">typedef</h2>\r\n<p><code>typedef</code>即类型定义的意思，就是给已有类型起别名。可以简化那些繁琐的类型名；也可以一定程度忽视不同平台的差异，不同平台见只需要修改<code>typedef</code>即可。</p>\r\n<h2 id=\"define-1\">#define</h2>\r\n<p><code>#define</code>为宏定义语句，就是文本替换</p>\r\n<h2 id=\"区别-1\">区别</h2>\r\n<ul>\r\n<li><p><code>typedef</code>关键字在编译阶段有效，由于是在编译阶段，因此<code>typedef</code>有类型检查的功能。<code>#define</code>是宏定义，发生在预处理阶段，即编译之前，只是简单的字符替换，没有进行任何检查。</p></li>\r\n<li><p><code>#define</code>没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而<code>typedef</code>有自己的定义域。</p></li>\r\n<li><p>对指针操作不同:</p></li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">int</span> * pint  <br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PINT int *</span><br>  <br><span class=\"hljs-type\">int</span> i1 = <span class=\"hljs-number\">2</span>, i2 = <span class=\"hljs-number\">3</span>, i3 = <span class=\"hljs-number\">4</span>;<br>  <br><span class=\"hljs-type\">const</span> pint p1 = &amp;i1;    <span class=\"hljs-comment\">// p1不可更改，相当于 int* const  </span><br><span class=\"hljs-type\">const</span> PINT p2 = &amp;i2;    <span class=\"hljs-comment\">// p2可以修改，因为就是 const int *  </span><br>PINT <span class=\"hljs-type\">const</span> p3 = &amp;i3;    <span class=\"hljs-comment\">// p3本身不可以修改，就是 int * const  </span><br></code></pre></td></tr></table></figure>\r\n<p>相关链接：<br />\r\n<a\r\nhref=\"https://www.cnblogs.com/lulipro/p/5976601.html\">C++头文件，预处理详解\r\n- lulipro - 博客园</a><br />\r\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; e8dca420d7048ad9484cd8252ef496504eab0a20 <a\r\nhref=\"https://zhuanlan.zhihu.com/p/152046509\">C++中的static</a></p>\r\n","site":{"data":{}},"excerpt":"<p>在C++中有几个看上去不同，一想却有几分相同，但细究的确不同的修饰符，这里记述一下关于static,const,define这几个小伙子。</p>","more":"<h1 id=\"static\">static</h1>\r\n<h2 id=\"静态数据的存储\">静态数据的存储</h2>\r\n<blockquote>\r\n<p>全局(静态)存储区：(狗屎机翻说的都不是人话)</p>\r\n<p>分为DATA段与BSS段。<br />\r\nDATA段(全局初始化区): 存放初始化的全局变量和静态变量。<br />\r\nBSS段(全局未初始化区): 存放未初始化的全局变量和静态变量。<br />\r\n程序结束时全局存储器自动释放，BSS段会在程序执行前被系统自动清0，即未初始化的全局变量和静态变量在程序执行之前已经为0。<br />\r\n在<strong>静态数据区的变量会在程序开始时，就完成初始化，也是唯一的一次初始化</strong>。</p>\r\n</blockquote>\r\n<h3 id=\"static对于变量\">static对于变量</h3>\r\n<p><strong>1.局部变量</strong></p>\r\n<p>在局部变量前加上关键字<code>static</code>，其将被定义为局部静态变量。</p>\r\n<p>内存位置: 静态存储区<br />\r\n初始化: 局部的静态变量只被初始化一次<br />\r\n作用域:\r\n作用域仍为局部作用域，数据仍在局部可见，定义它的函数或者语句块结束的时候，作用域随之结束。</p>\r\n<blockquote>\r\n<p>当<code>static</code>作用于局部变量时，改变了其存储位置，从栈转存到静态存储区，也改变了生存周期，在离开作用域后变量没有被销毁，仍存储在内存中，只是保留了原有的可见性，即没改变作用域，在程序结束后释放其占用的内存。</p>\r\n</blockquote>\r\n<p><strong>2.全局变量</strong></p>\r\n<p>在全局变量上作用，其变为全局静态变量。</p>\r\n<p>内存位置: 静态存储区；<br />\r\n初始化: 未经初始化的全局变量自动初始化为0；<br />\r\n作用域:\r\n全局静态变量作用于当前文件，即在声明他的文件外是不可见的，只能在本文件中使用。</p>\r\n<blockquote>\r\n<p>全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。但二者区别在于非静态全局变量作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的\r\n<strong>(在其他源文件中使用时加上<code>extern</code>关键字重新声明即可)</strong>。而静态全局变量反而限制了其作用域，即限定为定义该变量的源文件中有效，在同一源程序中的其他源文件中无法使用。</p>\r\n</blockquote>\r\n<h3 id=\"static对于函数\">static对于函数</h3>\r\n<p>修饰普通函数，表明函数的作用范围，仅仅在定义该函数的文件内才能使用。在多人开发过程中可以使用这个技巧，把函数作用域同上述的全局变量一样，限制在该文件内，防止和他人函数重名。</p>\r\n<h3 id=\"static对于类\">static对于类</h3>\r\n<p><strong>1.成员变量</strong></p>\r\n<p>用<code>static</code>修饰类的数据成员，使其成为<strong>类的全局变量</strong>，被所有类的对象共享，<strong>包括派生类的对象！</strong><br />\r\n因此<code>static</code>成员必须在类外进行初始化，而不能在构造函数内进行初始化，不过也可以使用<code>const</code>修饰<code>static</code>数据成员在类内初始化。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span>  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> staticNum;  <br>    <span class=\"hljs-built_in\">MyClass</span>();  <br>    ~<span class=\"hljs-built_in\">MyClass</span>();      <br>&#125;<br>  <br><span class=\"hljs-type\">int</span> MyClass::staticNum = <span class=\"hljs-number\">1</span>;  <br></code></pre></td></tr></table></figure>\r\n<p><strong>2.成员函数</strong></p>\r\n<p>用<code>static</code>修饰成员函数，使整个类只存在一份这个函数，所有对象共享，<strong>不含<code>this</code>指针</strong>。<br />\r\n静态成员是可以独立访问的，无需创建任何实例就能调用。</p>\r\n<p><strong>不可以同时用<code>const</code>和<code>static</code>修饰<em>成员函数</em>。</strong></p>\r\n<h1 id=\"const\">const</h1>\r\n<ul>\r\n<li><p>限定变量不可修改。</p></li>\r\n<li><p>限定成员函数不能修改任何数据成员。</p></li>\r\n</ul>\r\n<h2 id=\"const-和-指针\">const 和 指针</h2>\r\n<ul>\r\n<li>指向常量的指针</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 第一种  </span><br><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">2</span>;  <br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">4</span>;  <br><span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> *p;  <br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p = &amp;a;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;a:&quot;</span>&lt;&lt;*p&lt;&lt;endl;    <span class=\"hljs-comment\">// 2  </span><br>a++;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;a:&quot;</span>&lt;&lt;**p&lt;&lt;endl;    <span class=\"hljs-comment\">// 3  </span><br>p = &amp;b;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;b:&quot;</span>&lt;&lt;*p&lt;&lt;endl;  <br></code></pre></td></tr></table></figure>\r\n<p><code>const int *p</code>和<code>int const *p</code>一样，<code>const</code>修饰<code>int</code>，在<code>p</code>看来<code>a</code>是常量，所以不能用<code>(*p)++</code>修改数据，但是可以<code>a++</code>修改，因为<code>a</code>实际就是普通变量，只是<code>cont int *p</code>一厢情愿罢了。</p>\r\n<ul>\r\n<li>指针常量</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">2</span>;  <br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">4</span>;  <br><span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> p = &amp;a;  <br>cout &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class=\"hljs-comment\">// 2  </span><br>a++;                           <span class=\"hljs-comment\">// 3  </span><br>(*p)++;                        <span class=\"hljs-comment\">// 4  </span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class=\"hljs-comment\">// 4  </span><br></code></pre></td></tr></table></figure>\r\n<p><code>int* const</code> 的 <code>const</code> 修饰\r\n<code>int*</code>，表示<strong>该指针是常量，初始化后无法修改</strong>，但是<strong>其指向对象可以修改</strong>。<code>p</code>\r\n指向的是 <code>int</code> 类型，不是<code>const int</code>\r\n类型，<code>const int* const</code> 才是指向 <code>const int</code>\r\n类型。</p>\r\n<h1\r\nid=\"static和const可以同时修饰成员函数吗\">static和const可以同时修饰成员函数吗？</h1>\r\n<p>不可以，C++编译器在实现<code>const</code>的成员函数时，为了确保该函数不能修改类的实例状态，会在函数中添加一个隐式的参数<code>const this*</code>。但当一个成员为<code>static</code>时，该函数是没有<code>this</code>指针的，就是说<code>const</code>和<code>static</code>冲突了，相互矛盾。<br />\r\n<code>static</code>是表示该函数只作用在类型的静态变量上，与类的实例没有关系；<br />\r\n<code>const</code>是确保函数不能修改实例的状态，与类型的静态变量没有关系。<br />\r\n二者一个脱离实例，一个保护实例。</p>\r\n<h2 id=\"const-和-define-定义常量的区别\">const 和 #define\r\n定义常量的区别</h2>\r\n<ul>\r\n<li><p>编译器处理方式不同:<br />\r\ndefine: 是“编译时”的概念，在预处理阶段进行替换。<br />\r\nconst: 是“运行时”的概念，在编译阶段确定其值</p></li>\r\n<li><p>类型检查:<br />\r\ndefine: 无类型，不进行类型安全检查，可能会产生<br />\r\nconst: 有数据类型，编译时会检查</p></li>\r\n<li><p>内存空间:<br />\r\ndefine:\r\n不分配内存，给出立即数，使用几次就进行几次替换，内存中会有多个拷贝，消耗大。<br />\r\nconst: 在静态存储区分配空间，程序运行中在内存中仅有一次拷贝。</p></li>\r\n<li><p>函数参数:<br />\r\n宏定义不能作为参数传递给函数。<br />\r\nconst常量可以在函数的参数列表中出现。</p></li>\r\n<li><p>在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储和读内存的操作，效率高。</p></li>\r\n<li><p>define宏替换只做替换，不做表达式计算。</p></li>\r\n</ul>\r\n<h1 id=\"typedef-与-define-的区别\">typedef 与 #define 的区别</h1>\r\n<h2 id=\"typedef\">typedef</h2>\r\n<p><code>typedef</code>即类型定义的意思，就是给已有类型起别名。可以简化那些繁琐的类型名；也可以一定程度忽视不同平台的差异，不同平台见只需要修改<code>typedef</code>即可。</p>\r\n<h2 id=\"define\">#define</h2>\r\n<p><code>#define</code>为宏定义语句，就是文本替换</p>\r\n<h2 id=\"区别\">区别</h2>\r\n<ul>\r\n<li><p><code>typedef</code>关键字在编译阶段有效，由于是在编译阶段，因此<code>typedef</code>有类型检查的功能。<code>#define</code>是宏定义，发生在预处理阶段，即编译之前，只是简单的字符替换，没有进行任何检查。</p></li>\r\n<li><p><code>#define</code>没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而<code>typedef</code>有自己的定义域。</p></li>\r\n<li><p>对指针操作不同:</p></li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">int</span> * pint  <br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PINT int *</span><br>  <br><span class=\"hljs-type\">int</span> i1 = <span class=\"hljs-number\">2</span>, i2 = <span class=\"hljs-number\">3</span>, i3 = <span class=\"hljs-number\">4</span>;<br>  <br><span class=\"hljs-type\">const</span> pint p1 = &amp;i1;    <span class=\"hljs-comment\">// p1不可更改，相当于 int* const  </span><br><span class=\"hljs-type\">const</span> PINT p2 = &amp;i2;    <span class=\"hljs-comment\">// p2可以修改，因为就是 const int *  </span><br>PINT <span class=\"hljs-type\">const</span> p3 = &amp;i3;    <span class=\"hljs-comment\">// p3本身不可以修改，就是 int * const  </span><br></code></pre></td></tr></table></figure>\r\n<p>相关链接：<br />\r\n<a\r\nhref=\"https://www.cnblogs.com/lulipro/p/5976601.html\">C++头文件，预处理详解\r\n- lulipro - 博客园</a><br />\r\n======= --- title: C++之static,const,define date: 2022-05-02 13:11:42\r\ntags:</p>\r\n<hr />\r\n<p>在C++中有几个看上去不同，一想却有几分相同，但细究的确不同的修饰符，这里记述一下关于static,const,define这几个小伙子。</p>\r\n<!--more-->\r\n<h1 id=\"static-1\">static</h1>\r\n<h2 id=\"静态数据的存储-1\">静态数据的存储</h2>\r\n<blockquote>\r\n<p>全局(静态)存储区：(狗屎机翻说的都不是人话)</p>\r\n<p>分为DATA段与BSS段。<br />\r\nDATA段(全局初始化区): 存放初始化的全局变量和静态变量。<br />\r\nBSS段(全局未初始化区): 存放未初始化的全局变量和静态变量。<br />\r\n程序结束时全局存储器自动释放，BSS段会在程序执行前被系统自动清0，即未初始化的全局变量和静态变量在程序执行之前已经为0。<br />\r\n在<strong>静态数据区的变量会在程序开始时，就完成初始化，也是唯一的一次初始化</strong>。</p>\r\n</blockquote>\r\n<h3 id=\"static对于变量-1\">static对于变量</h3>\r\n<p><strong>1.局部变量</strong></p>\r\n<p>在局部变量前加上关键字<code>static</code>，其将被定义为局部静态变量。</p>\r\n<p>内存位置: 静态存储区<br />\r\n初始化: 局部的静态变量只被初始化一次<br />\r\n作用域:\r\n作用域仍为局部作用域，数据仍在局部可见，定义它的函数或者语句块结束的时候，作用域随之结束。</p>\r\n<blockquote>\r\n<p>当<code>static</code>作用于局部变量时，改变了其存储位置，从栈转存到静态存储区，也改变了生存周期，在离开作用域后变量没有被销毁，仍存储在内存中，只是保留了原有的可见性，即没改变作用域，在程序结束后释放其占用的内存。</p>\r\n</blockquote>\r\n<p><strong>2.全局变量</strong></p>\r\n<p>在全局变量上作用，其变为全局静态变量。</p>\r\n<p>内存位置: 静态存储区；<br />\r\n初始化: 未经初始化的全局变量自动初始化为0；<br />\r\n作用域:\r\n全局静态变量作用于当前文件，即在声明他的文件外是不可见的，只能在本文件中使用。</p>\r\n<blockquote>\r\n<p>全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。但二者区别在于非静态全局变量作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的\r\n<strong>(在其他源文件中使用时加上<code>extern</code>关键字重新声明即可)</strong>。而静态全局变量反而限制了其作用域，即限定为定义该变量的源文件中有效，在同一源程序中的其他源文件中无法使用。</p>\r\n</blockquote>\r\n<h3 id=\"static对于函数-1\">static对于函数</h3>\r\n<p>修饰普通函数，表明函数的作用范围，仅仅在定义该函数的文件内才能使用。在多人开发过程中可以使用这个技巧，把函数作用域同上述的全局变量一样，限制在该文件内，防止和他人函数重名。</p>\r\n<h3 id=\"static对于类-1\">static对于类</h3>\r\n<p><strong>1.成员变量</strong></p>\r\n<p>用<code>static</code>修饰类的数据成员，使其成为<strong>类的全局变量</strong>，被所有类的对象共享，<strong>包括派生类的对象！</strong><br />\r\n因此<code>static</code>成员必须在类外进行初始化，而不能在构造函数内进行初始化，不过也可以使用<code>const</code>修饰<code>static</code>数据成员在类内初始化。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span>  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> staticNum;  <br>    <span class=\"hljs-built_in\">MyClass</span>();  <br>    ~<span class=\"hljs-built_in\">MyClass</span>();      <br>&#125;<br>  <br><span class=\"hljs-type\">int</span> MyClass::staticNum = <span class=\"hljs-number\">1</span>;  <br></code></pre></td></tr></table></figure>\r\n<p><strong>2.成员函数</strong></p>\r\n<p>用<code>static</code>修饰成员函数，使整个类只存在一份这个函数，所有对象共享，<strong>不含<code>this</code>指针</strong>。<br />\r\n静态成员是可以独立访问的，无需创建任何实例就能调用。</p>\r\n<p><strong>不可以同时用<code>const</code>和<code>static</code>修饰<em>成员函数</em>。</strong></p>\r\n<h1 id=\"const-1\">const</h1>\r\n<ul>\r\n<li><p>限定变量不可修改。</p></li>\r\n<li><p>限定成员函数不能修改任何数据成员。</p></li>\r\n</ul>\r\n<h2 id=\"const-和-指针-1\">const 和 指针</h2>\r\n<ul>\r\n<li>指向常量的指针</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 第一种  </span><br><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">2</span>;  <br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">4</span>;  <br><span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> *p;  <br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p = &amp;a;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;a:&quot;</span>&lt;&lt;*p&lt;&lt;endl;    <span class=\"hljs-comment\">// 2  </span><br>a++;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;a:&quot;</span>&lt;&lt;**p&lt;&lt;endl;    <span class=\"hljs-comment\">// 3  </span><br>p = &amp;b;  <br>cout&lt;&lt;<span class=\"hljs-string\">&quot;b:&quot;</span>&lt;&lt;*p&lt;&lt;endl;  <br></code></pre></td></tr></table></figure>\r\n<p><code>const int *p</code>和<code>int const *p</code>一样，<code>const</code>修饰<code>int</code>，在<code>p</code>看来<code>a</code>是常量，所以不能用<code>(*p)++</code>修改数据，但是可以<code>a++</code>修改，因为<code>a</code>实际就是普通变量，只是<code>cont int *p</code>一厢情愿罢了。</p>\r\n<ul>\r\n<li>指针常量</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">2</span>;  <br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">4</span>;  <br><span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> p = &amp;a;  <br>cout &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class=\"hljs-comment\">// 2  </span><br>a++;                           <span class=\"hljs-comment\">// 3  </span><br>(*p)++;                        <span class=\"hljs-comment\">// 4  </span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;a:&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class=\"hljs-comment\">// 4  </span><br></code></pre></td></tr></table></figure>\r\n<p><code>int* const</code> 的 <code>const</code> 修饰\r\n<code>int*</code>，表示<strong>该指针是常量，初始化后无法修改</strong>，但是<strong>其指向对象可以修改</strong>。<code>p</code>\r\n指向的是 <code>int</code> 类型，不是<code>const int</code>\r\n类型，<code>const int* const</code> 才是指向 <code>const int</code>\r\n类型。</p>\r\n<h1\r\nid=\"static和const可以同时修饰成员函数吗-1\">static和const可以同时修饰成员函数吗？</h1>\r\n<p>不可以，C++编译器在实现<code>const</code>的成员函数时，为了确保该函数不能修改类的实例状态，会在函数中添加一个隐式的参数<code>const this*</code>。但当一个成员为<code>static</code>时，该函数是没有<code>this</code>指针的，就是说<code>const</code>和<code>static</code>冲突了，相互矛盾。<br />\r\n<code>static</code>是表示该函数只作用在类型的静态变量上，与类的实例没有关系；<br />\r\n<code>const</code>是确保函数不能修改实例的状态，与类型的静态变量没有关系。<br />\r\n二者一个脱离实例，一个保护实例。</p>\r\n<h2 id=\"const-和-define-定义常量的区别-1\">const 和 #define\r\n定义常量的区别</h2>\r\n<ul>\r\n<li><p>编译器处理方式不同:<br />\r\ndefine: 是“编译时”的概念，在预处理阶段进行替换。<br />\r\nconst: 是“运行时”的概念，在编译阶段确定其值</p></li>\r\n<li><p>类型检查:<br />\r\ndefine: 无类型，不进行类型安全检查，可能会产生<br />\r\nconst: 有数据类型，编译时会检查</p></li>\r\n<li><p>内存空间:<br />\r\ndefine:\r\n不分配内存，给出立即数，使用几次就进行几次替换，内存中会有多个拷贝，消耗大。<br />\r\nconst: 在静态存储区分配空间，程序运行中在内存中仅有一次拷贝。</p></li>\r\n<li><p>函数参数:<br />\r\n宏定义不能作为参数传递给函数。<br />\r\nconst常量可以在函数的参数列表中出现。</p></li>\r\n<li><p>在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储和读内存的操作，效率高。</p></li>\r\n<li><p>define宏替换只做替换，不做表达式计算。</p></li>\r\n</ul>\r\n<h1 id=\"typedef-与-define-的区别-1\">typedef 与 #define 的区别</h1>\r\n<h2 id=\"typedef-1\">typedef</h2>\r\n<p><code>typedef</code>即类型定义的意思，就是给已有类型起别名。可以简化那些繁琐的类型名；也可以一定程度忽视不同平台的差异，不同平台见只需要修改<code>typedef</code>即可。</p>\r\n<h2 id=\"define-1\">#define</h2>\r\n<p><code>#define</code>为宏定义语句，就是文本替换</p>\r\n<h2 id=\"区别-1\">区别</h2>\r\n<ul>\r\n<li><p><code>typedef</code>关键字在编译阶段有效，由于是在编译阶段，因此<code>typedef</code>有类型检查的功能。<code>#define</code>是宏定义，发生在预处理阶段，即编译之前，只是简单的字符替换，没有进行任何检查。</p></li>\r\n<li><p><code>#define</code>没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而<code>typedef</code>有自己的定义域。</p></li>\r\n<li><p>对指针操作不同:</p></li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">int</span> * pint  <br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PINT int *</span><br>  <br><span class=\"hljs-type\">int</span> i1 = <span class=\"hljs-number\">2</span>, i2 = <span class=\"hljs-number\">3</span>, i3 = <span class=\"hljs-number\">4</span>;<br>  <br><span class=\"hljs-type\">const</span> pint p1 = &amp;i1;    <span class=\"hljs-comment\">// p1不可更改，相当于 int* const  </span><br><span class=\"hljs-type\">const</span> PINT p2 = &amp;i2;    <span class=\"hljs-comment\">// p2可以修改，因为就是 const int *  </span><br>PINT <span class=\"hljs-type\">const</span> p3 = &amp;i3;    <span class=\"hljs-comment\">// p3本身不可以修改，就是 int * const  </span><br></code></pre></td></tr></table></figure>\r\n<p>相关链接：<br />\r\n<a\r\nhref=\"https://www.cnblogs.com/lulipro/p/5976601.html\">C++头文件，预处理详解\r\n- lulipro - 博客园</a><br />\r\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; e8dca420d7048ad9484cd8252ef496504eab0a20 <a\r\nhref=\"https://zhuanlan.zhihu.com/p/152046509\">C++中的static</a></p>"},{"title":"C++11之 lambda 和 function","date":"2023-05-01T06:20:22.000Z","_content":"  \nC++11 的lambda 表达式和 function 是新引入的功能，他们的好处在于可以**简化代码、使之更灵活**而且在并发编程中一个 lambda 表达式或 function 对象作为线程的执行体会更安全，避免为一个线程单独写一个函数。  \n<!--more-->\n  \n# Lambda 和 Function\n  \n## Lambda 和 Function 的好处\n  \n1. Lambda表达式能够简化代码，使代码更加简洁。Lambda表达式相当于一个匿名函数，可以在需要的地方直接定义使用，不必再为了实现某个功能而额外定义一个函数。  \n2. Lambda表达式和Function都能够实现函数对象的传递，即将函数作为参数传递给其他函数。这种方式可以让代码更加灵活，更加符合面向对象编程的思想。  \n3. Function是一个通用的函数封装器，可以将任何可调用的对象（比如函数指针、成员函数指针、Lambda表达式等）转换为一个统一的函数类型。Function可以让代码更加通用，更不易出错。  \n4. Lambda表达式和Function都能够简化并发编程的代码。在并发编程中，有时需要定义一个Lambda表达式或Function对象作为一个线程的执行体，这样可以避免为线程另外写一个函数。\n  \n总结：Lambda表达式和Function的好处包括代码简洁、函数传递灵活、通用性强、并发编程简单等。\n  \n## 实例代码\n  \n~~~c++\nfunction<int(int)> dfs=[&](int cur) -> int {\n    int res=0;\n    for(int nei : g[cur])\n    {\n        res = max(res,dfs(nei));\n    }\n    return information[cur]+res;\n};\n~~~\n  \n## function\n  \nfunction 是 std::function 类型，可以用来存储任意可调用对象，包括函数指针、Lambda 表达式等等。\n  \n其使用方法为  \n`function<int(char)>` , int 为声明的返回值类型，而 char 为声明的参数类型，如果有多个参数即多个声明，如 `function<void(int,char)>`。\n  \nfunction 和函数指针有些类似，但是代码更灵活可以和 lambda 表达式相结合使用，而没有指针带来的问题，但是因为使用了模板所以会有一定的实例化开销。  \n我们也可以用 auto 去指定 lambda 表达式的匿名函数。\n  \n~~~c++\nauto funcPtr = &functionName;\nauto lambda = [](int x, int y){ return x+y;};\nint (*function) (int,int) = lambda;\t// 将 Lambda 表达式赋值给函数指针\n~~~\n  \nint (*funcPtr)(int, int) 是一个函数指针，它可以指向一个返回类型为 int，参数列表为 (int, int) 的函数。而 lambda 表达式则相当于一个匿名函数，用于表示一个可调用对象，可以被赋值给一个函数指针。\n  \n## Lambda\n  \n可以用在 sort 函数中自定义排序\n  \n~~~c++\nsort(nums.begin(),nums.end(),[&](const int& a, const int& b)\n     {\n         if(a < b)\n         {\n             return true;\n         }\n         return false;\n     });\n~~~\n  \n其中“[&]\"表示的是捕获方式，Lambda 表达式有三种捕获方式：\n  \n1. ”[&]“，用引用去捕获所有外部变量，表示该 Lambda 表达式使用一个引用以捕获所有局部变量。这意味着Lambda函数内的局部变量实际上是对外部作用域中的同名变量的别名。在Lambda函数中，对于捕获的变量的修改将直接影响外部作用域中的原始变量。  \n2. \"[=]\"：以复制方式捕获所有外部变量。Lambda 表达式使用复制构造函数以复制传递给它们的所有数据，并在 Lambda 函数体中使用该复制的变量副本。当然，对于复制的对象进行修改，不会影响到原始参数。  \n3. \"[cur]\"：以复制方式仅捕获外部变量 cur。这种方式只捕获指定的变量，每个指定的变量都使用复制构造函数以复制传递给它们的数据。\n  \n### 捕获变量例\n  \n这里的捕获变量不是说 lambda 表达式定义的函数参数，而是对函数外部变量的使用，比如  \n~~~c++\nint a = 1;\nauto func = [=]() mutable\n{\n    a += 1;\n    return a;\n};a\nstd::cout << func() << std::endl;\t// 2\nstd::cout << a << std::endl;\t// 1\n~~~\n  \n这里就是对 int a，lambda表达式用那种方式使用，而非()内的参数。  \n还有一点\n  \n~~~c++\nint a = 1;\nauto func = [=](int& a) mutable\n{\n    a += 1;\n    return a;\n};\nint b = 0;\nstd::cout << func(b) << std::endl;\t// 1\nstd::cout << b << std::endl;\t// 1\n~~~\n  \n这里的(int& a)对a有更高优先级，就是先匹配函数参数，外部定义的 int a，lambda函数是无法使用的。\n  \n1. [&], 所有参数全为引用\n  \n   ~~~c++  \n   int a=1;  \n   auto func=[&]()  \n   {  \n       a+=1;  \n       return a;  \n   }  \n   std::cout << func()<<std::endl;\t// 2  \n   ~~~\n  \n2. [=], 所有变量都复制捕获\n  \n   ~~~c++  \n   int a = 1;  \n   auto func=[=]() mutable  \n   {  \n       a+=1;  \n       return a;  \n   };  \n   std::cout << func() <<std::endl;\t// 2  \n   std::cout << a <<std::endl;\t// 1  \n   ~~~\n  \n3. [cur], 指定某个参数的捕获方式\n  \n   ~~~c++  \n   int num1 = 1, num2 = 2;  \n   auto func = [num1, &num2]() mutable{  \n   \tnum1 += 1;  \n   \tnum2 += 1;  \n   \treturn num1 + num2;  \n   };  \n   std::cout << func() << std::endl; // 2+3=5  \n   std::cout << num1 << num2 << std::endl; // 1,3  \n   ~~~\n  \n4.[], 如果在 Lambda 表达式中使用了 `[]`，而没有写任何符号，表示不捕获任何外部变量。这种情况下，**Lambda 表达式只能访问自己内部定义的变量和函数，不能访问任何外部的变量和函数。**  \n对于之前的a，b参数覆盖问题就应该声明成[]。\n  \n~~~c++\nint a = 1;\nauto func = [](int& a)\n{\n    a += 1;\n    return a;\n};\nint b = 0;\nstd::cout << func(b) << std::endl;\t// 1\nstd::cout << b << std::endl;\t// 1\n~~~\n  \n### mutable\n  \n`mutable` 是 C++ 中的一个关键字，用于修饰类的成员变量或者 Lambda 表达式中捕获的变量，表示这些变量是可变的，即使在 const 或者引用等限制的情况下也可以被修改。\n  \n在 Lambda 表达式中，如果想要修改按值捕获的外部变量，需要将其声明为 `mutable`，否则会编译错误。例如：  \n~~~c++\nint a = 10;\nauto func = [a]() mutable {\n    a += 1;\n    return a;\n};\nstd::cout << func() << std::endl; // 输出 11\nstd::cout << a << std::endl; // 输出 10\n~~~\n  \n### 指定返回值类型\n  \nlambda 表达式可以指定返回值类型，只需要  \n~~~c++\nfunction<int(int)> dfs=[&](int cur) -> int {\n    return cur;\n};\n~~~\n  \n这里的`->`就指定了返回值 int 类型。  ","source":"_posts/C++11之function和lambda.md","raw":"---\ntitle: C++11之 lambda 和 function\ndate: 2023-05-01 14:20:22\ntags:\n---\n  \nC++11 的lambda 表达式和 function 是新引入的功能，他们的好处在于可以**简化代码、使之更灵活**而且在并发编程中一个 lambda 表达式或 function 对象作为线程的执行体会更安全，避免为一个线程单独写一个函数。  \n<!--more-->\n  \n# Lambda 和 Function\n  \n## Lambda 和 Function 的好处\n  \n1. Lambda表达式能够简化代码，使代码更加简洁。Lambda表达式相当于一个匿名函数，可以在需要的地方直接定义使用，不必再为了实现某个功能而额外定义一个函数。  \n2. Lambda表达式和Function都能够实现函数对象的传递，即将函数作为参数传递给其他函数。这种方式可以让代码更加灵活，更加符合面向对象编程的思想。  \n3. Function是一个通用的函数封装器，可以将任何可调用的对象（比如函数指针、成员函数指针、Lambda表达式等）转换为一个统一的函数类型。Function可以让代码更加通用，更不易出错。  \n4. Lambda表达式和Function都能够简化并发编程的代码。在并发编程中，有时需要定义一个Lambda表达式或Function对象作为一个线程的执行体，这样可以避免为线程另外写一个函数。\n  \n总结：Lambda表达式和Function的好处包括代码简洁、函数传递灵活、通用性强、并发编程简单等。\n  \n## 实例代码\n  \n~~~c++\nfunction<int(int)> dfs=[&](int cur) -> int {\n    int res=0;\n    for(int nei : g[cur])\n    {\n        res = max(res,dfs(nei));\n    }\n    return information[cur]+res;\n};\n~~~\n  \n## function\n  \nfunction 是 std::function 类型，可以用来存储任意可调用对象，包括函数指针、Lambda 表达式等等。\n  \n其使用方法为  \n`function<int(char)>` , int 为声明的返回值类型，而 char 为声明的参数类型，如果有多个参数即多个声明，如 `function<void(int,char)>`。\n  \nfunction 和函数指针有些类似，但是代码更灵活可以和 lambda 表达式相结合使用，而没有指针带来的问题，但是因为使用了模板所以会有一定的实例化开销。  \n我们也可以用 auto 去指定 lambda 表达式的匿名函数。\n  \n~~~c++\nauto funcPtr = &functionName;\nauto lambda = [](int x, int y){ return x+y;};\nint (*function) (int,int) = lambda;\t// 将 Lambda 表达式赋值给函数指针\n~~~\n  \nint (*funcPtr)(int, int) 是一个函数指针，它可以指向一个返回类型为 int，参数列表为 (int, int) 的函数。而 lambda 表达式则相当于一个匿名函数，用于表示一个可调用对象，可以被赋值给一个函数指针。\n  \n## Lambda\n  \n可以用在 sort 函数中自定义排序\n  \n~~~c++\nsort(nums.begin(),nums.end(),[&](const int& a, const int& b)\n     {\n         if(a < b)\n         {\n             return true;\n         }\n         return false;\n     });\n~~~\n  \n其中“[&]\"表示的是捕获方式，Lambda 表达式有三种捕获方式：\n  \n1. ”[&]“，用引用去捕获所有外部变量，表示该 Lambda 表达式使用一个引用以捕获所有局部变量。这意味着Lambda函数内的局部变量实际上是对外部作用域中的同名变量的别名。在Lambda函数中，对于捕获的变量的修改将直接影响外部作用域中的原始变量。  \n2. \"[=]\"：以复制方式捕获所有外部变量。Lambda 表达式使用复制构造函数以复制传递给它们的所有数据，并在 Lambda 函数体中使用该复制的变量副本。当然，对于复制的对象进行修改，不会影响到原始参数。  \n3. \"[cur]\"：以复制方式仅捕获外部变量 cur。这种方式只捕获指定的变量，每个指定的变量都使用复制构造函数以复制传递给它们的数据。\n  \n### 捕获变量例\n  \n这里的捕获变量不是说 lambda 表达式定义的函数参数，而是对函数外部变量的使用，比如  \n~~~c++\nint a = 1;\nauto func = [=]() mutable\n{\n    a += 1;\n    return a;\n};a\nstd::cout << func() << std::endl;\t// 2\nstd::cout << a << std::endl;\t// 1\n~~~\n  \n这里就是对 int a，lambda表达式用那种方式使用，而非()内的参数。  \n还有一点\n  \n~~~c++\nint a = 1;\nauto func = [=](int& a) mutable\n{\n    a += 1;\n    return a;\n};\nint b = 0;\nstd::cout << func(b) << std::endl;\t// 1\nstd::cout << b << std::endl;\t// 1\n~~~\n  \n这里的(int& a)对a有更高优先级，就是先匹配函数参数，外部定义的 int a，lambda函数是无法使用的。\n  \n1. [&], 所有参数全为引用\n  \n   ~~~c++  \n   int a=1;  \n   auto func=[&]()  \n   {  \n       a+=1;  \n       return a;  \n   }  \n   std::cout << func()<<std::endl;\t// 2  \n   ~~~\n  \n2. [=], 所有变量都复制捕获\n  \n   ~~~c++  \n   int a = 1;  \n   auto func=[=]() mutable  \n   {  \n       a+=1;  \n       return a;  \n   };  \n   std::cout << func() <<std::endl;\t// 2  \n   std::cout << a <<std::endl;\t// 1  \n   ~~~\n  \n3. [cur], 指定某个参数的捕获方式\n  \n   ~~~c++  \n   int num1 = 1, num2 = 2;  \n   auto func = [num1, &num2]() mutable{  \n   \tnum1 += 1;  \n   \tnum2 += 1;  \n   \treturn num1 + num2;  \n   };  \n   std::cout << func() << std::endl; // 2+3=5  \n   std::cout << num1 << num2 << std::endl; // 1,3  \n   ~~~\n  \n4.[], 如果在 Lambda 表达式中使用了 `[]`，而没有写任何符号，表示不捕获任何外部变量。这种情况下，**Lambda 表达式只能访问自己内部定义的变量和函数，不能访问任何外部的变量和函数。**  \n对于之前的a，b参数覆盖问题就应该声明成[]。\n  \n~~~c++\nint a = 1;\nauto func = [](int& a)\n{\n    a += 1;\n    return a;\n};\nint b = 0;\nstd::cout << func(b) << std::endl;\t// 1\nstd::cout << b << std::endl;\t// 1\n~~~\n  \n### mutable\n  \n`mutable` 是 C++ 中的一个关键字，用于修饰类的成员变量或者 Lambda 表达式中捕获的变量，表示这些变量是可变的，即使在 const 或者引用等限制的情况下也可以被修改。\n  \n在 Lambda 表达式中，如果想要修改按值捕获的外部变量，需要将其声明为 `mutable`，否则会编译错误。例如：  \n~~~c++\nint a = 10;\nauto func = [a]() mutable {\n    a += 1;\n    return a;\n};\nstd::cout << func() << std::endl; // 输出 11\nstd::cout << a << std::endl; // 输出 10\n~~~\n  \n### 指定返回值类型\n  \nlambda 表达式可以指定返回值类型，只需要  \n~~~c++\nfunction<int(int)> dfs=[&](int cur) -> int {\n    return cur;\n};\n~~~\n  \n这里的`->`就指定了返回值 int 类型。  ","slug":"C++11之function和lambda","published":1,"updated":"2024-01-14T08:13:08.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppthy0003bkbw18x39mzp","content":"<p>C++11 的lambda 表达式和 function\r\n是新引入的功能，他们的好处在于可以<strong>简化代码、使之更灵活</strong>而且在并发编程中一个\r\nlambda 表达式或 function\r\n对象作为线程的执行体会更安全，避免为一个线程单独写一个函数。<br />\r\n<span id=\"more\"></span></p>\r\n<h1 id=\"lambda-和-function\">Lambda 和 Function</h1>\r\n<h2 id=\"lambda-和-function-的好处\">Lambda 和 Function 的好处</h2>\r\n<ol type=\"1\">\r\n<li>Lambda表达式能够简化代码，使代码更加简洁。Lambda表达式相当于一个匿名函数，可以在需要的地方直接定义使用，不必再为了实现某个功能而额外定义一个函数。<br />\r\n</li>\r\n<li>Lambda表达式和Function都能够实现函数对象的传递，即将函数作为参数传递给其他函数。这种方式可以让代码更加灵活，更加符合面向对象编程的思想。<br />\r\n</li>\r\n<li>Function是一个通用的函数封装器，可以将任何可调用的对象（比如函数指针、成员函数指针、Lambda表达式等）转换为一个统一的函数类型。Function可以让代码更加通用，更不易出错。<br />\r\n</li>\r\n<li>Lambda表达式和Function都能够简化并发编程的代码。在并发编程中，有时需要定义一个Lambda表达式或Function对象作为一个线程的执行体，这样可以避免为线程另外写一个函数。</li>\r\n</ol>\r\n<p>总结：Lambda表达式和Function的好处包括代码简洁、函数传递灵活、通用性强、并发编程简单等。</p>\r\n<h2 id=\"实例代码\">实例代码</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">function&lt;<span class=\"hljs-type\">int</span>(<span class=\"hljs-type\">int</span>)&gt; dfs=[&amp;](<span class=\"hljs-type\">int</span> cur) -&gt; <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-type\">int</span> res=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> nei : g[cur])<br>    &#123;<br>        res = <span class=\"hljs-built_in\">max</span>(res,<span class=\"hljs-built_in\">dfs</span>(nei));<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> information[cur]+res;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"function\">function</h2>\r\n<p>function 是 std::function\r\n类型，可以用来存储任意可调用对象，包括函数指针、Lambda 表达式等等。</p>\r\n<p>其使用方法为<br />\r\n<code>function&lt;int(char)&gt;</code> , int 为声明的返回值类型，而 char\r\n为声明的参数类型，如果有多个参数即多个声明，如\r\n<code>function&lt;void(int,char)&gt;</code>。</p>\r\n<p>function 和函数指针有些类似，但是代码更灵活可以和 lambda\r\n表达式相结合使用，而没有指针带来的问题，但是因为使用了模板所以会有一定的实例化开销。<br />\r\n我们也可以用 auto 去指定 lambda 表达式的匿名函数。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> funcPtr = &amp;functionName;<br><span class=\"hljs-keyword\">auto</span> lambda = [](<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)&#123; <span class=\"hljs-keyword\">return</span> x+y;&#125;;<br><span class=\"hljs-built_in\">int</span> (*function) (<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>) = lambda;\t<span class=\"hljs-comment\">// 将 Lambda 表达式赋值给函数指针</span><br></code></pre></td></tr></table></figure>\r\n<p>int (*funcPtr)(int, int) 是一个函数指针，它可以指向一个返回类型为\r\nint，参数列表为 (int, int) 的函数。而 lambda\r\n表达式则相当于一个匿名函数，用于表示一个可调用对象，可以被赋值给一个函数指针。</p>\r\n<h2 id=\"lambda\">Lambda</h2>\r\n<p>可以用在 sort 函数中自定义排序</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>(),[&amp;](<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>&amp; a, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>&amp; b)<br>     &#123;<br>         <span class=\"hljs-keyword\">if</span>(a &lt; b)<br>         &#123;<br>             <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>         &#125;<br>         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>     &#125;);<br></code></pre></td></tr></table></figure>\r\n<p>其中“[&amp;]\"表示的是捕获方式，Lambda 表达式有三种捕获方式：</p>\r\n<ol type=\"1\">\r\n<li>”[&amp;]“，用引用去捕获所有外部变量，表示该 Lambda\r\n表达式使用一个引用以捕获所有局部变量。这意味着Lambda函数内的局部变量实际上是对外部作用域中的同名变量的别名。在Lambda函数中，对于捕获的变量的修改将直接影响外部作用域中的原始变量。<br />\r\n</li>\r\n<li>\"[=]\"：以复制方式捕获所有外部变量。Lambda\r\n表达式使用复制构造函数以复制传递给它们的所有数据，并在 Lambda\r\n函数体中使用该复制的变量副本。当然，对于复制的对象进行修改，不会影响到原始参数。<br />\r\n</li>\r\n<li>\"[cur]\"：以复制方式仅捕获外部变量\r\ncur。这种方式只捕获指定的变量，每个指定的变量都使用复制构造函数以复制传递给它们的数据。</li>\r\n</ol>\r\n<h3 id=\"捕获变量例\">捕获变量例</h3>\r\n<p>这里的捕获变量不是说 lambda\r\n表达式定义的函数参数，而是对函数外部变量的使用，比如<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">auto</span> func = [=]() <span class=\"hljs-keyword\">mutable</span><br>&#123;<br>    a += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;;a<br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>() &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 2</span><br>std::cout &lt;&lt; a &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure></p>\r\n<p>这里就是对 int a，lambda表达式用那种方式使用，而非()内的参数。<br />\r\n还有一点</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">auto</span> func = [=](<span class=\"hljs-type\">int</span>&amp; a) <span class=\"hljs-keyword\">mutable</span><br>&#123;<br>    a += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;;<br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">0</span>;<br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>(b) &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 1</span><br>std::cout &lt;&lt; b &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\r\n<p>这里的(int&amp; a)对a有更高优先级，就是先匹配函数参数，外部定义的 int\r\na，lambda函数是无法使用的。</p>\r\n<ol type=\"1\">\r\n<li><p>[&amp;], 所有参数全为引用</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a=<span class=\"hljs-number\">1</span>;  <br><span class=\"hljs-keyword\">auto</span> func=[&amp;]()  <br>&#123;  <br>    a+=<span class=\"hljs-number\">1</span>;  <br>    <span class=\"hljs-keyword\">return</span> a;  <br>&#125;  <br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>()&lt;&lt;std::endl;\t<span class=\"hljs-comment\">// 2  </span><br></code></pre></td></tr></table></figure></li>\r\n<li><p>[=], 所有变量都复制捕获</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">1</span>;  <br><span class=\"hljs-keyword\">auto</span> func=[=]() <span class=\"hljs-keyword\">mutable</span>  <br>&#123;  <br>    a+=<span class=\"hljs-number\">1</span>;  <br>    <span class=\"hljs-keyword\">return</span> a;  <br>&#125;;  <br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>() &lt;&lt;std::endl;\t<span class=\"hljs-comment\">// 2  </span><br>std::cout &lt;&lt; a &lt;&lt;std::endl;\t<span class=\"hljs-comment\">// 1  </span><br></code></pre></td></tr></table></figure></li>\r\n<li><p>[cur], 指定某个参数的捕获方式</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> num1 = <span class=\"hljs-number\">1</span>, num2 = <span class=\"hljs-number\">2</span>;  <br><span class=\"hljs-keyword\">auto</span> func = [num1, &amp;num2]() <span class=\"hljs-keyword\">mutable</span>&#123;  <br>\tnum1 += <span class=\"hljs-number\">1</span>;  <br>\tnum2 += <span class=\"hljs-number\">1</span>;  <br>\t<span class=\"hljs-keyword\">return</span> num1 + num2;  <br>&#125;;  <br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>() &lt;&lt; std::endl; <span class=\"hljs-comment\">// 2+3=5  </span><br>std::cout &lt;&lt; num1 &lt;&lt; num2 &lt;&lt; std::endl; <span class=\"hljs-comment\">// 1,3  </span><br></code></pre></td></tr></table></figure></li>\r\n</ol>\r\n<p>4.[], 如果在 Lambda 表达式中使用了\r\n<code>[]</code>，而没有写任何符号，表示不捕获任何外部变量。这种情况下，<strong>Lambda\r\n表达式只能访问自己内部定义的变量和函数，不能访问任何外部的变量和函数。</strong><br />\r\n对于之前的a，b参数覆盖问题就应该声明成[]。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">auto</span> func = [](<span class=\"hljs-type\">int</span>&amp; a)<br>&#123;<br>    a += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;;<br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">0</span>;<br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>(b) &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 1</span><br>std::cout &lt;&lt; b &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\r\n<h3 id=\"mutable\">mutable</h3>\r\n<p><code>mutable</code> 是 C++ 中的一个关键字，用于修饰类的成员变量或者\r\nLambda 表达式中捕获的变量，表示这些变量是可变的，即使在 const\r\n或者引用等限制的情况下也可以被修改。</p>\r\n<p>在 Lambda 表达式中，如果想要修改按值捕获的外部变量，需要将其声明为\r\n<code>mutable</code>，否则会编译错误。例如：<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">auto</span> func = [a]() <span class=\"hljs-keyword\">mutable</span> &#123;<br>    a += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;;<br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>() &lt;&lt; std::endl; <span class=\"hljs-comment\">// 输出 11</span><br>std::cout &lt;&lt; a &lt;&lt; std::endl; <span class=\"hljs-comment\">// 输出 10</span><br></code></pre></td></tr></table></figure></p>\r\n<h3 id=\"指定返回值类型\">指定返回值类型</h3>\r\n<p>lambda 表达式可以指定返回值类型，只需要<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">function&lt;<span class=\"hljs-type\">int</span>(<span class=\"hljs-type\">int</span>)&gt; dfs=[&amp;](<span class=\"hljs-type\">int</span> cur) -&gt; <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> cur;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<p>这里的<code>-&gt;</code>就指定了返回值 int 类型。</p>\r\n","site":{"data":{}},"excerpt":"<p>C++11 的lambda 表达式和 function\r\n是新引入的功能，他们的好处在于可以<strong>简化代码、使之更灵活</strong>而且在并发编程中一个\r\nlambda 表达式或 function\r\n对象作为线程的执行体会更安全，避免为一个线程单独写一个函数。<br />","more":"</p>\r\n<h1 id=\"lambda-和-function\">Lambda 和 Function</h1>\r\n<h2 id=\"lambda-和-function-的好处\">Lambda 和 Function 的好处</h2>\r\n<ol type=\"1\">\r\n<li>Lambda表达式能够简化代码，使代码更加简洁。Lambda表达式相当于一个匿名函数，可以在需要的地方直接定义使用，不必再为了实现某个功能而额外定义一个函数。<br />\r\n</li>\r\n<li>Lambda表达式和Function都能够实现函数对象的传递，即将函数作为参数传递给其他函数。这种方式可以让代码更加灵活，更加符合面向对象编程的思想。<br />\r\n</li>\r\n<li>Function是一个通用的函数封装器，可以将任何可调用的对象（比如函数指针、成员函数指针、Lambda表达式等）转换为一个统一的函数类型。Function可以让代码更加通用，更不易出错。<br />\r\n</li>\r\n<li>Lambda表达式和Function都能够简化并发编程的代码。在并发编程中，有时需要定义一个Lambda表达式或Function对象作为一个线程的执行体，这样可以避免为线程另外写一个函数。</li>\r\n</ol>\r\n<p>总结：Lambda表达式和Function的好处包括代码简洁、函数传递灵活、通用性强、并发编程简单等。</p>\r\n<h2 id=\"实例代码\">实例代码</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">function&lt;<span class=\"hljs-type\">int</span>(<span class=\"hljs-type\">int</span>)&gt; dfs=[&amp;](<span class=\"hljs-type\">int</span> cur) -&gt; <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-type\">int</span> res=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> nei : g[cur])<br>    &#123;<br>        res = <span class=\"hljs-built_in\">max</span>(res,<span class=\"hljs-built_in\">dfs</span>(nei));<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> information[cur]+res;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"function\">function</h2>\r\n<p>function 是 std::function\r\n类型，可以用来存储任意可调用对象，包括函数指针、Lambda 表达式等等。</p>\r\n<p>其使用方法为<br />\r\n<code>function&lt;int(char)&gt;</code> , int 为声明的返回值类型，而 char\r\n为声明的参数类型，如果有多个参数即多个声明，如\r\n<code>function&lt;void(int,char)&gt;</code>。</p>\r\n<p>function 和函数指针有些类似，但是代码更灵活可以和 lambda\r\n表达式相结合使用，而没有指针带来的问题，但是因为使用了模板所以会有一定的实例化开销。<br />\r\n我们也可以用 auto 去指定 lambda 表达式的匿名函数。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> funcPtr = &amp;functionName;<br><span class=\"hljs-keyword\">auto</span> lambda = [](<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)&#123; <span class=\"hljs-keyword\">return</span> x+y;&#125;;<br><span class=\"hljs-built_in\">int</span> (*function) (<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>) = lambda;\t<span class=\"hljs-comment\">// 将 Lambda 表达式赋值给函数指针</span><br></code></pre></td></tr></table></figure>\r\n<p>int (*funcPtr)(int, int) 是一个函数指针，它可以指向一个返回类型为\r\nint，参数列表为 (int, int) 的函数。而 lambda\r\n表达式则相当于一个匿名函数，用于表示一个可调用对象，可以被赋值给一个函数指针。</p>\r\n<h2 id=\"lambda\">Lambda</h2>\r\n<p>可以用在 sort 函数中自定义排序</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>(),[&amp;](<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>&amp; a, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>&amp; b)<br>     &#123;<br>         <span class=\"hljs-keyword\">if</span>(a &lt; b)<br>         &#123;<br>             <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>         &#125;<br>         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>     &#125;);<br></code></pre></td></tr></table></figure>\r\n<p>其中“[&amp;]\"表示的是捕获方式，Lambda 表达式有三种捕获方式：</p>\r\n<ol type=\"1\">\r\n<li>”[&amp;]“，用引用去捕获所有外部变量，表示该 Lambda\r\n表达式使用一个引用以捕获所有局部变量。这意味着Lambda函数内的局部变量实际上是对外部作用域中的同名变量的别名。在Lambda函数中，对于捕获的变量的修改将直接影响外部作用域中的原始变量。<br />\r\n</li>\r\n<li>\"[=]\"：以复制方式捕获所有外部变量。Lambda\r\n表达式使用复制构造函数以复制传递给它们的所有数据，并在 Lambda\r\n函数体中使用该复制的变量副本。当然，对于复制的对象进行修改，不会影响到原始参数。<br />\r\n</li>\r\n<li>\"[cur]\"：以复制方式仅捕获外部变量\r\ncur。这种方式只捕获指定的变量，每个指定的变量都使用复制构造函数以复制传递给它们的数据。</li>\r\n</ol>\r\n<h3 id=\"捕获变量例\">捕获变量例</h3>\r\n<p>这里的捕获变量不是说 lambda\r\n表达式定义的函数参数，而是对函数外部变量的使用，比如<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">auto</span> func = [=]() <span class=\"hljs-keyword\">mutable</span><br>&#123;<br>    a += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;;a<br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>() &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 2</span><br>std::cout &lt;&lt; a &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure></p>\r\n<p>这里就是对 int a，lambda表达式用那种方式使用，而非()内的参数。<br />\r\n还有一点</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">auto</span> func = [=](<span class=\"hljs-type\">int</span>&amp; a) <span class=\"hljs-keyword\">mutable</span><br>&#123;<br>    a += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;;<br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">0</span>;<br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>(b) &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 1</span><br>std::cout &lt;&lt; b &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\r\n<p>这里的(int&amp; a)对a有更高优先级，就是先匹配函数参数，外部定义的 int\r\na，lambda函数是无法使用的。</p>\r\n<ol type=\"1\">\r\n<li><p>[&amp;], 所有参数全为引用</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a=<span class=\"hljs-number\">1</span>;  <br><span class=\"hljs-keyword\">auto</span> func=[&amp;]()  <br>&#123;  <br>    a+=<span class=\"hljs-number\">1</span>;  <br>    <span class=\"hljs-keyword\">return</span> a;  <br>&#125;  <br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>()&lt;&lt;std::endl;\t<span class=\"hljs-comment\">// 2  </span><br></code></pre></td></tr></table></figure></li>\r\n<li><p>[=], 所有变量都复制捕获</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">1</span>;  <br><span class=\"hljs-keyword\">auto</span> func=[=]() <span class=\"hljs-keyword\">mutable</span>  <br>&#123;  <br>    a+=<span class=\"hljs-number\">1</span>;  <br>    <span class=\"hljs-keyword\">return</span> a;  <br>&#125;;  <br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>() &lt;&lt;std::endl;\t<span class=\"hljs-comment\">// 2  </span><br>std::cout &lt;&lt; a &lt;&lt;std::endl;\t<span class=\"hljs-comment\">// 1  </span><br></code></pre></td></tr></table></figure></li>\r\n<li><p>[cur], 指定某个参数的捕获方式</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> num1 = <span class=\"hljs-number\">1</span>, num2 = <span class=\"hljs-number\">2</span>;  <br><span class=\"hljs-keyword\">auto</span> func = [num1, &amp;num2]() <span class=\"hljs-keyword\">mutable</span>&#123;  <br>\tnum1 += <span class=\"hljs-number\">1</span>;  <br>\tnum2 += <span class=\"hljs-number\">1</span>;  <br>\t<span class=\"hljs-keyword\">return</span> num1 + num2;  <br>&#125;;  <br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>() &lt;&lt; std::endl; <span class=\"hljs-comment\">// 2+3=5  </span><br>std::cout &lt;&lt; num1 &lt;&lt; num2 &lt;&lt; std::endl; <span class=\"hljs-comment\">// 1,3  </span><br></code></pre></td></tr></table></figure></li>\r\n</ol>\r\n<p>4.[], 如果在 Lambda 表达式中使用了\r\n<code>[]</code>，而没有写任何符号，表示不捕获任何外部变量。这种情况下，<strong>Lambda\r\n表达式只能访问自己内部定义的变量和函数，不能访问任何外部的变量和函数。</strong><br />\r\n对于之前的a，b参数覆盖问题就应该声明成[]。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">auto</span> func = [](<span class=\"hljs-type\">int</span>&amp; a)<br>&#123;<br>    a += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;;<br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">0</span>;<br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>(b) &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 1</span><br>std::cout &lt;&lt; b &lt;&lt; std::endl;\t<span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\r\n<h3 id=\"mutable\">mutable</h3>\r\n<p><code>mutable</code> 是 C++ 中的一个关键字，用于修饰类的成员变量或者\r\nLambda 表达式中捕获的变量，表示这些变量是可变的，即使在 const\r\n或者引用等限制的情况下也可以被修改。</p>\r\n<p>在 Lambda 表达式中，如果想要修改按值捕获的外部变量，需要将其声明为\r\n<code>mutable</code>，否则会编译错误。例如：<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">auto</span> func = [a]() <span class=\"hljs-keyword\">mutable</span> &#123;<br>    a += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> a;<br>&#125;;<br>std::cout &lt;&lt; <span class=\"hljs-built_in\">func</span>() &lt;&lt; std::endl; <span class=\"hljs-comment\">// 输出 11</span><br>std::cout &lt;&lt; a &lt;&lt; std::endl; <span class=\"hljs-comment\">// 输出 10</span><br></code></pre></td></tr></table></figure></p>\r\n<h3 id=\"指定返回值类型\">指定返回值类型</h3>\r\n<p>lambda 表达式可以指定返回值类型，只需要<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">function&lt;<span class=\"hljs-type\">int</span>(<span class=\"hljs-type\">int</span>)&gt; dfs=[&amp;](<span class=\"hljs-type\">int</span> cur) -&gt; <span class=\"hljs-type\">int</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> cur;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<p>这里的<code>-&gt;</code>就指定了返回值 int 类型。</p>"},{"title":"Dissolve in Unity","date":"2022-04-09T04:35:18.000Z","_content":"  \n# Dissolve in Unity\n  \n参考冯乐乐所著《Unity Shader 入门精要》在unity里实现简单的消融(Dissolve)效果，主要思想是利用噪声纹理，进行透明度剔除。(图片在GitHub加载失败可能是网络问题)\n  \n## 结果预览\n  \n![Alt pic](https://raw.githubusercontent.com/HollowEmiya/DissolveShader/main/DissolveResult.png)\n  \n<!--more-->\n  \n## 思路\n  \n我们先思考我们所需的消融效果是什么样的，需要物体被部分烧毁的痕迹，物体会被烧得镂空，燃烧的边缘有着颜色变化，大体而言就是这样。所以我们只需要利用噪声纹理，对物体表面进行依据透明度的剔除(Clip)来模拟镂空就好，再根据由噪声纹理得到的**透明度**和我们所定义**消融系数**对颜色进行插值就可以模拟边缘烧焦的效果(因为透明度更高的部分被clip了，所以我们这样简单的模拟就能得到很好的效果)。\n  \n## Word is weak, show me your code\n  \n<div align=\"center\">\n<img title=\"\" src=\"https://raw.githubusercontent.com/HollowEmiya/DissolveShader/main/DissolveMat.png\" alt=\"\"></div>\n  \n<center>Shader 面版</center>\n  \n    Properties  \n        {  \n            _BurnAmount (\"Burn Amount\", Range(0.0, 1.0)) = 0.0  \n            _LineWidth (\"Burn Line Width\", Range(0.0, 0.2)) = 0.1  \n            _MainTex (\"Base (RGB)\", 2D) = \"white\" { }  \n            _BumpMap (\"Normal Map\", 2D) = \"bump\" { }  \n            _BurnFirstColor (\"Burn First Color\", Color) = (1, 0, 0, 1)  \n            _BurnSecondColor (\"Burn Second Color\", Color) = (1, 0, 0, 1)  \n            _BurnMap (\"Burn Map\", 2D) = \"white\" { }  \n        }\n  \n我们首先需要定义所要用到的消融系数`_BurnAmount`，控制消融效果边缘宽度的`_LineWidth`，物体的主纹理、法线纹理、噪声纹理，以及用以模拟烧焦边缘的两个颜色`FirstColor`,`SecondColor`……\n  \n### Pass\n  \n然后来看第一个Pass部分，由于我们需要镂空效果所以我们要关闭Cull，来保证背面的片元也被成功渲染，渲染模式设置为普通的前向渲染即可。\n  \n    Tags {“LightMode” = “ForwardBase”}  \n    Cull Off\n  \n### 顶点着色器\n  \n关于顶点着色器，我们计算好视体空间坐标、所用的纹理坐标、世界坐标及切线下的光线方向，填充v2f即可。\n  \n    v2f vert(a2v v) {  \n                v2f o;  \n                o.pos = UnityObjectToClipPos(v.vertex);\n    \n                o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);  \n                o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);  \n                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);\n    \n                TANGENT_SPACE_ROTATION;  \n                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;\n    \n                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n    \n                TRANSFER_SHADOW(o);\n    \n                return o;  \n            }\n  \n因为我们使用了法线纹理，所以需要利用切线空间下的光照进行漫反射的计算。\n  \n### 片元着色器\n  \n接下来是重点的片元着色器\n  \n    fixed4 frag(v2f i) : SV_Target {  \n                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;\n    \n                clip(burn.r - _BurnAmount);\n    \n                float3 tangentLightDir = normalize(i.lightDir);  \n                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));\n    \n                fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;\n    \n                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;\n    \n                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentLightDir, tangentNormal));\n    \n                fixed t = 1 - smoothstep(0.0, _LineWidth, burn.r - _BurnAmount);\n    \n                fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);  \n                burnColor = pow(burnColor, 5);\n    \n                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);  \n                fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));\n    \n                return fixed4(finalColor, 1);  \n            }\n  \n可以看到我们先对噪声纹理进行采样，之后运用clip函数(剔除传入参数小于0的片元)根据纹理结果和我们设置的消融系数来进行片元剔除。\n  \n利用smoothstep函数计算系数t，smoothstep是根据第三个参数对第一、二个参数空间进行平滑过渡，区间左侧为零，右侧为1，区间做过度。\n  \n系数t越大越接近消融部分，越小越远离消融部分，t为0即像素显示正常颜色，t为1表明像素在燃烧边界。\n  \n根据t对FirstColor和SecondColor来进行lerp插值，模拟边缘的烧焦效果，因为“烧毁的部分”已经被clip掉了，所以我们的模拟不用担心透明度大于消融系数的部分。\n  \n同时使用pow函数对burnColor处理，使其更真实。\n  \n再用系数t对光照效果(ambient+diffuse)和烧焦颜色插值，这里使用一个step函数保证我们消融系数为0时，可以正常返回物体本身的颜色。\n  \n到这里其实主要部分已经完成了，不过我们还需要处理阴影，因为我们使用了透明效果，只要涉及到透明效果我们就一定要对阴影十分留意，如果不做处理，阴影还依照原本物体的样子投射阴影那么我们的模拟就穿帮了，这肯定不是我们想看到的，还好利用Unity我们不需要太复杂的处理。\n  \n### 关于阴影\n  \n我们需要做的就是把我们在消融模拟时剔除的片元，“真正的剔除”。也就是真的把物体烧了(笑。\n  \n开玩笑的，其实还是依照纹理采样来的透明度在生成阴影的pass剔除对应的片元。\n  \n先设置Pass的渲染模式\n  \n    Tags { \"LightMode\"=\"ShadowCaster\" }\n  \n#### 顶点着色器\n  \n顶点着色器及v2f结构体\n  \n    v2f vert(appdata_base v) {  \n                    v2f o;\n    \n                    TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);\n    \n                    o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);\n    \n                    return o;  \n                }\n  \n#### 片元着色器\n  \n片元着色器\n  \n    fixed4 frag(v2f i) : SV_Target {  \n                    fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;\n    \n                    clip(burn.r - _BurnAmount);\n    \n                    SHADOW_CASTER_FRAGMENT(i);  \n                }\n  \nclip用法和消融模拟中一样，而 V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET、SHADOW_CASTER_FRAGMENT 是老常客了，投射阴影重点就在于我们需要按照正常模拟那样对片元进行处理(是保留？还是剔除？)，利用Unity提供的这三个老常客我们可以省去很多很多的工作。\n  \n在结构体 v2f 中 V2F_SHADOW CASTER 来定义阴影投射需要定义的变量，在顶点着  \n色器中，使用 TRANSFER_SHADOW_ CASTER _NORMALOFFSET 来填充 V2F_SHADOW_   \nASTER在背后声明的变量，这是Unity帮我们完成的。。在片元着  \n色器中，SHADOW_ CASTER_FRAGMENT 来让 Unity 为我们完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。\n  \n注意，在我们使用Unity的内置宏时，我们的命名以及变量使用需要符合Unity的规范，例如， TRANSFER_SHADOW_ CASTER_NORMALOFFSET 会使用名称`v`作为输入结构体，v需要包含顶点位置 v.vertex 和顶点法线 v.normal，这些变量的appdata_base包含的，而当我们需要顶点动画时，可以在顶点着色器修改vertex，再传递给TRANSFER_SHADOW_ CASTER_NORMALOFFSET，这是可以的。\n  \n最后，也可以编写一个脚本根据时间修改Mat的_BurnAmount属性，来模拟基于时间的消融效果。\n  \n<a href=\"https://github.com/HollowEmiya/DissolveShader\" target=\"_blank\">代码地址</a>\n  \n[演示视频](https://www.bilibili.com/video/BV1BY4y1i7a8?spm_id_from=333.999.0.0)  ","source":"_posts/Dissolve-in-Unity.md","raw":"---\ntitle: Dissolve in Unity\ndate: 2022-04-09 12:35:18\ntags:\n---\n  \n# Dissolve in Unity\n  \n参考冯乐乐所著《Unity Shader 入门精要》在unity里实现简单的消融(Dissolve)效果，主要思想是利用噪声纹理，进行透明度剔除。(图片在GitHub加载失败可能是网络问题)\n  \n## 结果预览\n  \n![Alt pic](https://raw.githubusercontent.com/HollowEmiya/DissolveShader/main/DissolveResult.png)\n  \n<!--more-->\n  \n## 思路\n  \n我们先思考我们所需的消融效果是什么样的，需要物体被部分烧毁的痕迹，物体会被烧得镂空，燃烧的边缘有着颜色变化，大体而言就是这样。所以我们只需要利用噪声纹理，对物体表面进行依据透明度的剔除(Clip)来模拟镂空就好，再根据由噪声纹理得到的**透明度**和我们所定义**消融系数**对颜色进行插值就可以模拟边缘烧焦的效果(因为透明度更高的部分被clip了，所以我们这样简单的模拟就能得到很好的效果)。\n  \n## Word is weak, show me your code\n  \n<div align=\"center\">\n<img title=\"\" src=\"https://raw.githubusercontent.com/HollowEmiya/DissolveShader/main/DissolveMat.png\" alt=\"\"></div>\n  \n<center>Shader 面版</center>\n  \n    Properties  \n        {  \n            _BurnAmount (\"Burn Amount\", Range(0.0, 1.0)) = 0.0  \n            _LineWidth (\"Burn Line Width\", Range(0.0, 0.2)) = 0.1  \n            _MainTex (\"Base (RGB)\", 2D) = \"white\" { }  \n            _BumpMap (\"Normal Map\", 2D) = \"bump\" { }  \n            _BurnFirstColor (\"Burn First Color\", Color) = (1, 0, 0, 1)  \n            _BurnSecondColor (\"Burn Second Color\", Color) = (1, 0, 0, 1)  \n            _BurnMap (\"Burn Map\", 2D) = \"white\" { }  \n        }\n  \n我们首先需要定义所要用到的消融系数`_BurnAmount`，控制消融效果边缘宽度的`_LineWidth`，物体的主纹理、法线纹理、噪声纹理，以及用以模拟烧焦边缘的两个颜色`FirstColor`,`SecondColor`……\n  \n### Pass\n  \n然后来看第一个Pass部分，由于我们需要镂空效果所以我们要关闭Cull，来保证背面的片元也被成功渲染，渲染模式设置为普通的前向渲染即可。\n  \n    Tags {“LightMode” = “ForwardBase”}  \n    Cull Off\n  \n### 顶点着色器\n  \n关于顶点着色器，我们计算好视体空间坐标、所用的纹理坐标、世界坐标及切线下的光线方向，填充v2f即可。\n  \n    v2f vert(a2v v) {  \n                v2f o;  \n                o.pos = UnityObjectToClipPos(v.vertex);\n    \n                o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);  \n                o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);  \n                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);\n    \n                TANGENT_SPACE_ROTATION;  \n                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;\n    \n                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n    \n                TRANSFER_SHADOW(o);\n    \n                return o;  \n            }\n  \n因为我们使用了法线纹理，所以需要利用切线空间下的光照进行漫反射的计算。\n  \n### 片元着色器\n  \n接下来是重点的片元着色器\n  \n    fixed4 frag(v2f i) : SV_Target {  \n                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;\n    \n                clip(burn.r - _BurnAmount);\n    \n                float3 tangentLightDir = normalize(i.lightDir);  \n                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));\n    \n                fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;\n    \n                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;\n    \n                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentLightDir, tangentNormal));\n    \n                fixed t = 1 - smoothstep(0.0, _LineWidth, burn.r - _BurnAmount);\n    \n                fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);  \n                burnColor = pow(burnColor, 5);\n    \n                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);  \n                fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));\n    \n                return fixed4(finalColor, 1);  \n            }\n  \n可以看到我们先对噪声纹理进行采样，之后运用clip函数(剔除传入参数小于0的片元)根据纹理结果和我们设置的消融系数来进行片元剔除。\n  \n利用smoothstep函数计算系数t，smoothstep是根据第三个参数对第一、二个参数空间进行平滑过渡，区间左侧为零，右侧为1，区间做过度。\n  \n系数t越大越接近消融部分，越小越远离消融部分，t为0即像素显示正常颜色，t为1表明像素在燃烧边界。\n  \n根据t对FirstColor和SecondColor来进行lerp插值，模拟边缘的烧焦效果，因为“烧毁的部分”已经被clip掉了，所以我们的模拟不用担心透明度大于消融系数的部分。\n  \n同时使用pow函数对burnColor处理，使其更真实。\n  \n再用系数t对光照效果(ambient+diffuse)和烧焦颜色插值，这里使用一个step函数保证我们消融系数为0时，可以正常返回物体本身的颜色。\n  \n到这里其实主要部分已经完成了，不过我们还需要处理阴影，因为我们使用了透明效果，只要涉及到透明效果我们就一定要对阴影十分留意，如果不做处理，阴影还依照原本物体的样子投射阴影那么我们的模拟就穿帮了，这肯定不是我们想看到的，还好利用Unity我们不需要太复杂的处理。\n  \n### 关于阴影\n  \n我们需要做的就是把我们在消融模拟时剔除的片元，“真正的剔除”。也就是真的把物体烧了(笑。\n  \n开玩笑的，其实还是依照纹理采样来的透明度在生成阴影的pass剔除对应的片元。\n  \n先设置Pass的渲染模式\n  \n    Tags { \"LightMode\"=\"ShadowCaster\" }\n  \n#### 顶点着色器\n  \n顶点着色器及v2f结构体\n  \n    v2f vert(appdata_base v) {  \n                    v2f o;\n    \n                    TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);\n    \n                    o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);\n    \n                    return o;  \n                }\n  \n#### 片元着色器\n  \n片元着色器\n  \n    fixed4 frag(v2f i) : SV_Target {  \n                    fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;\n    \n                    clip(burn.r - _BurnAmount);\n    \n                    SHADOW_CASTER_FRAGMENT(i);  \n                }\n  \nclip用法和消融模拟中一样，而 V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET、SHADOW_CASTER_FRAGMENT 是老常客了，投射阴影重点就在于我们需要按照正常模拟那样对片元进行处理(是保留？还是剔除？)，利用Unity提供的这三个老常客我们可以省去很多很多的工作。\n  \n在结构体 v2f 中 V2F_SHADOW CASTER 来定义阴影投射需要定义的变量，在顶点着  \n色器中，使用 TRANSFER_SHADOW_ CASTER _NORMALOFFSET 来填充 V2F_SHADOW_   \nASTER在背后声明的变量，这是Unity帮我们完成的。。在片元着  \n色器中，SHADOW_ CASTER_FRAGMENT 来让 Unity 为我们完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。\n  \n注意，在我们使用Unity的内置宏时，我们的命名以及变量使用需要符合Unity的规范，例如， TRANSFER_SHADOW_ CASTER_NORMALOFFSET 会使用名称`v`作为输入结构体，v需要包含顶点位置 v.vertex 和顶点法线 v.normal，这些变量的appdata_base包含的，而当我们需要顶点动画时，可以在顶点着色器修改vertex，再传递给TRANSFER_SHADOW_ CASTER_NORMALOFFSET，这是可以的。\n  \n最后，也可以编写一个脚本根据时间修改Mat的_BurnAmount属性，来模拟基于时间的消融效果。\n  \n<a href=\"https://github.com/HollowEmiya/DissolveShader\" target=\"_blank\">代码地址</a>\n  \n[演示视频](https://www.bilibili.com/video/BV1BY4y1i7a8?spm_id_from=333.999.0.0)  ","slug":"Dissolve-in-Unity","published":1,"updated":"2025-08-12T15:42:09.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppthy0004bkbw34a03r58","content":"<h1 id=\"dissolve-in-unity\">Dissolve in Unity</h1>\r\n<p>参考冯乐乐所著《Unity Shader\r\n入门精要》在unity里实现简单的消融(Dissolve)效果，主要思想是利用噪声纹理，进行透明度剔除。(图片在GitHub加载失败可能是网络问题)</p>\r\n<h2 id=\"结果预览\">结果预览</h2>\r\n<figure>\r\n<img\r\nsrc=\"https://raw.githubusercontent.com/HollowEmiya/DissolveShader/main/DissolveResult.png\"\r\nalt=\"Alt pic\" />\r\n<figcaption aria-hidden=\"true\">Alt pic</figcaption>\r\n</figure>\r\n<span id=\"more\"></span>\r\n<h2 id=\"思路\">思路</h2>\r\n<p>我们先思考我们所需的消融效果是什么样的，需要物体被部分烧毁的痕迹，物体会被烧得镂空，燃烧的边缘有着颜色变化，大体而言就是这样。所以我们只需要利用噪声纹理，对物体表面进行依据透明度的剔除(Clip)来模拟镂空就好，再根据由噪声纹理得到的<strong>透明度</strong>和我们所定义<strong>消融系数</strong>对颜色进行插值就可以模拟边缘烧焦的效果(因为透明度更高的部分被clip了，所以我们这样简单的模拟就能得到很好的效果)。</p>\r\n<h2 id=\"word-is-weak-show-me-your-code\">Word is weak, show me your\r\ncode</h2>\r\n<div data-align=\"center\">\r\n<img title=\"\" src=\"https://raw.githubusercontent.com/HollowEmiya/DissolveShader/main/DissolveMat.png\" alt=\"\">\r\n</div>\r\n<center>\r\nShader 面版\r\n</center>\r\n<pre><code class=\"hljs\">Properties  \r\n    &#123;  \r\n        _BurnAmount (&quot;Burn Amount&quot;, Range(0.0, 1.0)) = 0.0  \r\n        _LineWidth (&quot;Burn Line Width&quot;, Range(0.0, 0.2)) = 0.1  \r\n        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123; &#125;  \r\n        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123; &#125;  \r\n        _BurnFirstColor (&quot;Burn First Color&quot;, Color) = (1, 0, 0, 1)  \r\n        _BurnSecondColor (&quot;Burn Second Color&quot;, Color) = (1, 0, 0, 1)  \r\n        _BurnMap (&quot;Burn Map&quot;, 2D) = &quot;white&quot; &#123; &#125;  \r\n    &#125;</code></pre>\r\n<p>我们首先需要定义所要用到的消融系数<code>_BurnAmount</code>，控制消融效果边缘宽度的<code>_LineWidth</code>，物体的主纹理、法线纹理、噪声纹理，以及用以模拟烧焦边缘的两个颜色<code>FirstColor</code>,<code>SecondColor</code>……</p>\r\n<h3 id=\"pass\">Pass</h3>\r\n<p>然后来看第一个Pass部分，由于我们需要镂空效果所以我们要关闭Cull，来保证背面的片元也被成功渲染，渲染模式设置为普通的前向渲染即可。</p>\r\n<pre><code class=\"hljs\">Tags &#123;“LightMode” = “ForwardBase”&#125;  \r\nCull Off</code></pre>\r\n<h3 id=\"顶点着色器\">顶点着色器</h3>\r\n<p>关于顶点着色器，我们计算好视体空间坐标、所用的纹理坐标、世界坐标及切线下的光线方向，填充v2f即可。</p>\r\n<pre><code class=\"hljs\">v2f vert(a2v v) &#123;  \r\n            v2f o;  \r\n            o.pos = UnityObjectToClipPos(v.vertex);\r\n\r\n            o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);  \r\n            o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);  \r\n            o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);\r\n\r\n            TANGENT_SPACE_ROTATION;  \r\n            o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;\r\n\r\n            o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\r\n\r\n            TRANSFER_SHADOW(o);\r\n\r\n            return o;  \r\n        &#125;</code></pre>\r\n<p>因为我们使用了法线纹理，所以需要利用切线空间下的光照进行漫反射的计算。</p>\r\n<h3 id=\"片元着色器\">片元着色器</h3>\r\n<p>接下来是重点的片元着色器</p>\r\n<pre><code class=\"hljs\">fixed4 frag(v2f i) : SV_Target &#123;  \r\n            fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;\r\n\r\n            clip(burn.r - _BurnAmount);\r\n\r\n            float3 tangentLightDir = normalize(i.lightDir);  \r\n            fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));\r\n\r\n            fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;\r\n\r\n            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;\r\n\r\n            fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentLightDir, tangentNormal));\r\n\r\n            fixed t = 1 - smoothstep(0.0, _LineWidth, burn.r - _BurnAmount);\r\n\r\n            fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);  \r\n            burnColor = pow(burnColor, 5);\r\n\r\n            UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);  \r\n            fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));\r\n\r\n            return fixed4(finalColor, 1);  \r\n        &#125;</code></pre>\r\n<p>可以看到我们先对噪声纹理进行采样，之后运用clip函数(剔除传入参数小于0的片元)根据纹理结果和我们设置的消融系数来进行片元剔除。</p>\r\n<p>利用smoothstep函数计算系数t，smoothstep是根据第三个参数对第一、二个参数空间进行平滑过渡，区间左侧为零，右侧为1，区间做过度。</p>\r\n<p>系数t越大越接近消融部分，越小越远离消融部分，t为0即像素显示正常颜色，t为1表明像素在燃烧边界。</p>\r\n<p>根据t对FirstColor和SecondColor来进行lerp插值，模拟边缘的烧焦效果，因为“烧毁的部分”已经被clip掉了，所以我们的模拟不用担心透明度大于消融系数的部分。</p>\r\n<p>同时使用pow函数对burnColor处理，使其更真实。</p>\r\n<p>再用系数t对光照效果(ambient+diffuse)和烧焦颜色插值，这里使用一个step函数保证我们消融系数为0时，可以正常返回物体本身的颜色。</p>\r\n<p>到这里其实主要部分已经完成了，不过我们还需要处理阴影，因为我们使用了透明效果，只要涉及到透明效果我们就一定要对阴影十分留意，如果不做处理，阴影还依照原本物体的样子投射阴影那么我们的模拟就穿帮了，这肯定不是我们想看到的，还好利用Unity我们不需要太复杂的处理。</p>\r\n<h3 id=\"关于阴影\">关于阴影</h3>\r\n<p>我们需要做的就是把我们在消融模拟时剔除的片元，“真正的剔除”。也就是真的把物体烧了(笑。</p>\r\n<p>开玩笑的，其实还是依照纹理采样来的透明度在生成阴影的pass剔除对应的片元。</p>\r\n<p>先设置Pass的渲染模式</p>\r\n<pre><code class=\"hljs\">Tags &#123; &quot;LightMode&quot;=&quot;ShadowCaster&quot; &#125;</code></pre>\r\n<h4 id=\"顶点着色器-1\">顶点着色器</h4>\r\n<p>顶点着色器及v2f结构体</p>\r\n<pre><code class=\"hljs\">v2f vert(appdata_base v) &#123;  \r\n                v2f o;\r\n\r\n                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);\r\n\r\n                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);\r\n\r\n                return o;  \r\n            &#125;</code></pre>\r\n<h4 id=\"片元着色器-1\">片元着色器</h4>\r\n<p>片元着色器</p>\r\n<pre><code class=\"hljs\">fixed4 frag(v2f i) : SV_Target &#123;  \r\n                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;\r\n\r\n                clip(burn.r - _BurnAmount);\r\n\r\n                SHADOW_CASTER_FRAGMENT(i);  \r\n            &#125;</code></pre>\r\n<p>clip用法和消融模拟中一样，而\r\nV2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET、SHADOW_CASTER_FRAGMENT\r\n是老常客了，投射阴影重点就在于我们需要按照正常模拟那样对片元进行处理(是保留？还是剔除？)，利用Unity提供的这三个老常客我们可以省去很多很多的工作。</p>\r\n<p>在结构体 v2f 中 V2F_SHADOW CASTER\r\n来定义阴影投射需要定义的变量，在顶点着<br />\r\n色器中，使用 TRANSFER_SHADOW_ CASTER <em>NORMALOFFSET 来填充\r\nV2F_SHADOW</em><br />\r\nASTER在背后声明的变量，这是Unity帮我们完成的。。在片元着<br />\r\n色器中，SHADOW_ CASTER_FRAGMENT 来让 Unity\r\n为我们完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。</p>\r\n<p>注意，在我们使用Unity的内置宏时，我们的命名以及变量使用需要符合Unity的规范，例如，\r\nTRANSFER_SHADOW_ CASTER_NORMALOFFSET\r\n会使用名称<code>v</code>作为输入结构体，v需要包含顶点位置 v.vertex\r\n和顶点法线\r\nv.normal，这些变量的appdata_base包含的，而当我们需要顶点动画时，可以在顶点着色器修改vertex，再传递给TRANSFER_SHADOW_\r\nCASTER_NORMALOFFSET，这是可以的。</p>\r\n<p>最后，也可以编写一个脚本根据时间修改Mat的_BurnAmount属性，来模拟基于时间的消融效果。</p>\r\n<p><a href=\"https://github.com/HollowEmiya/DissolveShader\" target=\"_blank\">代码地址</a></p>\r\n<p><a\r\nhref=\"https://www.bilibili.com/video/BV1BY4y1i7a8?spm_id_from=333.999.0.0\">演示视频</a></p>\r\n","site":{"data":{}},"excerpt":"<h1 id=\"dissolve-in-unity\">Dissolve in Unity</h1>\r\n<p>参考冯乐乐所著《Unity Shader\r\n入门精要》在unity里实现简单的消融(Dissolve)效果，主要思想是利用噪声纹理，进行透明度剔除。(图片在GitHub加载失败可能是网络问题)</p>\r\n<h2 id=\"结果预览\">结果预览</h2>\r\n<figure>\r\n<img\r\nsrc=\"https://raw.githubusercontent.com/HollowEmiya/DissolveShader/main/DissolveResult.png\"\r\nalt=\"Alt pic\" />\r\n<figcaption aria-hidden=\"true\">Alt pic</figcaption>\r\n</figure>","more":"<h2 id=\"思路\">思路</h2>\r\n<p>我们先思考我们所需的消融效果是什么样的，需要物体被部分烧毁的痕迹，物体会被烧得镂空，燃烧的边缘有着颜色变化，大体而言就是这样。所以我们只需要利用噪声纹理，对物体表面进行依据透明度的剔除(Clip)来模拟镂空就好，再根据由噪声纹理得到的<strong>透明度</strong>和我们所定义<strong>消融系数</strong>对颜色进行插值就可以模拟边缘烧焦的效果(因为透明度更高的部分被clip了，所以我们这样简单的模拟就能得到很好的效果)。</p>\r\n<h2 id=\"word-is-weak-show-me-your-code\">Word is weak, show me your\r\ncode</h2>\r\n<div data-align=\"center\">\r\n<img title=\"\" src=\"https://raw.githubusercontent.com/HollowEmiya/DissolveShader/main/DissolveMat.png\" alt=\"\">\r\n</div>\r\n<center>\r\nShader 面版\r\n</center>\r\n<pre><code>Properties  \r\n    &#123;  \r\n        _BurnAmount (&quot;Burn Amount&quot;, Range(0.0, 1.0)) = 0.0  \r\n        _LineWidth (&quot;Burn Line Width&quot;, Range(0.0, 0.2)) = 0.1  \r\n        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123; &#125;  \r\n        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123; &#125;  \r\n        _BurnFirstColor (&quot;Burn First Color&quot;, Color) = (1, 0, 0, 1)  \r\n        _BurnSecondColor (&quot;Burn Second Color&quot;, Color) = (1, 0, 0, 1)  \r\n        _BurnMap (&quot;Burn Map&quot;, 2D) = &quot;white&quot; &#123; &#125;  \r\n    &#125;</code></pre>\r\n<p>我们首先需要定义所要用到的消融系数<code>_BurnAmount</code>，控制消融效果边缘宽度的<code>_LineWidth</code>，物体的主纹理、法线纹理、噪声纹理，以及用以模拟烧焦边缘的两个颜色<code>FirstColor</code>,<code>SecondColor</code>……</p>\r\n<h3 id=\"pass\">Pass</h3>\r\n<p>然后来看第一个Pass部分，由于我们需要镂空效果所以我们要关闭Cull，来保证背面的片元也被成功渲染，渲染模式设置为普通的前向渲染即可。</p>\r\n<pre><code>Tags &#123;“LightMode” = “ForwardBase”&#125;  \r\nCull Off</code></pre>\r\n<h3 id=\"顶点着色器\">顶点着色器</h3>\r\n<p>关于顶点着色器，我们计算好视体空间坐标、所用的纹理坐标、世界坐标及切线下的光线方向，填充v2f即可。</p>\r\n<pre><code>v2f vert(a2v v) &#123;  \r\n            v2f o;  \r\n            o.pos = UnityObjectToClipPos(v.vertex);\r\n\r\n            o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);  \r\n            o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);  \r\n            o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);\r\n\r\n            TANGENT_SPACE_ROTATION;  \r\n            o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;\r\n\r\n            o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\r\n\r\n            TRANSFER_SHADOW(o);\r\n\r\n            return o;  \r\n        &#125;</code></pre>\r\n<p>因为我们使用了法线纹理，所以需要利用切线空间下的光照进行漫反射的计算。</p>\r\n<h3 id=\"片元着色器\">片元着色器</h3>\r\n<p>接下来是重点的片元着色器</p>\r\n<pre><code>fixed4 frag(v2f i) : SV_Target &#123;  \r\n            fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;\r\n\r\n            clip(burn.r - _BurnAmount);\r\n\r\n            float3 tangentLightDir = normalize(i.lightDir);  \r\n            fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));\r\n\r\n            fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;\r\n\r\n            fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;\r\n\r\n            fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentLightDir, tangentNormal));\r\n\r\n            fixed t = 1 - smoothstep(0.0, _LineWidth, burn.r - _BurnAmount);\r\n\r\n            fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);  \r\n            burnColor = pow(burnColor, 5);\r\n\r\n            UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);  \r\n            fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));\r\n\r\n            return fixed4(finalColor, 1);  \r\n        &#125;</code></pre>\r\n<p>可以看到我们先对噪声纹理进行采样，之后运用clip函数(剔除传入参数小于0的片元)根据纹理结果和我们设置的消融系数来进行片元剔除。</p>\r\n<p>利用smoothstep函数计算系数t，smoothstep是根据第三个参数对第一、二个参数空间进行平滑过渡，区间左侧为零，右侧为1，区间做过度。</p>\r\n<p>系数t越大越接近消融部分，越小越远离消融部分，t为0即像素显示正常颜色，t为1表明像素在燃烧边界。</p>\r\n<p>根据t对FirstColor和SecondColor来进行lerp插值，模拟边缘的烧焦效果，因为“烧毁的部分”已经被clip掉了，所以我们的模拟不用担心透明度大于消融系数的部分。</p>\r\n<p>同时使用pow函数对burnColor处理，使其更真实。</p>\r\n<p>再用系数t对光照效果(ambient+diffuse)和烧焦颜色插值，这里使用一个step函数保证我们消融系数为0时，可以正常返回物体本身的颜色。</p>\r\n<p>到这里其实主要部分已经完成了，不过我们还需要处理阴影，因为我们使用了透明效果，只要涉及到透明效果我们就一定要对阴影十分留意，如果不做处理，阴影还依照原本物体的样子投射阴影那么我们的模拟就穿帮了，这肯定不是我们想看到的，还好利用Unity我们不需要太复杂的处理。</p>\r\n<h3 id=\"关于阴影\">关于阴影</h3>\r\n<p>我们需要做的就是把我们在消融模拟时剔除的片元，“真正的剔除”。也就是真的把物体烧了(笑。</p>\r\n<p>开玩笑的，其实还是依照纹理采样来的透明度在生成阴影的pass剔除对应的片元。</p>\r\n<p>先设置Pass的渲染模式</p>\r\n<pre><code>Tags &#123; &quot;LightMode&quot;=&quot;ShadowCaster&quot; &#125;</code></pre>\r\n<h4 id=\"顶点着色器-1\">顶点着色器</h4>\r\n<p>顶点着色器及v2f结构体</p>\r\n<pre><code>v2f vert(appdata_base v) &#123;  \r\n                v2f o;\r\n\r\n                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o);\r\n\r\n                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);\r\n\r\n                return o;  \r\n            &#125;</code></pre>\r\n<h4 id=\"片元着色器-1\">片元着色器</h4>\r\n<p>片元着色器</p>\r\n<pre><code>fixed4 frag(v2f i) : SV_Target &#123;  \r\n                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;\r\n\r\n                clip(burn.r - _BurnAmount);\r\n\r\n                SHADOW_CASTER_FRAGMENT(i);  \r\n            &#125;</code></pre>\r\n<p>clip用法和消融模拟中一样，而\r\nV2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET、SHADOW_CASTER_FRAGMENT\r\n是老常客了，投射阴影重点就在于我们需要按照正常模拟那样对片元进行处理(是保留？还是剔除？)，利用Unity提供的这三个老常客我们可以省去很多很多的工作。</p>\r\n<p>在结构体 v2f 中 V2F_SHADOW CASTER\r\n来定义阴影投射需要定义的变量，在顶点着<br />\r\n色器中，使用 TRANSFER_SHADOW_ CASTER <em>NORMALOFFSET 来填充\r\nV2F_SHADOW</em><br />\r\nASTER在背后声明的变量，这是Unity帮我们完成的。。在片元着<br />\r\n色器中，SHADOW_ CASTER_FRAGMENT 来让 Unity\r\n为我们完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。</p>\r\n<p>注意，在我们使用Unity的内置宏时，我们的命名以及变量使用需要符合Unity的规范，例如，\r\nTRANSFER_SHADOW_ CASTER_NORMALOFFSET\r\n会使用名称<code>v</code>作为输入结构体，v需要包含顶点位置 v.vertex\r\n和顶点法线\r\nv.normal，这些变量的appdata_base包含的，而当我们需要顶点动画时，可以在顶点着色器修改vertex，再传递给TRANSFER_SHADOW_\r\nCASTER_NORMALOFFSET，这是可以的。</p>\r\n<p>最后，也可以编写一个脚本根据时间修改Mat的_BurnAmount属性，来模拟基于时间的消融效果。</p>\r\n<p><a href=\"https://github.com/HollowEmiya/DissolveShader\" target=\"_blank\">代码地址</a></p>\r\n<p><a\r\nhref=\"https://www.bilibili.com/video/BV1BY4y1i7a8?spm_id_from=333.999.0.0\">演示视频</a></p>"},{"title":"C++ RAII","date":"2022-04-01T04:24:22.000Z","typora-root-url":"./..","_content":"  \n[What is RAII?](https://medium.com/swlh/what-is-raii-e016d00269f9)  \n[Youtube Vedio](https://www.youtube.com/watch?v=q6dVKMgeEkk)\n  \n<!--more-->\n  \n# C++ RAII(Resurce Acquisition Is Initialization)\n  \n## RAII 用来做什么?\n  \n### 内存\n  \n当我们在 C++ 中分配内存时，比如开辟一个数组，`int *arr = new int[dynamicSize]` ,那么我后续一定要记得去 `delete[] arr`，否则就会发生**内存泄漏**。也就是管理内存都需要我们手动去进行。\n  \n### 锁\n然后我们看看使用锁，假设我们想显式同步代码的某些部分。我创建一个 `std::mutex`，然后调用 `mutex.lock()`。如果忘记调用 `mutex.unlock()`，或者在解锁前发生异常(导致`mutex.unlock()`)未被调用，当其他线程尝试获取锁时将死锁。\n  \n### 线程\n如果我们想在另一个线程运行代码，然后我创建了一个线程。如果我们记得`jion`就没有问题，但是如果我们忘记了，并且线程超出了自己的作用域，`std::terminate`将被调用，程序会终止。\n  \n#### 线程相关内容补充\n  \n在C++中，创建线程后，如果没有适当地处理线程的结束，可能会导致程序意外终止。\n  \n当你创建一个新的线程并开始执行代码时，主线程和新线程是并行执行的。如果在主线程退出之前没有 join（或者使用 detach 分离线程），那么主线程结束时，程序会调用 `std::terminate` 来终止所有尚未结束的线程。\n  \n这种情况的发生通常是由于在主线程退出之前，新线程尚未完成，而没有等待新线程结束（或者分离）而导致的。因此，在使用线程时，确保在适当的时机对线程进行 join 或 detach 是非常重要的。\n  \n##### 关于 join 和 detach\n  \njoin 和 detach 是 c++ 两种管理线程的方法。\n  \n1. `join` 通过阻塞当前线程等待被调用的线程完成，确保主线程在子线程执行完毕后在继续执行，从而避免子线程在主线程退出去终止，或者超出作用域导致 `std::terminate` 导致整个进程结束。\n  \n   ~~~c++  \n   std::thread t(threadFunction);\n   \n   t.jion();\t\t// 阻塞该主线程，等待子线程完成  \n   ~~~\n  \n2. `detach` 将当前线程和新线程分离，使其独立运行。一旦被分离后就无法使用 `join` 方法等待线程结束。<u>**此时**线程的生命周期就由自己控制了，主线程和子线程可以并发执行，互相独立。</u>\n  \n   ~~~c++  \n   std::thread(threadFuntion);  \n   t.detach();  \n   ~~~\n  \n通过以上三个例子，我们可以看到错误发生是有一定规律的。首先在这些例子中我们获取了某些资源，如Heap上的内存、锁、线程。获取资源当然没有问题，但是当资源超出作用范围问题就发生了(内存泄露，死锁，进程终止)，在第一个问题中我们要时刻记得 delete、第二个需要 unlock，第三个需要 join，这显然是很繁琐的。\n  \nRAII 就是为了避免犯错和繁琐的手动释放。  \nC++ 和 Java，Python等的垃圾回收不同其析构函数是显式的，离开作用域自动销毁。  \n其他比如向 vector push一个资源，然后退出引用计数归零，但是不会立即删除，而是过段时间后调用一个 GC 程序将引用计数为零的对象删除。\n  \n但是如果对高性能计算有要求，如**时序**或**性能**就不能依赖 GC。\n  \n### RAII: 异常安全( exception-safe )\n  \nC++ 标准确保在异常发生时，也能调用 已创建对象的析构函数，因此 C++ 不需要 Java 那种 finally 语句确保执行。\n  \n### RAII 离不开  构造函数 和 析构函数\n  \n~~~c++\nstruct Pig\n{\n    std::string name;\n    int age;\n    \n    Pig():name(\"Kit\"),age(10)\n    {\n        \n    }\n    \n    Pig(string n, int a):name(n),age(a)\t\t// 拷贝构造函数\n    {\n        \n    }\n    \n    Pig(string n, int a)\t\t// 拷贝赋值函数\n    {\n        name = n;\n        age = a;\n    }\n}; \n\nint main()\n{\n    Pig pig0;\n    Pig pig1(\"Kiii\",2);\n}\n~~~\n  \n* 高效：使用初始化列表可以避免重复初始化，如果不使用，首先会先将数据成员空初始化，然后在构造函数内部进行赋值。  \n* 避免错误，因为不用初始化列表会先对成员进行无参初始化，而这时若类成员没有无参构造函数就会出错。  \n* 类成员为 const，因为 const 对象只能初始化一次，所以只能在初始化列表中进行。\n  \n> 要记住非初始化列表都是先进行无参初始化然后再在函数内进行一次赋值，即一次初始化，一次赋值。\n  \n#### 构造函数单个参数\n  \n~~~cpp\nstruct Pig\n{\n\tstring name;\n    int age;\n    \n    Pig(int age_):name(\"a Pig aged\"+to_string(age_)),age(age_)\n    {\n        \n    }\n}\n\nint main()\n{\n    Pig pig = 80;\n}\n~~~\n  \n这里 `= 80` 是隐式地调用了构造函数，如果想为了可读性避免这种隐式构造，可以使用 explicit。  \n~~~c++\nstruct Pig\n{\n\tstring name;\n    int age;\n    \n    explicit Pig(int age_):name(\"a Pig aged\"+to_string(age_)),age(age_)\n    {\n        \n    }\n}\n\nint main()\n{\n    // Pig pig = 80;\n    Pig pig(80);\n}\n~~~\n  \nexplicit 使其必须使用`(80)`这种格式显式调用构造函数。  \nexplicit 的作用就在于避免因为隐式调用而导致代码可读性的降低。\n  \n#### explicit 多参数\n  \n~~~c++\nstruct Pig\n{\n    string p_name;\n    int p_age;\n    \n    explicit Pig(string name, int age):p_name(name),p_age(age)\n    {\n        \n    }\n};\n\nint main()\n{\n    Pig pig = {\"Kit\",5};\t// Error\n    Pig pig2{\"Kit2\",7};\t\t// Right\n    Pig pig3(\"Kit3\",10);\t// Right\n}\n~~~\n  \nexplicit 可以用于多参数，并且在上面例子中，explicit 避免了 `{\"kit\",5}` 的隐式调用，并且接受了 `Pig pig2{\"Kit2\",7}` 的显式调用。\n  \n#### () 和 {} 调用的区别\n  \n1. `int(3.14f) ` 不会报错，但是 `int{3.14f}` 会报错，因为 {} 是非强制类型转换。  \n2. 假如 使用 `Pig pig2{\"jit2\",4.5}` 这就会出错了……\n  \nby the way，现在别使用 int() 了，太蠢了，而且不安全，比如 要是转换为指针可能会发生错误。应该使用 `static_cast<int>()` 进行。\n  \n### 编译器默认生成的构造函数：无参 ( POD 陷阱 )\n  \n当一个类没有定义任何构造函数，且类成员都有无参的构造函数，编译器会自动生成一个无参构造函数，会调用每个成员的无参构造函数。\n  \n**注意**这些类型**不会被初始化为0**。\n  \n1. int, float, double 等基础类型  \n2. `void*`, `Object*` 等指针类型  \n3. 完全有这些类型组成的类\n  \n* 这些类型称为 **POD( plain-of-data )**  \n  POD 的存在是出于兼容性和性能考虑，这些类型会将其所在内存位置的数据直接作为自己的初始值。\n  \n所以如果你打算使用编译器自动生成的初始化函数，最好对类成员用 `{}` 进行一个指定初始化，这样在 自动生成的构造函数中就会初始化为你指定的值。  \n~~~c++\nstruct Pig\n{\n    string p_name;\n    int weight{0};\t\t// 自动生成的构造函数会将其初始化为0\n};\n~~~\n  \n或者使用`=`也可以，但是要注意类对象其本身的构造函数是否有 explicit 修饰  \n~~~c++\nstruct Demo\n{\n    explicit Demo(string a, string b)\n    {\n        \n    }\n};\n\nstruct Pig\n{\n    string p_name;\n    int weight = 0;\n    Demo pd{\"a\",\"b\"};\t\t// 可以通过编译\n    // Demo pd = {\"a\",\"bb\"};\t// 这样就不行\n};\n~~~\n  \n>`int x{};  \n>void* p{};`  \n>  \n>和  \n>  \n>`int x{0};  \n>void* p{nullptr};`  \n>  \n>等价，都是**零初始化**\n  \n### 编译器默认生成的构造函数：C++11 初始化\n  \n在 C++11 中，如果一个类(和他的基类) 没有定义任何构造函数，这时编译器会自动生成一个**参数个数和成员一样的构造函数**。\n  \n会将 {} 内容，**按顺序赋值给对象的每一个成员**\n  \n不过这种只支持 {} 或者 = {}\n  \n~~~c++\nstruct Pig\n{\n    int a;\n    int b;\n};\n\nstruct Deo\n{\n    Pig pig;\n    int a;\n};\n\nint main() {\n    // Write C++ code here\n    std::cout << \"Hello world!\";\n    Pig pig{1,2};\n    std::cout << pig.a << std::endl;\t\t\t// 1\n    Deo deo{{3,2},1};\n    std::cout << deo.pig.a << std::endl;\t\t// 3\n    return 0;\n}\n~~~\n  \n当然这时候无参构造函数也是存在的。\n  \n和默认指定结合  \n~~~c++\nstruct Pig\n{\n    string p_name;\n    int p_weight{0};\n};\n\nint main()\n{\n    Pig pig{\"kit\"};\t\t// weight 未指定，使用 0\n}\n~~~\n  \n### 有自定义构造函数时仍想用默认构造函数：`=default`\n  \n一旦我们自定义了构造函数，编译器便**不会生成默认的无参构造函数**  \n但是如果我们仍然想使用，就可以用 `=default` 关键字。\n  \n~~~C++\nstruct Pig\n{\n    string pName;\n    int pWeight;\n    \n    Pig() = default;\n    \n    Pig(string name, int wei)\n        :pName(name),pWeight(wei)\n        {\n            \n        }\n}\n~~~\n  \n*but 初始化列表的那个构造函数好像不能 =default 出来*\n  \n### 编译器默认生成的构造函数：拷贝构造函数\n  \n`Pig(cosnt Pig& other)`  \n参数为 Pig 类型，调用如下\n  \n~~~c++\nint main()\n{\n    Pig pig{\"Kit\",90};\n    \n    Pig pig2 = pig;\n    // Pig pig2(pig);\t\t// 与上面的一样\n}\n~~~\n  \n即便我们自定义了构造函数，拷贝构造函数也不会删除。\n  \n### 舍弃拷贝构造函数：`=delete`\n  \n如果不想使用拷贝构造函数可以使用 `delete` 修饰  \n~~~C++\nstruct Pig\n{\n    string pName;\n    int pWeight{0};\n    \n    Pig()=default;\n    \n    Pig(string name, int wei):pName(name),pWeight(wei)\n    {}\n    \n    Pig(const Pig&) = delete;\t\t// 禁止拷贝构造\n    Pig& operatpor=(Pig const &) = delete;\t//  禁止拷贝赋值\n}\n~~~\n  \n`Pig pig2 = pig;` \n  \n这是**拷贝构造**  \n~~~C++ \nPig pig2;\t// 无参构造\npig2 = pig;\t// 拷贝赋值\n~~~\n  \n这是**拷贝赋值**\n  \n#### 为什么拷贝赋值函数返回值是引用\n  \n为了实现链式赋值，返回要是左值引用，而非临时对象的将亡值。\n  \n### 构造函数全家桶\n  \n#### 三五法则：一\n  \n<img src=\"imgs/C++RAII/35.png\">\n  \n1. 如果定义了析构函数，为了防止 doulefree 要么 delete 拷贝构造和拷贝赋值，要么自定义。  \n   也就是深拷贝和浅拷贝。  \n   浅拷贝会导致两个对象内的指针指向同一内存，所以我们要手动实现深拷贝。  \n   如果定义了析构函数很有可能是因为我们类内对象有些无法被默认的析构函数销毁，  \n   所以可能会有深拷贝和浅拷贝问题，如果只需要浅拷贝那就删除拷贝构造和拷贝赋值函数，C++会默认生成的。  \n2. 如果不实现拷贝赋值函数，编译器可能会以 析构+拷贝构造 的方式实现拷贝赋值的效果。  \n3. 与上面同理。\n  \n#### 拷贝和移动\n  \n有时候我们只需要一份 data，不需要复制，我们更希望把 对象 **移动**过去。  \n拷贝是 O(n)，移动是 O(1)  \n可以使用 std::move  \nv2 被移动到 v1 后原来的 v2 会被清空，所以一定要确保 v2 后续不会会再被使用。 \n  \n#### 移动进阶：swap\n  \n我们不仅可以使用move  \n也可以使用 `std::swap` 交换 v1 和 v2  \n可以利用 swap 实现双缓存技术。\n  \n#### 哪些情况会触发 move\n  \n* 会触发move  \n  * `return v2;`  作为返回值  \n  * `v1 = std::vector<int>(200)` 就地构造  \n  * `v1 = std::move(v2)` 显式move  \n* 拷贝  \n  * `return std::as_const(v2)`，显式拷贝   \n  * `v1 =v2` , 默认拷贝  \n* 下式不会 move 也不会 copy  \n  * `std::move(v2)`  \n  * `std::as_const(v2)`  \n  * 这两个函数只负责转换类型，不会发生实际的 copy 和 move。\n  \n### 移动构造函数：缺省实现\n  \n* 移动构造 ≈ 拷贝构造 + 解构他 + 他默认构造   (这里的他是移动的源对象)  \n* 移动赋值 ≈ 拷贝赋值 + 他结构 + 他默认构造\n  \n只要 我们不自己定义，编译器就会这样做  \n这也就是三五法则中 第4点, 为什么定义 **拷贝构造** 和 **拷贝赋值** 后最好定义 **移动构造** 和 **移动赋值**\n  \n## RAII 解决内存管理：`unique_ptr`\n  \nC++11 引用 `unique_ptr` 容器，其结构函数会调用 delete p。  \n~~~c++\nstruct C\n{\n    C(){printf(\"C\");}\n    ~C(){printf(\"~C\");}\n}\n\nint main()\n{\n    std::unique_ptr<C> p = std::make_unique<C>();\n    if(..)\n    {\n        return 1;\t// 自动释放 p\n    }\n    return 0; \t\t// 自动释放 p\n}\n~~~\n  \n而且将 C++98 的   \n~~~C++\ndelete p;\np = nullptr;\n~~~\n  \n封装为了一个操作：  \n`p = nullptr;` 等价于 `p.reset();`\n  \n#### `uniqur_ptr`: 禁止拷贝\n  \n为什么禁止拷贝，如果拷贝了这个指针，  \n而 `unique_ptr` 的析构函数使用了 delete，可能就会出现 double free 的问题。  \n所以，在我们写函数时，如果用 `unique_ptr` 作为参数就会报错。\n  \n##### 解决方案1：获取原始指针( C* )\n  \n* 第一种情况，我们不需要 夺走 资源的 **占有权**  \n  比如只是一个函数调用，**并不需要结果掌管对象生命周期的大权**。  \n  使用 `p.get()` 获取指针，然后进行操作。\n  \n  ~~~C++  \n   void func(C* cp)  \n   {\n       \n   }\n  \n  func(p.get());  \n  ~~~\n  \n* 第二种，我们需要夺走 资源的 **占有权**。  \n  ~~~c++  \n  std::vector<std::unique_ptr<C>> objectList;\n  \n  void func(std::unique_ptr<C> p)  \n  {  \n      objectList.push_back(std::move(p));  \n  }\n  \n  int main()  \n  {  \n      std::unique_ptr<C> p = std::make_unique<C>();  \n      printf(\"移交前:%p\\n\",p.get());\t\t// 不为null  \n      func(std::move(p));  \n      printf(\"移交后:%p\\n\",p.get());\t\t// 为null  \n      return 0;  \n  }  \n  ~~~\n  \n  因此我们要使用 move 接过掌管对象生命周期的大权。\n  \n#### 移交控制权后仍希望访问到 p 指向的对象\n  \n我们移交后，原来的指针就变 nullptr，这时无法访问。  \n##### 解决办法：提前获取指针\n  \n使用get函数提前获取原始指针，  \n不用担心周期问题，这个原始指针的所有权归move后的新`unique_ptr` 所有。  \n`C* raw_p = p.get();`\n  \n但是要时刻注意 move 后的 `unique_ptr` 是否被删除！\n  \n~~~c++\nint main()\n{\n    std::unique_ptr<C> p = std::make_unique<C>();\n\tC *raw_p = p.get();\n\tfunc(std::move(p));\n    \n    raw_p->do();\n    \n    objlist.clear();\n    \n    raw_p->do();\t// !!! Error 悬空指针\n}\n~~~\n  \n## `shared_ptr`\n  \n* `unique_ptr` 由于为了解决 double free 而**禁止拷贝**，导致使用起来很困难，容易犯错。  \n* `shared_ptr`，牺牲效率换取自由度，通过 **引用计数** 来解决 **重复释放** 的问题。\n  \n1. 当 `shared_ptr` 被初始化时，将计数器设为1；  \n2. 当  `shared_ptr` 被拷贝时， 计数器 +1；  \n3.  当一个  `shared_ptr`  被解构时，计数器 -1，直到计数器为 0，则自动销毁其所指向的对象。\n  \n* 我们可以使用 `p.use_count()` 获取当前的引用计数。\n  \n###  `shared_ptr` 和 循环引用\n  \n~~~cpp\nstruct C\n{\n    std:;shared_ptr<C> m_child;\n    std::shared_ptr<C> m_parent;\n};\n\nint main()\n{\n    auto parent = std::make_shared<C>();\n    auto child = std::make_shared<C>();\n    \n    parent->m_child = child;\n    child->m_parent = parent;\n    // 这里 parent 和 child 互相引用\n    \n    parent = nullptr;\t// 失败，child 的 m_parent 还在引用\n    child = nullptr;\t// 失败，parent 的 m_child 还在引用\n    \n    return 0;\n}\n~~~\n  \n即便 main 函数退出，这两块内存都无法释放。\n  \n## `weak_ptr` \n  \n### 循环引用：解决方案1\n  \n* 将逻辑上“不具有所属权” 的那一个 `shared_ptr`，改为 `weak_ptr` 即可。  \n  ~~~c++  \n  struct C  \n  {  \n      std:;shared_ptr<C> m_child;  \n      std::weak_ptr<C> m_parent;  \n  };\n  \n  int main()  \n  {  \n      auto parent = std::make_shared<C>();  \n      auto child = std::make_shared<C>();\n      \n      parent->m_child = child;  \n      child->m_parent = parent;  \n      // 这里 parent 和 child 互相引用\n      \n      parent = nullptr;\t// 释放，因为 child 指向的是其 **弱引用**  \n      child = nullptr;\t// 释放，因为指向 child 的 parent 已经释放了\n      \n      return 0;  \n  }  \n  ~~~\n\n  \n#### 不影响 shared_ptr 计数：弱引用 weak_ptr\n  \n* expired() 可以判断，weak_ptr 是否失效，如果 shared_ptr 已经释放了，该 weak_ptr 就失效了。  \n  `waek_p.expired()`\n  \n* lock()，如果有需求可以随时使用 lock 函数产生一个新的 shared_ptr。但不 lock 时 weak_ptr 不会影响计数。  \n  ~~~c++  \n  std::shared_ptr<C> p = std::make_shared<C>();  \n  std::weak_ptr<C> weak_p = p;  \n  weak_p.lock()->do_something();\t// 执行完毕后 lock 出来的 shared_ptr 就销毁了，不影响 shared_ptr 的计数，我理解为 lock 返回一个 shared_ptr 的将亡值，这行结束后自动解构  \n  ~~~\n  \n## 智能指针：作为类的成员变量\n  \n1. unique_ptr，**当该对象仅属于我**，比如父窗口下的子窗口  \n2. 原始指针，**当对象不属于我，但是他释放**<u>**前**</u>**我必然被释放。**  \n   有一定风险，比如子窗口中指向父窗口的指针。  \n3. shared_ptr：**当有多个对象共享时，或虽然该对象仅属于我，但是有 weak_ptr 的需要**  \n4. weak_ptr：**当该对象不属于我，且他释放**<u>**后**</u>**我仍可能不被释放。**比如：指向窗口上一次被点击的元素。  \n5. 初学者可多用 shard_ptr 和 weak_ptr 的组合，更加安全。\n  \n### 循环引用解决方案2：设置为原始指针\n  \n~~~c++\nstruct C\n{\n\tstd::shared_ptr<C> m_child;\n\tC* m_parent;\n}\n\nint main()\n{\n\tauto parent = std::make_shared<C>();\n\tauto child = std::make_shared<C>();\n\t\n\tparent->m_child = child;\n\tchild->m_parent = parent.get();\t\t// 这里 parent.get 得到的原始指针是归属于 shared_ptr parent 的\n\t\n\tparent = nullptr;\n\tchild = nullptr;\n\t\n\treturn 0;\n}\n~~~\n  \n还有更适合父窗口-子窗口的解决方案。  \n刚才提到原始指针的应用场景：当一个对象不属于我，但是他释放<u>前</u>我必须释放。  \n这里可以发现父窗口的释放必须导致子窗口的释放。\n  \n## 智能指针使用\n  \n### 成员都是安全类型：五大函数，一个也不用声明\n  \n* 如果类的所有成员都是 **安全** 类型，那么五大函数都无需声明，你的类型就是自动**安全的**。  \n* 最好的判断方式是：如果你不需要 **自定义的解构函数** 这个类就无需担心。  \n* 如果我们需要自定义 解构函数，往往意味着你的类成员中，包含不安全类型。  \n* 一般有两种情况：  \n  1. **类管理着资源**  \n  2. **类是数据结构**\n  \n#### 管理着资源(仅需要浅拷贝)：删除拷贝函数，统一用 shared_ptr 管理\n  \n* 因为资源，往往是不能被复制的。比如 一个 openGL 的 shader\n  \n* 如果允许拷贝(浅拷贝)，就相当于把 标记资源的 int 复制两遍，之后就会出现 double free 的问题。\n  \n#### 数据结构(需要深拷贝)：如果可以，定义拷贝和移动\n  \n* 我们设计的**数据结构**通常是支持深拷贝的，这需要我们自己去定义实现，如果实在无法实现那就删除。\n  \n### 函数如何避免拷贝\n  \n使用常引用：`Pig const & pig`\n  \n#### 如何避免不经意的隐式拷贝\n  \n我们可以将 拷贝构造函数声明为 explicit   \n这样隐式拷贝就会出错，让我们发现隐式拷贝的发生。\n  \n## 后续阅读\n  \n1. P-IMPL模式  \n2. 虚函数与纯虚函数  \n3. 拷贝如何作为虚函数  \n4. `std:unique_ptr::release()`  \n5. ` std:.enable_shared_from_this`  \n6. `dynamic_cast`  \n7. `std::dynamic_pointer_cast`  \n8. 运算符重载  \n9. 右值引用&&  \n10. `std::shared_ptr<void>`和 `std:any`  ","source":"_posts/C++RAII.md","raw":"---\ntitle: C++ RAII\ndate: 2022-04-01 12:24:22\ntags: \ntypora-root-url: ./..\n---\n  \n[What is RAII?](https://medium.com/swlh/what-is-raii-e016d00269f9)  \n[Youtube Vedio](https://www.youtube.com/watch?v=q6dVKMgeEkk)\n  \n<!--more-->\n  \n# C++ RAII(Resurce Acquisition Is Initialization)\n  \n## RAII 用来做什么?\n  \n### 内存\n  \n当我们在 C++ 中分配内存时，比如开辟一个数组，`int *arr = new int[dynamicSize]` ,那么我后续一定要记得去 `delete[] arr`，否则就会发生**内存泄漏**。也就是管理内存都需要我们手动去进行。\n  \n### 锁\n然后我们看看使用锁，假设我们想显式同步代码的某些部分。我创建一个 `std::mutex`，然后调用 `mutex.lock()`。如果忘记调用 `mutex.unlock()`，或者在解锁前发生异常(导致`mutex.unlock()`)未被调用，当其他线程尝试获取锁时将死锁。\n  \n### 线程\n如果我们想在另一个线程运行代码，然后我创建了一个线程。如果我们记得`jion`就没有问题，但是如果我们忘记了，并且线程超出了自己的作用域，`std::terminate`将被调用，程序会终止。\n  \n#### 线程相关内容补充\n  \n在C++中，创建线程后，如果没有适当地处理线程的结束，可能会导致程序意外终止。\n  \n当你创建一个新的线程并开始执行代码时，主线程和新线程是并行执行的。如果在主线程退出之前没有 join（或者使用 detach 分离线程），那么主线程结束时，程序会调用 `std::terminate` 来终止所有尚未结束的线程。\n  \n这种情况的发生通常是由于在主线程退出之前，新线程尚未完成，而没有等待新线程结束（或者分离）而导致的。因此，在使用线程时，确保在适当的时机对线程进行 join 或 detach 是非常重要的。\n  \n##### 关于 join 和 detach\n  \njoin 和 detach 是 c++ 两种管理线程的方法。\n  \n1. `join` 通过阻塞当前线程等待被调用的线程完成，确保主线程在子线程执行完毕后在继续执行，从而避免子线程在主线程退出去终止，或者超出作用域导致 `std::terminate` 导致整个进程结束。\n  \n   ~~~c++  \n   std::thread t(threadFunction);\n   \n   t.jion();\t\t// 阻塞该主线程，等待子线程完成  \n   ~~~\n  \n2. `detach` 将当前线程和新线程分离，使其独立运行。一旦被分离后就无法使用 `join` 方法等待线程结束。<u>**此时**线程的生命周期就由自己控制了，主线程和子线程可以并发执行，互相独立。</u>\n  \n   ~~~c++  \n   std::thread(threadFuntion);  \n   t.detach();  \n   ~~~\n  \n通过以上三个例子，我们可以看到错误发生是有一定规律的。首先在这些例子中我们获取了某些资源，如Heap上的内存、锁、线程。获取资源当然没有问题，但是当资源超出作用范围问题就发生了(内存泄露，死锁，进程终止)，在第一个问题中我们要时刻记得 delete、第二个需要 unlock，第三个需要 join，这显然是很繁琐的。\n  \nRAII 就是为了避免犯错和繁琐的手动释放。  \nC++ 和 Java，Python等的垃圾回收不同其析构函数是显式的，离开作用域自动销毁。  \n其他比如向 vector push一个资源，然后退出引用计数归零，但是不会立即删除，而是过段时间后调用一个 GC 程序将引用计数为零的对象删除。\n  \n但是如果对高性能计算有要求，如**时序**或**性能**就不能依赖 GC。\n  \n### RAII: 异常安全( exception-safe )\n  \nC++ 标准确保在异常发生时，也能调用 已创建对象的析构函数，因此 C++ 不需要 Java 那种 finally 语句确保执行。\n  \n### RAII 离不开  构造函数 和 析构函数\n  \n~~~c++\nstruct Pig\n{\n    std::string name;\n    int age;\n    \n    Pig():name(\"Kit\"),age(10)\n    {\n        \n    }\n    \n    Pig(string n, int a):name(n),age(a)\t\t// 拷贝构造函数\n    {\n        \n    }\n    \n    Pig(string n, int a)\t\t// 拷贝赋值函数\n    {\n        name = n;\n        age = a;\n    }\n}; \n\nint main()\n{\n    Pig pig0;\n    Pig pig1(\"Kiii\",2);\n}\n~~~\n  \n* 高效：使用初始化列表可以避免重复初始化，如果不使用，首先会先将数据成员空初始化，然后在构造函数内部进行赋值。  \n* 避免错误，因为不用初始化列表会先对成员进行无参初始化，而这时若类成员没有无参构造函数就会出错。  \n* 类成员为 const，因为 const 对象只能初始化一次，所以只能在初始化列表中进行。\n  \n> 要记住非初始化列表都是先进行无参初始化然后再在函数内进行一次赋值，即一次初始化，一次赋值。\n  \n#### 构造函数单个参数\n  \n~~~cpp\nstruct Pig\n{\n\tstring name;\n    int age;\n    \n    Pig(int age_):name(\"a Pig aged\"+to_string(age_)),age(age_)\n    {\n        \n    }\n}\n\nint main()\n{\n    Pig pig = 80;\n}\n~~~\n  \n这里 `= 80` 是隐式地调用了构造函数，如果想为了可读性避免这种隐式构造，可以使用 explicit。  \n~~~c++\nstruct Pig\n{\n\tstring name;\n    int age;\n    \n    explicit Pig(int age_):name(\"a Pig aged\"+to_string(age_)),age(age_)\n    {\n        \n    }\n}\n\nint main()\n{\n    // Pig pig = 80;\n    Pig pig(80);\n}\n~~~\n  \nexplicit 使其必须使用`(80)`这种格式显式调用构造函数。  \nexplicit 的作用就在于避免因为隐式调用而导致代码可读性的降低。\n  \n#### explicit 多参数\n  \n~~~c++\nstruct Pig\n{\n    string p_name;\n    int p_age;\n    \n    explicit Pig(string name, int age):p_name(name),p_age(age)\n    {\n        \n    }\n};\n\nint main()\n{\n    Pig pig = {\"Kit\",5};\t// Error\n    Pig pig2{\"Kit2\",7};\t\t// Right\n    Pig pig3(\"Kit3\",10);\t// Right\n}\n~~~\n  \nexplicit 可以用于多参数，并且在上面例子中，explicit 避免了 `{\"kit\",5}` 的隐式调用，并且接受了 `Pig pig2{\"Kit2\",7}` 的显式调用。\n  \n#### () 和 {} 调用的区别\n  \n1. `int(3.14f) ` 不会报错，但是 `int{3.14f}` 会报错，因为 {} 是非强制类型转换。  \n2. 假如 使用 `Pig pig2{\"jit2\",4.5}` 这就会出错了……\n  \nby the way，现在别使用 int() 了，太蠢了，而且不安全，比如 要是转换为指针可能会发生错误。应该使用 `static_cast<int>()` 进行。\n  \n### 编译器默认生成的构造函数：无参 ( POD 陷阱 )\n  \n当一个类没有定义任何构造函数，且类成员都有无参的构造函数，编译器会自动生成一个无参构造函数，会调用每个成员的无参构造函数。\n  \n**注意**这些类型**不会被初始化为0**。\n  \n1. int, float, double 等基础类型  \n2. `void*`, `Object*` 等指针类型  \n3. 完全有这些类型组成的类\n  \n* 这些类型称为 **POD( plain-of-data )**  \n  POD 的存在是出于兼容性和性能考虑，这些类型会将其所在内存位置的数据直接作为自己的初始值。\n  \n所以如果你打算使用编译器自动生成的初始化函数，最好对类成员用 `{}` 进行一个指定初始化，这样在 自动生成的构造函数中就会初始化为你指定的值。  \n~~~c++\nstruct Pig\n{\n    string p_name;\n    int weight{0};\t\t// 自动生成的构造函数会将其初始化为0\n};\n~~~\n  \n或者使用`=`也可以，但是要注意类对象其本身的构造函数是否有 explicit 修饰  \n~~~c++\nstruct Demo\n{\n    explicit Demo(string a, string b)\n    {\n        \n    }\n};\n\nstruct Pig\n{\n    string p_name;\n    int weight = 0;\n    Demo pd{\"a\",\"b\"};\t\t// 可以通过编译\n    // Demo pd = {\"a\",\"bb\"};\t// 这样就不行\n};\n~~~\n  \n>`int x{};  \n>void* p{};`  \n>  \n>和  \n>  \n>`int x{0};  \n>void* p{nullptr};`  \n>  \n>等价，都是**零初始化**\n  \n### 编译器默认生成的构造函数：C++11 初始化\n  \n在 C++11 中，如果一个类(和他的基类) 没有定义任何构造函数，这时编译器会自动生成一个**参数个数和成员一样的构造函数**。\n  \n会将 {} 内容，**按顺序赋值给对象的每一个成员**\n  \n不过这种只支持 {} 或者 = {}\n  \n~~~c++\nstruct Pig\n{\n    int a;\n    int b;\n};\n\nstruct Deo\n{\n    Pig pig;\n    int a;\n};\n\nint main() {\n    // Write C++ code here\n    std::cout << \"Hello world!\";\n    Pig pig{1,2};\n    std::cout << pig.a << std::endl;\t\t\t// 1\n    Deo deo{{3,2},1};\n    std::cout << deo.pig.a << std::endl;\t\t// 3\n    return 0;\n}\n~~~\n  \n当然这时候无参构造函数也是存在的。\n  \n和默认指定结合  \n~~~c++\nstruct Pig\n{\n    string p_name;\n    int p_weight{0};\n};\n\nint main()\n{\n    Pig pig{\"kit\"};\t\t// weight 未指定，使用 0\n}\n~~~\n  \n### 有自定义构造函数时仍想用默认构造函数：`=default`\n  \n一旦我们自定义了构造函数，编译器便**不会生成默认的无参构造函数**  \n但是如果我们仍然想使用，就可以用 `=default` 关键字。\n  \n~~~C++\nstruct Pig\n{\n    string pName;\n    int pWeight;\n    \n    Pig() = default;\n    \n    Pig(string name, int wei)\n        :pName(name),pWeight(wei)\n        {\n            \n        }\n}\n~~~\n  \n*but 初始化列表的那个构造函数好像不能 =default 出来*\n  \n### 编译器默认生成的构造函数：拷贝构造函数\n  \n`Pig(cosnt Pig& other)`  \n参数为 Pig 类型，调用如下\n  \n~~~c++\nint main()\n{\n    Pig pig{\"Kit\",90};\n    \n    Pig pig2 = pig;\n    // Pig pig2(pig);\t\t// 与上面的一样\n}\n~~~\n  \n即便我们自定义了构造函数，拷贝构造函数也不会删除。\n  \n### 舍弃拷贝构造函数：`=delete`\n  \n如果不想使用拷贝构造函数可以使用 `delete` 修饰  \n~~~C++\nstruct Pig\n{\n    string pName;\n    int pWeight{0};\n    \n    Pig()=default;\n    \n    Pig(string name, int wei):pName(name),pWeight(wei)\n    {}\n    \n    Pig(const Pig&) = delete;\t\t// 禁止拷贝构造\n    Pig& operatpor=(Pig const &) = delete;\t//  禁止拷贝赋值\n}\n~~~\n  \n`Pig pig2 = pig;` \n  \n这是**拷贝构造**  \n~~~C++ \nPig pig2;\t// 无参构造\npig2 = pig;\t// 拷贝赋值\n~~~\n  \n这是**拷贝赋值**\n  \n#### 为什么拷贝赋值函数返回值是引用\n  \n为了实现链式赋值，返回要是左值引用，而非临时对象的将亡值。\n  \n### 构造函数全家桶\n  \n#### 三五法则：一\n  \n<img src=\"imgs/C++RAII/35.png\">\n  \n1. 如果定义了析构函数，为了防止 doulefree 要么 delete 拷贝构造和拷贝赋值，要么自定义。  \n   也就是深拷贝和浅拷贝。  \n   浅拷贝会导致两个对象内的指针指向同一内存，所以我们要手动实现深拷贝。  \n   如果定义了析构函数很有可能是因为我们类内对象有些无法被默认的析构函数销毁，  \n   所以可能会有深拷贝和浅拷贝问题，如果只需要浅拷贝那就删除拷贝构造和拷贝赋值函数，C++会默认生成的。  \n2. 如果不实现拷贝赋值函数，编译器可能会以 析构+拷贝构造 的方式实现拷贝赋值的效果。  \n3. 与上面同理。\n  \n#### 拷贝和移动\n  \n有时候我们只需要一份 data，不需要复制，我们更希望把 对象 **移动**过去。  \n拷贝是 O(n)，移动是 O(1)  \n可以使用 std::move  \nv2 被移动到 v1 后原来的 v2 会被清空，所以一定要确保 v2 后续不会会再被使用。 \n  \n#### 移动进阶：swap\n  \n我们不仅可以使用move  \n也可以使用 `std::swap` 交换 v1 和 v2  \n可以利用 swap 实现双缓存技术。\n  \n#### 哪些情况会触发 move\n  \n* 会触发move  \n  * `return v2;`  作为返回值  \n  * `v1 = std::vector<int>(200)` 就地构造  \n  * `v1 = std::move(v2)` 显式move  \n* 拷贝  \n  * `return std::as_const(v2)`，显式拷贝   \n  * `v1 =v2` , 默认拷贝  \n* 下式不会 move 也不会 copy  \n  * `std::move(v2)`  \n  * `std::as_const(v2)`  \n  * 这两个函数只负责转换类型，不会发生实际的 copy 和 move。\n  \n### 移动构造函数：缺省实现\n  \n* 移动构造 ≈ 拷贝构造 + 解构他 + 他默认构造   (这里的他是移动的源对象)  \n* 移动赋值 ≈ 拷贝赋值 + 他结构 + 他默认构造\n  \n只要 我们不自己定义，编译器就会这样做  \n这也就是三五法则中 第4点, 为什么定义 **拷贝构造** 和 **拷贝赋值** 后最好定义 **移动构造** 和 **移动赋值**\n  \n## RAII 解决内存管理：`unique_ptr`\n  \nC++11 引用 `unique_ptr` 容器，其结构函数会调用 delete p。  \n~~~c++\nstruct C\n{\n    C(){printf(\"C\");}\n    ~C(){printf(\"~C\");}\n}\n\nint main()\n{\n    std::unique_ptr<C> p = std::make_unique<C>();\n    if(..)\n    {\n        return 1;\t// 自动释放 p\n    }\n    return 0; \t\t// 自动释放 p\n}\n~~~\n  \n而且将 C++98 的   \n~~~C++\ndelete p;\np = nullptr;\n~~~\n  \n封装为了一个操作：  \n`p = nullptr;` 等价于 `p.reset();`\n  \n#### `uniqur_ptr`: 禁止拷贝\n  \n为什么禁止拷贝，如果拷贝了这个指针，  \n而 `unique_ptr` 的析构函数使用了 delete，可能就会出现 double free 的问题。  \n所以，在我们写函数时，如果用 `unique_ptr` 作为参数就会报错。\n  \n##### 解决方案1：获取原始指针( C* )\n  \n* 第一种情况，我们不需要 夺走 资源的 **占有权**  \n  比如只是一个函数调用，**并不需要结果掌管对象生命周期的大权**。  \n  使用 `p.get()` 获取指针，然后进行操作。\n  \n  ~~~C++  \n   void func(C* cp)  \n   {\n       \n   }\n  \n  func(p.get());  \n  ~~~\n  \n* 第二种，我们需要夺走 资源的 **占有权**。  \n  ~~~c++  \n  std::vector<std::unique_ptr<C>> objectList;\n  \n  void func(std::unique_ptr<C> p)  \n  {  \n      objectList.push_back(std::move(p));  \n  }\n  \n  int main()  \n  {  \n      std::unique_ptr<C> p = std::make_unique<C>();  \n      printf(\"移交前:%p\\n\",p.get());\t\t// 不为null  \n      func(std::move(p));  \n      printf(\"移交后:%p\\n\",p.get());\t\t// 为null  \n      return 0;  \n  }  \n  ~~~\n  \n  因此我们要使用 move 接过掌管对象生命周期的大权。\n  \n#### 移交控制权后仍希望访问到 p 指向的对象\n  \n我们移交后，原来的指针就变 nullptr，这时无法访问。  \n##### 解决办法：提前获取指针\n  \n使用get函数提前获取原始指针，  \n不用担心周期问题，这个原始指针的所有权归move后的新`unique_ptr` 所有。  \n`C* raw_p = p.get();`\n  \n但是要时刻注意 move 后的 `unique_ptr` 是否被删除！\n  \n~~~c++\nint main()\n{\n    std::unique_ptr<C> p = std::make_unique<C>();\n\tC *raw_p = p.get();\n\tfunc(std::move(p));\n    \n    raw_p->do();\n    \n    objlist.clear();\n    \n    raw_p->do();\t// !!! Error 悬空指针\n}\n~~~\n  \n## `shared_ptr`\n  \n* `unique_ptr` 由于为了解决 double free 而**禁止拷贝**，导致使用起来很困难，容易犯错。  \n* `shared_ptr`，牺牲效率换取自由度，通过 **引用计数** 来解决 **重复释放** 的问题。\n  \n1. 当 `shared_ptr` 被初始化时，将计数器设为1；  \n2. 当  `shared_ptr` 被拷贝时， 计数器 +1；  \n3.  当一个  `shared_ptr`  被解构时，计数器 -1，直到计数器为 0，则自动销毁其所指向的对象。\n  \n* 我们可以使用 `p.use_count()` 获取当前的引用计数。\n  \n###  `shared_ptr` 和 循环引用\n  \n~~~cpp\nstruct C\n{\n    std:;shared_ptr<C> m_child;\n    std::shared_ptr<C> m_parent;\n};\n\nint main()\n{\n    auto parent = std::make_shared<C>();\n    auto child = std::make_shared<C>();\n    \n    parent->m_child = child;\n    child->m_parent = parent;\n    // 这里 parent 和 child 互相引用\n    \n    parent = nullptr;\t// 失败，child 的 m_parent 还在引用\n    child = nullptr;\t// 失败，parent 的 m_child 还在引用\n    \n    return 0;\n}\n~~~\n  \n即便 main 函数退出，这两块内存都无法释放。\n  \n## `weak_ptr` \n  \n### 循环引用：解决方案1\n  \n* 将逻辑上“不具有所属权” 的那一个 `shared_ptr`，改为 `weak_ptr` 即可。  \n  ~~~c++  \n  struct C  \n  {  \n      std:;shared_ptr<C> m_child;  \n      std::weak_ptr<C> m_parent;  \n  };\n  \n  int main()  \n  {  \n      auto parent = std::make_shared<C>();  \n      auto child = std::make_shared<C>();\n      \n      parent->m_child = child;  \n      child->m_parent = parent;  \n      // 这里 parent 和 child 互相引用\n      \n      parent = nullptr;\t// 释放，因为 child 指向的是其 **弱引用**  \n      child = nullptr;\t// 释放，因为指向 child 的 parent 已经释放了\n      \n      return 0;  \n  }  \n  ~~~\n\n  \n#### 不影响 shared_ptr 计数：弱引用 weak_ptr\n  \n* expired() 可以判断，weak_ptr 是否失效，如果 shared_ptr 已经释放了，该 weak_ptr 就失效了。  \n  `waek_p.expired()`\n  \n* lock()，如果有需求可以随时使用 lock 函数产生一个新的 shared_ptr。但不 lock 时 weak_ptr 不会影响计数。  \n  ~~~c++  \n  std::shared_ptr<C> p = std::make_shared<C>();  \n  std::weak_ptr<C> weak_p = p;  \n  weak_p.lock()->do_something();\t// 执行完毕后 lock 出来的 shared_ptr 就销毁了，不影响 shared_ptr 的计数，我理解为 lock 返回一个 shared_ptr 的将亡值，这行结束后自动解构  \n  ~~~\n  \n## 智能指针：作为类的成员变量\n  \n1. unique_ptr，**当该对象仅属于我**，比如父窗口下的子窗口  \n2. 原始指针，**当对象不属于我，但是他释放**<u>**前**</u>**我必然被释放。**  \n   有一定风险，比如子窗口中指向父窗口的指针。  \n3. shared_ptr：**当有多个对象共享时，或虽然该对象仅属于我，但是有 weak_ptr 的需要**  \n4. weak_ptr：**当该对象不属于我，且他释放**<u>**后**</u>**我仍可能不被释放。**比如：指向窗口上一次被点击的元素。  \n5. 初学者可多用 shard_ptr 和 weak_ptr 的组合，更加安全。\n  \n### 循环引用解决方案2：设置为原始指针\n  \n~~~c++\nstruct C\n{\n\tstd::shared_ptr<C> m_child;\n\tC* m_parent;\n}\n\nint main()\n{\n\tauto parent = std::make_shared<C>();\n\tauto child = std::make_shared<C>();\n\t\n\tparent->m_child = child;\n\tchild->m_parent = parent.get();\t\t// 这里 parent.get 得到的原始指针是归属于 shared_ptr parent 的\n\t\n\tparent = nullptr;\n\tchild = nullptr;\n\t\n\treturn 0;\n}\n~~~\n  \n还有更适合父窗口-子窗口的解决方案。  \n刚才提到原始指针的应用场景：当一个对象不属于我，但是他释放<u>前</u>我必须释放。  \n这里可以发现父窗口的释放必须导致子窗口的释放。\n  \n## 智能指针使用\n  \n### 成员都是安全类型：五大函数，一个也不用声明\n  \n* 如果类的所有成员都是 **安全** 类型，那么五大函数都无需声明，你的类型就是自动**安全的**。  \n* 最好的判断方式是：如果你不需要 **自定义的解构函数** 这个类就无需担心。  \n* 如果我们需要自定义 解构函数，往往意味着你的类成员中，包含不安全类型。  \n* 一般有两种情况：  \n  1. **类管理着资源**  \n  2. **类是数据结构**\n  \n#### 管理着资源(仅需要浅拷贝)：删除拷贝函数，统一用 shared_ptr 管理\n  \n* 因为资源，往往是不能被复制的。比如 一个 openGL 的 shader\n  \n* 如果允许拷贝(浅拷贝)，就相当于把 标记资源的 int 复制两遍，之后就会出现 double free 的问题。\n  \n#### 数据结构(需要深拷贝)：如果可以，定义拷贝和移动\n  \n* 我们设计的**数据结构**通常是支持深拷贝的，这需要我们自己去定义实现，如果实在无法实现那就删除。\n  \n### 函数如何避免拷贝\n  \n使用常引用：`Pig const & pig`\n  \n#### 如何避免不经意的隐式拷贝\n  \n我们可以将 拷贝构造函数声明为 explicit   \n这样隐式拷贝就会出错，让我们发现隐式拷贝的发生。\n  \n## 后续阅读\n  \n1. P-IMPL模式  \n2. 虚函数与纯虚函数  \n3. 拷贝如何作为虚函数  \n4. `std:unique_ptr::release()`  \n5. ` std:.enable_shared_from_this`  \n6. `dynamic_cast`  \n7. `std::dynamic_pointer_cast`  \n8. 运算符重载  \n9. 右值引用&&  \n10. `std::shared_ptr<void>`和 `std:any`  ","slug":"C++RAII","published":1,"updated":"2024-01-14T08:13:08.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppthz0005bkbw6e9pesi0","content":"<p><a href=\"https://medium.com/swlh/what-is-raii-e016d00269f9\">What is\r\nRAII?</a><br />\r\n<a href=\"https://www.youtube.com/watch?v=q6dVKMgeEkk\">Youtube\r\nVedio</a></p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"c-raiiresurce-acquisition-is-initialization\">C++ RAII(Resurce\r\nAcquisition Is Initialization)</h1>\r\n<h2 id=\"raii-用来做什么\">RAII 用来做什么?</h2>\r\n<h3 id=\"内存\">内存</h3>\r\n<p>当我们在 C++\r\n中分配内存时，比如开辟一个数组，<code>int *arr = new int[dynamicSize]</code>\r\n,那么我后续一定要记得去\r\n<code>delete[] arr</code>，否则就会发生<strong>内存泄漏</strong>。也就是管理内存都需要我们手动去进行。</p>\r\n<h3 id=\"锁\">锁</h3>\r\n<p>然后我们看看使用锁，假设我们想显式同步代码的某些部分。我创建一个\r\n<code>std::mutex</code>，然后调用\r\n<code>mutex.lock()</code>。如果忘记调用\r\n<code>mutex.unlock()</code>，或者在解锁前发生异常(导致<code>mutex.unlock()</code>)未被调用，当其他线程尝试获取锁时将死锁。</p>\r\n<h3 id=\"线程\">线程</h3>\r\n<p>如果我们想在另一个线程运行代码，然后我创建了一个线程。如果我们记得<code>jion</code>就没有问题，但是如果我们忘记了，并且线程超出了自己的作用域，<code>std::terminate</code>将被调用，程序会终止。</p>\r\n<h4 id=\"线程相关内容补充\">线程相关内容补充</h4>\r\n<p>在C++中，创建线程后，如果没有适当地处理线程的结束，可能会导致程序意外终止。</p>\r\n<p>当你创建一个新的线程并开始执行代码时，主线程和新线程是并行执行的。如果在主线程退出之前没有\r\njoin（或者使用 detach 分离线程），那么主线程结束时，程序会调用\r\n<code>std::terminate</code> 来终止所有尚未结束的线程。</p>\r\n<p>这种情况的发生通常是由于在主线程退出之前，新线程尚未完成，而没有等待新线程结束（或者分离）而导致的。因此，在使用线程时，确保在适当的时机对线程进行\r\njoin 或 detach 是非常重要的。</p>\r\n<h5 id=\"关于-join-和-detach\">关于 join 和 detach</h5>\r\n<p>join 和 detach 是 c++ 两种管理线程的方法。</p>\r\n<ol type=\"1\">\r\n<li><p><code>join</code>\r\n通过阻塞当前线程等待被调用的线程完成，确保主线程在子线程执行完毕后在继续执行，从而避免子线程在主线程退出去终止，或者超出作用域导致\r\n<code>std::terminate</code> 导致整个进程结束。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t</span><span class=\"hljs-params\">(threadFunction)</span></span>;<br><br>t.<span class=\"hljs-built_in\">jion</span>();\t\t<span class=\"hljs-comment\">// 阻塞该主线程，等待子线程完成  </span><br></code></pre></td></tr></table></figure></li>\r\n<li><p><code>detach</code>\r\n将当前线程和新线程分离，使其独立运行。一旦被分离后就无法使用\r\n<code>join</code>\r\n方法等待线程结束。<u><strong>此时</strong>线程的生命周期就由自己控制了，主线程和子线程可以并发执行，互相独立。</u></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">std::<span class=\"hljs-built_in\">thread</span>(threadFuntion);  <br>t.<span class=\"hljs-built_in\">detach</span>();  <br></code></pre></td></tr></table></figure></li>\r\n</ol>\r\n<p>通过以上三个例子，我们可以看到错误发生是有一定规律的。首先在这些例子中我们获取了某些资源，如Heap上的内存、锁、线程。获取资源当然没有问题，但是当资源超出作用范围问题就发生了(内存泄露，死锁，进程终止)，在第一个问题中我们要时刻记得\r\ndelete、第二个需要 unlock，第三个需要 join，这显然是很繁琐的。</p>\r\n<p>RAII 就是为了避免犯错和繁琐的手动释放。<br />\r\nC++ 和\r\nJava，Python等的垃圾回收不同其析构函数是显式的，离开作用域自动销毁。<br />\r\n其他比如向 vector\r\npush一个资源，然后退出引用计数归零，但是不会立即删除，而是过段时间后调用一个\r\nGC 程序将引用计数为零的对象删除。</p>\r\n<p>但是如果对高性能计算有要求，如<strong>时序</strong>或<strong>性能</strong>就不能依赖\r\nGC。</p>\r\n<h3 id=\"raii-异常安全-exception-safe\">RAII: 异常安全( exception-safe\r\n)</h3>\r\n<p>C++ 标准确保在异常发生时，也能调用 已创建对象的析构函数，因此 C++\r\n不需要 Java 那种 finally 语句确保执行。</p>\r\n<h3 id=\"raii-离不开-构造函数-和-析构函数\">RAII 离不开 构造函数 和\r\n析构函数</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    std::string name;<br>    <span class=\"hljs-type\">int</span> age;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>():<span class=\"hljs-built_in\">name</span>(<span class=\"hljs-string\">&quot;Kit&quot;</span>),<span class=\"hljs-built_in\">age</span>(<span class=\"hljs-number\">10</span>)<br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(string n, <span class=\"hljs-type\">int</span> a):<span class=\"hljs-built_in\">name</span>(n),<span class=\"hljs-built_in\">age</span>(a)\t\t<span class=\"hljs-comment\">// 拷贝构造函数</span><br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(string n, <span class=\"hljs-type\">int</span> a)\t\t<span class=\"hljs-comment\">// 拷贝赋值函数</span><br>    &#123;<br>        name = n;<br>        age = a;<br>    &#125;<br>&#125;; <br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Pig pig0;<br>    <span class=\"hljs-function\">Pig <span class=\"hljs-title\">pig1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Kiii&quot;</span>,<span class=\"hljs-number\">2</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>高效：使用初始化列表可以避免重复初始化，如果不使用，首先会先将数据成员空初始化，然后在构造函数内部进行赋值。<br />\r\n</li>\r\n<li>避免错误，因为不用初始化列表会先对成员进行无参初始化，而这时若类成员没有无参构造函数就会出错。<br />\r\n</li>\r\n<li>类成员为 const，因为 const\r\n对象只能初始化一次，所以只能在初始化列表中进行。</li>\r\n</ul>\r\n<blockquote>\r\n<p>要记住非初始化列表都是先进行无参初始化然后再在函数内进行一次赋值，即一次初始化，一次赋值。</p>\r\n</blockquote>\r\n<h4 id=\"构造函数单个参数\">构造函数单个参数</h4>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>\tstring name;<br>    <span class=\"hljs-type\">int</span> age;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(<span class=\"hljs-type\">int</span> age_):<span class=\"hljs-built_in\">name</span>(<span class=\"hljs-string\">&quot;a Pig aged&quot;</span>+<span class=\"hljs-built_in\">to_string</span>(age_)),<span class=\"hljs-built_in\">age</span>(age_)<br>    &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Pig pig = <span class=\"hljs-number\">80</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>这里 <code>= 80</code>\r\n是隐式地调用了构造函数，如果想为了可读性避免这种隐式构造，可以使用\r\nexplicit。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>\tstring name;<br>    <span class=\"hljs-type\">int</span> age;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Pig</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> age_)</span>:name(<span class=\"hljs-string\">&quot;a Pig aged&quot;</span>+to_string(age_)),age(age_)</span><br><span class=\"hljs-function\">    &#123;</span><br>        <br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// Pig pig = 80;</span><br>    <span class=\"hljs-function\">Pig <span class=\"hljs-title\">pig</span><span class=\"hljs-params\">(<span class=\"hljs-number\">80</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>explicit\r\n使其必须使用<code>(80)</code>这种格式显式调用构造函数。<br />\r\nexplicit 的作用就在于避免因为隐式调用而导致代码可读性的降低。</p>\r\n<h4 id=\"explicit-多参数\">explicit 多参数</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string p_name;<br>    <span class=\"hljs-type\">int</span> p_age;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Pig</span><span class=\"hljs-params\">(string name, <span class=\"hljs-type\">int</span> age)</span>:p_name(name),p_age(age)</span><br><span class=\"hljs-function\">    &#123;</span><br>        <br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Pig pig = &#123;<span class=\"hljs-string\">&quot;Kit&quot;</span>,<span class=\"hljs-number\">5</span>&#125;;\t<span class=\"hljs-comment\">// Error</span><br>    Pig pig2&#123;<span class=\"hljs-string\">&quot;Kit2&quot;</span>,<span class=\"hljs-number\">7</span>&#125;;\t\t<span class=\"hljs-comment\">// Right</span><br>    <span class=\"hljs-function\">Pig <span class=\"hljs-title\">pig3</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Kit3&quot;</span>,<span class=\"hljs-number\">10</span>)</span></span>;\t<span class=\"hljs-comment\">// Right</span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>explicit 可以用于多参数，并且在上面例子中，explicit 避免了\r\n<code>&#123;\"kit\",5&#125;</code> 的隐式调用，并且接受了\r\n<code>Pig pig2&#123;\"Kit2\",7&#125;</code> 的显式调用。</p>\r\n<h4 id=\"和-调用的区别\">() 和 {} 调用的区别</h4>\r\n<ol type=\"1\">\r\n<li><code>int(3.14f)</code> 不会报错，但是 <code>int&#123;3.14f&#125;</code>\r\n会报错，因为 {} 是非强制类型转换。<br />\r\n</li>\r\n<li>假如 使用 <code>Pig pig2&#123;\"jit2\",4.5&#125;</code> 这就会出错了……</li>\r\n</ol>\r\n<p>by the way，现在别使用 int() 了，太蠢了，而且不安全，比如\r\n要是转换为指针可能会发生错误。应该使用\r\n<code>static_cast&lt;int&gt;()</code> 进行。</p>\r\n<h3\r\nid=\"编译器默认生成的构造函数无参-pod-陷阱\">编译器默认生成的构造函数：无参\r\n( POD 陷阱 )</h3>\r\n<p>当一个类没有定义任何构造函数，且类成员都有无参的构造函数，编译器会自动生成一个无参构造函数，会调用每个成员的无参构造函数。</p>\r\n<p><strong>注意</strong>这些类型<strong>不会被初始化为0</strong>。</p>\r\n<ol type=\"1\">\r\n<li>int, float, double 等基础类型<br />\r\n</li>\r\n<li><code>void*</code>, <code>Object*</code> 等指针类型<br />\r\n</li>\r\n<li>完全有这些类型组成的类</li>\r\n</ol>\r\n<ul>\r\n<li>这些类型称为 <strong>POD( plain-of-data )</strong><br />\r\nPOD\r\n的存在是出于兼容性和性能考虑，这些类型会将其所在内存位置的数据直接作为自己的初始值。</li>\r\n</ul>\r\n<p>所以如果你打算使用编译器自动生成的初始化函数，最好对类成员用\r\n<code>&#123;&#125;</code> 进行一个指定初始化，这样在\r\n自动生成的构造函数中就会初始化为你指定的值。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string p_name;<br>    <span class=\"hljs-type\">int</span> weight&#123;<span class=\"hljs-number\">0</span>&#125;;\t\t<span class=\"hljs-comment\">// 自动生成的构造函数会将其初始化为0</span><br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<p>或者使用<code>=</code>也可以，但是要注意类对象其本身的构造函数是否有\r\nexplicit 修饰<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Demo</span><br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Demo</span><span class=\"hljs-params\">(string a, string b)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string p_name;<br>    <span class=\"hljs-type\">int</span> weight = <span class=\"hljs-number\">0</span>;<br>    Demo pd&#123;<span class=\"hljs-string\">&quot;a&quot;</span>,<span class=\"hljs-string\">&quot;b&quot;</span>&#125;;\t\t<span class=\"hljs-comment\">// 可以通过编译</span><br>    <span class=\"hljs-comment\">// Demo pd = &#123;&quot;a&quot;,&quot;bb&quot;&#125;;\t// 这样就不行</span><br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<blockquote>\r\n<p><code>int x&#123;&#125;;   void* p&#123;&#125;;</code></p>\r\n<p>和</p>\r\n<p><code>int x&#123;0&#125;;   void* p&#123;nullptr&#125;;</code></p>\r\n<p>等价，都是<strong>零初始化</strong></p>\r\n</blockquote>\r\n<h3\r\nid=\"编译器默认生成的构造函数c11-初始化\">编译器默认生成的构造函数：C++11\r\n初始化</h3>\r\n<p>在 C++11 中，如果一个类(和他的基类)\r\n没有定义任何构造函数，这时编译器会自动生成一个<strong>参数个数和成员一样的构造函数</strong>。</p>\r\n<p>会将 {} 内容，<strong>按顺序赋值给对象的每一个成员</strong></p>\r\n<p>不过这种只支持 {} 或者 = {}</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> a;<br>    <span class=\"hljs-type\">int</span> b;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Deo</span><br>&#123;<br>    Pig pig;<br>    <span class=\"hljs-type\">int</span> a;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// Write C++ code here</span><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hello world!&quot;</span>;<br>    Pig pig&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>&#125;;<br>    std::cout &lt;&lt; pig.a &lt;&lt; std::endl;\t\t\t<span class=\"hljs-comment\">// 1</span><br>    Deo deo&#123;&#123;<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>&#125;,<span class=\"hljs-number\">1</span>&#125;;<br>    std::cout &lt;&lt; deo.pig.a &lt;&lt; std::endl;\t\t<span class=\"hljs-comment\">// 3</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>当然这时候无参构造函数也是存在的。</p>\r\n<p>和默认指定结合<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string p_name;<br>    <span class=\"hljs-type\">int</span> p_weight&#123;<span class=\"hljs-number\">0</span>&#125;;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Pig pig&#123;<span class=\"hljs-string\">&quot;kit&quot;</span>&#125;;\t\t<span class=\"hljs-comment\">// weight 未指定，使用 0</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<h3\r\nid=\"有自定义构造函数时仍想用默认构造函数default\">有自定义构造函数时仍想用默认构造函数：<code>=default</code></h3>\r\n<p>一旦我们自定义了构造函数，编译器便<strong>不会生成默认的无参构造函数</strong><br />\r\n但是如果我们仍然想使用，就可以用 <code>=default</code> 关键字。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string pName;<br>    <span class=\"hljs-type\">int</span> pWeight;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>() = <span class=\"hljs-keyword\">default</span>;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(string name, <span class=\"hljs-type\">int</span> wei)<br>        :<span class=\"hljs-built_in\">pName</span>(name),<span class=\"hljs-built_in\">pWeight</span>(wei)<br>        &#123;<br>            <br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p><em>but 初始化列表的那个构造函数好像不能 =default 出来</em></p>\r\n<h3\r\nid=\"编译器默认生成的构造函数拷贝构造函数\">编译器默认生成的构造函数：拷贝构造函数</h3>\r\n<p><code>Pig(cosnt Pig&amp; other)</code><br />\r\n参数为 Pig 类型，调用如下</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Pig pig&#123;<span class=\"hljs-string\">&quot;Kit&quot;</span>,<span class=\"hljs-number\">90</span>&#125;;<br>    <br>    Pig pig2 = pig;<br>    <span class=\"hljs-comment\">// Pig pig2(pig);\t\t// 与上面的一样</span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>即便我们自定义了构造函数，拷贝构造函数也不会删除。</p>\r\n<h3\r\nid=\"舍弃拷贝构造函数delete\">舍弃拷贝构造函数：<code>=delete</code></h3>\r\n<p>如果不想使用拷贝构造函数可以使用 <code>delete</code> 修饰<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string pName;<br>    <span class=\"hljs-type\">int</span> pWeight&#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>()=<span class=\"hljs-keyword\">default</span>;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(string name, <span class=\"hljs-type\">int</span> wei):<span class=\"hljs-built_in\">pName</span>(name),<span class=\"hljs-built_in\">pWeight</span>(wei)<br>    &#123;&#125;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(<span class=\"hljs-type\">const</span> Pig&amp;) = <span class=\"hljs-keyword\">delete</span>;\t\t<span class=\"hljs-comment\">// 禁止拷贝构造</span><br>    Pig&amp; operatpor=(Pig <span class=\"hljs-type\">const</span> &amp;) = <span class=\"hljs-keyword\">delete</span>;\t<span class=\"hljs-comment\">//  禁止拷贝赋值</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p><code>Pig pig2 = pig;</code></p>\r\n<p>这是<strong>拷贝构造</strong><br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">Pig pig2;\t<span class=\"hljs-comment\">// 无参构造</span><br>pig2 = pig;\t<span class=\"hljs-comment\">// 拷贝赋值</span><br></code></pre></td></tr></table></figure></p>\r\n<p>这是<strong>拷贝赋值</strong></p>\r\n<h4\r\nid=\"为什么拷贝赋值函数返回值是引用\">为什么拷贝赋值函数返回值是引用</h4>\r\n<p>为了实现链式赋值，返回要是左值引用，而非临时对象的将亡值。</p>\r\n<h3 id=\"构造函数全家桶\">构造函数全家桶</h3>\r\n<h4 id=\"三五法则一\">三五法则：一</h4>\r\n<p><img src=\"imgs/C++RAII/35.png\"></p>\r\n<ol type=\"1\">\r\n<li>如果定义了析构函数，为了防止 doulefree 要么 delete\r\n拷贝构造和拷贝赋值，要么自定义。<br />\r\n也就是深拷贝和浅拷贝。<br />\r\n浅拷贝会导致两个对象内的指针指向同一内存，所以我们要手动实现深拷贝。<br />\r\n如果定义了析构函数很有可能是因为我们类内对象有些无法被默认的析构函数销毁，<br />\r\n所以可能会有深拷贝和浅拷贝问题，如果只需要浅拷贝那就删除拷贝构造和拷贝赋值函数，C++会默认生成的。<br />\r\n</li>\r\n<li>如果不实现拷贝赋值函数，编译器可能会以 析构+拷贝构造\r\n的方式实现拷贝赋值的效果。<br />\r\n</li>\r\n<li>与上面同理。</li>\r\n</ol>\r\n<h4 id=\"拷贝和移动\">拷贝和移动</h4>\r\n<p>有时候我们只需要一份 data，不需要复制，我们更希望把 对象\r\n<strong>移动</strong>过去。<br />\r\n拷贝是 O(n)，移动是 O(1)<br />\r\n可以使用 std::move<br />\r\nv2 被移动到 v1 后原来的 v2 会被清空，所以一定要确保 v2\r\n后续不会会再被使用。</p>\r\n<h4 id=\"移动进阶swap\">移动进阶：swap</h4>\r\n<p>我们不仅可以使用move<br />\r\n也可以使用 <code>std::swap</code> 交换 v1 和 v2<br />\r\n可以利用 swap 实现双缓存技术。</p>\r\n<h4 id=\"哪些情况会触发-move\">哪些情况会触发 move</h4>\r\n<ul>\r\n<li>会触发move\r\n<ul>\r\n<li><code>return v2;</code> 作为返回值<br />\r\n</li>\r\n<li><code>v1 = std::vector&lt;int&gt;(200)</code> 就地构造<br />\r\n</li>\r\n<li><code>v1 = std::move(v2)</code> 显式move<br />\r\n</li>\r\n</ul></li>\r\n<li>拷贝\r\n<ul>\r\n<li><code>return std::as_const(v2)</code>，显式拷贝<br />\r\n</li>\r\n<li><code>v1 =v2</code> , 默认拷贝<br />\r\n</li>\r\n</ul></li>\r\n<li>下式不会 move 也不会 copy\r\n<ul>\r\n<li><code>std::move(v2)</code><br />\r\n</li>\r\n<li><code>std::as_const(v2)</code><br />\r\n</li>\r\n<li>这两个函数只负责转换类型，不会发生实际的 copy 和 move。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"移动构造函数缺省实现\">移动构造函数：缺省实现</h3>\r\n<ul>\r\n<li>移动构造 ≈ 拷贝构造 + 解构他 + 他默认构造\r\n(这里的他是移动的源对象)<br />\r\n</li>\r\n<li>移动赋值 ≈ 拷贝赋值 + 他结构 + 他默认构造</li>\r\n</ul>\r\n<p>只要 我们不自己定义，编译器就会这样做<br />\r\n这也就是三五法则中 第4点, 为什么定义 <strong>拷贝构造</strong> 和\r\n<strong>拷贝赋值</strong> 后最好定义 <strong>移动构造</strong> 和\r\n<strong>移动赋值</strong></p>\r\n<h2 id=\"raii-解决内存管理unique_ptr\">RAII\r\n解决内存管理：<code>unique_ptr</code></h2>\r\n<p>C++11 引用 <code>unique_ptr</code> 容器，其结构函数会调用 delete\r\np。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">C</span><br>&#123;<br>    <span class=\"hljs-built_in\">C</span>()&#123;<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;C&quot;</span>);&#125;<br>    ~<span class=\"hljs-built_in\">C</span>()&#123;<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;~C&quot;</span>);&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::unique_ptr&lt;C&gt; p = std::<span class=\"hljs-built_in\">make_unique</span>&lt;C&gt;();<br>    <span class=\"hljs-keyword\">if</span>(..)<br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\t<span class=\"hljs-comment\">// 自动释放 p</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; \t\t<span class=\"hljs-comment\">// 自动释放 p</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>而且将 C++98 的<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">delete</span> p;<br>p = <span class=\"hljs-literal\">nullptr</span>;<br></code></pre></td></tr></table></figure></p>\r\n<p>封装为了一个操作：<br />\r\n<code>p = nullptr;</code> 等价于 <code>p.reset();</code></p>\r\n<h4 id=\"uniqur_ptr-禁止拷贝\"><code>uniqur_ptr</code>: 禁止拷贝</h4>\r\n<p>为什么禁止拷贝，如果拷贝了这个指针，<br />\r\n而 <code>unique_ptr</code> 的析构函数使用了 delete，可能就会出现 double\r\nfree 的问题。<br />\r\n所以，在我们写函数时，如果用 <code>unique_ptr</code>\r\n作为参数就会报错。</p>\r\n<h5 id=\"解决方案1获取原始指针-c\">解决方案1：获取原始指针( C* )</h5>\r\n<ul>\r\n<li><p>第一种情况，我们不需要 夺走 资源的 <strong>占有权</strong><br />\r\n比如只是一个函数调用，<strong>并不需要结果掌管对象生命周期的大权</strong>。<br />\r\n使用 <code>p.get()</code> 获取指针，然后进行操作。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(C* cp)</span>  </span><br><span class=\"hljs-function\"> </span>&#123;<br>     <br> &#125;<br><br><span class=\"hljs-built_in\">func</span>(p.<span class=\"hljs-built_in\">get</span>());  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>第二种，我们需要夺走 资源的 <strong>占有权</strong>。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">std::vector&lt;std::unique_ptr&lt;C&gt;&gt; objectList;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(std::unique_ptr&lt;C&gt; p)</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    objectList.<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">move</span>(p));  <br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    std::unique_ptr&lt;C&gt; p = std::<span class=\"hljs-built_in\">make_unique</span>&lt;C&gt;();  <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;移交前:%p\\n&quot;</span>,p.<span class=\"hljs-built_in\">get</span>());\t\t<span class=\"hljs-comment\">// 不为null  </span><br>    <span class=\"hljs-built_in\">func</span>(std::<span class=\"hljs-built_in\">move</span>(p));  <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;移交后:%p\\n&quot;</span>,p.<span class=\"hljs-built_in\">get</span>());\t\t<span class=\"hljs-comment\">// 为null  </span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure></p>\r\n<p>因此我们要使用 move 接过掌管对象生命周期的大权。</p></li>\r\n</ul>\r\n<h4 id=\"移交控制权后仍希望访问到-p-指向的对象\">移交控制权后仍希望访问到\r\np 指向的对象</h4>\r\n<p>我们移交后，原来的指针就变 nullptr，这时无法访问。<br />\r\n##### 解决办法：提前获取指针</p>\r\n<p>使用get函数提前获取原始指针，<br />\r\n不用担心周期问题，这个原始指针的所有权归move后的新<code>unique_ptr</code>\r\n所有。<br />\r\n<code>C* raw_p = p.get();</code></p>\r\n<p>但是要时刻注意 move 后的 <code>unique_ptr</code> 是否被删除！</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::unique_ptr&lt;C&gt; p = std::<span class=\"hljs-built_in\">make_unique</span>&lt;C&gt;();<br>\tC *raw_p = p.<span class=\"hljs-built_in\">get</span>();<br>\t<span class=\"hljs-built_in\">func</span>(std::<span class=\"hljs-built_in\">move</span>(p));<br>    <br>    raw_p-&gt;<span class=\"hljs-built_in\">do</span>();<br>    <br>    objlist.<span class=\"hljs-built_in\">clear</span>();<br>    <br>    raw_p-&gt;<span class=\"hljs-built_in\">do</span>();\t<span class=\"hljs-comment\">// !!! Error 悬空指针</span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"shared_ptr\"><code>shared_ptr</code></h2>\r\n<ul>\r\n<li><code>unique_ptr</code> 由于为了解决 double free\r\n而<strong>禁止拷贝</strong>，导致使用起来很困难，容易犯错。<br />\r\n</li>\r\n<li><code>shared_ptr</code>，牺牲效率换取自由度，通过\r\n<strong>引用计数</strong> 来解决 <strong>重复释放</strong> 的问题。</li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>当 <code>shared_ptr</code> 被初始化时，将计数器设为1；<br />\r\n</li>\r\n<li>当 <code>shared_ptr</code> 被拷贝时， 计数器 +1；<br />\r\n</li>\r\n<li>当一个 <code>shared_ptr</code> 被解构时，计数器 -1，直到计数器为\r\n0，则自动销毁其所指向的对象。</li>\r\n</ol>\r\n<ul>\r\n<li>我们可以使用 <code>p.use_count()</code> 获取当前的引用计数。</li>\r\n</ul>\r\n<h3 id=\"shared_ptr-和-循环引用\"><code>shared_ptr</code> 和 循环引用</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">C</span><br>&#123;<br>    std:;shared_ptr&lt;C&gt; m_child;<br>    std::shared_ptr&lt;C&gt; m_parent;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">auto</span> parent = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();<br>    <span class=\"hljs-keyword\">auto</span> child = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();<br>    <br>    parent-&gt;m_child = child;<br>    child-&gt;m_parent = parent;<br>    <span class=\"hljs-comment\">// 这里 parent 和 child 互相引用</span><br>    <br>    parent = <span class=\"hljs-literal\">nullptr</span>;\t<span class=\"hljs-comment\">// 失败，child 的 m_parent 还在引用</span><br>    child = <span class=\"hljs-literal\">nullptr</span>;\t<span class=\"hljs-comment\">// 失败，parent 的 m_child 还在引用</span><br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>即便 main 函数退出，这两块内存都无法释放。</p>\r\n<h2 id=\"weak_ptr\"><code>weak_ptr</code></h2>\r\n<h3 id=\"循环引用解决方案1\">循环引用：解决方案1</h3>\r\n<ul>\r\n<li>将逻辑上“不具有所属权” 的那一个 <code>shared_ptr</code>，改为\r\n<code>weak_ptr</code> 即可。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">C</span>  <br>&#123;  <br>    std:;shared_ptr&lt;C&gt; m_child;  <br>    std::weak_ptr&lt;C&gt; m_parent;  <br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    <span class=\"hljs-keyword\">auto</span> parent = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();  <br>    <span class=\"hljs-keyword\">auto</span> child = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();<br>    <br>    parent-&gt;m_child = child;  <br>    child-&gt;m_parent = parent;  <br>    <span class=\"hljs-comment\">// 这里 parent 和 child 互相引用</span><br>    <br>    parent = <span class=\"hljs-literal\">nullptr</span>;\t<span class=\"hljs-comment\">// 释放，因为 child 指向的是其 **弱引用**  </span><br>    child = <span class=\"hljs-literal\">nullptr</span>;\t<span class=\"hljs-comment\">// 释放，因为指向 child 的 parent 已经释放了</span><br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h4 id=\"不影响-shared_ptr-计数弱引用-weak_ptr\">不影响 shared_ptr\r\n计数：弱引用 weak_ptr</h4>\r\n<ul>\r\n<li><p>expired() 可以判断，weak_ptr 是否失效，如果 shared_ptr\r\n已经释放了，该 weak_ptr 就失效了。<br />\r\n<code>waek_p.expired()</code></p></li>\r\n<li><p>lock()，如果有需求可以随时使用 lock 函数产生一个新的\r\nshared_ptr。但不 lock 时 weak_ptr 不会影响计数。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">std::shared_ptr&lt;C&gt; p = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();  <br>std::weak_ptr&lt;C&gt; weak_p = p;  <br>weak_p.<span class=\"hljs-built_in\">lock</span>()-&gt;<span class=\"hljs-built_in\">do_something</span>();\t<span class=\"hljs-comment\">// 执行完毕后 lock 出来的 shared_ptr 就销毁了，不影响 shared_ptr 的计数，我理解为 lock 返回一个 shared_ptr 的将亡值，这行结束后自动解构  </span><br></code></pre></td></tr></table></figure></p></li>\r\n</ul>\r\n<h2 id=\"智能指针作为类的成员变量\">智能指针：作为类的成员变量</h2>\r\n<ol type=\"1\">\r\n<li>unique_ptr，<strong>当该对象仅属于我</strong>，比如父窗口下的子窗口<br />\r\n</li>\r\n<li>原始指针，<strong>当对象不属于我，但是他释放</strong><u><strong>前</strong></u><strong>我必然被释放。</strong><br />\r\n有一定风险，比如子窗口中指向父窗口的指针。<br />\r\n</li>\r\n<li>shared_ptr：<strong>当有多个对象共享时，或虽然该对象仅属于我，但是有\r\nweak_ptr 的需要</strong><br />\r\n</li>\r\n<li>weak_ptr：<strong>当该对象不属于我，且他释放</strong><u><strong>后</strong></u><strong>我仍可能不被释放。</strong>比如：指向窗口上一次被点击的元素。<br />\r\n</li>\r\n<li>初学者可多用 shard_ptr 和 weak_ptr 的组合，更加安全。</li>\r\n</ol>\r\n<h3\r\nid=\"循环引用解决方案2设置为原始指针\">循环引用解决方案2：设置为原始指针</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">C</span><br>&#123;<br>\tstd::shared_ptr&lt;C&gt; m_child;<br>\tC* m_parent;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">auto</span> parent = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();<br>\t<span class=\"hljs-keyword\">auto</span> child = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();<br>\t<br>\tparent-&gt;m_child = child;<br>\tchild-&gt;m_parent = parent.<span class=\"hljs-built_in\">get</span>();\t\t<span class=\"hljs-comment\">// 这里 parent.get 得到的原始指针是归属于 shared_ptr parent 的</span><br>\t<br>\tparent = <span class=\"hljs-literal\">nullptr</span>;<br>\tchild = <span class=\"hljs-literal\">nullptr</span>;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>还有更适合父窗口-子窗口的解决方案。<br />\r\n刚才提到原始指针的应用场景：当一个对象不属于我，但是他释放<u>前</u>我必须释放。<br />\r\n这里可以发现父窗口的释放必须导致子窗口的释放。</p>\r\n<h2 id=\"智能指针使用\">智能指针使用</h2>\r\n<h3\r\nid=\"成员都是安全类型五大函数一个也不用声明\">成员都是安全类型：五大函数，一个也不用声明</h3>\r\n<ul>\r\n<li>如果类的所有成员都是 <strong>安全</strong>\r\n类型，那么五大函数都无需声明，你的类型就是自动<strong>安全的</strong>。<br />\r\n</li>\r\n<li>最好的判断方式是：如果你不需要 <strong>自定义的解构函数</strong>\r\n这个类就无需担心。<br />\r\n</li>\r\n<li>如果我们需要自定义\r\n解构函数，往往意味着你的类成员中，包含不安全类型。<br />\r\n</li>\r\n<li>一般有两种情况：\r\n<ol type=\"1\">\r\n<li><strong>类管理着资源</strong><br />\r\n</li>\r\n<li><strong>类是数据结构</strong></li>\r\n</ol></li>\r\n</ul>\r\n<h4\r\nid=\"管理着资源仅需要浅拷贝删除拷贝函数统一用-shared_ptr-管理\">管理着资源(仅需要浅拷贝)：删除拷贝函数，统一用\r\nshared_ptr 管理</h4>\r\n<ul>\r\n<li><p>因为资源，往往是不能被复制的。比如 一个 openGL 的 shader</p></li>\r\n<li><p>如果允许拷贝(浅拷贝)，就相当于把 标记资源的 int\r\n复制两遍，之后就会出现 double free 的问题。</p></li>\r\n</ul>\r\n<h4\r\nid=\"数据结构需要深拷贝如果可以定义拷贝和移动\">数据结构(需要深拷贝)：如果可以，定义拷贝和移动</h4>\r\n<ul>\r\n<li>我们设计的<strong>数据结构</strong>通常是支持深拷贝的，这需要我们自己去定义实现，如果实在无法实现那就删除。</li>\r\n</ul>\r\n<h3 id=\"函数如何避免拷贝\">函数如何避免拷贝</h3>\r\n<p>使用常引用：<code>Pig const &amp; pig</code></p>\r\n<h4 id=\"如何避免不经意的隐式拷贝\">如何避免不经意的隐式拷贝</h4>\r\n<p>我们可以将 拷贝构造函数声明为 explicit<br />\r\n这样隐式拷贝就会出错，让我们发现隐式拷贝的发生。</p>\r\n<h2 id=\"后续阅读\">后续阅读</h2>\r\n<ol type=\"1\">\r\n<li>P-IMPL模式<br />\r\n</li>\r\n<li>虚函数与纯虚函数<br />\r\n</li>\r\n<li>拷贝如何作为虚函数<br />\r\n</li>\r\n<li><code>std:unique_ptr::release()</code><br />\r\n</li>\r\n<li><code>std:.enable_shared_from_this</code><br />\r\n</li>\r\n<li><code>dynamic_cast</code><br />\r\n</li>\r\n<li><code>std::dynamic_pointer_cast</code><br />\r\n</li>\r\n<li>运算符重载<br />\r\n</li>\r\n<li>右值引用&amp;&amp;<br />\r\n</li>\r\n<li><code>std::shared_ptr&lt;void&gt;</code>和 <code>std:any</code></li>\r\n</ol>\r\n","site":{"data":{}},"excerpt":"<p><a href=\"https://medium.com/swlh/what-is-raii-e016d00269f9\">What is\r\nRAII?</a><br />\r\n<a href=\"https://www.youtube.com/watch?v=q6dVKMgeEkk\">Youtube\r\nVedio</a></p>","more":"<h1 id=\"c-raiiresurce-acquisition-is-initialization\">C++ RAII(Resurce\r\nAcquisition Is Initialization)</h1>\r\n<h2 id=\"raii-用来做什么\">RAII 用来做什么?</h2>\r\n<h3 id=\"内存\">内存</h3>\r\n<p>当我们在 C++\r\n中分配内存时，比如开辟一个数组，<code>int *arr = new int[dynamicSize]</code>\r\n,那么我后续一定要记得去\r\n<code>delete[] arr</code>，否则就会发生<strong>内存泄漏</strong>。也就是管理内存都需要我们手动去进行。</p>\r\n<h3 id=\"锁\">锁</h3>\r\n<p>然后我们看看使用锁，假设我们想显式同步代码的某些部分。我创建一个\r\n<code>std::mutex</code>，然后调用\r\n<code>mutex.lock()</code>。如果忘记调用\r\n<code>mutex.unlock()</code>，或者在解锁前发生异常(导致<code>mutex.unlock()</code>)未被调用，当其他线程尝试获取锁时将死锁。</p>\r\n<h3 id=\"线程\">线程</h3>\r\n<p>如果我们想在另一个线程运行代码，然后我创建了一个线程。如果我们记得<code>jion</code>就没有问题，但是如果我们忘记了，并且线程超出了自己的作用域，<code>std::terminate</code>将被调用，程序会终止。</p>\r\n<h4 id=\"线程相关内容补充\">线程相关内容补充</h4>\r\n<p>在C++中，创建线程后，如果没有适当地处理线程的结束，可能会导致程序意外终止。</p>\r\n<p>当你创建一个新的线程并开始执行代码时，主线程和新线程是并行执行的。如果在主线程退出之前没有\r\njoin（或者使用 detach 分离线程），那么主线程结束时，程序会调用\r\n<code>std::terminate</code> 来终止所有尚未结束的线程。</p>\r\n<p>这种情况的发生通常是由于在主线程退出之前，新线程尚未完成，而没有等待新线程结束（或者分离）而导致的。因此，在使用线程时，确保在适当的时机对线程进行\r\njoin 或 detach 是非常重要的。</p>\r\n<h5 id=\"关于-join-和-detach\">关于 join 和 detach</h5>\r\n<p>join 和 detach 是 c++ 两种管理线程的方法。</p>\r\n<ol type=\"1\">\r\n<li><p><code>join</code>\r\n通过阻塞当前线程等待被调用的线程完成，确保主线程在子线程执行完毕后在继续执行，从而避免子线程在主线程退出去终止，或者超出作用域导致\r\n<code>std::terminate</code> 导致整个进程结束。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t</span><span class=\"hljs-params\">(threadFunction)</span></span>;<br><br>t.<span class=\"hljs-built_in\">jion</span>();\t\t<span class=\"hljs-comment\">// 阻塞该主线程，等待子线程完成  </span><br></code></pre></td></tr></table></figure></li>\r\n<li><p><code>detach</code>\r\n将当前线程和新线程分离，使其独立运行。一旦被分离后就无法使用\r\n<code>join</code>\r\n方法等待线程结束。<u><strong>此时</strong>线程的生命周期就由自己控制了，主线程和子线程可以并发执行，互相独立。</u></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">std::<span class=\"hljs-built_in\">thread</span>(threadFuntion);  <br>t.<span class=\"hljs-built_in\">detach</span>();  <br></code></pre></td></tr></table></figure></li>\r\n</ol>\r\n<p>通过以上三个例子，我们可以看到错误发生是有一定规律的。首先在这些例子中我们获取了某些资源，如Heap上的内存、锁、线程。获取资源当然没有问题，但是当资源超出作用范围问题就发生了(内存泄露，死锁，进程终止)，在第一个问题中我们要时刻记得\r\ndelete、第二个需要 unlock，第三个需要 join，这显然是很繁琐的。</p>\r\n<p>RAII 就是为了避免犯错和繁琐的手动释放。<br />\r\nC++ 和\r\nJava，Python等的垃圾回收不同其析构函数是显式的，离开作用域自动销毁。<br />\r\n其他比如向 vector\r\npush一个资源，然后退出引用计数归零，但是不会立即删除，而是过段时间后调用一个\r\nGC 程序将引用计数为零的对象删除。</p>\r\n<p>但是如果对高性能计算有要求，如<strong>时序</strong>或<strong>性能</strong>就不能依赖\r\nGC。</p>\r\n<h3 id=\"raii-异常安全-exception-safe\">RAII: 异常安全( exception-safe\r\n)</h3>\r\n<p>C++ 标准确保在异常发生时，也能调用 已创建对象的析构函数，因此 C++\r\n不需要 Java 那种 finally 语句确保执行。</p>\r\n<h3 id=\"raii-离不开-构造函数-和-析构函数\">RAII 离不开 构造函数 和\r\n析构函数</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    std::string name;<br>    <span class=\"hljs-type\">int</span> age;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>():<span class=\"hljs-built_in\">name</span>(<span class=\"hljs-string\">&quot;Kit&quot;</span>),<span class=\"hljs-built_in\">age</span>(<span class=\"hljs-number\">10</span>)<br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(string n, <span class=\"hljs-type\">int</span> a):<span class=\"hljs-built_in\">name</span>(n),<span class=\"hljs-built_in\">age</span>(a)\t\t<span class=\"hljs-comment\">// 拷贝构造函数</span><br>    &#123;<br>        <br>    &#125;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(string n, <span class=\"hljs-type\">int</span> a)\t\t<span class=\"hljs-comment\">// 拷贝赋值函数</span><br>    &#123;<br>        name = n;<br>        age = a;<br>    &#125;<br>&#125;; <br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Pig pig0;<br>    <span class=\"hljs-function\">Pig <span class=\"hljs-title\">pig1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Kiii&quot;</span>,<span class=\"hljs-number\">2</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>高效：使用初始化列表可以避免重复初始化，如果不使用，首先会先将数据成员空初始化，然后在构造函数内部进行赋值。<br />\r\n</li>\r\n<li>避免错误，因为不用初始化列表会先对成员进行无参初始化，而这时若类成员没有无参构造函数就会出错。<br />\r\n</li>\r\n<li>类成员为 const，因为 const\r\n对象只能初始化一次，所以只能在初始化列表中进行。</li>\r\n</ul>\r\n<blockquote>\r\n<p>要记住非初始化列表都是先进行无参初始化然后再在函数内进行一次赋值，即一次初始化，一次赋值。</p>\r\n</blockquote>\r\n<h4 id=\"构造函数单个参数\">构造函数单个参数</h4>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>\tstring name;<br>    <span class=\"hljs-type\">int</span> age;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(<span class=\"hljs-type\">int</span> age_):<span class=\"hljs-built_in\">name</span>(<span class=\"hljs-string\">&quot;a Pig aged&quot;</span>+<span class=\"hljs-built_in\">to_string</span>(age_)),<span class=\"hljs-built_in\">age</span>(age_)<br>    &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Pig pig = <span class=\"hljs-number\">80</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>这里 <code>= 80</code>\r\n是隐式地调用了构造函数，如果想为了可读性避免这种隐式构造，可以使用\r\nexplicit。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>\tstring name;<br>    <span class=\"hljs-type\">int</span> age;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Pig</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> age_)</span>:name(<span class=\"hljs-string\">&quot;a Pig aged&quot;</span>+to_string(age_)),age(age_)</span><br><span class=\"hljs-function\">    &#123;</span><br>        <br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// Pig pig = 80;</span><br>    <span class=\"hljs-function\">Pig <span class=\"hljs-title\">pig</span><span class=\"hljs-params\">(<span class=\"hljs-number\">80</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>explicit\r\n使其必须使用<code>(80)</code>这种格式显式调用构造函数。<br />\r\nexplicit 的作用就在于避免因为隐式调用而导致代码可读性的降低。</p>\r\n<h4 id=\"explicit-多参数\">explicit 多参数</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string p_name;<br>    <span class=\"hljs-type\">int</span> p_age;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Pig</span><span class=\"hljs-params\">(string name, <span class=\"hljs-type\">int</span> age)</span>:p_name(name),p_age(age)</span><br><span class=\"hljs-function\">    &#123;</span><br>        <br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Pig pig = &#123;<span class=\"hljs-string\">&quot;Kit&quot;</span>,<span class=\"hljs-number\">5</span>&#125;;\t<span class=\"hljs-comment\">// Error</span><br>    Pig pig2&#123;<span class=\"hljs-string\">&quot;Kit2&quot;</span>,<span class=\"hljs-number\">7</span>&#125;;\t\t<span class=\"hljs-comment\">// Right</span><br>    <span class=\"hljs-function\">Pig <span class=\"hljs-title\">pig3</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Kit3&quot;</span>,<span class=\"hljs-number\">10</span>)</span></span>;\t<span class=\"hljs-comment\">// Right</span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>explicit 可以用于多参数，并且在上面例子中，explicit 避免了\r\n<code>&#123;\"kit\",5&#125;</code> 的隐式调用，并且接受了\r\n<code>Pig pig2&#123;\"Kit2\",7&#125;</code> 的显式调用。</p>\r\n<h4 id=\"和-调用的区别\">() 和 {} 调用的区别</h4>\r\n<ol type=\"1\">\r\n<li><code>int(3.14f)</code> 不会报错，但是 <code>int&#123;3.14f&#125;</code>\r\n会报错，因为 {} 是非强制类型转换。<br />\r\n</li>\r\n<li>假如 使用 <code>Pig pig2&#123;\"jit2\",4.5&#125;</code> 这就会出错了……</li>\r\n</ol>\r\n<p>by the way，现在别使用 int() 了，太蠢了，而且不安全，比如\r\n要是转换为指针可能会发生错误。应该使用\r\n<code>static_cast&lt;int&gt;()</code> 进行。</p>\r\n<h3\r\nid=\"编译器默认生成的构造函数无参-pod-陷阱\">编译器默认生成的构造函数：无参\r\n( POD 陷阱 )</h3>\r\n<p>当一个类没有定义任何构造函数，且类成员都有无参的构造函数，编译器会自动生成一个无参构造函数，会调用每个成员的无参构造函数。</p>\r\n<p><strong>注意</strong>这些类型<strong>不会被初始化为0</strong>。</p>\r\n<ol type=\"1\">\r\n<li>int, float, double 等基础类型<br />\r\n</li>\r\n<li><code>void*</code>, <code>Object*</code> 等指针类型<br />\r\n</li>\r\n<li>完全有这些类型组成的类</li>\r\n</ol>\r\n<ul>\r\n<li>这些类型称为 <strong>POD( plain-of-data )</strong><br />\r\nPOD\r\n的存在是出于兼容性和性能考虑，这些类型会将其所在内存位置的数据直接作为自己的初始值。</li>\r\n</ul>\r\n<p>所以如果你打算使用编译器自动生成的初始化函数，最好对类成员用\r\n<code>&#123;&#125;</code> 进行一个指定初始化，这样在\r\n自动生成的构造函数中就会初始化为你指定的值。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string p_name;<br>    <span class=\"hljs-type\">int</span> weight&#123;<span class=\"hljs-number\">0</span>&#125;;\t\t<span class=\"hljs-comment\">// 自动生成的构造函数会将其初始化为0</span><br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<p>或者使用<code>=</code>也可以，但是要注意类对象其本身的构造函数是否有\r\nexplicit 修饰<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Demo</span><br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Demo</span><span class=\"hljs-params\">(string a, string b)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string p_name;<br>    <span class=\"hljs-type\">int</span> weight = <span class=\"hljs-number\">0</span>;<br>    Demo pd&#123;<span class=\"hljs-string\">&quot;a&quot;</span>,<span class=\"hljs-string\">&quot;b&quot;</span>&#125;;\t\t<span class=\"hljs-comment\">// 可以通过编译</span><br>    <span class=\"hljs-comment\">// Demo pd = &#123;&quot;a&quot;,&quot;bb&quot;&#125;;\t// 这样就不行</span><br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<blockquote>\r\n<p><code>int x&#123;&#125;;   void* p&#123;&#125;;</code></p>\r\n<p>和</p>\r\n<p><code>int x&#123;0&#125;;   void* p&#123;nullptr&#125;;</code></p>\r\n<p>等价，都是<strong>零初始化</strong></p>\r\n</blockquote>\r\n<h3\r\nid=\"编译器默认生成的构造函数c11-初始化\">编译器默认生成的构造函数：C++11\r\n初始化</h3>\r\n<p>在 C++11 中，如果一个类(和他的基类)\r\n没有定义任何构造函数，这时编译器会自动生成一个<strong>参数个数和成员一样的构造函数</strong>。</p>\r\n<p>会将 {} 内容，<strong>按顺序赋值给对象的每一个成员</strong></p>\r\n<p>不过这种只支持 {} 或者 = {}</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> a;<br>    <span class=\"hljs-type\">int</span> b;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Deo</span><br>&#123;<br>    Pig pig;<br>    <span class=\"hljs-type\">int</span> a;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// Write C++ code here</span><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hello world!&quot;</span>;<br>    Pig pig&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>&#125;;<br>    std::cout &lt;&lt; pig.a &lt;&lt; std::endl;\t\t\t<span class=\"hljs-comment\">// 1</span><br>    Deo deo&#123;&#123;<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>&#125;,<span class=\"hljs-number\">1</span>&#125;;<br>    std::cout &lt;&lt; deo.pig.a &lt;&lt; std::endl;\t\t<span class=\"hljs-comment\">// 3</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>当然这时候无参构造函数也是存在的。</p>\r\n<p>和默认指定结合<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string p_name;<br>    <span class=\"hljs-type\">int</span> p_weight&#123;<span class=\"hljs-number\">0</span>&#125;;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Pig pig&#123;<span class=\"hljs-string\">&quot;kit&quot;</span>&#125;;\t\t<span class=\"hljs-comment\">// weight 未指定，使用 0</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<h3\r\nid=\"有自定义构造函数时仍想用默认构造函数default\">有自定义构造函数时仍想用默认构造函数：<code>=default</code></h3>\r\n<p>一旦我们自定义了构造函数，编译器便<strong>不会生成默认的无参构造函数</strong><br />\r\n但是如果我们仍然想使用，就可以用 <code>=default</code> 关键字。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string pName;<br>    <span class=\"hljs-type\">int</span> pWeight;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>() = <span class=\"hljs-keyword\">default</span>;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(string name, <span class=\"hljs-type\">int</span> wei)<br>        :<span class=\"hljs-built_in\">pName</span>(name),<span class=\"hljs-built_in\">pWeight</span>(wei)<br>        &#123;<br>            <br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p><em>but 初始化列表的那个构造函数好像不能 =default 出来</em></p>\r\n<h3\r\nid=\"编译器默认生成的构造函数拷贝构造函数\">编译器默认生成的构造函数：拷贝构造函数</h3>\r\n<p><code>Pig(cosnt Pig&amp; other)</code><br />\r\n参数为 Pig 类型，调用如下</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Pig pig&#123;<span class=\"hljs-string\">&quot;Kit&quot;</span>,<span class=\"hljs-number\">90</span>&#125;;<br>    <br>    Pig pig2 = pig;<br>    <span class=\"hljs-comment\">// Pig pig2(pig);\t\t// 与上面的一样</span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>即便我们自定义了构造函数，拷贝构造函数也不会删除。</p>\r\n<h3\r\nid=\"舍弃拷贝构造函数delete\">舍弃拷贝构造函数：<code>=delete</code></h3>\r\n<p>如果不想使用拷贝构造函数可以使用 <code>delete</code> 修饰<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pig</span><br>&#123;<br>    string pName;<br>    <span class=\"hljs-type\">int</span> pWeight&#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>()=<span class=\"hljs-keyword\">default</span>;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(string name, <span class=\"hljs-type\">int</span> wei):<span class=\"hljs-built_in\">pName</span>(name),<span class=\"hljs-built_in\">pWeight</span>(wei)<br>    &#123;&#125;<br>    <br>    <span class=\"hljs-built_in\">Pig</span>(<span class=\"hljs-type\">const</span> Pig&amp;) = <span class=\"hljs-keyword\">delete</span>;\t\t<span class=\"hljs-comment\">// 禁止拷贝构造</span><br>    Pig&amp; operatpor=(Pig <span class=\"hljs-type\">const</span> &amp;) = <span class=\"hljs-keyword\">delete</span>;\t<span class=\"hljs-comment\">//  禁止拷贝赋值</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p><code>Pig pig2 = pig;</code></p>\r\n<p>这是<strong>拷贝构造</strong><br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">Pig pig2;\t<span class=\"hljs-comment\">// 无参构造</span><br>pig2 = pig;\t<span class=\"hljs-comment\">// 拷贝赋值</span><br></code></pre></td></tr></table></figure></p>\r\n<p>这是<strong>拷贝赋值</strong></p>\r\n<h4\r\nid=\"为什么拷贝赋值函数返回值是引用\">为什么拷贝赋值函数返回值是引用</h4>\r\n<p>为了实现链式赋值，返回要是左值引用，而非临时对象的将亡值。</p>\r\n<h3 id=\"构造函数全家桶\">构造函数全家桶</h3>\r\n<h4 id=\"三五法则一\">三五法则：一</h4>\r\n<p><img src=\"imgs/C++RAII/35.png\"></p>\r\n<ol type=\"1\">\r\n<li>如果定义了析构函数，为了防止 doulefree 要么 delete\r\n拷贝构造和拷贝赋值，要么自定义。<br />\r\n也就是深拷贝和浅拷贝。<br />\r\n浅拷贝会导致两个对象内的指针指向同一内存，所以我们要手动实现深拷贝。<br />\r\n如果定义了析构函数很有可能是因为我们类内对象有些无法被默认的析构函数销毁，<br />\r\n所以可能会有深拷贝和浅拷贝问题，如果只需要浅拷贝那就删除拷贝构造和拷贝赋值函数，C++会默认生成的。<br />\r\n</li>\r\n<li>如果不实现拷贝赋值函数，编译器可能会以 析构+拷贝构造\r\n的方式实现拷贝赋值的效果。<br />\r\n</li>\r\n<li>与上面同理。</li>\r\n</ol>\r\n<h4 id=\"拷贝和移动\">拷贝和移动</h4>\r\n<p>有时候我们只需要一份 data，不需要复制，我们更希望把 对象\r\n<strong>移动</strong>过去。<br />\r\n拷贝是 O(n)，移动是 O(1)<br />\r\n可以使用 std::move<br />\r\nv2 被移动到 v1 后原来的 v2 会被清空，所以一定要确保 v2\r\n后续不会会再被使用。</p>\r\n<h4 id=\"移动进阶swap\">移动进阶：swap</h4>\r\n<p>我们不仅可以使用move<br />\r\n也可以使用 <code>std::swap</code> 交换 v1 和 v2<br />\r\n可以利用 swap 实现双缓存技术。</p>\r\n<h4 id=\"哪些情况会触发-move\">哪些情况会触发 move</h4>\r\n<ul>\r\n<li>会触发move\r\n<ul>\r\n<li><code>return v2;</code> 作为返回值<br />\r\n</li>\r\n<li><code>v1 = std::vector&lt;int&gt;(200)</code> 就地构造<br />\r\n</li>\r\n<li><code>v1 = std::move(v2)</code> 显式move<br />\r\n</li>\r\n</ul></li>\r\n<li>拷贝\r\n<ul>\r\n<li><code>return std::as_const(v2)</code>，显式拷贝<br />\r\n</li>\r\n<li><code>v1 =v2</code> , 默认拷贝<br />\r\n</li>\r\n</ul></li>\r\n<li>下式不会 move 也不会 copy\r\n<ul>\r\n<li><code>std::move(v2)</code><br />\r\n</li>\r\n<li><code>std::as_const(v2)</code><br />\r\n</li>\r\n<li>这两个函数只负责转换类型，不会发生实际的 copy 和 move。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"移动构造函数缺省实现\">移动构造函数：缺省实现</h3>\r\n<ul>\r\n<li>移动构造 ≈ 拷贝构造 + 解构他 + 他默认构造\r\n(这里的他是移动的源对象)<br />\r\n</li>\r\n<li>移动赋值 ≈ 拷贝赋值 + 他结构 + 他默认构造</li>\r\n</ul>\r\n<p>只要 我们不自己定义，编译器就会这样做<br />\r\n这也就是三五法则中 第4点, 为什么定义 <strong>拷贝构造</strong> 和\r\n<strong>拷贝赋值</strong> 后最好定义 <strong>移动构造</strong> 和\r\n<strong>移动赋值</strong></p>\r\n<h2 id=\"raii-解决内存管理unique_ptr\">RAII\r\n解决内存管理：<code>unique_ptr</code></h2>\r\n<p>C++11 引用 <code>unique_ptr</code> 容器，其结构函数会调用 delete\r\np。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">C</span><br>&#123;<br>    <span class=\"hljs-built_in\">C</span>()&#123;<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;C&quot;</span>);&#125;<br>    ~<span class=\"hljs-built_in\">C</span>()&#123;<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;~C&quot;</span>);&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::unique_ptr&lt;C&gt; p = std::<span class=\"hljs-built_in\">make_unique</span>&lt;C&gt;();<br>    <span class=\"hljs-keyword\">if</span>(..)<br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\t<span class=\"hljs-comment\">// 自动释放 p</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; \t\t<span class=\"hljs-comment\">// 自动释放 p</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>而且将 C++98 的<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">delete</span> p;<br>p = <span class=\"hljs-literal\">nullptr</span>;<br></code></pre></td></tr></table></figure></p>\r\n<p>封装为了一个操作：<br />\r\n<code>p = nullptr;</code> 等价于 <code>p.reset();</code></p>\r\n<h4 id=\"uniqur_ptr-禁止拷贝\"><code>uniqur_ptr</code>: 禁止拷贝</h4>\r\n<p>为什么禁止拷贝，如果拷贝了这个指针，<br />\r\n而 <code>unique_ptr</code> 的析构函数使用了 delete，可能就会出现 double\r\nfree 的问题。<br />\r\n所以，在我们写函数时，如果用 <code>unique_ptr</code>\r\n作为参数就会报错。</p>\r\n<h5 id=\"解决方案1获取原始指针-c\">解决方案1：获取原始指针( C* )</h5>\r\n<ul>\r\n<li><p>第一种情况，我们不需要 夺走 资源的 <strong>占有权</strong><br />\r\n比如只是一个函数调用，<strong>并不需要结果掌管对象生命周期的大权</strong>。<br />\r\n使用 <code>p.get()</code> 获取指针，然后进行操作。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(C* cp)</span>  </span><br><span class=\"hljs-function\"> </span>&#123;<br>     <br> &#125;<br><br><span class=\"hljs-built_in\">func</span>(p.<span class=\"hljs-built_in\">get</span>());  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>第二种，我们需要夺走 资源的 <strong>占有权</strong>。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">std::vector&lt;std::unique_ptr&lt;C&gt;&gt; objectList;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(std::unique_ptr&lt;C&gt; p)</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    objectList.<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">move</span>(p));  <br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    std::unique_ptr&lt;C&gt; p = std::<span class=\"hljs-built_in\">make_unique</span>&lt;C&gt;();  <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;移交前:%p\\n&quot;</span>,p.<span class=\"hljs-built_in\">get</span>());\t\t<span class=\"hljs-comment\">// 不为null  </span><br>    <span class=\"hljs-built_in\">func</span>(std::<span class=\"hljs-built_in\">move</span>(p));  <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;移交后:%p\\n&quot;</span>,p.<span class=\"hljs-built_in\">get</span>());\t\t<span class=\"hljs-comment\">// 为null  </span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure></p>\r\n<p>因此我们要使用 move 接过掌管对象生命周期的大权。</p></li>\r\n</ul>\r\n<h4 id=\"移交控制权后仍希望访问到-p-指向的对象\">移交控制权后仍希望访问到\r\np 指向的对象</h4>\r\n<p>我们移交后，原来的指针就变 nullptr，这时无法访问。<br />\r\n##### 解决办法：提前获取指针</p>\r\n<p>使用get函数提前获取原始指针，<br />\r\n不用担心周期问题，这个原始指针的所有权归move后的新<code>unique_ptr</code>\r\n所有。<br />\r\n<code>C* raw_p = p.get();</code></p>\r\n<p>但是要时刻注意 move 后的 <code>unique_ptr</code> 是否被删除！</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::unique_ptr&lt;C&gt; p = std::<span class=\"hljs-built_in\">make_unique</span>&lt;C&gt;();<br>\tC *raw_p = p.<span class=\"hljs-built_in\">get</span>();<br>\t<span class=\"hljs-built_in\">func</span>(std::<span class=\"hljs-built_in\">move</span>(p));<br>    <br>    raw_p-&gt;<span class=\"hljs-built_in\">do</span>();<br>    <br>    objlist.<span class=\"hljs-built_in\">clear</span>();<br>    <br>    raw_p-&gt;<span class=\"hljs-built_in\">do</span>();\t<span class=\"hljs-comment\">// !!! Error 悬空指针</span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"shared_ptr\"><code>shared_ptr</code></h2>\r\n<ul>\r\n<li><code>unique_ptr</code> 由于为了解决 double free\r\n而<strong>禁止拷贝</strong>，导致使用起来很困难，容易犯错。<br />\r\n</li>\r\n<li><code>shared_ptr</code>，牺牲效率换取自由度，通过\r\n<strong>引用计数</strong> 来解决 <strong>重复释放</strong> 的问题。</li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>当 <code>shared_ptr</code> 被初始化时，将计数器设为1；<br />\r\n</li>\r\n<li>当 <code>shared_ptr</code> 被拷贝时， 计数器 +1；<br />\r\n</li>\r\n<li>当一个 <code>shared_ptr</code> 被解构时，计数器 -1，直到计数器为\r\n0，则自动销毁其所指向的对象。</li>\r\n</ol>\r\n<ul>\r\n<li>我们可以使用 <code>p.use_count()</code> 获取当前的引用计数。</li>\r\n</ul>\r\n<h3 id=\"shared_ptr-和-循环引用\"><code>shared_ptr</code> 和 循环引用</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">C</span><br>&#123;<br>    std:;shared_ptr&lt;C&gt; m_child;<br>    std::shared_ptr&lt;C&gt; m_parent;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">auto</span> parent = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();<br>    <span class=\"hljs-keyword\">auto</span> child = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();<br>    <br>    parent-&gt;m_child = child;<br>    child-&gt;m_parent = parent;<br>    <span class=\"hljs-comment\">// 这里 parent 和 child 互相引用</span><br>    <br>    parent = <span class=\"hljs-literal\">nullptr</span>;\t<span class=\"hljs-comment\">// 失败，child 的 m_parent 还在引用</span><br>    child = <span class=\"hljs-literal\">nullptr</span>;\t<span class=\"hljs-comment\">// 失败，parent 的 m_child 还在引用</span><br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>即便 main 函数退出，这两块内存都无法释放。</p>\r\n<h2 id=\"weak_ptr\"><code>weak_ptr</code></h2>\r\n<h3 id=\"循环引用解决方案1\">循环引用：解决方案1</h3>\r\n<ul>\r\n<li>将逻辑上“不具有所属权” 的那一个 <code>shared_ptr</code>，改为\r\n<code>weak_ptr</code> 即可。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">C</span>  <br>&#123;  <br>    std:;shared_ptr&lt;C&gt; m_child;  <br>    std::weak_ptr&lt;C&gt; m_parent;  <br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    <span class=\"hljs-keyword\">auto</span> parent = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();  <br>    <span class=\"hljs-keyword\">auto</span> child = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();<br>    <br>    parent-&gt;m_child = child;  <br>    child-&gt;m_parent = parent;  <br>    <span class=\"hljs-comment\">// 这里 parent 和 child 互相引用</span><br>    <br>    parent = <span class=\"hljs-literal\">nullptr</span>;\t<span class=\"hljs-comment\">// 释放，因为 child 指向的是其 **弱引用**  </span><br>    child = <span class=\"hljs-literal\">nullptr</span>;\t<span class=\"hljs-comment\">// 释放，因为指向 child 的 parent 已经释放了</span><br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h4 id=\"不影响-shared_ptr-计数弱引用-weak_ptr\">不影响 shared_ptr\r\n计数：弱引用 weak_ptr</h4>\r\n<ul>\r\n<li><p>expired() 可以判断，weak_ptr 是否失效，如果 shared_ptr\r\n已经释放了，该 weak_ptr 就失效了。<br />\r\n<code>waek_p.expired()</code></p></li>\r\n<li><p>lock()，如果有需求可以随时使用 lock 函数产生一个新的\r\nshared_ptr。但不 lock 时 weak_ptr 不会影响计数。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">std::shared_ptr&lt;C&gt; p = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();  <br>std::weak_ptr&lt;C&gt; weak_p = p;  <br>weak_p.<span class=\"hljs-built_in\">lock</span>()-&gt;<span class=\"hljs-built_in\">do_something</span>();\t<span class=\"hljs-comment\">// 执行完毕后 lock 出来的 shared_ptr 就销毁了，不影响 shared_ptr 的计数，我理解为 lock 返回一个 shared_ptr 的将亡值，这行结束后自动解构  </span><br></code></pre></td></tr></table></figure></p></li>\r\n</ul>\r\n<h2 id=\"智能指针作为类的成员变量\">智能指针：作为类的成员变量</h2>\r\n<ol type=\"1\">\r\n<li>unique_ptr，<strong>当该对象仅属于我</strong>，比如父窗口下的子窗口<br />\r\n</li>\r\n<li>原始指针，<strong>当对象不属于我，但是他释放</strong><u><strong>前</strong></u><strong>我必然被释放。</strong><br />\r\n有一定风险，比如子窗口中指向父窗口的指针。<br />\r\n</li>\r\n<li>shared_ptr：<strong>当有多个对象共享时，或虽然该对象仅属于我，但是有\r\nweak_ptr 的需要</strong><br />\r\n</li>\r\n<li>weak_ptr：<strong>当该对象不属于我，且他释放</strong><u><strong>后</strong></u><strong>我仍可能不被释放。</strong>比如：指向窗口上一次被点击的元素。<br />\r\n</li>\r\n<li>初学者可多用 shard_ptr 和 weak_ptr 的组合，更加安全。</li>\r\n</ol>\r\n<h3\r\nid=\"循环引用解决方案2设置为原始指针\">循环引用解决方案2：设置为原始指针</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">C</span><br>&#123;<br>\tstd::shared_ptr&lt;C&gt; m_child;<br>\tC* m_parent;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">auto</span> parent = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();<br>\t<span class=\"hljs-keyword\">auto</span> child = std::<span class=\"hljs-built_in\">make_shared</span>&lt;C&gt;();<br>\t<br>\tparent-&gt;m_child = child;<br>\tchild-&gt;m_parent = parent.<span class=\"hljs-built_in\">get</span>();\t\t<span class=\"hljs-comment\">// 这里 parent.get 得到的原始指针是归属于 shared_ptr parent 的</span><br>\t<br>\tparent = <span class=\"hljs-literal\">nullptr</span>;<br>\tchild = <span class=\"hljs-literal\">nullptr</span>;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>还有更适合父窗口-子窗口的解决方案。<br />\r\n刚才提到原始指针的应用场景：当一个对象不属于我，但是他释放<u>前</u>我必须释放。<br />\r\n这里可以发现父窗口的释放必须导致子窗口的释放。</p>\r\n<h2 id=\"智能指针使用\">智能指针使用</h2>\r\n<h3\r\nid=\"成员都是安全类型五大函数一个也不用声明\">成员都是安全类型：五大函数，一个也不用声明</h3>\r\n<ul>\r\n<li>如果类的所有成员都是 <strong>安全</strong>\r\n类型，那么五大函数都无需声明，你的类型就是自动<strong>安全的</strong>。<br />\r\n</li>\r\n<li>最好的判断方式是：如果你不需要 <strong>自定义的解构函数</strong>\r\n这个类就无需担心。<br />\r\n</li>\r\n<li>如果我们需要自定义\r\n解构函数，往往意味着你的类成员中，包含不安全类型。<br />\r\n</li>\r\n<li>一般有两种情况：\r\n<ol type=\"1\">\r\n<li><strong>类管理着资源</strong><br />\r\n</li>\r\n<li><strong>类是数据结构</strong></li>\r\n</ol></li>\r\n</ul>\r\n<h4\r\nid=\"管理着资源仅需要浅拷贝删除拷贝函数统一用-shared_ptr-管理\">管理着资源(仅需要浅拷贝)：删除拷贝函数，统一用\r\nshared_ptr 管理</h4>\r\n<ul>\r\n<li><p>因为资源，往往是不能被复制的。比如 一个 openGL 的 shader</p></li>\r\n<li><p>如果允许拷贝(浅拷贝)，就相当于把 标记资源的 int\r\n复制两遍，之后就会出现 double free 的问题。</p></li>\r\n</ul>\r\n<h4\r\nid=\"数据结构需要深拷贝如果可以定义拷贝和移动\">数据结构(需要深拷贝)：如果可以，定义拷贝和移动</h4>\r\n<ul>\r\n<li>我们设计的<strong>数据结构</strong>通常是支持深拷贝的，这需要我们自己去定义实现，如果实在无法实现那就删除。</li>\r\n</ul>\r\n<h3 id=\"函数如何避免拷贝\">函数如何避免拷贝</h3>\r\n<p>使用常引用：<code>Pig const &amp; pig</code></p>\r\n<h4 id=\"如何避免不经意的隐式拷贝\">如何避免不经意的隐式拷贝</h4>\r\n<p>我们可以将 拷贝构造函数声明为 explicit<br />\r\n这样隐式拷贝就会出错，让我们发现隐式拷贝的发生。</p>\r\n<h2 id=\"后续阅读\">后续阅读</h2>\r\n<ol type=\"1\">\r\n<li>P-IMPL模式<br />\r\n</li>\r\n<li>虚函数与纯虚函数<br />\r\n</li>\r\n<li>拷贝如何作为虚函数<br />\r\n</li>\r\n<li><code>std:unique_ptr::release()</code><br />\r\n</li>\r\n<li><code>std:.enable_shared_from_this</code><br />\r\n</li>\r\n<li><code>dynamic_cast</code><br />\r\n</li>\r\n<li><code>std::dynamic_pointer_cast</code><br />\r\n</li>\r\n<li>运算符重载<br />\r\n</li>\r\n<li>右值引用&amp;&amp;<br />\r\n</li>\r\n<li><code>std::shared_ptr&lt;void&gt;</code>和 <code>std:any</code></li>\r\n</ol>"},{"title":"GPU Driven And Hierarchical Z-Bufferr","math":true,"index_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","banner_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","date":"2025-02-22T16:00:00.000Z","typora-root-url":"../","_content":"\n关于 GPU Driven And Hierarchical Z-Buffer\n\n# GPU Driven And Hierarchical Z-Buffer\n\n## Hierarchical Z-Buffer\n\n### Question\n\n为什么**遮挡查询**，要2x2的像素。\n首先我们的做法是把包围盒投影到屏幕空间采样对应等级的Mipmap，那这个投影过程可能就会有精度缺失。\n如果之采样1个像素就会降低命中率，尤其是我们找寻最高LOD层级才能大概率找到对应的 1x1 像素，这命中率是不高的。","source":"_posts/GPU Driven And Hierarchical Z-Buffer.md","raw":"---\ntitle: GPU Driven And Hierarchical Z-Bufferr\nmath: true\ntags: [图形学,渲染]\nindex_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\nbanner_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\ndate: 2025-02-23\ntypora-root-url: ../\n\n---\n\n关于 GPU Driven And Hierarchical Z-Buffer\n\n# GPU Driven And Hierarchical Z-Buffer\n\n## Hierarchical Z-Buffer\n\n### Question\n\n为什么**遮挡查询**，要2x2的像素。\n首先我们的做法是把包围盒投影到屏幕空间采样对应等级的Mipmap，那这个投影过程可能就会有精度缺失。\n如果之采样1个像素就会降低命中率，尤其是我们找寻最高LOD层级才能大概率找到对应的 1x1 像素，这命中率是不高的。","slug":"GPU Driven And Hierarchical Z-Buffer","published":1,"updated":"2025-02-23T16:52:43.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppthz0006bkbw8al1bmcm","content":"<p>关于 GPU Driven And Hierarchical Z-Buffer</p>\r\n<h1 id=\"gpu-driven-and-hierarchical-z-buffer\">GPU Driven And\r\nHierarchical Z-Buffer</h1>\r\n<h2 id=\"hierarchical-z-buffer\">Hierarchical Z-Buffer</h2>\r\n<h3 id=\"question\">Question</h3>\r\n<p>为什么<strong>遮挡查询</strong>，要2x2的像素。\r\n首先我们的做法是把包围盒投影到屏幕空间采样对应等级的Mipmap，那这个投影过程可能就会有精度缺失。\r\n如果之采样1个像素就会降低命中率，尤其是我们找寻最高LOD层级才能大概率找到对应的\r\n1x1 像素，这命中率是不高的。</p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>关于 GPU Driven And Hierarchical Z-Buffer</p>\r\n<h1 id=\"gpu-driven-and-hierarchical-z-buffer\">GPU Driven And\r\nHierarchical Z-Buffer</h1>\r\n<h2 id=\"hierarchical-z-buffer\">Hierarchical Z-Buffer</h2>\r\n<h3 id=\"question\">Question</h3>\r\n<p>为什么<strong>遮挡查询</strong>，要2x2的像素。\r\n首先我们的做法是把包围盒投影到屏幕空间采样对应等级的Mipmap，那这个投影过程可能就会有精度缺失。\r\n如果之采样1个像素就会降低命中率，尤其是我们找寻最高LOD层级才能大概率找到对应的\r\n1x1 像素，这命中率是不高的。</p>\r\n"},{"title":"C++11 多线程","date":"2023-08-21T12:24:22.000Z","typora-root-url":"./..","_content":"  \n[小彭老师](https://www.bilibili.com/video/BV1Ya411q7y4/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=1fa1b82383f6efb8a2632316da9afad0)\n  \n之前一直没有系统学过，最近心里也很乱，听一下小彭老师然后自己整理了一些。\n  \n<!--more-->\n  \n# Multithreading\n  \n## Time\n  \n### C++11 标准库：`std::chrono`\n  \n* 利用 C++ 强类型的特点，明确 **时间点** 和 **时间段**，区分不同的**时间单位**。\n  \n* 时间点：2023年8月22日 21点38分54秒\n  \n* 时间段：2分20秒\n  \n* 时间点类型：`chrono::steady_clock::time_pointer` 等\n  \n* 时间段类型：`chrono::milliseconds`, `chrono::seconds`, `chrono::minutes` 等等。  \n  ~~~C++  \n  auto t0 = chrono::stready_clock::now();\t\t// 当前时间点  \n  auto t1 = t0 + chrono::seconds(30);\t\t\t// 当前时间30s后  \n  auto dt = t1 - t0;\t\t// 两个时间点的差，时间段  \n  int64_t sec = chrono::duration_cast<chrono::seconds>(dt).count();\t\t\t// 获取时间差的秒数  \n  double ms = std::chrono::duration_cast<std::chrono::duration<double, std::million>>(dt).count();  \n  ~~~\n  \n  std::chrono::duration<T, R> , 用 T 类型表示，单位为 R，单位不写默认为秒。  \n  std::chrono::second 是 std::chrono::duration<int_64> 的类型别名\n  \n#### 跨平台 sleep：`std::this_thread::sleep_for`\n  \n~~~C++\nstd::this_thread::sleep_for(std::chrono::milliseconds(480));\n~~~\n  \n* milliseconds 毫秒  \n* microseconds 微秒  \n* seconds\n  \n#### `std::this_thread::sleep_until`\n  \n睡到某个时间点  \n~~~c++\nauto t = std::chrono::steady_clock::now() + std::chrono::milliseconds(400);\nstd::this_thread::sleep_until(t);\n~~~\n  \n## Thread\n  \n* **进程**：我们的一个程序就是一个进程  \n* **线程**：线程是进程中的实体，是系统调度、分配的最小单位。  \n  进程本身不能获取 CPU 时间，而线程可以。  \n* 每个线程共享内存空间，开销较小。  \n* 每个进程拥有独立的内存空间，因此开销更大。\n  \n#### 为什么需要多线程\n  \n可以实现无阻塞的多任务程序。  \n做到程序的异步实现。\n  \n* 比如：下载器，下载一个大文件的同时还需要和用户进行交互。  \n  这个时候下载文件 和 用户交互就是一个进程的两个任务。  \n  如果不使用线程，纯串行，在下载时用户就无法操作了，只能等待下载完毕。  \n* 不用多进程是因为，进程的地址独立，进程间沟通困难，消耗资源更多。\n  \n### C++ 多线程：`std::thread`\n  \n* `std::thread` 构造函数的参数可以是任意的 lambda 表达式。  \n* 当线程启动，就会指向 lambda 里的内容。\n  \n#### 错误：找不到符号 `pthread_thread`\n  \n这是因为 `std::thread` 是基于 `pthread`的，  \n所以在 CMakeLists.txt 里链接 Threads::Threads 即可。\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.10)\n\nset(CMAKE_CXX_STANDARD 17)\n\nproject(threadDemo LANGUAGES CXX)\n\nadd_executable(threadDemo main.cpp)\n\nfind_package(Threads REQUIRED)\ntarget_link_libraries(threadDemo PUBLIC Threads::Threads)\n~~~\n  \n就是这两行：  \n`find_package(Threads REQUIRED)`  \n`target_link_libraries(threadDemo PUBLIC Threads::Threads)`\n  \n### 主线程等待子线程\n  \n在我们退出主线程时，可能子线程还未执行完毕。  \n可以使用 std::thread 类的 join() 来等待某一个进程的结束。  \n我们可以使用 joinable() 判断 thread 对象是否还对线程有管理权限。\n  \n### std::thread 的解构函数会销毁线程\n  \n* 作为 C++ 类同样遵循 RAII 思想，线程实际也是一种资源。  \n  thread 自定义了解构函数，删除了拷贝构造函数、拷贝赋值函数，但提供了移动构造函数、移动复制函数。\n  \n### 析构函数不再销毁线程：t1.detach()\n  \n调用成员函数 detach() 可以将线程和 std::thread 对象分离。  \n意味着 线程 的生命周期不再由当前 std::thread 对象管理，而在线程退出以后自动销毁自己。  \n不过这也还是会在进程结束后，自动退出，因为进程结束会调用 terminal 销毁全部线程。\n  \n### 析构函数不再销毁线程：自己构建全局线程池\n  \n如果不想，detach 后线程还未执行完毕就销毁。  \n可以自己建一个全局的线程池，创建线程就 push 进去，在程序结束前 逐个 join 即可。\n  \n~~~c++\nstd::vector<std::thread> poll;\n\nvoid func()\n{\n    std::thread t1([&]{\n        download(\"hello.zip\");\n    });\n    pool.push_back(std::move(t1));\n}\n\nint main()\n{\n    func();\n   \n    for(auto &th : pool) th.join();\n}\n~~~\n  \n#### 改进一下\n  \n~~~C++\nclass ThreadPool\n{\n    std::vector<std::thread> m_pool;\n    \npublic:\n    void push_back(std::thread thr)\n    {\n        m_pool.push_back(std::move(thr));\n    }\n    \n    ~ThreadPool()\n    {\n        for(auto &t : m_pool) t.join();\n    }\n};\n\nThreadPool tpool;\n\nvoid func()\n{\n    std::thread t1([&]{\n        download();\n    });\n    tpool.push_back(std::move(t1));\n}\n\nint main()\n{\n    func();\n    return 0;\n}\n~~~\n  \n### C++20 引入 `std::jthread`：符合 RAII 思想，解构时自动 join()\n  \n* C++ 20 的 `std::jthread` 和 `std::thread` 的不同在于，其解构函数会自动调用 join() 函数，让线程等待，直到完全执行。\n  \n## 碎碎念\n  \npython 没有线程，其实是 并发而非并行。  \nblender 也用了 怕python 而且 ui 层由OpenGL渲染出来，所以很多都是单线程会出现等待不能操作的结果。\n  \nOpenGL 和 DX12相比就是，DX12 是支持多线程的可以做到真正的并发，计算性能会提升很多。\n  \n## 异步\n  \n### `std::async`\n  \n~~~C++\nint download()\n{\n    // do something a long time\n    return 404;\n}\n\nvoid interact()\n{\n    std::string name;\n    std::cin >> name;\n    std::cout << \"Hi, \" << name << std::endl;\n}\n\nint main()\n{\n    std::future<int> fret = std::async([&]{\n        return download();\n    });\n    interact();\n    int ret = fret.get();\n    std::cout << \"Result is:\" << ret << std::endl;\n    return 0;\n}\n~~~\n  \n* `std::async` 接受一个带有返回值的 lambda，自身返回一个 `std::future` 对象。  \n  这个 future 是什么意思呢？在 `std::future<int> fret=..` 这里 fret 的返回值是 `int`，意思就是这个 int 现在还没有，但是我保证以后一定会有。   \n* 这 `async` 里的 lambda 并非立即执行，而是在后台会挂起一个线程默默执行。  \n* 最后调用 future 的 **get()** 方法，如果此时 download 还没完成，会**等待** download 完成，并获取 返回值。\n  \n#### 等待 wait\n  \n* 除了 get()，future 还有 **wait()** ，可以等待执行结束但是不会返回其值。\n  \n#### 等待一段时间：wait_for()\n  \n* 线程未结束，wait() 会无限等待。  \n* 而 wait_for() 则可以指定一个最长的等待时间，用 chrono 里的类表示单位。他会返回一个 std::future_status 表示等待是否完成。  \n* 如果超过时间还未完成，就会放弃等待，返回 `future_status::timeout`  \n* 如果线程在指定时间内执行完毕，等待就成功了，返回`future_status::ready`  \n* 同理还有 `wait_until()` 其参数是一个时间点。\n  \n#### 另一种用法：`std::launch::deferred` 做 `std::async` 的参数\n  \n* `std::async` 的第一个参数可设为 `std:;launch::deferred`，这时不会创建线程，只会把 lambda 函数体内的运算**推迟**到 future 的 get() 被调用后。  \n* 这种写法，lambda 的执行仍在主线程中，只是函数式编程上的异步，而不涉及到多线程。(可以用这个实现惰性求值(lazy evaluation) )\n  \n~~~c++\nstd::future<int> fret = std::async(std::launch::deferred, [&]{\n    return 909;\n});\n~~~\n  \n### `std::async` 的底层实现：`std::promise`\n  \n~~~C++\nint main()\n{\n    std::promise<int> pret;\n    std::thread t1([&]{\n        auto ret = download();\n        pret.set_value(ret);\n    });\n    std:::funture<int> fret = pret.get_future();\n    \n}\n~~~\n  \n* 如果不想 `std::async` 帮你自动创建线程，想要手动创建线程，可以直接用 `std::promise`  \n* 然后线程返回时，用 `set_value()` 设置返回值。  \n  在主线程中，用 `get_future()` 获取其 `std::future`对象，进一步 `get()` 可以等待并获取线程返回值。\n  \n### std::future 小贴士\n  \n* 为了符合 RAII 思想，删除了拷贝构造函数和拷贝赋值函数。  \n  如果需要浅拷贝，实现共享同一个 future 对象，可以使用 `std：：shared_future`。  \n* 如果不需要返回值，`std::async` 里的 lambda 返回类型可以为 void，但这时的 future 对象也要为 `std::future<void>`  \n* 同理有 `std::promise<void>`，但其 set_value() 不接受参数，仅仅作为同步作用，没有实际的值。\n  \n## 互斥量\n  \n### 多线程打架实例\n  \n~~~c++\nint main()\n{\n    std::vector<int> arr;\n    std::thread t1([&]{\n        for(int i = 0; i < 1000; ++i)\n        {\n            arr.push_back(1);\n        }\n    });\n    std::thread t2([&]{\n        for(int i = 0; i < 1000; ++i)\n        {\n            arr.push_back(2);\n        }\n    });\n    t1.join();\n    t2.join();\n    return 0;\n}\n~~~\n  \n* 两个线程向同一个数组里推数据导致崩溃。  \n* vector 并非 多线程安全 (MT-safe) 的容器。  \n  多个线程同时访问同一个 vector 对象会出现 **数据竞争 (data-race) **现象。\n  \n### `std::mutex` ：上锁，防止多个线程进入某一段代码\n  \n* 调用 `std::mutex` 的 `lock()` 时，会检测 `mutex` 是否已经**上锁**。  \n* 如果没有**锁定**，则对 `mutex` 进行上锁  \n* 如果已经**锁定**，则陷入等待，直到 `mutex` 被另一线程**解锁**后，才再次**上锁**。  \n* 调用 `unlock()` 则会解锁操作  \n* 这样可以保证 lock 和 unlock 之间的代码段，同一时间只有一个线程在执行，避免数据竞争。\n  \n### `std::lock_guard`: 符合 RAII 思想的锁\n  \n* 根据 RAII 思想，锁视为一种资源，上锁视为锁的获取，解锁视为锁的释放。  \n* `std::lock_guard` 就是这样的一个工具类，其构造函数会 `mtx.lock()`，解构函数会 `mtx.unlock()`。从而退出函数作用域时能够自动解锁，避免程序员忘记解锁。\n  \n~~~C++\nint main()\n{\n    std::vector<int> arr;\n    std::mutex mtx;\n    std::thread t1([&]{\n        std::lock_guard grd(mtx);\n        arr.push_back(1);\n    });\n    \n    std::thread t2([&]{\n        std::lock_guard grd(mtx);\n        arr.push_back(2);\n    });\n    \n    t1.join();\n    t2.join();\n    return 0;\n}\n~~~\n  \n但是也因为 `lock_guard`太符合 RAII 思想，导致其很死板，我们想提前 unlock 只能让他超出其作用范围。  \n为了更灵活的应用锁，就有了 `unique_lock` \n  \n### `std::unique_lock`: 符合 RAII 思想，但自由度更高\n  \n* `std::lock_guard` 严格在解构时 unlock()，但我们有时希望提前 unlock。这时就可以使用 `std::unique_lock`，他额外存储了一个 flag 表示释放已经被释放。他会在解构时检测这个 flag，如果没有释放，则调用 unlock，否则不调用。  \n* 然后可以直接调用 unique_lock 的 unlock 函数来提前解锁，但即使忘记也没关系，在超出作用域时其会自动检测一边是否需要解锁。\n  \n#### `std::unique_lock`: 用 `std::defer_lock` 作为参数\n  \n* `std::unique_lock` 的构造函数还可以有一个额外参数 `std::defer_lock`  \n* 指定此参数后，`std::unique_lock`不会在构造函数中 `mtx.lock()`了，需要后续手动 `grd.lock()` 才能上锁。  \n* 好处是，即使忘记了 `grd.unlock()` 也能够自动调用 `mtx.unlock()`\n  \n~~~C++\nint main()\n{\n    std::vector<int> arr;\n    std::mutex mtx;\n    std::thread t1([&]{\n        for(int i=0;i<10;i++)\n        {\n            std::unique_lock<std::mutex> grd(mtx);\n            arr.push_back(1);\n\t\t}\n    });\n    \n    \n    std::thread t2([&]{\n        for(int i=0;i<10;i++)\n        {\n            std::unique_lock<std::mutex>grd(mtx, std::defer_lock);\n            grd.lock();\n            arr.push_back(2);\n            // grd.unlock();\n\t\t}\n    });\n    \n    t1.join();\n    t2.join();\n    return;\n}\n~~~\n  \n### 多个对象？每个对象使用一个 mutex 即可\n  \n~~~c++\nint main()\n{\n    std::vector<int> arr1;\n    std::vector<int> arr2;\n    \n    std::mutex mtx1;\n    std::mutex mtx2;\n    \n    std::thread t1([&]{\n        for(int i = 0; i < 10; i++)\n        {\n            {\n                std::lock_guard grd(mtx1);\n            \tarr1.push_back(1);\n            }\n            \n            {\n                std::lock_guard grd(mtx2);\n                arr2.push_back(1);\n            }\n        }\n    });\n    \n    std::thread t2([&]{\n        for(int i = 0; i < 10; i++)\n        {\n            {\n                std::lock_guard grd(mtx1);\n            \tarr1.push_back(2);\n            }\n            \n            {\n                std::lock_guard grd(mtx2);\n                arr2.push_back(2);\n            }\n        }\n    });\n    \n    t1.join();\n    t2.join();\n    return;\n}\n~~~\n  \n### 如果上锁失败，却不想等待：`try_lock()`\n  \n~~~c++\nint main()\n{\n    std::mutex mtx1;\n    if(mtx1.try_lock())\n    {\n        std::cout << \"Successed!\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Failed!\" << std::endl;\n    }\n    \n    if(mtx1.try_lock())\n    {\n        std::cout << \"Successed!\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Failed!\" << std::endl;\n    }\n    \n    mtx.unlock();\n    return;\n}\n~~~\n  \n* `lock()` 如果发现 `mutex` 已经上锁的话，会等待他直到他解锁。  \n* 如果使用 `try_lock()` ，其上锁失败不会阻塞，而是直接返回 false，上锁成功会返回 true。\n  \n### `try_lock_for`\n  \n~~~C++\nint main()\n{\n    std::mutex mtx1;\n    if(mtx1.try_lock_for(std::chrono::milliseconds(500)))\n    {\n        std::cout << \"Successed!\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Failed!\" << std::endl;\n    }\n    \n    if(mtx1.try_lock_for(std::chrono::milliseconds(500)))\n    {\n        std::cout << \"Successed!\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Failed!\" << std::endl;\n    }\n    \n    mtx.unlock();\n    return;\n}\n~~~\n  \n* 在 `try_lock()` 的基础上，但是会等待一段时间。  \n* 类似的还有 `try_lock_until()`\n  \n### `std::unique_lock`: 用 `std::try_to_lock` 做参数\n  \n* 和无参数相比，它会调用 `mtx.try_lock()` 而非 `mtx.lock()`.  \n  `grd.owns_lock()` 判断是否上锁成功。\n  \n  ~~~c++  \n  int main()  \n  {  \n      std::mutex mtx;  \n      std::thread t1([&]{  \n          std::unique_lock<std::mutex>grd(mtx, std::try_to_lock);  \n          if(grd.owns_lock())  \n          {  \n              std::cout << \"Successed!\" << std::endl;  \n          }  \n          else  \n          {  \n              std::cout << \"Failed!\" << std::endl;  \n              std::this_thread::sleep_for(std::chrono::milliseconds(1000));  \n          }  \n      });\n      \n      t1.jion();  \n      t2.join();\n      \n      return 0;  \n  }  \n  ~~~\n  \n### `std::unique_lock`: `std::adopt_lock` 做参数\n  \n~~~c++\nint main()\n{\n    std::mutex mtx;\n    std::thread t1([&]{\n        std::unique_lock<std::mutex>grd(mtx);\n        std::cout << \"t1 lock the mutex\" << std::endl;\n        std::this_thread::sleep_for(std:chrono::milliseconds(1000));\n    });\n    \n    std::thread t2([&]{\n        mtx.lock();\n        std::unique_lock<std::mutex>grd(mtx, std::adopt_lock);\n        std::cout << \"t2 lock the mutex\" << std::endl;\n        std::this_thread::sleep_for(std:chrono::milliseconds(1000));\n    });\n\tt1.jion();\n    t2.join();\n    \n    return 0;\n}\n~~~\n  \n* 作用就是当我们的 mutex 已经上锁，但是我们又想使用 unique_lock / lock_guard 这种符合 RAII 思想的封装，以实现其可以自我解构，我们就在构造时使用 std::adopt_lock，就默认这个 mutex 已经上锁了。\n  \n### `std::unique_lock` 和 `std::mutex` 有相同的接口\n  \n* `std::unique_lock` 拥有 `std::mutex` 的所有成员函数：`lock()`, `unlock()`, `try_lock()`, `try_lock_for()` 等等。  \n  只是 unique_lock 会自动调用 unlock 罢了  \n* 而 `std::lock_guard` 无非是调用其构造参数中 名为 lock() 的成员函数罢了，所有我们甚至可以用 `std::unique_lock` 做 `std::lock_guard` 的构造函数参数 \n  \n* 更进一步，只要我们能有 满足 mutex 类对于成员函数的类，就可以做为 `std::lock_guard` 构造函数的参数。  \n  这种只要具有某些指定名字的成员函数，就可以判断一个类是否满足某些功能的思想，被成为 concept(概念)，相比 虚函数 和 动态多态的接口抽象，concept 能够使实现更加解耦，并且不会有性能损失。\n  \n## 死锁\n  \n### 同时锁住多个 mutex\n  \n~~~c++\nint main()\n{\n    std::mutex mtx1;\n    std::mutex mtx2;\n    \n    std:thread t1([&]{\n        for(int i = 0; i < 1000; ++i)\n        {\n            mtx1.lock();\n            mtx2.lock();\n            mtx2.unlock();\n            mtx1.unlock();\n        }\n    });\n    \n    std:thread t2([&]{\n        for(int i = 0; i < 1000; ++i)\n        {\n            mtx2.lock();\n            mtx1.lock();\n            mtx1.unlock();\n            mtx2.unlock();\n        }\n    });\n    \n    t1.jion();\n    t2.join();\n    \n    return 0;\n}\n~~~\n  \n* 因为线程是同步进行的，所以其指令不一定是同步的  \n* 可能就会：  \n  * t1锁住了mtx1  \n  * t2锁住了mtx2  \n  * t1需要锁mtx2，但是t2锁住了mtx2  \n  * t2需要锁mtx1，但是t1锁住了mtx1  \n  * t1，t2都陷入无尽的等待\n  \n#### 解决1：永远不要同时持有两个锁\n  \n* 简单粗暴的就是<u>不让一个线程同时持有两个锁</u>，分别上锁，来避免死锁\n  \n~~~c++\nint main()\n{\n    std::mutex mtx1;\n    std::mutex mtx2;\n    \n    std::thread t1([&]{\n        for(int i = 0; i < 100; i++)\n        {\n            mtx1.lock();\n            mtx1.unlock();\n            mtx2.lock();\n            mtx2.unlock();\n        }\n    });\n    \n    std::thread t2([&]{\n        for(int i = 0; i < 100; i++)\n        {\n            mtx2.lock();\n            mtx2.unlock();\n            mtx1.lock();\n            mtx1.unlock();\n        }\n    });\n    \n    t1.jion();\n    t2.join();\n    \n    return 0;\n}\n~~~\n  \n#### 解决方案2：确保双方上锁顺序一致\n  \n* 前面死锁是因为两个线程上锁的顺序不同，<u>保证双方上锁的顺序一致，即可避免死锁</u>\n  \n~~~C++\nint main()\n{\n    std::mutex mtx1;\n    std::mutex mtx2;\n    \n    std::thread t1([&]{\n        for(int i = 0; i < 100; i++)\n        {\n            mtx1.lock();\n            mtx2.lock();\n            mtx1.unlock();\n            mtx2.unlock();\n        }\n    });\n    \n    std::thread t2([&]{\n        for(int i = 0; i < 100; i++)\n        {\n            mtx1.lock();\n            mtx2.lock();\n            mtx2.unlock();\n            mtx1.unlock();\n        }\n    });\n    \n    t1.jion();\n    t2.join();\n    \n    return 0;\n}\n~~~\n  \n#### 解决方案3：使用 `std::lock` 同时对多个 mutex 上锁\n  \n* `std::lock`  接受任意个 mutex 作为参数，且保证 <u>无论任意线程中调用的顺序是否相同，都不会产生死锁问题</u>\n  \n~~~C++\nint main()\n{\n    std::mutex mtx1;\n    std::mutex mtx2;\n    \n    std::thread t1([&]{\n        for(int i = 0; i < 1000; i++)\n        {\n\t\t\tstd::lock(mtx1, mtx2);\n            mtx1.unlock();\n            mtx2.unlock();\n        }\n    });\n    \n    std::thread t2([&]{\n        for(int i = 0; i < 1000; i++)\n        {\n            std::lock(mtx2, mtx1);\n            mtx2.unlock();\n            mtx1.unlock();\n        }\n    });\n    \n    t1.join();\n    t2.join();\n    return 0;\n}\n~~~\n  \n#### `std::lock` 的 RAII 版本 : `std::scoped_lock`\n  \n* 和 `std::lock_guard` / `std::unique_lock`相对应，`std::lock` 也有 RAII 的版本 `std::scoped_lock`, 只不过其可以同时对多个 mutex 上锁。\n  \n### 同一个线程重复调用 lock() 也会造成死锁\n  \n~~~C++\nstd::mutex mtx;\n\nvoid other()\n{\n\tmtx.lock();\n    //...\n    mtx.unlock();\n}\n\nvoid func()\n{\n\tmtx.lock();\n    other();\n    mtx.unlock();\n}\n\nint main()\n{\n    func();\n    return 0;\n}\n~~~\n  \n* 这里 `func` lock了mtx，而lock之后调用 other，other 需要 mtx，陷入等待  \n  这就是 同一线程多次对同一个 mutex 进行 lock 导致死锁。\n  \n#### 解决一：other 不 lock\n  \n这种情况一定要说明 other 非线程安全的，在调用前务必保证其 mutex 已经上锁。\n  \n#### 解决二：改用 `std::recursive_mutex`\n  \n~~~C++\nstd::recursive_mutex mtx;\n\nvoid other()\n{\n\tmtx.lock();\n    //...\n    mtx.unlock();\n}\n\nvoid func()\n{\n\tmtx.lock();\n    other();\n    mtx.unlock();\n}\n\nint main()\n{\n    func();\n    return 0;\n}\n~~~\n  \n* 如果 `other` 不让改，可以用 `std::recursive_mutex`  \n  会判断是不是同一个线程 `lock()` 了多次同一个锁  \n  如果是则让计数器加1，在之后 `unlock()` 时会让计数器减1，减到0时才真正解锁。但是相比普通的 `std::mutex` 会有一定的性能损失。\n  \n* 也有 `std::recursive_timed_mutex`，如果我们需要 `try_lock_for()`\n  \n## 数据结构\n  \n### 案例：多线程使用 `std::vector`\n  \n之前提到 `vector` 是线程不安全的，会出现数据竞争(data-race)\n  \n### 封装线程安全的 `vector`\n  \n加入我们这样做：  \n~~~C++\nclass MTVector\n{\n    std::mutex m_mutex;\n    std::vector<int> m_arr;\n    \npublic:\n    void push_back(val)\n    {\n        m_mtx.lock();\n        m_arr.push_back(val);\n        m_mtr.unlock();\n    }\n    \n    size_t size() const\n    {\n        m_mtx.lock();\t//\n        size_t ret = m_arr.size();\n        m_mtx.unlock();\t//\n        return ret;\n    }\n};\n~~~\n  \n* 我们用用一个类进行简单封装，使访问都受到 `mutex` 的保护  \n* 但是会出错哦，因为 `size()` 是 `const` 函数，而 `mutex::lock()` 并非 `const` 函数。但是 `size()`为了兼容之前的代码，必须是 const 的。\n  \n#### 逻辑上 `const` 而部分成员非 `const`: `mutable`\n  \n* 我们必须为了 `mutex` 放弃声明 `size()` 为 `const` 吗？  \n  不必这样，`size()` 在逻辑上仍然应该是 `const` 的。  \n  所以，为了能让 `this` 为 `const` 时仅仅对 `m_mtx` 做特殊处理，可以声明 `mutable` 关键字修饰他，从而所有成员只有他不是 `const` 的。\n  \n~~~C++\nclass MTVector\n{\n    mutable std::mutex m_mutex;\t//\n    std::vector<int> m_arr;\n    \npublic:\n    void push_back(val)\n    {\n        m_mtx.lock();\n        m_arr.push_back(val);\n        m_mtr.unlock();\n    }\n    \n    size_t size() const\n    {\n        m_mtx.lock();\n        size_t ret = m_arr.size();\n        m_mtx.unlock();\n        return ret;\n    }\n};\n~~~\n  \n### 为什么需要读写锁\n  \n实际上我们**读的时候可以共享**，但是写的时候不能共享，**写必须独占**，因为写一半被读取可能会读到错误的数据。\n  \n所以就有了读写锁，读写情况有三种：\n  \n* n 个人读，没有写入  \n* 1 个人写入，没有读取  \n* 没有读取，也没有写入\n  \n### `shared_mutex` —— 读写锁\n  \n~~~c++\nclass MTVector\n{\n    mutable std::shared_mutex m_mutex;\t//\n    std::vector<int> m_arr;\n    \npublic:\n    void push_back(val)\n    {\n        m_mtx.lock();\n        m_arr.push_back(val);\n        m_mtr.unlock();\n    }\n    \n    size_t size() const\n    {\n        m_mtx.lock_shared();\n        size_t ret = m_arr.size();\n        m_mtx.unlock_shared();\n        return ret;\n    }\n};\n~~~\n  \n* 在上锁时，指定需求是 **读** 或者 **写**，负责调度的读写锁会帮助我们 判断是否需要等待。  \n* `push_back` 是写，所以使用 `lock` 和 `unlock`  \n* `size` 是读，使用 `lock_shared` 和 `unlock_shared`\n  \n### `std::shared_lock` : 符合 RAII 思想的 `lock_shared()`\n  \n* 我们用 `std::unique_lock` 封装 `lock()` 和 `unlock()`  \n  对应的，`std::shared_lock` 封装了 `lock_shared()` 和 `unlock_shared()`  \n* `shared_lock` 也支持 `defer_lock` 做参数，`owns_lock()` 判断等等。\n  \n~~~C++\nclass MTVector\n{\n    mutable std::shared_mutex m_mutex;\t//\n    std::vector<int> m_arr;\n    \npublic:\n    void push_back(val)\n    {\n        std::unique_lock<std::shared_mutex>grd(m_mtx);\t// 注意这里是 unique_lock\n        m_arr.push_back(val);\n    }\n    \n    size_t size() const\n    {\n        std::shared_lock grd(m_mtx);\t// 注意这里是 shared_lock\n        size_t ret = m_arr.size();\n        return ret;\n    }\n};\n~~~\n  \n### 只需一次性上锁，且符合 RAII 思想：访问者模式\n  \n~~~c++\nclass MTVector\n{\n    std::vector<int> m_arr;\n    std::mutex m_mtx;\n    \npublic:\n    class Accessor\n    {\n    \tMTVector &m_that;\n        std::unique_lock<std::mutex> m_guard;\n        \n    public:\n        Accessor(MTVector &that)\n            : m_that(that), m_guard(that.m_mtx)\n        {\n        \n        }\n        \n        void push_back(int val) const\n        {\n            return m_that.m_arr.push_back(val);\n        }\n        \n        size_t size() const\n        {\n            return m_that.m_arr.size();\n        }\n    };\n    \n    Accessor access()\n    {\n        return {*this};\n    }\n};\n~~~\n  \n* Accessor access() 将 `MTVector` 的 `this` 指针作为 Access 构造函数的参数  \n* 因为多次上锁解锁是存在性能消耗的\n  \n如果使用 shared_mutex  \n~~~C++\nclass MTVector\n{\n    std::vector<int> m_arr;\n    std::shared_mutex m_mtx;\n    \npublic:\n    class Accessor\n    {\n    \tMTVector &m_that;\n        std::unique_lock<std::shared_mutex> m_guard;\n        \n    public:\n        Accessor(MTVector &that)\n            : m_that(that), m_guard(that.m_mtx)\n        {\n        \n        }\n        \n        void push_back(int val) const\n        {\n            return m_that.m_arr.push_back(val);\n        }\n    };\n    \n    class ConstAccessor\n    {\n    \tMTVector &m_that;\n        std::shared_lock<std::shared_mutex> m_guard;\n        \n    public:\n        Accessor(MTVector &that)\n            : m_that(that), m_guard(that.m_mtx)\n        {\n        \n        }\n        \n        size_t size() const\n        {\n            return m_that.m_arr.size();\n        }\n    };\n    \n    Accessor access()\n    {\n        return {*this};\n    }\n    \n    ConstAccessor const_access()\n    {\n        return {*this};\n    }\n};\n~~~\n  \n## 条件变量\n  \n之前的互斥量更多的是防止数据竞争  \n而条件变量就类似他的名字，更多的是一个条件，只有条件发生了，这个线程才会继续执行。\n  \n### 条件变量：等待被唤醒\n  \n~~~C++\nint main()\n{\n    std::condition_variable cv;\n    std:;mutex mtx;\n    \n    std::thread t1([&]{\n        std::unique_lock<std::mutex>lck(mtx);\n        cv.wait(lck);\n        \n        std::cout << \"T1 is awake.\" << std::endl;\n    });\n    \n    std::this_thread::sleep_for(std::chrono::millionseconds(400));\n    \n    std::cout << \"Notifying ...\" << std::endl;\n    cv.notify_one();\n    \n    t1.join();\n    return 0;\n}\n~~~\n  \n* `cv.wait(lck)` 将会让当前线程陷入等待。  \n* 在其他线程中调用 `cv.notify_one()` 则会唤醒那个陷入等待的线程。  \n* `std::condition_variable` 必须和 `std:unique_lock<std::mutex>` 一起使用\n  \n### 条件变量：等待某一变量成真\n  \n~~~c++\nint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    bool ready = false;\n    \n    std::thread t1([&]{\n        std::unique_lock<std::mutex> lck(mtx);\n        cv.wait(lck, [&] { return ready});\n        lck.unlock();\n        \n        std::cout << \"T1 is awake.\" << std::endl;\n    });\n    \n    std::cout << \"Notifying not ready!\" << std::endl;\n    cv.notify_one();\n    \n        \n    ready = true;\n    std::cout << \"Notifying ready\" << std::endl;\n    cv.notify_one();\n    \n    t1.join();\n    return 0;\n}\n~~~\n  \n* `cv.wait(lck, expr)` 中 `expr` 是一个 lambda 表达式。  \n  只有返回值为 true 时才会被唤醒，否则继续等待。\n  \n### 条件变量：多个等待者\n  \n~~~C++\nint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    \n    std::thread t1([&] {\n        std::unique_lock<std::mutex> lck(mtx);\n        cv.wait(lck);\n        std::cout << \"T1 is awake!\" << std::endl;\n    });\n    \n    std::condition_variable cv;\n    std::mutex mtx;\n    \n    std::thread t2([&] {\n        std::unique_lock<std::mutex> lck(mtx);\n        cv.wait(lck);\n        std::cout << \"T2 is awake!\" << std::endl;\n    });\n    \n    std::condition_variable cv;\n    std::mutex mtx;\n    \n    std::thread t3([&] {\n        std::unique_lock<std::mutex> lck(mtx);\n        cv.wait(lck);\n        std::cout << \"T3 is awake!\" << std::endl;\n    });\n    \n    std::this_thread::sleep_for(std::chrono::millionseconds(400));\n    \n    std::cout << \"Notify One\" << std::endl;\n    cv.notify_one();\t// awake t1 only\n    \n    std::this_thread::sleep_for(std::chrono::millionseconds(400));\n    \n    std::cout << \"Notify One\" << std::endl;\n    cv.notify_all();\t// awake t2 and t3\n    \n    t1.join();\n    t2.join();\n    t3.join();\n}\n~~~\n  \n* `cv.notify_one()` 只会唤醒其中一个等待的线程，而 `cv.notify_all()` 会唤醒全部。  \n* 这就是为什么 `wait()` 需要有个 `unique_lock` 作为参数，因为要保证多个线程同时唤醒时只有一个可以被启动。如果不需要这个锁，在 `wait()` 返回后调用 `lck.unlock()` 即可。  \n* `wait()` 的过程中会暂时 `unlock()` 这个锁。\n  \n### 实例：实现生产者-消费者模式\n  \n~~~c++\nint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    \n    std::vector<int> foods;\n    \n    std::thread t1([&] {\n        std::unique_lock<std::mutex> lck(mtx);\n        \n        cv.wait(lck, [&]{\n            return foods.size() != 0;\n        });\n        \n        auto food = foods.back();\n        foods.pop_back();\n        lck.unlock();\n        \n        std::cout << \"T1 get food: \" << food << std::endl;\n    });\n    \n    \n    std::thread t2([&] {\n        std::unique_lock<std::mutex> lck(mtx);\n        \n        cv.wait(lck, [&]{\n            return foods.size() != 0;\n        });\n        \n        auto food = foods.back();\n        foods.pop_back();\n        lck.unlock();\n        \n        std::cout << \"T2 get food: \" << food << std::endl;\n    });\n    \n    foods.push_back(42);\n    cv.notify_one();\n    foods.push_back(422);\n    cv.notify_one();\n    \n    foods.push_back(66);\n    foods.push_back(92);\n    cv.notify_all();\n    \n    t1.join();\n    t2.join();\n    \n    return 0;\n}\n~~~\n  \n### `std::condition_variable` tips\n  \n1. `std::condition_variable` 仅支持 `std::unique_lock<std::mutex>` 作为参数，如果需要其他类型的 mutex，使用 `std::condition_variable_any`  \n2. 其还有 `wait_for()` 和 `wait_until()` 分别接受 chrono 的时间段和时间点\n  \n## 原子操作\n  \n### 经典案例：多个线程修改同一个计数器\n  \n~~~c++\nint main()\n{\n    int counter = 0;\n    \n    std::thread t1([&] {\n        for(int i=0;i<100;i++)\n        {\n            counter += 1;\n        }\n    });\n    \n    std::thread t2([&] {\n        for(int i=0;i<100;i++)\n        {\n            counter += 1;\n        }\n    });\n    \n    t1.join();\n    t2.join();\n    std::cout << counter<< std::endl;\n    return 0;\n}\n~~~\n  \n这里即便是简单的 +1 操作也会冲突，因为对于 CPU 而言会是多个指令，执行时会发生冲突。\n  \n如果我们的操作不是原子的，就会造成数据冲入或者写入/读取错误。\n  \n#### 暴力解决：mutex 上锁\n  \n* 能解决，但是这样操作系统来进行线程调度，会进入**内核态**再回到用户态，这样切换，有很大的开销。  \n* 归根结底就是 mutex 太昂贵了\n  \n#### 建议使用 atomic：有专门的硬件指令加持\n  \n~~~C++\nint main()\n{\n    std::atomic<int> counter = 0;\n    \n    std::thread t1([&] {\n        for(int i=0;i<100;i++)\n        {\n            counter += 1;\n        }\n    });\n    \n    std::thread t2([&] {\n        for(int i=0;i<100;i++)\n        {\n            counter += 1;\n        }\n    });\n    \n    t1.join();\n    t2.join();\n    std::cout << counter<< std::endl;\n    return 0;\n}\n~~~\n  \n* atomic 对 += 等操作会转换为专门的指令  \n* CPU 识别到对应的指令会锁住内存总线，放弃乱序执行的优化，强制同步之前的内存操作，保证操作的原子性。  \n* 注意，对 += 和 ++ 原子，但是分开写 c = c + 1 就不可以了\n  \n### fetch_add：和 += 等价 \n  \n* `fetch_add` : +=  \n* `store ` : =  \n* `load` 读取 `int` 值\n  \n### fetch_add 能够返回旧值\n  \n* 先 fetch 一个旧值，然后再 add  \n* 这个特点使其可以**并行地往一个列表追加数据**\n  \n### exchange：读取的同时写入\n  \n先取出来，然后再写入\n  \n### compare_exchange_strong\n  \n读取，比较是否相等，相等则写入\n  \n`counter.compare_exchange_strong(cmp,val)` counter 和 cmp 比，相等就写入val值  ","source":"_posts/C++11之多线程.md","raw":"---\ntitle: C++11 多线程\ndate: 2023-08-21 20:24:22\ntags: \ntypora-root-url: ./..\n---\n  \n[小彭老师](https://www.bilibili.com/video/BV1Ya411q7y4/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=1fa1b82383f6efb8a2632316da9afad0)\n  \n之前一直没有系统学过，最近心里也很乱，听一下小彭老师然后自己整理了一些。\n  \n<!--more-->\n  \n# Multithreading\n  \n## Time\n  \n### C++11 标准库：`std::chrono`\n  \n* 利用 C++ 强类型的特点，明确 **时间点** 和 **时间段**，区分不同的**时间单位**。\n  \n* 时间点：2023年8月22日 21点38分54秒\n  \n* 时间段：2分20秒\n  \n* 时间点类型：`chrono::steady_clock::time_pointer` 等\n  \n* 时间段类型：`chrono::milliseconds`, `chrono::seconds`, `chrono::minutes` 等等。  \n  ~~~C++  \n  auto t0 = chrono::stready_clock::now();\t\t// 当前时间点  \n  auto t1 = t0 + chrono::seconds(30);\t\t\t// 当前时间30s后  \n  auto dt = t1 - t0;\t\t// 两个时间点的差，时间段  \n  int64_t sec = chrono::duration_cast<chrono::seconds>(dt).count();\t\t\t// 获取时间差的秒数  \n  double ms = std::chrono::duration_cast<std::chrono::duration<double, std::million>>(dt).count();  \n  ~~~\n  \n  std::chrono::duration<T, R> , 用 T 类型表示，单位为 R，单位不写默认为秒。  \n  std::chrono::second 是 std::chrono::duration<int_64> 的类型别名\n  \n#### 跨平台 sleep：`std::this_thread::sleep_for`\n  \n~~~C++\nstd::this_thread::sleep_for(std::chrono::milliseconds(480));\n~~~\n  \n* milliseconds 毫秒  \n* microseconds 微秒  \n* seconds\n  \n#### `std::this_thread::sleep_until`\n  \n睡到某个时间点  \n~~~c++\nauto t = std::chrono::steady_clock::now() + std::chrono::milliseconds(400);\nstd::this_thread::sleep_until(t);\n~~~\n  \n## Thread\n  \n* **进程**：我们的一个程序就是一个进程  \n* **线程**：线程是进程中的实体，是系统调度、分配的最小单位。  \n  进程本身不能获取 CPU 时间，而线程可以。  \n* 每个线程共享内存空间，开销较小。  \n* 每个进程拥有独立的内存空间，因此开销更大。\n  \n#### 为什么需要多线程\n  \n可以实现无阻塞的多任务程序。  \n做到程序的异步实现。\n  \n* 比如：下载器，下载一个大文件的同时还需要和用户进行交互。  \n  这个时候下载文件 和 用户交互就是一个进程的两个任务。  \n  如果不使用线程，纯串行，在下载时用户就无法操作了，只能等待下载完毕。  \n* 不用多进程是因为，进程的地址独立，进程间沟通困难，消耗资源更多。\n  \n### C++ 多线程：`std::thread`\n  \n* `std::thread` 构造函数的参数可以是任意的 lambda 表达式。  \n* 当线程启动，就会指向 lambda 里的内容。\n  \n#### 错误：找不到符号 `pthread_thread`\n  \n这是因为 `std::thread` 是基于 `pthread`的，  \n所以在 CMakeLists.txt 里链接 Threads::Threads 即可。\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.10)\n\nset(CMAKE_CXX_STANDARD 17)\n\nproject(threadDemo LANGUAGES CXX)\n\nadd_executable(threadDemo main.cpp)\n\nfind_package(Threads REQUIRED)\ntarget_link_libraries(threadDemo PUBLIC Threads::Threads)\n~~~\n  \n就是这两行：  \n`find_package(Threads REQUIRED)`  \n`target_link_libraries(threadDemo PUBLIC Threads::Threads)`\n  \n### 主线程等待子线程\n  \n在我们退出主线程时，可能子线程还未执行完毕。  \n可以使用 std::thread 类的 join() 来等待某一个进程的结束。  \n我们可以使用 joinable() 判断 thread 对象是否还对线程有管理权限。\n  \n### std::thread 的解构函数会销毁线程\n  \n* 作为 C++ 类同样遵循 RAII 思想，线程实际也是一种资源。  \n  thread 自定义了解构函数，删除了拷贝构造函数、拷贝赋值函数，但提供了移动构造函数、移动复制函数。\n  \n### 析构函数不再销毁线程：t1.detach()\n  \n调用成员函数 detach() 可以将线程和 std::thread 对象分离。  \n意味着 线程 的生命周期不再由当前 std::thread 对象管理，而在线程退出以后自动销毁自己。  \n不过这也还是会在进程结束后，自动退出，因为进程结束会调用 terminal 销毁全部线程。\n  \n### 析构函数不再销毁线程：自己构建全局线程池\n  \n如果不想，detach 后线程还未执行完毕就销毁。  \n可以自己建一个全局的线程池，创建线程就 push 进去，在程序结束前 逐个 join 即可。\n  \n~~~c++\nstd::vector<std::thread> poll;\n\nvoid func()\n{\n    std::thread t1([&]{\n        download(\"hello.zip\");\n    });\n    pool.push_back(std::move(t1));\n}\n\nint main()\n{\n    func();\n   \n    for(auto &th : pool) th.join();\n}\n~~~\n  \n#### 改进一下\n  \n~~~C++\nclass ThreadPool\n{\n    std::vector<std::thread> m_pool;\n    \npublic:\n    void push_back(std::thread thr)\n    {\n        m_pool.push_back(std::move(thr));\n    }\n    \n    ~ThreadPool()\n    {\n        for(auto &t : m_pool) t.join();\n    }\n};\n\nThreadPool tpool;\n\nvoid func()\n{\n    std::thread t1([&]{\n        download();\n    });\n    tpool.push_back(std::move(t1));\n}\n\nint main()\n{\n    func();\n    return 0;\n}\n~~~\n  \n### C++20 引入 `std::jthread`：符合 RAII 思想，解构时自动 join()\n  \n* C++ 20 的 `std::jthread` 和 `std::thread` 的不同在于，其解构函数会自动调用 join() 函数，让线程等待，直到完全执行。\n  \n## 碎碎念\n  \npython 没有线程，其实是 并发而非并行。  \nblender 也用了 怕python 而且 ui 层由OpenGL渲染出来，所以很多都是单线程会出现等待不能操作的结果。\n  \nOpenGL 和 DX12相比就是，DX12 是支持多线程的可以做到真正的并发，计算性能会提升很多。\n  \n## 异步\n  \n### `std::async`\n  \n~~~C++\nint download()\n{\n    // do something a long time\n    return 404;\n}\n\nvoid interact()\n{\n    std::string name;\n    std::cin >> name;\n    std::cout << \"Hi, \" << name << std::endl;\n}\n\nint main()\n{\n    std::future<int> fret = std::async([&]{\n        return download();\n    });\n    interact();\n    int ret = fret.get();\n    std::cout << \"Result is:\" << ret << std::endl;\n    return 0;\n}\n~~~\n  \n* `std::async` 接受一个带有返回值的 lambda，自身返回一个 `std::future` 对象。  \n  这个 future 是什么意思呢？在 `std::future<int> fret=..` 这里 fret 的返回值是 `int`，意思就是这个 int 现在还没有，但是我保证以后一定会有。   \n* 这 `async` 里的 lambda 并非立即执行，而是在后台会挂起一个线程默默执行。  \n* 最后调用 future 的 **get()** 方法，如果此时 download 还没完成，会**等待** download 完成，并获取 返回值。\n  \n#### 等待 wait\n  \n* 除了 get()，future 还有 **wait()** ，可以等待执行结束但是不会返回其值。\n  \n#### 等待一段时间：wait_for()\n  \n* 线程未结束，wait() 会无限等待。  \n* 而 wait_for() 则可以指定一个最长的等待时间，用 chrono 里的类表示单位。他会返回一个 std::future_status 表示等待是否完成。  \n* 如果超过时间还未完成，就会放弃等待，返回 `future_status::timeout`  \n* 如果线程在指定时间内执行完毕，等待就成功了，返回`future_status::ready`  \n* 同理还有 `wait_until()` 其参数是一个时间点。\n  \n#### 另一种用法：`std::launch::deferred` 做 `std::async` 的参数\n  \n* `std::async` 的第一个参数可设为 `std:;launch::deferred`，这时不会创建线程，只会把 lambda 函数体内的运算**推迟**到 future 的 get() 被调用后。  \n* 这种写法，lambda 的执行仍在主线程中，只是函数式编程上的异步，而不涉及到多线程。(可以用这个实现惰性求值(lazy evaluation) )\n  \n~~~c++\nstd::future<int> fret = std::async(std::launch::deferred, [&]{\n    return 909;\n});\n~~~\n  \n### `std::async` 的底层实现：`std::promise`\n  \n~~~C++\nint main()\n{\n    std::promise<int> pret;\n    std::thread t1([&]{\n        auto ret = download();\n        pret.set_value(ret);\n    });\n    std:::funture<int> fret = pret.get_future();\n    \n}\n~~~\n  \n* 如果不想 `std::async` 帮你自动创建线程，想要手动创建线程，可以直接用 `std::promise`  \n* 然后线程返回时，用 `set_value()` 设置返回值。  \n  在主线程中，用 `get_future()` 获取其 `std::future`对象，进一步 `get()` 可以等待并获取线程返回值。\n  \n### std::future 小贴士\n  \n* 为了符合 RAII 思想，删除了拷贝构造函数和拷贝赋值函数。  \n  如果需要浅拷贝，实现共享同一个 future 对象，可以使用 `std：：shared_future`。  \n* 如果不需要返回值，`std::async` 里的 lambda 返回类型可以为 void，但这时的 future 对象也要为 `std::future<void>`  \n* 同理有 `std::promise<void>`，但其 set_value() 不接受参数，仅仅作为同步作用，没有实际的值。\n  \n## 互斥量\n  \n### 多线程打架实例\n  \n~~~c++\nint main()\n{\n    std::vector<int> arr;\n    std::thread t1([&]{\n        for(int i = 0; i < 1000; ++i)\n        {\n            arr.push_back(1);\n        }\n    });\n    std::thread t2([&]{\n        for(int i = 0; i < 1000; ++i)\n        {\n            arr.push_back(2);\n        }\n    });\n    t1.join();\n    t2.join();\n    return 0;\n}\n~~~\n  \n* 两个线程向同一个数组里推数据导致崩溃。  \n* vector 并非 多线程安全 (MT-safe) 的容器。  \n  多个线程同时访问同一个 vector 对象会出现 **数据竞争 (data-race) **现象。\n  \n### `std::mutex` ：上锁，防止多个线程进入某一段代码\n  \n* 调用 `std::mutex` 的 `lock()` 时，会检测 `mutex` 是否已经**上锁**。  \n* 如果没有**锁定**，则对 `mutex` 进行上锁  \n* 如果已经**锁定**，则陷入等待，直到 `mutex` 被另一线程**解锁**后，才再次**上锁**。  \n* 调用 `unlock()` 则会解锁操作  \n* 这样可以保证 lock 和 unlock 之间的代码段，同一时间只有一个线程在执行，避免数据竞争。\n  \n### `std::lock_guard`: 符合 RAII 思想的锁\n  \n* 根据 RAII 思想，锁视为一种资源，上锁视为锁的获取，解锁视为锁的释放。  \n* `std::lock_guard` 就是这样的一个工具类，其构造函数会 `mtx.lock()`，解构函数会 `mtx.unlock()`。从而退出函数作用域时能够自动解锁，避免程序员忘记解锁。\n  \n~~~C++\nint main()\n{\n    std::vector<int> arr;\n    std::mutex mtx;\n    std::thread t1([&]{\n        std::lock_guard grd(mtx);\n        arr.push_back(1);\n    });\n    \n    std::thread t2([&]{\n        std::lock_guard grd(mtx);\n        arr.push_back(2);\n    });\n    \n    t1.join();\n    t2.join();\n    return 0;\n}\n~~~\n  \n但是也因为 `lock_guard`太符合 RAII 思想，导致其很死板，我们想提前 unlock 只能让他超出其作用范围。  \n为了更灵活的应用锁，就有了 `unique_lock` \n  \n### `std::unique_lock`: 符合 RAII 思想，但自由度更高\n  \n* `std::lock_guard` 严格在解构时 unlock()，但我们有时希望提前 unlock。这时就可以使用 `std::unique_lock`，他额外存储了一个 flag 表示释放已经被释放。他会在解构时检测这个 flag，如果没有释放，则调用 unlock，否则不调用。  \n* 然后可以直接调用 unique_lock 的 unlock 函数来提前解锁，但即使忘记也没关系，在超出作用域时其会自动检测一边是否需要解锁。\n  \n#### `std::unique_lock`: 用 `std::defer_lock` 作为参数\n  \n* `std::unique_lock` 的构造函数还可以有一个额外参数 `std::defer_lock`  \n* 指定此参数后，`std::unique_lock`不会在构造函数中 `mtx.lock()`了，需要后续手动 `grd.lock()` 才能上锁。  \n* 好处是，即使忘记了 `grd.unlock()` 也能够自动调用 `mtx.unlock()`\n  \n~~~C++\nint main()\n{\n    std::vector<int> arr;\n    std::mutex mtx;\n    std::thread t1([&]{\n        for(int i=0;i<10;i++)\n        {\n            std::unique_lock<std::mutex> grd(mtx);\n            arr.push_back(1);\n\t\t}\n    });\n    \n    \n    std::thread t2([&]{\n        for(int i=0;i<10;i++)\n        {\n            std::unique_lock<std::mutex>grd(mtx, std::defer_lock);\n            grd.lock();\n            arr.push_back(2);\n            // grd.unlock();\n\t\t}\n    });\n    \n    t1.join();\n    t2.join();\n    return;\n}\n~~~\n  \n### 多个对象？每个对象使用一个 mutex 即可\n  \n~~~c++\nint main()\n{\n    std::vector<int> arr1;\n    std::vector<int> arr2;\n    \n    std::mutex mtx1;\n    std::mutex mtx2;\n    \n    std::thread t1([&]{\n        for(int i = 0; i < 10; i++)\n        {\n            {\n                std::lock_guard grd(mtx1);\n            \tarr1.push_back(1);\n            }\n            \n            {\n                std::lock_guard grd(mtx2);\n                arr2.push_back(1);\n            }\n        }\n    });\n    \n    std::thread t2([&]{\n        for(int i = 0; i < 10; i++)\n        {\n            {\n                std::lock_guard grd(mtx1);\n            \tarr1.push_back(2);\n            }\n            \n            {\n                std::lock_guard grd(mtx2);\n                arr2.push_back(2);\n            }\n        }\n    });\n    \n    t1.join();\n    t2.join();\n    return;\n}\n~~~\n  \n### 如果上锁失败，却不想等待：`try_lock()`\n  \n~~~c++\nint main()\n{\n    std::mutex mtx1;\n    if(mtx1.try_lock())\n    {\n        std::cout << \"Successed!\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Failed!\" << std::endl;\n    }\n    \n    if(mtx1.try_lock())\n    {\n        std::cout << \"Successed!\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Failed!\" << std::endl;\n    }\n    \n    mtx.unlock();\n    return;\n}\n~~~\n  \n* `lock()` 如果发现 `mutex` 已经上锁的话，会等待他直到他解锁。  \n* 如果使用 `try_lock()` ，其上锁失败不会阻塞，而是直接返回 false，上锁成功会返回 true。\n  \n### `try_lock_for`\n  \n~~~C++\nint main()\n{\n    std::mutex mtx1;\n    if(mtx1.try_lock_for(std::chrono::milliseconds(500)))\n    {\n        std::cout << \"Successed!\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Failed!\" << std::endl;\n    }\n    \n    if(mtx1.try_lock_for(std::chrono::milliseconds(500)))\n    {\n        std::cout << \"Successed!\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Failed!\" << std::endl;\n    }\n    \n    mtx.unlock();\n    return;\n}\n~~~\n  \n* 在 `try_lock()` 的基础上，但是会等待一段时间。  \n* 类似的还有 `try_lock_until()`\n  \n### `std::unique_lock`: 用 `std::try_to_lock` 做参数\n  \n* 和无参数相比，它会调用 `mtx.try_lock()` 而非 `mtx.lock()`.  \n  `grd.owns_lock()` 判断是否上锁成功。\n  \n  ~~~c++  \n  int main()  \n  {  \n      std::mutex mtx;  \n      std::thread t1([&]{  \n          std::unique_lock<std::mutex>grd(mtx, std::try_to_lock);  \n          if(grd.owns_lock())  \n          {  \n              std::cout << \"Successed!\" << std::endl;  \n          }  \n          else  \n          {  \n              std::cout << \"Failed!\" << std::endl;  \n              std::this_thread::sleep_for(std::chrono::milliseconds(1000));  \n          }  \n      });\n      \n      t1.jion();  \n      t2.join();\n      \n      return 0;  \n  }  \n  ~~~\n  \n### `std::unique_lock`: `std::adopt_lock` 做参数\n  \n~~~c++\nint main()\n{\n    std::mutex mtx;\n    std::thread t1([&]{\n        std::unique_lock<std::mutex>grd(mtx);\n        std::cout << \"t1 lock the mutex\" << std::endl;\n        std::this_thread::sleep_for(std:chrono::milliseconds(1000));\n    });\n    \n    std::thread t2([&]{\n        mtx.lock();\n        std::unique_lock<std::mutex>grd(mtx, std::adopt_lock);\n        std::cout << \"t2 lock the mutex\" << std::endl;\n        std::this_thread::sleep_for(std:chrono::milliseconds(1000));\n    });\n\tt1.jion();\n    t2.join();\n    \n    return 0;\n}\n~~~\n  \n* 作用就是当我们的 mutex 已经上锁，但是我们又想使用 unique_lock / lock_guard 这种符合 RAII 思想的封装，以实现其可以自我解构，我们就在构造时使用 std::adopt_lock，就默认这个 mutex 已经上锁了。\n  \n### `std::unique_lock` 和 `std::mutex` 有相同的接口\n  \n* `std::unique_lock` 拥有 `std::mutex` 的所有成员函数：`lock()`, `unlock()`, `try_lock()`, `try_lock_for()` 等等。  \n  只是 unique_lock 会自动调用 unlock 罢了  \n* 而 `std::lock_guard` 无非是调用其构造参数中 名为 lock() 的成员函数罢了，所有我们甚至可以用 `std::unique_lock` 做 `std::lock_guard` 的构造函数参数 \n  \n* 更进一步，只要我们能有 满足 mutex 类对于成员函数的类，就可以做为 `std::lock_guard` 构造函数的参数。  \n  这种只要具有某些指定名字的成员函数，就可以判断一个类是否满足某些功能的思想，被成为 concept(概念)，相比 虚函数 和 动态多态的接口抽象，concept 能够使实现更加解耦，并且不会有性能损失。\n  \n## 死锁\n  \n### 同时锁住多个 mutex\n  \n~~~c++\nint main()\n{\n    std::mutex mtx1;\n    std::mutex mtx2;\n    \n    std:thread t1([&]{\n        for(int i = 0; i < 1000; ++i)\n        {\n            mtx1.lock();\n            mtx2.lock();\n            mtx2.unlock();\n            mtx1.unlock();\n        }\n    });\n    \n    std:thread t2([&]{\n        for(int i = 0; i < 1000; ++i)\n        {\n            mtx2.lock();\n            mtx1.lock();\n            mtx1.unlock();\n            mtx2.unlock();\n        }\n    });\n    \n    t1.jion();\n    t2.join();\n    \n    return 0;\n}\n~~~\n  \n* 因为线程是同步进行的，所以其指令不一定是同步的  \n* 可能就会：  \n  * t1锁住了mtx1  \n  * t2锁住了mtx2  \n  * t1需要锁mtx2，但是t2锁住了mtx2  \n  * t2需要锁mtx1，但是t1锁住了mtx1  \n  * t1，t2都陷入无尽的等待\n  \n#### 解决1：永远不要同时持有两个锁\n  \n* 简单粗暴的就是<u>不让一个线程同时持有两个锁</u>，分别上锁，来避免死锁\n  \n~~~c++\nint main()\n{\n    std::mutex mtx1;\n    std::mutex mtx2;\n    \n    std::thread t1([&]{\n        for(int i = 0; i < 100; i++)\n        {\n            mtx1.lock();\n            mtx1.unlock();\n            mtx2.lock();\n            mtx2.unlock();\n        }\n    });\n    \n    std::thread t2([&]{\n        for(int i = 0; i < 100; i++)\n        {\n            mtx2.lock();\n            mtx2.unlock();\n            mtx1.lock();\n            mtx1.unlock();\n        }\n    });\n    \n    t1.jion();\n    t2.join();\n    \n    return 0;\n}\n~~~\n  \n#### 解决方案2：确保双方上锁顺序一致\n  \n* 前面死锁是因为两个线程上锁的顺序不同，<u>保证双方上锁的顺序一致，即可避免死锁</u>\n  \n~~~C++\nint main()\n{\n    std::mutex mtx1;\n    std::mutex mtx2;\n    \n    std::thread t1([&]{\n        for(int i = 0; i < 100; i++)\n        {\n            mtx1.lock();\n            mtx2.lock();\n            mtx1.unlock();\n            mtx2.unlock();\n        }\n    });\n    \n    std::thread t2([&]{\n        for(int i = 0; i < 100; i++)\n        {\n            mtx1.lock();\n            mtx2.lock();\n            mtx2.unlock();\n            mtx1.unlock();\n        }\n    });\n    \n    t1.jion();\n    t2.join();\n    \n    return 0;\n}\n~~~\n  \n#### 解决方案3：使用 `std::lock` 同时对多个 mutex 上锁\n  \n* `std::lock`  接受任意个 mutex 作为参数，且保证 <u>无论任意线程中调用的顺序是否相同，都不会产生死锁问题</u>\n  \n~~~C++\nint main()\n{\n    std::mutex mtx1;\n    std::mutex mtx2;\n    \n    std::thread t1([&]{\n        for(int i = 0; i < 1000; i++)\n        {\n\t\t\tstd::lock(mtx1, mtx2);\n            mtx1.unlock();\n            mtx2.unlock();\n        }\n    });\n    \n    std::thread t2([&]{\n        for(int i = 0; i < 1000; i++)\n        {\n            std::lock(mtx2, mtx1);\n            mtx2.unlock();\n            mtx1.unlock();\n        }\n    });\n    \n    t1.join();\n    t2.join();\n    return 0;\n}\n~~~\n  \n#### `std::lock` 的 RAII 版本 : `std::scoped_lock`\n  \n* 和 `std::lock_guard` / `std::unique_lock`相对应，`std::lock` 也有 RAII 的版本 `std::scoped_lock`, 只不过其可以同时对多个 mutex 上锁。\n  \n### 同一个线程重复调用 lock() 也会造成死锁\n  \n~~~C++\nstd::mutex mtx;\n\nvoid other()\n{\n\tmtx.lock();\n    //...\n    mtx.unlock();\n}\n\nvoid func()\n{\n\tmtx.lock();\n    other();\n    mtx.unlock();\n}\n\nint main()\n{\n    func();\n    return 0;\n}\n~~~\n  \n* 这里 `func` lock了mtx，而lock之后调用 other，other 需要 mtx，陷入等待  \n  这就是 同一线程多次对同一个 mutex 进行 lock 导致死锁。\n  \n#### 解决一：other 不 lock\n  \n这种情况一定要说明 other 非线程安全的，在调用前务必保证其 mutex 已经上锁。\n  \n#### 解决二：改用 `std::recursive_mutex`\n  \n~~~C++\nstd::recursive_mutex mtx;\n\nvoid other()\n{\n\tmtx.lock();\n    //...\n    mtx.unlock();\n}\n\nvoid func()\n{\n\tmtx.lock();\n    other();\n    mtx.unlock();\n}\n\nint main()\n{\n    func();\n    return 0;\n}\n~~~\n  \n* 如果 `other` 不让改，可以用 `std::recursive_mutex`  \n  会判断是不是同一个线程 `lock()` 了多次同一个锁  \n  如果是则让计数器加1，在之后 `unlock()` 时会让计数器减1，减到0时才真正解锁。但是相比普通的 `std::mutex` 会有一定的性能损失。\n  \n* 也有 `std::recursive_timed_mutex`，如果我们需要 `try_lock_for()`\n  \n## 数据结构\n  \n### 案例：多线程使用 `std::vector`\n  \n之前提到 `vector` 是线程不安全的，会出现数据竞争(data-race)\n  \n### 封装线程安全的 `vector`\n  \n加入我们这样做：  \n~~~C++\nclass MTVector\n{\n    std::mutex m_mutex;\n    std::vector<int> m_arr;\n    \npublic:\n    void push_back(val)\n    {\n        m_mtx.lock();\n        m_arr.push_back(val);\n        m_mtr.unlock();\n    }\n    \n    size_t size() const\n    {\n        m_mtx.lock();\t//\n        size_t ret = m_arr.size();\n        m_mtx.unlock();\t//\n        return ret;\n    }\n};\n~~~\n  \n* 我们用用一个类进行简单封装，使访问都受到 `mutex` 的保护  \n* 但是会出错哦，因为 `size()` 是 `const` 函数，而 `mutex::lock()` 并非 `const` 函数。但是 `size()`为了兼容之前的代码，必须是 const 的。\n  \n#### 逻辑上 `const` 而部分成员非 `const`: `mutable`\n  \n* 我们必须为了 `mutex` 放弃声明 `size()` 为 `const` 吗？  \n  不必这样，`size()` 在逻辑上仍然应该是 `const` 的。  \n  所以，为了能让 `this` 为 `const` 时仅仅对 `m_mtx` 做特殊处理，可以声明 `mutable` 关键字修饰他，从而所有成员只有他不是 `const` 的。\n  \n~~~C++\nclass MTVector\n{\n    mutable std::mutex m_mutex;\t//\n    std::vector<int> m_arr;\n    \npublic:\n    void push_back(val)\n    {\n        m_mtx.lock();\n        m_arr.push_back(val);\n        m_mtr.unlock();\n    }\n    \n    size_t size() const\n    {\n        m_mtx.lock();\n        size_t ret = m_arr.size();\n        m_mtx.unlock();\n        return ret;\n    }\n};\n~~~\n  \n### 为什么需要读写锁\n  \n实际上我们**读的时候可以共享**，但是写的时候不能共享，**写必须独占**，因为写一半被读取可能会读到错误的数据。\n  \n所以就有了读写锁，读写情况有三种：\n  \n* n 个人读，没有写入  \n* 1 个人写入，没有读取  \n* 没有读取，也没有写入\n  \n### `shared_mutex` —— 读写锁\n  \n~~~c++\nclass MTVector\n{\n    mutable std::shared_mutex m_mutex;\t//\n    std::vector<int> m_arr;\n    \npublic:\n    void push_back(val)\n    {\n        m_mtx.lock();\n        m_arr.push_back(val);\n        m_mtr.unlock();\n    }\n    \n    size_t size() const\n    {\n        m_mtx.lock_shared();\n        size_t ret = m_arr.size();\n        m_mtx.unlock_shared();\n        return ret;\n    }\n};\n~~~\n  \n* 在上锁时，指定需求是 **读** 或者 **写**，负责调度的读写锁会帮助我们 判断是否需要等待。  \n* `push_back` 是写，所以使用 `lock` 和 `unlock`  \n* `size` 是读，使用 `lock_shared` 和 `unlock_shared`\n  \n### `std::shared_lock` : 符合 RAII 思想的 `lock_shared()`\n  \n* 我们用 `std::unique_lock` 封装 `lock()` 和 `unlock()`  \n  对应的，`std::shared_lock` 封装了 `lock_shared()` 和 `unlock_shared()`  \n* `shared_lock` 也支持 `defer_lock` 做参数，`owns_lock()` 判断等等。\n  \n~~~C++\nclass MTVector\n{\n    mutable std::shared_mutex m_mutex;\t//\n    std::vector<int> m_arr;\n    \npublic:\n    void push_back(val)\n    {\n        std::unique_lock<std::shared_mutex>grd(m_mtx);\t// 注意这里是 unique_lock\n        m_arr.push_back(val);\n    }\n    \n    size_t size() const\n    {\n        std::shared_lock grd(m_mtx);\t// 注意这里是 shared_lock\n        size_t ret = m_arr.size();\n        return ret;\n    }\n};\n~~~\n  \n### 只需一次性上锁，且符合 RAII 思想：访问者模式\n  \n~~~c++\nclass MTVector\n{\n    std::vector<int> m_arr;\n    std::mutex m_mtx;\n    \npublic:\n    class Accessor\n    {\n    \tMTVector &m_that;\n        std::unique_lock<std::mutex> m_guard;\n        \n    public:\n        Accessor(MTVector &that)\n            : m_that(that), m_guard(that.m_mtx)\n        {\n        \n        }\n        \n        void push_back(int val) const\n        {\n            return m_that.m_arr.push_back(val);\n        }\n        \n        size_t size() const\n        {\n            return m_that.m_arr.size();\n        }\n    };\n    \n    Accessor access()\n    {\n        return {*this};\n    }\n};\n~~~\n  \n* Accessor access() 将 `MTVector` 的 `this` 指针作为 Access 构造函数的参数  \n* 因为多次上锁解锁是存在性能消耗的\n  \n如果使用 shared_mutex  \n~~~C++\nclass MTVector\n{\n    std::vector<int> m_arr;\n    std::shared_mutex m_mtx;\n    \npublic:\n    class Accessor\n    {\n    \tMTVector &m_that;\n        std::unique_lock<std::shared_mutex> m_guard;\n        \n    public:\n        Accessor(MTVector &that)\n            : m_that(that), m_guard(that.m_mtx)\n        {\n        \n        }\n        \n        void push_back(int val) const\n        {\n            return m_that.m_arr.push_back(val);\n        }\n    };\n    \n    class ConstAccessor\n    {\n    \tMTVector &m_that;\n        std::shared_lock<std::shared_mutex> m_guard;\n        \n    public:\n        Accessor(MTVector &that)\n            : m_that(that), m_guard(that.m_mtx)\n        {\n        \n        }\n        \n        size_t size() const\n        {\n            return m_that.m_arr.size();\n        }\n    };\n    \n    Accessor access()\n    {\n        return {*this};\n    }\n    \n    ConstAccessor const_access()\n    {\n        return {*this};\n    }\n};\n~~~\n  \n## 条件变量\n  \n之前的互斥量更多的是防止数据竞争  \n而条件变量就类似他的名字，更多的是一个条件，只有条件发生了，这个线程才会继续执行。\n  \n### 条件变量：等待被唤醒\n  \n~~~C++\nint main()\n{\n    std::condition_variable cv;\n    std:;mutex mtx;\n    \n    std::thread t1([&]{\n        std::unique_lock<std::mutex>lck(mtx);\n        cv.wait(lck);\n        \n        std::cout << \"T1 is awake.\" << std::endl;\n    });\n    \n    std::this_thread::sleep_for(std::chrono::millionseconds(400));\n    \n    std::cout << \"Notifying ...\" << std::endl;\n    cv.notify_one();\n    \n    t1.join();\n    return 0;\n}\n~~~\n  \n* `cv.wait(lck)` 将会让当前线程陷入等待。  \n* 在其他线程中调用 `cv.notify_one()` 则会唤醒那个陷入等待的线程。  \n* `std::condition_variable` 必须和 `std:unique_lock<std::mutex>` 一起使用\n  \n### 条件变量：等待某一变量成真\n  \n~~~c++\nint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    bool ready = false;\n    \n    std::thread t1([&]{\n        std::unique_lock<std::mutex> lck(mtx);\n        cv.wait(lck, [&] { return ready});\n        lck.unlock();\n        \n        std::cout << \"T1 is awake.\" << std::endl;\n    });\n    \n    std::cout << \"Notifying not ready!\" << std::endl;\n    cv.notify_one();\n    \n        \n    ready = true;\n    std::cout << \"Notifying ready\" << std::endl;\n    cv.notify_one();\n    \n    t1.join();\n    return 0;\n}\n~~~\n  \n* `cv.wait(lck, expr)` 中 `expr` 是一个 lambda 表达式。  \n  只有返回值为 true 时才会被唤醒，否则继续等待。\n  \n### 条件变量：多个等待者\n  \n~~~C++\nint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    \n    std::thread t1([&] {\n        std::unique_lock<std::mutex> lck(mtx);\n        cv.wait(lck);\n        std::cout << \"T1 is awake!\" << std::endl;\n    });\n    \n    std::condition_variable cv;\n    std::mutex mtx;\n    \n    std::thread t2([&] {\n        std::unique_lock<std::mutex> lck(mtx);\n        cv.wait(lck);\n        std::cout << \"T2 is awake!\" << std::endl;\n    });\n    \n    std::condition_variable cv;\n    std::mutex mtx;\n    \n    std::thread t3([&] {\n        std::unique_lock<std::mutex> lck(mtx);\n        cv.wait(lck);\n        std::cout << \"T3 is awake!\" << std::endl;\n    });\n    \n    std::this_thread::sleep_for(std::chrono::millionseconds(400));\n    \n    std::cout << \"Notify One\" << std::endl;\n    cv.notify_one();\t// awake t1 only\n    \n    std::this_thread::sleep_for(std::chrono::millionseconds(400));\n    \n    std::cout << \"Notify One\" << std::endl;\n    cv.notify_all();\t// awake t2 and t3\n    \n    t1.join();\n    t2.join();\n    t3.join();\n}\n~~~\n  \n* `cv.notify_one()` 只会唤醒其中一个等待的线程，而 `cv.notify_all()` 会唤醒全部。  \n* 这就是为什么 `wait()` 需要有个 `unique_lock` 作为参数，因为要保证多个线程同时唤醒时只有一个可以被启动。如果不需要这个锁，在 `wait()` 返回后调用 `lck.unlock()` 即可。  \n* `wait()` 的过程中会暂时 `unlock()` 这个锁。\n  \n### 实例：实现生产者-消费者模式\n  \n~~~c++\nint main()\n{\n    std::condition_variable cv;\n    std::mutex mtx;\n    \n    std::vector<int> foods;\n    \n    std::thread t1([&] {\n        std::unique_lock<std::mutex> lck(mtx);\n        \n        cv.wait(lck, [&]{\n            return foods.size() != 0;\n        });\n        \n        auto food = foods.back();\n        foods.pop_back();\n        lck.unlock();\n        \n        std::cout << \"T1 get food: \" << food << std::endl;\n    });\n    \n    \n    std::thread t2([&] {\n        std::unique_lock<std::mutex> lck(mtx);\n        \n        cv.wait(lck, [&]{\n            return foods.size() != 0;\n        });\n        \n        auto food = foods.back();\n        foods.pop_back();\n        lck.unlock();\n        \n        std::cout << \"T2 get food: \" << food << std::endl;\n    });\n    \n    foods.push_back(42);\n    cv.notify_one();\n    foods.push_back(422);\n    cv.notify_one();\n    \n    foods.push_back(66);\n    foods.push_back(92);\n    cv.notify_all();\n    \n    t1.join();\n    t2.join();\n    \n    return 0;\n}\n~~~\n  \n### `std::condition_variable` tips\n  \n1. `std::condition_variable` 仅支持 `std::unique_lock<std::mutex>` 作为参数，如果需要其他类型的 mutex，使用 `std::condition_variable_any`  \n2. 其还有 `wait_for()` 和 `wait_until()` 分别接受 chrono 的时间段和时间点\n  \n## 原子操作\n  \n### 经典案例：多个线程修改同一个计数器\n  \n~~~c++\nint main()\n{\n    int counter = 0;\n    \n    std::thread t1([&] {\n        for(int i=0;i<100;i++)\n        {\n            counter += 1;\n        }\n    });\n    \n    std::thread t2([&] {\n        for(int i=0;i<100;i++)\n        {\n            counter += 1;\n        }\n    });\n    \n    t1.join();\n    t2.join();\n    std::cout << counter<< std::endl;\n    return 0;\n}\n~~~\n  \n这里即便是简单的 +1 操作也会冲突，因为对于 CPU 而言会是多个指令，执行时会发生冲突。\n  \n如果我们的操作不是原子的，就会造成数据冲入或者写入/读取错误。\n  \n#### 暴力解决：mutex 上锁\n  \n* 能解决，但是这样操作系统来进行线程调度，会进入**内核态**再回到用户态，这样切换，有很大的开销。  \n* 归根结底就是 mutex 太昂贵了\n  \n#### 建议使用 atomic：有专门的硬件指令加持\n  \n~~~C++\nint main()\n{\n    std::atomic<int> counter = 0;\n    \n    std::thread t1([&] {\n        for(int i=0;i<100;i++)\n        {\n            counter += 1;\n        }\n    });\n    \n    std::thread t2([&] {\n        for(int i=0;i<100;i++)\n        {\n            counter += 1;\n        }\n    });\n    \n    t1.join();\n    t2.join();\n    std::cout << counter<< std::endl;\n    return 0;\n}\n~~~\n  \n* atomic 对 += 等操作会转换为专门的指令  \n* CPU 识别到对应的指令会锁住内存总线，放弃乱序执行的优化，强制同步之前的内存操作，保证操作的原子性。  \n* 注意，对 += 和 ++ 原子，但是分开写 c = c + 1 就不可以了\n  \n### fetch_add：和 += 等价 \n  \n* `fetch_add` : +=  \n* `store ` : =  \n* `load` 读取 `int` 值\n  \n### fetch_add 能够返回旧值\n  \n* 先 fetch 一个旧值，然后再 add  \n* 这个特点使其可以**并行地往一个列表追加数据**\n  \n### exchange：读取的同时写入\n  \n先取出来，然后再写入\n  \n### compare_exchange_strong\n  \n读取，比较是否相等，相等则写入\n  \n`counter.compare_exchange_strong(cmp,val)` counter 和 cmp 比，相等就写入val值  ","slug":"C++11之多线程","published":1,"updated":"2024-01-14T08:13:08.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppthz0007bkbw2cwp7je5","content":"<p><a\r\nhref=\"https://www.bilibili.com/video/BV1Ya411q7y4/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0\">小彭老师</a></p>\r\n<p>之前一直没有系统学过，最近心里也很乱，听一下小彭老师然后自己整理了一些。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"multithreading\">Multithreading</h1>\r\n<h2 id=\"time\">Time</h2>\r\n<h3 id=\"c11-标准库stdchrono\">C++11 标准库：<code>std::chrono</code></h3>\r\n<ul>\r\n<li><p>利用 C++ 强类型的特点，明确 <strong>时间点</strong> 和\r\n<strong>时间段</strong>，区分不同的<strong>时间单位</strong>。</p></li>\r\n<li><p>时间点：2023年8月22日 21点38分54秒</p></li>\r\n<li><p>时间段：2分20秒</p></li>\r\n<li><p>时间点类型：<code>chrono::steady_clock::time_pointer</code>\r\n等</p></li>\r\n<li><p>时间段类型：<code>chrono::milliseconds</code>,\r\n<code>chrono::seconds</code>, <code>chrono::minutes</code> 等等。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">auto</span> t0 = chrono::stready_clock::<span class=\"hljs-built_in\">now</span>();\t\t<span class=\"hljs-comment\">// 当前时间点  </span><br><span class=\"hljs-keyword\">auto</span> t1 = t0 + chrono::<span class=\"hljs-built_in\">seconds</span>(<span class=\"hljs-number\">30</span>);\t\t\t<span class=\"hljs-comment\">// 当前时间30s后  </span><br><span class=\"hljs-keyword\">auto</span> dt = t1 - t0;\t\t<span class=\"hljs-comment\">// 两个时间点的差，时间段  </span><br><span class=\"hljs-type\">int64_t</span> sec = chrono::<span class=\"hljs-built_in\">duration_cast</span>&lt;chrono::seconds&gt;(dt).<span class=\"hljs-built_in\">count</span>();\t\t\t<span class=\"hljs-comment\">// 获取时间差的秒数  </span><br><span class=\"hljs-type\">double</span> ms = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class=\"hljs-type\">double</span>, std::million&gt;&gt;(dt).<span class=\"hljs-built_in\">count</span>();  <br></code></pre></td></tr></table></figure></p>\r\n<p>std::chrono::duration&lt;T, R&gt; , 用 T 类型表示，单位为\r\nR，单位不写默认为秒。<br />\r\nstd::chrono::second 是 std::chrono::duration<int_64> 的类型别名</p></li>\r\n</ul>\r\n<h4 id=\"跨平台-sleepstdthis_threadsleep_for\">跨平台\r\nsleep：<code>std::this_thread::sleep_for</code></h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::this_thread::<span class=\"hljs-built_in\">sleep_for</span>(std::chrono::<span class=\"hljs-built_in\">milliseconds</span>(<span class=\"hljs-number\">480</span>));<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>milliseconds 毫秒<br />\r\n</li>\r\n<li>microseconds 微秒<br />\r\n</li>\r\n<li>seconds</li>\r\n</ul>\r\n<h4\r\nid=\"stdthis_threadsleep_until\"><code>std::this_thread::sleep_until</code></h4>\r\n<p>睡到某个时间点<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> t = std::chrono::steady_clock::<span class=\"hljs-built_in\">now</span>() + std::chrono::<span class=\"hljs-built_in\">milliseconds</span>(<span class=\"hljs-number\">400</span>);<br>std::this_thread::<span class=\"hljs-built_in\">sleep_until</span>(t);<br></code></pre></td></tr></table></figure></p>\r\n<h2 id=\"thread\">Thread</h2>\r\n<ul>\r\n<li><strong>进程</strong>：我们的一个程序就是一个进程<br />\r\n</li>\r\n<li><strong>线程</strong>：线程是进程中的实体，是系统调度、分配的最小单位。<br />\r\n进程本身不能获取 CPU 时间，而线程可以。<br />\r\n</li>\r\n<li>每个线程共享内存空间，开销较小。<br />\r\n</li>\r\n<li>每个进程拥有独立的内存空间，因此开销更大。</li>\r\n</ul>\r\n<h4 id=\"为什么需要多线程\">为什么需要多线程</h4>\r\n<p>可以实现无阻塞的多任务程序。<br />\r\n做到程序的异步实现。</p>\r\n<ul>\r\n<li>比如：下载器，下载一个大文件的同时还需要和用户进行交互。<br />\r\n这个时候下载文件 和 用户交互就是一个进程的两个任务。<br />\r\n如果不使用线程，纯串行，在下载时用户就无法操作了，只能等待下载完毕。<br />\r\n</li>\r\n<li>不用多进程是因为，进程的地址独立，进程间沟通困难，消耗资源更多。</li>\r\n</ul>\r\n<h3 id=\"c-多线程stdthread\">C++ 多线程：<code>std::thread</code></h3>\r\n<ul>\r\n<li><code>std::thread</code> 构造函数的参数可以是任意的 lambda\r\n表达式。<br />\r\n</li>\r\n<li>当线程启动，就会指向 lambda 里的内容。</li>\r\n</ul>\r\n<h4 id=\"错误找不到符号-pthread_thread\">错误：找不到符号\r\n<code>pthread_thread</code></h4>\r\n<p>这是因为 <code>std::thread</code> 是基于\r\n<code>pthread</code>的，<br />\r\n所以在 CMakeLists.txt 里链接 Threads::Threads 即可。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.10</span>)<br><br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">17</span>)<br><br><span class=\"hljs-keyword\">project</span>(threadDemo LANGUAGES CXX)<br><br><span class=\"hljs-keyword\">add_executable</span>(threadDemo main.cpp)<br><br><span class=\"hljs-keyword\">find_package</span>(Threads REQUIRED)<br><span class=\"hljs-keyword\">target_link_libraries</span>(threadDemo PUBLIC Threads::Threads)<br></code></pre></td></tr></table></figure>\r\n<p>就是这两行：<br />\r\n<code>find_package(Threads REQUIRED)</code><br />\r\n<code>target_link_libraries(threadDemo PUBLIC Threads::Threads)</code></p>\r\n<h3 id=\"主线程等待子线程\">主线程等待子线程</h3>\r\n<p>在我们退出主线程时，可能子线程还未执行完毕。<br />\r\n可以使用 std::thread 类的 join() 来等待某一个进程的结束。<br />\r\n我们可以使用 joinable() 判断 thread 对象是否还对线程有管理权限。</p>\r\n<h3 id=\"stdthread-的解构函数会销毁线程\">std::thread\r\n的解构函数会销毁线程</h3>\r\n<ul>\r\n<li>作为 C++ 类同样遵循 RAII 思想，线程实际也是一种资源。<br />\r\nthread\r\n自定义了解构函数，删除了拷贝构造函数、拷贝赋值函数，但提供了移动构造函数、移动复制函数。</li>\r\n</ul>\r\n<h3\r\nid=\"析构函数不再销毁线程t1.detach\">析构函数不再销毁线程：t1.detach()</h3>\r\n<p>调用成员函数 detach() 可以将线程和 std::thread 对象分离。<br />\r\n意味着 线程 的生命周期不再由当前 std::thread\r\n对象管理，而在线程退出以后自动销毁自己。<br />\r\n不过这也还是会在进程结束后，自动退出，因为进程结束会调用 terminal\r\n销毁全部线程。</p>\r\n<h3\r\nid=\"析构函数不再销毁线程自己构建全局线程池\">析构函数不再销毁线程：自己构建全局线程池</h3>\r\n<p>如果不想，detach 后线程还未执行完毕就销毁。<br />\r\n可以自己建一个全局的线程池，创建线程就 push 进去，在程序结束前 逐个 join\r\n即可。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">std::vector&lt;std::thread&gt; poll;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        download(<span class=\"hljs-string\">&quot;hello.zip&quot;</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    pool.<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">move</span>(t1));<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">func</span>();<br>   <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> &amp;th : pool) th.<span class=\"hljs-built_in\">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"改进一下\">改进一下</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ThreadPool</span><br>&#123;<br>    std::vector&lt;std::thread&gt; m_pool;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(std::thread thr)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_pool.<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">move</span>(thr));<br>    &#125;<br>    <br>    ~<span class=\"hljs-built_in\">ThreadPool</span>()<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> &amp;t : m_pool) t.<span class=\"hljs-built_in\">join</span>();<br>    &#125;<br>&#125;;<br><br>ThreadPool tpool;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        download();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    tpool.<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">move</span>(t1));<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">func</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"c20-引入-stdjthread符合-raii-思想解构时自动-join\">C++20 引入\r\n<code>std::jthread</code>：符合 RAII 思想，解构时自动 join()</h3>\r\n<ul>\r\n<li>C++ 20 的 <code>std::jthread</code> 和 <code>std::thread</code>\r\n的不同在于，其解构函数会自动调用 join()\r\n函数，让线程等待，直到完全执行。</li>\r\n</ul>\r\n<h2 id=\"碎碎念\">碎碎念</h2>\r\n<p>python 没有线程，其实是 并发而非并行。<br />\r\nblender 也用了 怕python 而且 ui\r\n层由OpenGL渲染出来，所以很多都是单线程会出现等待不能操作的结果。</p>\r\n<p>OpenGL 和 DX12相比就是，DX12\r\n是支持多线程的可以做到真正的并发，计算性能会提升很多。</p>\r\n<h2 id=\"异步\">异步</h2>\r\n<h3 id=\"stdasync\"><code>std::async</code></h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">download</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// do something a long time</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">404</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">interact</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::string name;<br>    std::cin &gt;&gt; name;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hi, &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::future&lt;<span class=\"hljs-type\">int</span>&gt; fret = std::<span class=\"hljs-built_in\">async</span>([&amp;]&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">download</span>();<br>    &#125;);<br>    <span class=\"hljs-built_in\">interact</span>();<br>    <span class=\"hljs-type\">int</span> ret = fret.<span class=\"hljs-built_in\">get</span>();<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Result is:&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><code>std::async</code> 接受一个带有返回值的 lambda，自身返回一个\r\n<code>std::future</code> 对象。<br />\r\n这个 future 是什么意思呢？在 <code>std::future&lt;int&gt; fret=..</code>\r\n这里 fret 的返回值是 <code>int</code>，意思就是这个 int\r\n现在还没有，但是我保证以后一定会有。<br />\r\n</li>\r\n<li>这 <code>async</code> 里的 lambda\r\n并非立即执行，而是在后台会挂起一个线程默默执行。<br />\r\n</li>\r\n<li>最后调用 future 的 <strong>get()</strong> 方法，如果此时 download\r\n还没完成，会<strong>等待</strong> download 完成，并获取 返回值。</li>\r\n</ul>\r\n<h4 id=\"等待-wait\">等待 wait</h4>\r\n<ul>\r\n<li>除了 get()，future 还有 <strong>wait()</strong>\r\n，可以等待执行结束但是不会返回其值。</li>\r\n</ul>\r\n<h4 id=\"等待一段时间wait_for\">等待一段时间：wait_for()</h4>\r\n<ul>\r\n<li>线程未结束，wait() 会无限等待。<br />\r\n</li>\r\n<li>而 wait_for() 则可以指定一个最长的等待时间，用 chrono\r\n里的类表示单位。他会返回一个 std::future_status 表示等待是否完成。<br />\r\n</li>\r\n<li>如果超过时间还未完成，就会放弃等待，返回\r\n<code>future_status::timeout</code><br />\r\n</li>\r\n<li>如果线程在指定时间内执行完毕，等待就成功了，返回<code>future_status::ready</code><br />\r\n</li>\r\n<li>同理还有 <code>wait_until()</code> 其参数是一个时间点。</li>\r\n</ul>\r\n<h4\r\nid=\"另一种用法stdlaunchdeferred-做-stdasync-的参数\">另一种用法：<code>std::launch::deferred</code>\r\n做 <code>std::async</code> 的参数</h4>\r\n<ul>\r\n<li><code>std::async</code> 的第一个参数可设为\r\n<code>std:;launch::deferred</code>，这时不会创建线程，只会把 lambda\r\n函数体内的运算<strong>推迟</strong>到 future 的 get() 被调用后。<br />\r\n</li>\r\n<li>这种写法，lambda\r\n的执行仍在主线程中，只是函数式编程上的异步，而不涉及到多线程。(可以用这个实现惰性求值(lazy\r\nevaluation) )</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">std::future&lt;<span class=\"hljs-type\">int</span>&gt; fret = std::<span class=\"hljs-built_in\">async</span>(std::launch::deferred, [&amp;]&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">909</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"stdasync-的底层实现stdpromise\"><code>std::async</code>\r\n的底层实现：<code>std::promise</code></h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::promise&lt;<span class=\"hljs-type\">int</span>&gt; pret;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">auto</span> ret = download();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        pret.set_value(ret);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    std:::funture&lt;<span class=\"hljs-type\">int</span>&gt; fret = pret.<span class=\"hljs-built_in\">get_future</span>();<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>如果不想 <code>std::async</code>\r\n帮你自动创建线程，想要手动创建线程，可以直接用\r\n<code>std::promise</code><br />\r\n</li>\r\n<li>然后线程返回时，用 <code>set_value()</code> 设置返回值。<br />\r\n在主线程中，用 <code>get_future()</code> 获取其\r\n<code>std::future</code>对象，进一步 <code>get()</code>\r\n可以等待并获取线程返回值。</li>\r\n</ul>\r\n<h3 id=\"stdfuture-小贴士\">std::future 小贴士</h3>\r\n<ul>\r\n<li>为了符合 RAII 思想，删除了拷贝构造函数和拷贝赋值函数。<br />\r\n如果需要浅拷贝，实现共享同一个 future 对象，可以使用\r\n<code>std：：shared_future</code>。<br />\r\n</li>\r\n<li>如果不需要返回值，<code>std::async</code> 里的 lambda 返回类型可以为\r\nvoid，但这时的 future 对象也要为\r\n<code>std::future&lt;void&gt;</code><br />\r\n</li>\r\n<li>同理有 <code>std::promise&lt;void&gt;</code>，但其 set_value()\r\n不接受参数，仅仅作为同步作用，没有实际的值。</li>\r\n</ul>\r\n<h2 id=\"互斥量\">互斥量</h2>\r\n<h3 id=\"多线程打架实例\">多线程打架实例</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; arr;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; ++i)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            arr.push_back(<span class=\"hljs-number\">1</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; ++i)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            arr.push_back(<span class=\"hljs-number\">2</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>两个线程向同一个数组里推数据导致崩溃。<br />\r\n</li>\r\n<li>vector 并非 多线程安全 (MT-safe) 的容器。<br />\r\n多个线程同时访问同一个 vector 对象会出现 <strong>数据竞争 (data-race)\r\n</strong>现象。</li>\r\n</ul>\r\n<h3 id=\"stdmutex-上锁防止多个线程进入某一段代码\"><code>std::mutex</code>\r\n：上锁，防止多个线程进入某一段代码</h3>\r\n<ul>\r\n<li>调用 <code>std::mutex</code> 的 <code>lock()</code> 时，会检测\r\n<code>mutex</code> 是否已经<strong>上锁</strong>。<br />\r\n</li>\r\n<li>如果没有<strong>锁定</strong>，则对 <code>mutex</code>\r\n进行上锁<br />\r\n</li>\r\n<li>如果已经<strong>锁定</strong>，则陷入等待，直到 <code>mutex</code>\r\n被另一线程<strong>解锁</strong>后，才再次<strong>上锁</strong>。<br />\r\n</li>\r\n<li>调用 <code>unlock()</code> 则会解锁操作<br />\r\n</li>\r\n<li>这样可以保证 lock 和 unlock\r\n之间的代码段，同一时间只有一个线程在执行，避免数据竞争。</li>\r\n</ul>\r\n<h3 id=\"stdlock_guard-符合-raii-思想的锁\"><code>std::lock_guard</code>:\r\n符合 RAII 思想的锁</h3>\r\n<ul>\r\n<li>根据 RAII\r\n思想，锁视为一种资源，上锁视为锁的获取，解锁视为锁的释放。<br />\r\n</li>\r\n<li><code>std::lock_guard</code> 就是这样的一个工具类，其构造函数会\r\n<code>mtx.lock()</code>，解构函数会\r\n<code>mtx.unlock()</code>。从而退出函数作用域时能够自动解锁，避免程序员忘记解锁。</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; arr;<br>    std::mutex mtx;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::lock_guard grd(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        arr.push_back(<span class=\"hljs-number\">1</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::lock_guard grd(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        arr.push_back(<span class=\"hljs-number\">2</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>但是也因为 <code>lock_guard</code>太符合 RAII\r\n思想，导致其很死板，我们想提前 unlock 只能让他超出其作用范围。<br />\r\n为了更灵活的应用锁，就有了 <code>unique_lock</code></p>\r\n<h3\r\nid=\"stdunique_lock-符合-raii-思想但自由度更高\"><code>std::unique_lock</code>:\r\n符合 RAII 思想，但自由度更高</h3>\r\n<ul>\r\n<li><code>std::lock_guard</code> 严格在解构时\r\nunlock()，但我们有时希望提前 unlock。这时就可以使用\r\n<code>std::unique_lock</code>，他额外存储了一个 flag\r\n表示释放已经被释放。他会在解构时检测这个 flag，如果没有释放，则调用\r\nunlock，否则不调用。<br />\r\n</li>\r\n<li>然后可以直接调用 unique_lock 的 unlock\r\n函数来提前解锁，但即使忘记也没关系，在超出作用域时其会自动检测一边是否需要解锁。</li>\r\n</ul>\r\n<h4\r\nid=\"stdunique_lock-用-stddefer_lock-作为参数\"><code>std::unique_lock</code>:\r\n用 <code>std::defer_lock</code> 作为参数</h4>\r\n<ul>\r\n<li><code>std::unique_lock</code> 的构造函数还可以有一个额外参数\r\n<code>std::defer_lock</code><br />\r\n</li>\r\n<li>指定此参数后，<code>std::unique_lock</code>不会在构造函数中\r\n<code>mtx.lock()</code>了，需要后续手动 <code>grd.lock()</code>\r\n才能上锁。<br />\r\n</li>\r\n<li>好处是，即使忘记了 <code>grd.unlock()</code> 也能够自动调用\r\n<code>mtx.unlock()</code></li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; arr;<br>    std::mutex mtx;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">10</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::unique_lock&lt;std::mutex&gt; grd(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            arr.push_back(<span class=\"hljs-number\">1</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t&#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">10</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::unique_lock&lt;std::mutex&gt;grd(mtx, std::defer_lock);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            grd.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            arr.push_back(<span class=\"hljs-number\">2</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            <span class=\"hljs-comment\">// grd.unlock();</span></span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t&#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"多个对象每个对象使用一个-mutex-即可\">多个对象？每个对象使用一个\r\nmutex 即可</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; arr1;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; arr2;<br>    <br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                std::lock_guard grd(mtx1);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            \tarr1.push_back(<span class=\"hljs-number\">1</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                std::lock_guard grd(mtx2);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                arr2.push_back(<span class=\"hljs-number\">1</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                std::lock_guard grd(mtx1);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            \tarr1.push_back(<span class=\"hljs-number\">2</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                std::lock_guard grd(mtx2);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                arr2.push_back(<span class=\"hljs-number\">2</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"如果上锁失败却不想等待try_lock\">如果上锁失败，却不想等待：<code>try_lock()</code></h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    <span class=\"hljs-keyword\">if</span>(mtx1.<span class=\"hljs-built_in\">try_lock</span>())<br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">if</span>(mtx1.<span class=\"hljs-built_in\">try_lock</span>())<br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><code>lock()</code> 如果发现 <code>mutex</code>\r\n已经上锁的话，会等待他直到他解锁。<br />\r\n</li>\r\n<li>如果使用 <code>try_lock()</code> ，其上锁失败不会阻塞，而是直接返回\r\nfalse，上锁成功会返回 true。</li>\r\n</ul>\r\n<h3 id=\"try_lock_for\"><code>try_lock_for</code></h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    <span class=\"hljs-keyword\">if</span>(mtx1.<span class=\"hljs-built_in\">try_lock_for</span>(std::chrono::<span class=\"hljs-built_in\">milliseconds</span>(<span class=\"hljs-number\">500</span>)))<br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">if</span>(mtx1.<span class=\"hljs-built_in\">try_lock_for</span>(std::chrono::<span class=\"hljs-built_in\">milliseconds</span>(<span class=\"hljs-number\">500</span>)))<br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>在 <code>try_lock()</code> 的基础上，但是会等待一段时间。<br />\r\n</li>\r\n<li>类似的还有 <code>try_lock_until()</code></li>\r\n</ul>\r\n<h3\r\nid=\"stdunique_lock-用-stdtry_to_lock-做参数\"><code>std::unique_lock</code>:\r\n用 <code>std::try_to_lock</code> 做参数</h3>\r\n<ul>\r\n<li><p>和无参数相比，它会调用 <code>mtx.try_lock()</code> 而非\r\n<code>mtx.lock()</code>.<br />\r\n<code>grd.owns_lock()</code> 判断是否上锁成功。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    std::mutex mtx;  <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt;grd(mtx, std::try_to_lock);  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">if</span>(grd.owns_lock())  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Successed!&quot;</span> &lt;&lt; std::endl;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">else</span>  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed!&quot;</span> &lt;&lt; std::endl;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class=\"hljs-number\">1000</span>));  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">jion</span>();  <br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3\r\nid=\"stdunique_lock-stdadopt_lock-做参数\"><code>std::unique_lock</code>:\r\n<code>std::adopt_lock</code> 做参数</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt;grd(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;t1 lock the mutex&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::this_thread::sleep_for(std:chrono::milliseconds(<span class=\"hljs-number\">1000</span>));</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        mtx.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt;grd(mtx, std::adopt_lock);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;t2 lock the mutex&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::this_thread::sleep_for(std:chrono::milliseconds(<span class=\"hljs-number\">1000</span>));</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>\tt1.<span class=\"hljs-built_in\">jion</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>作用就是当我们的 mutex 已经上锁，但是我们又想使用 unique_lock /\r\nlock_guard 这种符合 RAII\r\n思想的封装，以实现其可以自我解构，我们就在构造时使用\r\nstd::adopt_lock，就默认这个 mutex 已经上锁了。</li>\r\n</ul>\r\n<h3\r\nid=\"stdunique_lock-和-stdmutex-有相同的接口\"><code>std::unique_lock</code>\r\n和 <code>std::mutex</code> 有相同的接口</h3>\r\n<ul>\r\n<li><p><code>std::unique_lock</code> 拥有 <code>std::mutex</code>\r\n的所有成员函数：<code>lock()</code>, <code>unlock()</code>,\r\n<code>try_lock()</code>, <code>try_lock_for()</code> 等等。<br />\r\n只是 unique_lock 会自动调用 unlock 罢了<br />\r\n</p></li>\r\n<li><p>而 <code>std::lock_guard</code> 无非是调用其构造参数中 名为\r\nlock() 的成员函数罢了，所有我们甚至可以用 <code>std::unique_lock</code>\r\n做 <code>std::lock_guard</code> 的构造函数参数</p></li>\r\n<li><p>更进一步，只要我们能有 满足 mutex 类对于成员函数的类，就可以做为\r\n<code>std::lock_guard</code> 构造函数的参数。<br />\r\n这种只要具有某些指定名字的成员函数，就可以判断一个类是否满足某些功能的思想，被成为\r\nconcept(概念)，相比 虚函数 和 动态多态的接口抽象，concept\r\n能够使实现更加解耦，并且不会有性能损失。</p></li>\r\n</ul>\r\n<h2 id=\"死锁\">死锁</h2>\r\n<h3 id=\"同时锁住多个-mutex\">同时锁住多个 mutex</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    std:<span class=\"hljs-function\">thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; ++i)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std:<span class=\"hljs-function\">thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; ++i)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">jion</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>因为线程是同步进行的，所以其指令不一定是同步的<br />\r\n</li>\r\n<li>可能就会：\r\n<ul>\r\n<li>t1锁住了mtx1<br />\r\n</li>\r\n<li>t2锁住了mtx2<br />\r\n</li>\r\n<li>t1需要锁mtx2，但是t2锁住了mtx2<br />\r\n</li>\r\n<li>t2需要锁mtx1，但是t1锁住了mtx1<br />\r\n</li>\r\n<li>t1，t2都陷入无尽的等待</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"解决1永远不要同时持有两个锁\">解决1：永远不要同时持有两个锁</h4>\r\n<ul>\r\n<li>简单粗暴的就是<u>不让一个线程同时持有两个锁</u>，分别上锁，来避免死锁</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">jion</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4\r\nid=\"解决方案2确保双方上锁顺序一致\">解决方案2：确保双方上锁顺序一致</h4>\r\n<ul>\r\n<li>前面死锁是因为两个线程上锁的顺序不同，<u>保证双方上锁的顺序一致，即可避免死锁</u></li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">jion</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"解决方案3使用-stdlock-同时对多个-mutex-上锁\">解决方案3：使用\r\n<code>std::lock</code> 同时对多个 mutex 上锁</h4>\r\n<ul>\r\n<li><code>std::lock</code> 接受任意个 mutex 作为参数，且保证\r\n<u>无论任意线程中调用的顺序是否相同，都不会产生死锁问题</u></li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t\tstd::lock(mtx1, mtx2);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::lock(mtx2, mtx1);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"stdlock-的-raii-版本-stdscoped_lock\"><code>std::lock</code> 的\r\nRAII 版本 : <code>std::scoped_lock</code></h4>\r\n<ul>\r\n<li>和 <code>std::lock_guard</code> /\r\n<code>std::unique_lock</code>相对应，<code>std::lock</code> 也有 RAII\r\n的版本 <code>std::scoped_lock</code>, 只不过其可以同时对多个 mutex\r\n上锁。</li>\r\n</ul>\r\n<h3 id=\"同一个线程重复调用-lock-也会造成死锁\">同一个线程重复调用 lock()\r\n也会造成死锁</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::mutex mtx;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">other</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmtx.<span class=\"hljs-built_in\">lock</span>();<br>    <span class=\"hljs-comment\">//...</span><br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmtx.<span class=\"hljs-built_in\">lock</span>();<br>    <span class=\"hljs-built_in\">other</span>();<br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">func</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>这里 <code>func</code> lock了mtx，而lock之后调用 other，other 需要\r\nmtx，陷入等待<br />\r\n这就是 同一线程多次对同一个 mutex 进行 lock 导致死锁。</li>\r\n</ul>\r\n<h4 id=\"解决一other-不-lock\">解决一：other 不 lock</h4>\r\n<p>这种情况一定要说明 other 非线程安全的，在调用前务必保证其 mutex\r\n已经上锁。</p>\r\n<h4 id=\"解决二改用-stdrecursive_mutex\">解决二：改用\r\n<code>std::recursive_mutex</code></h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::recursive_mutex mtx;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">other</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmtx.<span class=\"hljs-built_in\">lock</span>();<br>    <span class=\"hljs-comment\">//...</span><br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmtx.<span class=\"hljs-built_in\">lock</span>();<br>    <span class=\"hljs-built_in\">other</span>();<br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">func</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><p>如果 <code>other</code> 不让改，可以用\r\n<code>std::recursive_mutex</code><br />\r\n会判断是不是同一个线程 <code>lock()</code> 了多次同一个锁<br />\r\n如果是则让计数器加1，在之后 <code>unlock()</code>\r\n时会让计数器减1，减到0时才真正解锁。但是相比普通的\r\n<code>std::mutex</code> 会有一定的性能损失。</p></li>\r\n<li><p>也有 <code>std::recursive_timed_mutex</code>，如果我们需要\r\n<code>try_lock_for()</code></p></li>\r\n</ul>\r\n<h2 id=\"数据结构\">数据结构</h2>\r\n<h3 id=\"案例多线程使用-stdvector\">案例：多线程使用\r\n<code>std::vector</code></h3>\r\n<p>之前提到 <code>vector</code>\r\n是线程不安全的，会出现数据竞争(data-race)</p>\r\n<h3 id=\"封装线程安全的-vector\">封装线程安全的 <code>vector</code></h3>\r\n<p>加入我们这样做：<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    std::mutex m_mutex;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(val)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock</span>();<br>        m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>        m_mtr.<span class=\"hljs-built_in\">unlock</span>();<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock</span>();\t<span class=\"hljs-comment\">//</span><br>        <span class=\"hljs-type\">size_t</span> ret = m_arr.<span class=\"hljs-built_in\">size</span>();<br>        m_mtx.<span class=\"hljs-built_in\">unlock</span>();\t<span class=\"hljs-comment\">//</span><br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>我们用用一个类进行简单封装，使访问都受到 <code>mutex</code>\r\n的保护<br />\r\n</li>\r\n<li>但是会出错哦，因为 <code>size()</code> 是 <code>const</code>\r\n函数，而 <code>mutex::lock()</code> 并非 <code>const</code> 函数。但是\r\n<code>size()</code>为了兼容之前的代码，必须是 const 的。</li>\r\n</ul>\r\n<h4 id=\"逻辑上-const-而部分成员非-const-mutable\">逻辑上\r\n<code>const</code> 而部分成员非 <code>const</code>:\r\n<code>mutable</code></h4>\r\n<ul>\r\n<li>我们必须为了 <code>mutex</code> 放弃声明 <code>size()</code> 为\r\n<code>const</code> 吗？<br />\r\n不必这样，<code>size()</code> 在逻辑上仍然应该是 <code>const</code>\r\n的。<br />\r\n所以，为了能让 <code>this</code> 为 <code>const</code> 时仅仅对\r\n<code>m_mtx</code> 做特殊处理，可以声明 <code>mutable</code>\r\n关键字修饰他，从而所有成员只有他不是 <code>const</code> 的。</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    <span class=\"hljs-keyword\">mutable</span> std::mutex m_mutex;\t<span class=\"hljs-comment\">//</span><br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(val)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock</span>();<br>        m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>        m_mtr.<span class=\"hljs-built_in\">unlock</span>();<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock</span>();<br>        <span class=\"hljs-type\">size_t</span> ret = m_arr.<span class=\"hljs-built_in\">size</span>();<br>        m_mtx.<span class=\"hljs-built_in\">unlock</span>();<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"为什么需要读写锁\">为什么需要读写锁</h3>\r\n<p>实际上我们<strong>读的时候可以共享</strong>，但是写的时候不能共享，<strong>写必须独占</strong>，因为写一半被读取可能会读到错误的数据。</p>\r\n<p>所以就有了读写锁，读写情况有三种：</p>\r\n<ul>\r\n<li>n 个人读，没有写入<br />\r\n</li>\r\n<li>1 个人写入，没有读取<br />\r\n</li>\r\n<li>没有读取，也没有写入</li>\r\n</ul>\r\n<h3 id=\"shared_mutex-读写锁\"><code>shared_mutex</code> —— 读写锁</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    <span class=\"hljs-keyword\">mutable</span> std::shared_mutex m_mutex;\t<span class=\"hljs-comment\">//</span><br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(val)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock</span>();<br>        m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>        m_mtr.<span class=\"hljs-built_in\">unlock</span>();<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock_shared</span>();<br>        <span class=\"hljs-type\">size_t</span> ret = m_arr.<span class=\"hljs-built_in\">size</span>();<br>        m_mtx.<span class=\"hljs-built_in\">unlock_shared</span>();<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>在上锁时，指定需求是 <strong>读</strong> 或者\r\n<strong>写</strong>，负责调度的读写锁会帮助我们 判断是否需要等待。<br />\r\n</li>\r\n<li><code>push_back</code> 是写，所以使用 <code>lock</code> 和\r\n<code>unlock</code><br />\r\n</li>\r\n<li><code>size</code> 是读，使用 <code>lock_shared</code> 和\r\n<code>unlock_shared</code></li>\r\n</ul>\r\n<h3\r\nid=\"stdshared_lock-符合-raii-思想的-lock_shared\"><code>std::shared_lock</code>\r\n: 符合 RAII 思想的 <code>lock_shared()</code></h3>\r\n<ul>\r\n<li>我们用 <code>std::unique_lock</code> 封装 <code>lock()</code> 和\r\n<code>unlock()</code><br />\r\n对应的，<code>std::shared_lock</code> 封装了 <code>lock_shared()</code>\r\n和 <code>unlock_shared()</code><br />\r\n</li>\r\n<li><code>shared_lock</code> 也支持 <code>defer_lock</code>\r\n做参数，<code>owns_lock()</code> 判断等等。</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    <span class=\"hljs-keyword\">mutable</span> std::shared_mutex m_mutex;\t<span class=\"hljs-comment\">//</span><br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(val)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::unique_lock&lt;std::shared_mutex&gt;<span class=\"hljs-built_in\">grd</span>(m_mtx);\t<span class=\"hljs-comment\">// 注意这里是 unique_lock</span><br>        m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-function\">std::shared_lock <span class=\"hljs-title\">grd</span><span class=\"hljs-params\">(m_mtx)</span></span>;\t<span class=\"hljs-comment\">// 注意这里是 shared_lock</span><br>        <span class=\"hljs-type\">size_t</span> ret = m_arr.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"只需一次性上锁且符合-raii-思想访问者模式\">只需一次性上锁，且符合\r\nRAII 思想：访问者模式</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    std::mutex m_mtx;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Accessor</span><br>    &#123;<br>    \tMTVector &amp;m_that;<br>        std::unique_lock&lt;std::mutex&gt; m_guard;<br>        <br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-built_in\">Accessor</span>(MTVector &amp;that)<br>            : <span class=\"hljs-built_in\">m_that</span>(that), <span class=\"hljs-built_in\">m_guard</span>(that.m_mtx)<br>        &#123;<br>        <br>        &#125;<br>        <br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> val)</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">        </span>&#123;<br>            <span class=\"hljs-keyword\">return</span> m_that.m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>        &#125;<br>        <br>        <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">        </span>&#123;<br>            <span class=\"hljs-keyword\">return</span> m_that.m_arr.<span class=\"hljs-built_in\">size</span>();<br>        &#125;<br>    &#125;;<br>    <br>    <span class=\"hljs-function\">Accessor <span class=\"hljs-title\">access</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;*<span class=\"hljs-keyword\">this</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>Accessor access() 将 <code>MTVector</code> 的 <code>this</code>\r\n指针作为 Access 构造函数的参数<br />\r\n</li>\r\n<li>因为多次上锁解锁是存在性能消耗的</li>\r\n</ul>\r\n<p>如果使用 shared_mutex<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    std::shared_mutex m_mtx;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Accessor</span><br>    &#123;<br>    \tMTVector &amp;m_that;<br>        std::unique_lock&lt;std::shared_mutex&gt; m_guard;<br>        <br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-built_in\">Accessor</span>(MTVector &amp;that)<br>            : <span class=\"hljs-built_in\">m_that</span>(that), <span class=\"hljs-built_in\">m_guard</span>(that.m_mtx)<br>        &#123;<br>        <br>        &#125;<br>        <br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> val)</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">        </span>&#123;<br>            <span class=\"hljs-keyword\">return</span> m_that.m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>        &#125;<br>    &#125;;<br>    <br>    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConstAccessor</span><br>    &#123;<br>    \tMTVector &amp;m_that;<br>        std::shared_lock&lt;std::shared_mutex&gt; m_guard;<br>        <br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-built_in\">Accessor</span>(MTVector &amp;that)<br>            : <span class=\"hljs-built_in\">m_that</span>(that), <span class=\"hljs-built_in\">m_guard</span>(that.m_mtx)<br>        &#123;<br>        <br>        &#125;<br>        <br>        <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">        </span>&#123;<br>            <span class=\"hljs-keyword\">return</span> m_that.m_arr.<span class=\"hljs-built_in\">size</span>();<br>        &#125;<br>    &#125;;<br>    <br>    <span class=\"hljs-function\">Accessor <span class=\"hljs-title\">access</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;*<span class=\"hljs-keyword\">this</span>&#125;;<br>    &#125;<br>    <br>    <span class=\"hljs-function\">ConstAccessor <span class=\"hljs-title\">const_access</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;*<span class=\"hljs-keyword\">this</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<h2 id=\"条件变量\">条件变量</h2>\r\n<p>之前的互斥量更多的是防止数据竞争<br />\r\n而条件变量就类似他的名字，更多的是一个条件，只有条件发生了，这个线程才会继续执行。</p>\r\n<h3 id=\"条件变量等待被唤醒\">条件变量：等待被唤醒</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::condition_variable cv;<br>    std:;mutex mtx;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt;lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T1 is awake.&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std::this_thread::<span class=\"hljs-built_in\">sleep_for</span>(std::chrono::<span class=\"hljs-built_in\">millionseconds</span>(<span class=\"hljs-number\">400</span>));<br>    <br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Notifying ...&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><code>cv.wait(lck)</code> 将会让当前线程陷入等待。<br />\r\n</li>\r\n<li>在其他线程中调用 <code>cv.notify_one()</code>\r\n则会唤醒那个陷入等待的线程。<br />\r\n</li>\r\n<li><code>std::condition_variable</code> 必须和\r\n<code>std:unique_lock&lt;std::mutex&gt;</code> 一起使用</li>\r\n</ul>\r\n<h3 id=\"条件变量等待某一变量成真\">条件变量：等待某一变量成真</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <span class=\"hljs-type\">bool</span> ready = <span class=\"hljs-literal\">false</span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck, [&amp;] &#123; <span class=\"hljs-keyword\">return</span> ready&#125;);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        lck.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T1 is awake.&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Notifying not ready!&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();<br>    <br>        <br>    ready = <span class=\"hljs-literal\">true</span>;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Notifying ready&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><code>cv.wait(lck, expr)</code> 中 <code>expr</code> 是一个 lambda\r\n表达式。<br />\r\n只有返回值为 true 时才会被唤醒，否则继续等待。</li>\r\n</ul>\r\n<h3 id=\"条件变量多个等待者\">条件变量：多个等待者</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T1 is awake!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T2 is awake!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t3</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T3 is awake!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std::this_thread::<span class=\"hljs-built_in\">sleep_for</span>(std::chrono::<span class=\"hljs-built_in\">millionseconds</span>(<span class=\"hljs-number\">400</span>));<br>    <br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Notify One&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();\t<span class=\"hljs-comment\">// awake t1 only</span><br>    <br>    std::this_thread::<span class=\"hljs-built_in\">sleep_for</span>(std::chrono::<span class=\"hljs-built_in\">millionseconds</span>(<span class=\"hljs-number\">400</span>));<br>    <br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Notify One&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class=\"hljs-built_in\">notify_all</span>();\t<span class=\"hljs-comment\">// awake t2 and t3</span><br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    t3.<span class=\"hljs-built_in\">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><code>cv.notify_one()</code> 只会唤醒其中一个等待的线程，而\r\n<code>cv.notify_all()</code> 会唤醒全部。<br />\r\n</li>\r\n<li>这就是为什么 <code>wait()</code> 需要有个 <code>unique_lock</code>\r\n作为参数，因为要保证多个线程同时唤醒时只有一个可以被启动。如果不需要这个锁，在\r\n<code>wait()</code> 返回后调用 <code>lck.unlock()</code> 即可。<br />\r\n</li>\r\n<li><code>wait()</code> 的过程中会暂时 <code>unlock()</code>\r\n这个锁。</li>\r\n</ul>\r\n<h3 id=\"实例实现生产者-消费者模式\">实例：实现生产者-消费者模式</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; foods;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck, [&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            <span class=\"hljs-keyword\">return</span> foods.size() != <span class=\"hljs-number\">0</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">auto</span> food = foods.back();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        foods.pop_back();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        lck.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T1 get food: &quot;</span> &lt;&lt; food &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck, [&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            <span class=\"hljs-keyword\">return</span> foods.size() != <span class=\"hljs-number\">0</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">auto</span> food = foods.back();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        foods.pop_back();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        lck.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T2 get food: &quot;</span> &lt;&lt; food &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    foods.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">42</span>);<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();<br>    foods.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">422</span>);<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();<br>    <br>    foods.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">66</span>);<br>    foods.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">92</span>);<br>    cv.<span class=\"hljs-built_in\">notify_all</span>();<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"stdcondition_variable-tips\"><code>std::condition_variable</code>\r\ntips</h3>\r\n<ol type=\"1\">\r\n<li><code>std::condition_variable</code> 仅支持\r\n<code>std::unique_lock&lt;std::mutex&gt;</code>\r\n作为参数，如果需要其他类型的 mutex，使用\r\n<code>std::condition_variable_any</code><br />\r\n</li>\r\n<li>其还有 <code>wait_for()</code> 和 <code>wait_until()</code> 分别接受\r\nchrono 的时间段和时间点</li>\r\n</ol>\r\n<h2 id=\"原子操作\">原子操作</h2>\r\n<h3\r\nid=\"经典案例多个线程修改同一个计数器\">经典案例：多个线程修改同一个计数器</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> counter = <span class=\"hljs-number\">0</span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            counter += <span class=\"hljs-number\">1</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            counter += <span class=\"hljs-number\">1</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    std::cout &lt;&lt; counter&lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>这里即便是简单的 +1 操作也会冲突，因为对于 CPU\r\n而言会是多个指令，执行时会发生冲突。</p>\r\n<p>如果我们的操作不是原子的，就会造成数据冲入或者写入/读取错误。</p>\r\n<h4 id=\"暴力解决mutex-上锁\">暴力解决：mutex 上锁</h4>\r\n<ul>\r\n<li>能解决，但是这样操作系统来进行线程调度，会进入<strong>内核态</strong>再回到用户态，这样切换，有很大的开销。<br />\r\n</li>\r\n<li>归根结底就是 mutex 太昂贵了</li>\r\n</ul>\r\n<h4 id=\"建议使用-atomic有专门的硬件指令加持\">建议使用\r\natomic：有专门的硬件指令加持</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::atomic&lt;<span class=\"hljs-type\">int</span>&gt; counter = <span class=\"hljs-number\">0</span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            counter += <span class=\"hljs-number\">1</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            counter += <span class=\"hljs-number\">1</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    std::cout &lt;&lt; counter&lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>atomic 对 += 等操作会转换为专门的指令<br />\r\n</li>\r\n<li>CPU\r\n识别到对应的指令会锁住内存总线，放弃乱序执行的优化，强制同步之前的内存操作，保证操作的原子性。<br />\r\n</li>\r\n<li>注意，对 += 和 ++ 原子，但是分开写 c = c + 1 就不可以了</li>\r\n</ul>\r\n<h3 id=\"fetch_add和-等价\">fetch_add：和 += 等价</h3>\r\n<ul>\r\n<li><code>fetch_add</code> : +=<br />\r\n</li>\r\n<li><code>store</code> : =<br />\r\n</li>\r\n<li><code>load</code> 读取 <code>int</code> 值</li>\r\n</ul>\r\n<h3 id=\"fetch_add-能够返回旧值\">fetch_add 能够返回旧值</h3>\r\n<ul>\r\n<li>先 fetch 一个旧值，然后再 add<br />\r\n</li>\r\n<li>这个特点使其可以<strong>并行地往一个列表追加数据</strong></li>\r\n</ul>\r\n<h3 id=\"exchange读取的同时写入\">exchange：读取的同时写入</h3>\r\n<p>先取出来，然后再写入</p>\r\n<h3 id=\"compare_exchange_strong\">compare_exchange_strong</h3>\r\n<p>读取，比较是否相等，相等则写入</p>\r\n<p><code>counter.compare_exchange_strong(cmp,val)</code> counter 和 cmp\r\n比，相等就写入val值</p>\r\n","site":{"data":{}},"excerpt":"<p><a\r\nhref=\"https://www.bilibili.com/video/BV1Ya411q7y4/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0\">小彭老师</a></p>\r\n<p>之前一直没有系统学过，最近心里也很乱，听一下小彭老师然后自己整理了一些。</p>","more":"<h1 id=\"multithreading\">Multithreading</h1>\r\n<h2 id=\"time\">Time</h2>\r\n<h3 id=\"c11-标准库stdchrono\">C++11 标准库：<code>std::chrono</code></h3>\r\n<ul>\r\n<li><p>利用 C++ 强类型的特点，明确 <strong>时间点</strong> 和\r\n<strong>时间段</strong>，区分不同的<strong>时间单位</strong>。</p></li>\r\n<li><p>时间点：2023年8月22日 21点38分54秒</p></li>\r\n<li><p>时间段：2分20秒</p></li>\r\n<li><p>时间点类型：<code>chrono::steady_clock::time_pointer</code>\r\n等</p></li>\r\n<li><p>时间段类型：<code>chrono::milliseconds</code>,\r\n<code>chrono::seconds</code>, <code>chrono::minutes</code> 等等。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">auto</span> t0 = chrono::stready_clock::<span class=\"hljs-built_in\">now</span>();\t\t<span class=\"hljs-comment\">// 当前时间点  </span><br><span class=\"hljs-keyword\">auto</span> t1 = t0 + chrono::<span class=\"hljs-built_in\">seconds</span>(<span class=\"hljs-number\">30</span>);\t\t\t<span class=\"hljs-comment\">// 当前时间30s后  </span><br><span class=\"hljs-keyword\">auto</span> dt = t1 - t0;\t\t<span class=\"hljs-comment\">// 两个时间点的差，时间段  </span><br><span class=\"hljs-type\">int64_t</span> sec = chrono::<span class=\"hljs-built_in\">duration_cast</span>&lt;chrono::seconds&gt;(dt).<span class=\"hljs-built_in\">count</span>();\t\t\t<span class=\"hljs-comment\">// 获取时间差的秒数  </span><br><span class=\"hljs-type\">double</span> ms = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class=\"hljs-type\">double</span>, std::million&gt;&gt;(dt).<span class=\"hljs-built_in\">count</span>();  <br></code></pre></td></tr></table></figure></p>\r\n<p>std::chrono::duration&lt;T, R&gt; , 用 T 类型表示，单位为\r\nR，单位不写默认为秒。<br />\r\nstd::chrono::second 是 std::chrono::duration<int_64> 的类型别名</p></li>\r\n</ul>\r\n<h4 id=\"跨平台-sleepstdthis_threadsleep_for\">跨平台\r\nsleep：<code>std::this_thread::sleep_for</code></h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::this_thread::<span class=\"hljs-built_in\">sleep_for</span>(std::chrono::<span class=\"hljs-built_in\">milliseconds</span>(<span class=\"hljs-number\">480</span>));<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>milliseconds 毫秒<br />\r\n</li>\r\n<li>microseconds 微秒<br />\r\n</li>\r\n<li>seconds</li>\r\n</ul>\r\n<h4\r\nid=\"stdthis_threadsleep_until\"><code>std::this_thread::sleep_until</code></h4>\r\n<p>睡到某个时间点<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> t = std::chrono::steady_clock::<span class=\"hljs-built_in\">now</span>() + std::chrono::<span class=\"hljs-built_in\">milliseconds</span>(<span class=\"hljs-number\">400</span>);<br>std::this_thread::<span class=\"hljs-built_in\">sleep_until</span>(t);<br></code></pre></td></tr></table></figure></p>\r\n<h2 id=\"thread\">Thread</h2>\r\n<ul>\r\n<li><strong>进程</strong>：我们的一个程序就是一个进程<br />\r\n</li>\r\n<li><strong>线程</strong>：线程是进程中的实体，是系统调度、分配的最小单位。<br />\r\n进程本身不能获取 CPU 时间，而线程可以。<br />\r\n</li>\r\n<li>每个线程共享内存空间，开销较小。<br />\r\n</li>\r\n<li>每个进程拥有独立的内存空间，因此开销更大。</li>\r\n</ul>\r\n<h4 id=\"为什么需要多线程\">为什么需要多线程</h4>\r\n<p>可以实现无阻塞的多任务程序。<br />\r\n做到程序的异步实现。</p>\r\n<ul>\r\n<li>比如：下载器，下载一个大文件的同时还需要和用户进行交互。<br />\r\n这个时候下载文件 和 用户交互就是一个进程的两个任务。<br />\r\n如果不使用线程，纯串行，在下载时用户就无法操作了，只能等待下载完毕。<br />\r\n</li>\r\n<li>不用多进程是因为，进程的地址独立，进程间沟通困难，消耗资源更多。</li>\r\n</ul>\r\n<h3 id=\"c-多线程stdthread\">C++ 多线程：<code>std::thread</code></h3>\r\n<ul>\r\n<li><code>std::thread</code> 构造函数的参数可以是任意的 lambda\r\n表达式。<br />\r\n</li>\r\n<li>当线程启动，就会指向 lambda 里的内容。</li>\r\n</ul>\r\n<h4 id=\"错误找不到符号-pthread_thread\">错误：找不到符号\r\n<code>pthread_thread</code></h4>\r\n<p>这是因为 <code>std::thread</code> 是基于\r\n<code>pthread</code>的，<br />\r\n所以在 CMakeLists.txt 里链接 Threads::Threads 即可。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.10</span>)<br><br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">17</span>)<br><br><span class=\"hljs-keyword\">project</span>(threadDemo LANGUAGES CXX)<br><br><span class=\"hljs-keyword\">add_executable</span>(threadDemo main.cpp)<br><br><span class=\"hljs-keyword\">find_package</span>(Threads REQUIRED)<br><span class=\"hljs-keyword\">target_link_libraries</span>(threadDemo PUBLIC Threads::Threads)<br></code></pre></td></tr></table></figure>\r\n<p>就是这两行：<br />\r\n<code>find_package(Threads REQUIRED)</code><br />\r\n<code>target_link_libraries(threadDemo PUBLIC Threads::Threads)</code></p>\r\n<h3 id=\"主线程等待子线程\">主线程等待子线程</h3>\r\n<p>在我们退出主线程时，可能子线程还未执行完毕。<br />\r\n可以使用 std::thread 类的 join() 来等待某一个进程的结束。<br />\r\n我们可以使用 joinable() 判断 thread 对象是否还对线程有管理权限。</p>\r\n<h3 id=\"stdthread-的解构函数会销毁线程\">std::thread\r\n的解构函数会销毁线程</h3>\r\n<ul>\r\n<li>作为 C++ 类同样遵循 RAII 思想，线程实际也是一种资源。<br />\r\nthread\r\n自定义了解构函数，删除了拷贝构造函数、拷贝赋值函数，但提供了移动构造函数、移动复制函数。</li>\r\n</ul>\r\n<h3\r\nid=\"析构函数不再销毁线程t1.detach\">析构函数不再销毁线程：t1.detach()</h3>\r\n<p>调用成员函数 detach() 可以将线程和 std::thread 对象分离。<br />\r\n意味着 线程 的生命周期不再由当前 std::thread\r\n对象管理，而在线程退出以后自动销毁自己。<br />\r\n不过这也还是会在进程结束后，自动退出，因为进程结束会调用 terminal\r\n销毁全部线程。</p>\r\n<h3\r\nid=\"析构函数不再销毁线程自己构建全局线程池\">析构函数不再销毁线程：自己构建全局线程池</h3>\r\n<p>如果不想，detach 后线程还未执行完毕就销毁。<br />\r\n可以自己建一个全局的线程池，创建线程就 push 进去，在程序结束前 逐个 join\r\n即可。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">std::vector&lt;std::thread&gt; poll;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        download(<span class=\"hljs-string\">&quot;hello.zip&quot;</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    pool.<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">move</span>(t1));<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">func</span>();<br>   <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> &amp;th : pool) th.<span class=\"hljs-built_in\">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"改进一下\">改进一下</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ThreadPool</span><br>&#123;<br>    std::vector&lt;std::thread&gt; m_pool;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(std::thread thr)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_pool.<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">move</span>(thr));<br>    &#125;<br>    <br>    ~<span class=\"hljs-built_in\">ThreadPool</span>()<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> &amp;t : m_pool) t.<span class=\"hljs-built_in\">join</span>();<br>    &#125;<br>&#125;;<br><br>ThreadPool tpool;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        download();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    tpool.<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">move</span>(t1));<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">func</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"c20-引入-stdjthread符合-raii-思想解构时自动-join\">C++20 引入\r\n<code>std::jthread</code>：符合 RAII 思想，解构时自动 join()</h3>\r\n<ul>\r\n<li>C++ 20 的 <code>std::jthread</code> 和 <code>std::thread</code>\r\n的不同在于，其解构函数会自动调用 join()\r\n函数，让线程等待，直到完全执行。</li>\r\n</ul>\r\n<h2 id=\"碎碎念\">碎碎念</h2>\r\n<p>python 没有线程，其实是 并发而非并行。<br />\r\nblender 也用了 怕python 而且 ui\r\n层由OpenGL渲染出来，所以很多都是单线程会出现等待不能操作的结果。</p>\r\n<p>OpenGL 和 DX12相比就是，DX12\r\n是支持多线程的可以做到真正的并发，计算性能会提升很多。</p>\r\n<h2 id=\"异步\">异步</h2>\r\n<h3 id=\"stdasync\"><code>std::async</code></h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">download</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// do something a long time</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">404</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">interact</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::string name;<br>    std::cin &gt;&gt; name;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hi, &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::future&lt;<span class=\"hljs-type\">int</span>&gt; fret = std::<span class=\"hljs-built_in\">async</span>([&amp;]&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">download</span>();<br>    &#125;);<br>    <span class=\"hljs-built_in\">interact</span>();<br>    <span class=\"hljs-type\">int</span> ret = fret.<span class=\"hljs-built_in\">get</span>();<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Result is:&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><code>std::async</code> 接受一个带有返回值的 lambda，自身返回一个\r\n<code>std::future</code> 对象。<br />\r\n这个 future 是什么意思呢？在 <code>std::future&lt;int&gt; fret=..</code>\r\n这里 fret 的返回值是 <code>int</code>，意思就是这个 int\r\n现在还没有，但是我保证以后一定会有。<br />\r\n</li>\r\n<li>这 <code>async</code> 里的 lambda\r\n并非立即执行，而是在后台会挂起一个线程默默执行。<br />\r\n</li>\r\n<li>最后调用 future 的 <strong>get()</strong> 方法，如果此时 download\r\n还没完成，会<strong>等待</strong> download 完成，并获取 返回值。</li>\r\n</ul>\r\n<h4 id=\"等待-wait\">等待 wait</h4>\r\n<ul>\r\n<li>除了 get()，future 还有 <strong>wait()</strong>\r\n，可以等待执行结束但是不会返回其值。</li>\r\n</ul>\r\n<h4 id=\"等待一段时间wait_for\">等待一段时间：wait_for()</h4>\r\n<ul>\r\n<li>线程未结束，wait() 会无限等待。<br />\r\n</li>\r\n<li>而 wait_for() 则可以指定一个最长的等待时间，用 chrono\r\n里的类表示单位。他会返回一个 std::future_status 表示等待是否完成。<br />\r\n</li>\r\n<li>如果超过时间还未完成，就会放弃等待，返回\r\n<code>future_status::timeout</code><br />\r\n</li>\r\n<li>如果线程在指定时间内执行完毕，等待就成功了，返回<code>future_status::ready</code><br />\r\n</li>\r\n<li>同理还有 <code>wait_until()</code> 其参数是一个时间点。</li>\r\n</ul>\r\n<h4\r\nid=\"另一种用法stdlaunchdeferred-做-stdasync-的参数\">另一种用法：<code>std::launch::deferred</code>\r\n做 <code>std::async</code> 的参数</h4>\r\n<ul>\r\n<li><code>std::async</code> 的第一个参数可设为\r\n<code>std:;launch::deferred</code>，这时不会创建线程，只会把 lambda\r\n函数体内的运算<strong>推迟</strong>到 future 的 get() 被调用后。<br />\r\n</li>\r\n<li>这种写法，lambda\r\n的执行仍在主线程中，只是函数式编程上的异步，而不涉及到多线程。(可以用这个实现惰性求值(lazy\r\nevaluation) )</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">std::future&lt;<span class=\"hljs-type\">int</span>&gt; fret = std::<span class=\"hljs-built_in\">async</span>(std::launch::deferred, [&amp;]&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">909</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"stdasync-的底层实现stdpromise\"><code>std::async</code>\r\n的底层实现：<code>std::promise</code></h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::promise&lt;<span class=\"hljs-type\">int</span>&gt; pret;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">auto</span> ret = download();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        pret.set_value(ret);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    std:::funture&lt;<span class=\"hljs-type\">int</span>&gt; fret = pret.<span class=\"hljs-built_in\">get_future</span>();<br>    <br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>如果不想 <code>std::async</code>\r\n帮你自动创建线程，想要手动创建线程，可以直接用\r\n<code>std::promise</code><br />\r\n</li>\r\n<li>然后线程返回时，用 <code>set_value()</code> 设置返回值。<br />\r\n在主线程中，用 <code>get_future()</code> 获取其\r\n<code>std::future</code>对象，进一步 <code>get()</code>\r\n可以等待并获取线程返回值。</li>\r\n</ul>\r\n<h3 id=\"stdfuture-小贴士\">std::future 小贴士</h3>\r\n<ul>\r\n<li>为了符合 RAII 思想，删除了拷贝构造函数和拷贝赋值函数。<br />\r\n如果需要浅拷贝，实现共享同一个 future 对象，可以使用\r\n<code>std：：shared_future</code>。<br />\r\n</li>\r\n<li>如果不需要返回值，<code>std::async</code> 里的 lambda 返回类型可以为\r\nvoid，但这时的 future 对象也要为\r\n<code>std::future&lt;void&gt;</code><br />\r\n</li>\r\n<li>同理有 <code>std::promise&lt;void&gt;</code>，但其 set_value()\r\n不接受参数，仅仅作为同步作用，没有实际的值。</li>\r\n</ul>\r\n<h2 id=\"互斥量\">互斥量</h2>\r\n<h3 id=\"多线程打架实例\">多线程打架实例</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; arr;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; ++i)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            arr.push_back(<span class=\"hljs-number\">1</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; ++i)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            arr.push_back(<span class=\"hljs-number\">2</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>两个线程向同一个数组里推数据导致崩溃。<br />\r\n</li>\r\n<li>vector 并非 多线程安全 (MT-safe) 的容器。<br />\r\n多个线程同时访问同一个 vector 对象会出现 <strong>数据竞争 (data-race)\r\n</strong>现象。</li>\r\n</ul>\r\n<h3 id=\"stdmutex-上锁防止多个线程进入某一段代码\"><code>std::mutex</code>\r\n：上锁，防止多个线程进入某一段代码</h3>\r\n<ul>\r\n<li>调用 <code>std::mutex</code> 的 <code>lock()</code> 时，会检测\r\n<code>mutex</code> 是否已经<strong>上锁</strong>。<br />\r\n</li>\r\n<li>如果没有<strong>锁定</strong>，则对 <code>mutex</code>\r\n进行上锁<br />\r\n</li>\r\n<li>如果已经<strong>锁定</strong>，则陷入等待，直到 <code>mutex</code>\r\n被另一线程<strong>解锁</strong>后，才再次<strong>上锁</strong>。<br />\r\n</li>\r\n<li>调用 <code>unlock()</code> 则会解锁操作<br />\r\n</li>\r\n<li>这样可以保证 lock 和 unlock\r\n之间的代码段，同一时间只有一个线程在执行，避免数据竞争。</li>\r\n</ul>\r\n<h3 id=\"stdlock_guard-符合-raii-思想的锁\"><code>std::lock_guard</code>:\r\n符合 RAII 思想的锁</h3>\r\n<ul>\r\n<li>根据 RAII\r\n思想，锁视为一种资源，上锁视为锁的获取，解锁视为锁的释放。<br />\r\n</li>\r\n<li><code>std::lock_guard</code> 就是这样的一个工具类，其构造函数会\r\n<code>mtx.lock()</code>，解构函数会\r\n<code>mtx.unlock()</code>。从而退出函数作用域时能够自动解锁，避免程序员忘记解锁。</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; arr;<br>    std::mutex mtx;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::lock_guard grd(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        arr.push_back(<span class=\"hljs-number\">1</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::lock_guard grd(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        arr.push_back(<span class=\"hljs-number\">2</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>但是也因为 <code>lock_guard</code>太符合 RAII\r\n思想，导致其很死板，我们想提前 unlock 只能让他超出其作用范围。<br />\r\n为了更灵活的应用锁，就有了 <code>unique_lock</code></p>\r\n<h3\r\nid=\"stdunique_lock-符合-raii-思想但自由度更高\"><code>std::unique_lock</code>:\r\n符合 RAII 思想，但自由度更高</h3>\r\n<ul>\r\n<li><code>std::lock_guard</code> 严格在解构时\r\nunlock()，但我们有时希望提前 unlock。这时就可以使用\r\n<code>std::unique_lock</code>，他额外存储了一个 flag\r\n表示释放已经被释放。他会在解构时检测这个 flag，如果没有释放，则调用\r\nunlock，否则不调用。<br />\r\n</li>\r\n<li>然后可以直接调用 unique_lock 的 unlock\r\n函数来提前解锁，但即使忘记也没关系，在超出作用域时其会自动检测一边是否需要解锁。</li>\r\n</ul>\r\n<h4\r\nid=\"stdunique_lock-用-stddefer_lock-作为参数\"><code>std::unique_lock</code>:\r\n用 <code>std::defer_lock</code> 作为参数</h4>\r\n<ul>\r\n<li><code>std::unique_lock</code> 的构造函数还可以有一个额外参数\r\n<code>std::defer_lock</code><br />\r\n</li>\r\n<li>指定此参数后，<code>std::unique_lock</code>不会在构造函数中\r\n<code>mtx.lock()</code>了，需要后续手动 <code>grd.lock()</code>\r\n才能上锁。<br />\r\n</li>\r\n<li>好处是，即使忘记了 <code>grd.unlock()</code> 也能够自动调用\r\n<code>mtx.unlock()</code></li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; arr;<br>    std::mutex mtx;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">10</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::unique_lock&lt;std::mutex&gt; grd(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            arr.push_back(<span class=\"hljs-number\">1</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t&#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">10</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::unique_lock&lt;std::mutex&gt;grd(mtx, std::defer_lock);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            grd.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            arr.push_back(<span class=\"hljs-number\">2</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            <span class=\"hljs-comment\">// grd.unlock();</span></span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t&#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"多个对象每个对象使用一个-mutex-即可\">多个对象？每个对象使用一个\r\nmutex 即可</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; arr1;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; arr2;<br>    <br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                std::lock_guard grd(mtx1);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            \tarr1.push_back(<span class=\"hljs-number\">1</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                std::lock_guard grd(mtx2);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                arr2.push_back(<span class=\"hljs-number\">1</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                std::lock_guard grd(mtx1);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            \tarr1.push_back(<span class=\"hljs-number\">2</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                std::lock_guard grd(mtx2);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                arr2.push_back(<span class=\"hljs-number\">2</span>);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"如果上锁失败却不想等待try_lock\">如果上锁失败，却不想等待：<code>try_lock()</code></h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    <span class=\"hljs-keyword\">if</span>(mtx1.<span class=\"hljs-built_in\">try_lock</span>())<br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">if</span>(mtx1.<span class=\"hljs-built_in\">try_lock</span>())<br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><code>lock()</code> 如果发现 <code>mutex</code>\r\n已经上锁的话，会等待他直到他解锁。<br />\r\n</li>\r\n<li>如果使用 <code>try_lock()</code> ，其上锁失败不会阻塞，而是直接返回\r\nfalse，上锁成功会返回 true。</li>\r\n</ul>\r\n<h3 id=\"try_lock_for\"><code>try_lock_for</code></h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    <span class=\"hljs-keyword\">if</span>(mtx1.<span class=\"hljs-built_in\">try_lock_for</span>(std::chrono::<span class=\"hljs-built_in\">milliseconds</span>(<span class=\"hljs-number\">500</span>)))<br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">if</span>(mtx1.<span class=\"hljs-built_in\">try_lock_for</span>(std::chrono::<span class=\"hljs-built_in\">milliseconds</span>(<span class=\"hljs-number\">500</span>)))<br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Successed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>在 <code>try_lock()</code> 的基础上，但是会等待一段时间。<br />\r\n</li>\r\n<li>类似的还有 <code>try_lock_until()</code></li>\r\n</ul>\r\n<h3\r\nid=\"stdunique_lock-用-stdtry_to_lock-做参数\"><code>std::unique_lock</code>:\r\n用 <code>std::try_to_lock</code> 做参数</h3>\r\n<ul>\r\n<li><p>和无参数相比，它会调用 <code>mtx.try_lock()</code> 而非\r\n<code>mtx.lock()</code>.<br />\r\n<code>grd.owns_lock()</code> 判断是否上锁成功。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    std::mutex mtx;  <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt;grd(mtx, std::try_to_lock);  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">if</span>(grd.owns_lock())  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Successed!&quot;</span> &lt;&lt; std::endl;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">else</span>  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed!&quot;</span> &lt;&lt; std::endl;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class=\"hljs-number\">1000</span>));  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;  </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">jion</span>();  <br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3\r\nid=\"stdunique_lock-stdadopt_lock-做参数\"><code>std::unique_lock</code>:\r\n<code>std::adopt_lock</code> 做参数</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx;<br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt;grd(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;t1 lock the mutex&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::this_thread::sleep_for(std:chrono::milliseconds(<span class=\"hljs-number\">1000</span>));</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        mtx.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt;grd(mtx, std::adopt_lock);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;t2 lock the mutex&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::this_thread::sleep_for(std:chrono::milliseconds(<span class=\"hljs-number\">1000</span>));</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>\tt1.<span class=\"hljs-built_in\">jion</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>作用就是当我们的 mutex 已经上锁，但是我们又想使用 unique_lock /\r\nlock_guard 这种符合 RAII\r\n思想的封装，以实现其可以自我解构，我们就在构造时使用\r\nstd::adopt_lock，就默认这个 mutex 已经上锁了。</li>\r\n</ul>\r\n<h3\r\nid=\"stdunique_lock-和-stdmutex-有相同的接口\"><code>std::unique_lock</code>\r\n和 <code>std::mutex</code> 有相同的接口</h3>\r\n<ul>\r\n<li><p><code>std::unique_lock</code> 拥有 <code>std::mutex</code>\r\n的所有成员函数：<code>lock()</code>, <code>unlock()</code>,\r\n<code>try_lock()</code>, <code>try_lock_for()</code> 等等。<br />\r\n只是 unique_lock 会自动调用 unlock 罢了<br />\r\n</p></li>\r\n<li><p>而 <code>std::lock_guard</code> 无非是调用其构造参数中 名为\r\nlock() 的成员函数罢了，所有我们甚至可以用 <code>std::unique_lock</code>\r\n做 <code>std::lock_guard</code> 的构造函数参数</p></li>\r\n<li><p>更进一步，只要我们能有 满足 mutex 类对于成员函数的类，就可以做为\r\n<code>std::lock_guard</code> 构造函数的参数。<br />\r\n这种只要具有某些指定名字的成员函数，就可以判断一个类是否满足某些功能的思想，被成为\r\nconcept(概念)，相比 虚函数 和 动态多态的接口抽象，concept\r\n能够使实现更加解耦，并且不会有性能损失。</p></li>\r\n</ul>\r\n<h2 id=\"死锁\">死锁</h2>\r\n<h3 id=\"同时锁住多个-mutex\">同时锁住多个 mutex</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    std:<span class=\"hljs-function\">thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; ++i)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std:<span class=\"hljs-function\">thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; ++i)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">jion</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>因为线程是同步进行的，所以其指令不一定是同步的<br />\r\n</li>\r\n<li>可能就会：\r\n<ul>\r\n<li>t1锁住了mtx1<br />\r\n</li>\r\n<li>t2锁住了mtx2<br />\r\n</li>\r\n<li>t1需要锁mtx2，但是t2锁住了mtx2<br />\r\n</li>\r\n<li>t2需要锁mtx1，但是t1锁住了mtx1<br />\r\n</li>\r\n<li>t1，t2都陷入无尽的等待</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"解决1永远不要同时持有两个锁\">解决1：永远不要同时持有两个锁</h4>\r\n<ul>\r\n<li>简单粗暴的就是<u>不让一个线程同时持有两个锁</u>，分别上锁，来避免死锁</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">jion</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4\r\nid=\"解决方案2确保双方上锁顺序一致\">解决方案2：确保双方上锁顺序一致</h4>\r\n<ul>\r\n<li>前面死锁是因为两个线程上锁的顺序不同，<u>保证双方上锁的顺序一致，即可避免死锁</u></li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.lock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">jion</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"解决方案3使用-stdlock-同时对多个-mutex-上锁\">解决方案3：使用\r\n<code>std::lock</code> 同时对多个 mutex 上锁</h4>\r\n<ul>\r\n<li><code>std::lock</code> 接受任意个 mutex 作为参数，且保证\r\n<u>无论任意线程中调用的顺序是否相同，都不会产生死锁问题</u></li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::mutex mtx1;<br>    std::mutex mtx2;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t\tstd::lock(mtx1, mtx2);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            std::lock(mtx2, mtx1);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx2.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            mtx1.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"stdlock-的-raii-版本-stdscoped_lock\"><code>std::lock</code> 的\r\nRAII 版本 : <code>std::scoped_lock</code></h4>\r\n<ul>\r\n<li>和 <code>std::lock_guard</code> /\r\n<code>std::unique_lock</code>相对应，<code>std::lock</code> 也有 RAII\r\n的版本 <code>std::scoped_lock</code>, 只不过其可以同时对多个 mutex\r\n上锁。</li>\r\n</ul>\r\n<h3 id=\"同一个线程重复调用-lock-也会造成死锁\">同一个线程重复调用 lock()\r\n也会造成死锁</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::mutex mtx;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">other</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmtx.<span class=\"hljs-built_in\">lock</span>();<br>    <span class=\"hljs-comment\">//...</span><br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmtx.<span class=\"hljs-built_in\">lock</span>();<br>    <span class=\"hljs-built_in\">other</span>();<br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">func</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>这里 <code>func</code> lock了mtx，而lock之后调用 other，other 需要\r\nmtx，陷入等待<br />\r\n这就是 同一线程多次对同一个 mutex 进行 lock 导致死锁。</li>\r\n</ul>\r\n<h4 id=\"解决一other-不-lock\">解决一：other 不 lock</h4>\r\n<p>这种情况一定要说明 other 非线程安全的，在调用前务必保证其 mutex\r\n已经上锁。</p>\r\n<h4 id=\"解决二改用-stdrecursive_mutex\">解决二：改用\r\n<code>std::recursive_mutex</code></h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">std::recursive_mutex mtx;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">other</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmtx.<span class=\"hljs-built_in\">lock</span>();<br>    <span class=\"hljs-comment\">//...</span><br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmtx.<span class=\"hljs-built_in\">lock</span>();<br>    <span class=\"hljs-built_in\">other</span>();<br>    mtx.<span class=\"hljs-built_in\">unlock</span>();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">func</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><p>如果 <code>other</code> 不让改，可以用\r\n<code>std::recursive_mutex</code><br />\r\n会判断是不是同一个线程 <code>lock()</code> 了多次同一个锁<br />\r\n如果是则让计数器加1，在之后 <code>unlock()</code>\r\n时会让计数器减1，减到0时才真正解锁。但是相比普通的\r\n<code>std::mutex</code> 会有一定的性能损失。</p></li>\r\n<li><p>也有 <code>std::recursive_timed_mutex</code>，如果我们需要\r\n<code>try_lock_for()</code></p></li>\r\n</ul>\r\n<h2 id=\"数据结构\">数据结构</h2>\r\n<h3 id=\"案例多线程使用-stdvector\">案例：多线程使用\r\n<code>std::vector</code></h3>\r\n<p>之前提到 <code>vector</code>\r\n是线程不安全的，会出现数据竞争(data-race)</p>\r\n<h3 id=\"封装线程安全的-vector\">封装线程安全的 <code>vector</code></h3>\r\n<p>加入我们这样做：<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    std::mutex m_mutex;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(val)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock</span>();<br>        m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>        m_mtr.<span class=\"hljs-built_in\">unlock</span>();<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock</span>();\t<span class=\"hljs-comment\">//</span><br>        <span class=\"hljs-type\">size_t</span> ret = m_arr.<span class=\"hljs-built_in\">size</span>();<br>        m_mtx.<span class=\"hljs-built_in\">unlock</span>();\t<span class=\"hljs-comment\">//</span><br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>我们用用一个类进行简单封装，使访问都受到 <code>mutex</code>\r\n的保护<br />\r\n</li>\r\n<li>但是会出错哦，因为 <code>size()</code> 是 <code>const</code>\r\n函数，而 <code>mutex::lock()</code> 并非 <code>const</code> 函数。但是\r\n<code>size()</code>为了兼容之前的代码，必须是 const 的。</li>\r\n</ul>\r\n<h4 id=\"逻辑上-const-而部分成员非-const-mutable\">逻辑上\r\n<code>const</code> 而部分成员非 <code>const</code>:\r\n<code>mutable</code></h4>\r\n<ul>\r\n<li>我们必须为了 <code>mutex</code> 放弃声明 <code>size()</code> 为\r\n<code>const</code> 吗？<br />\r\n不必这样，<code>size()</code> 在逻辑上仍然应该是 <code>const</code>\r\n的。<br />\r\n所以，为了能让 <code>this</code> 为 <code>const</code> 时仅仅对\r\n<code>m_mtx</code> 做特殊处理，可以声明 <code>mutable</code>\r\n关键字修饰他，从而所有成员只有他不是 <code>const</code> 的。</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    <span class=\"hljs-keyword\">mutable</span> std::mutex m_mutex;\t<span class=\"hljs-comment\">//</span><br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(val)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock</span>();<br>        m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>        m_mtr.<span class=\"hljs-built_in\">unlock</span>();<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock</span>();<br>        <span class=\"hljs-type\">size_t</span> ret = m_arr.<span class=\"hljs-built_in\">size</span>();<br>        m_mtx.<span class=\"hljs-built_in\">unlock</span>();<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"为什么需要读写锁\">为什么需要读写锁</h3>\r\n<p>实际上我们<strong>读的时候可以共享</strong>，但是写的时候不能共享，<strong>写必须独占</strong>，因为写一半被读取可能会读到错误的数据。</p>\r\n<p>所以就有了读写锁，读写情况有三种：</p>\r\n<ul>\r\n<li>n 个人读，没有写入<br />\r\n</li>\r\n<li>1 个人写入，没有读取<br />\r\n</li>\r\n<li>没有读取，也没有写入</li>\r\n</ul>\r\n<h3 id=\"shared_mutex-读写锁\"><code>shared_mutex</code> —— 读写锁</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    <span class=\"hljs-keyword\">mutable</span> std::shared_mutex m_mutex;\t<span class=\"hljs-comment\">//</span><br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(val)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock</span>();<br>        m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>        m_mtr.<span class=\"hljs-built_in\">unlock</span>();<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        m_mtx.<span class=\"hljs-built_in\">lock_shared</span>();<br>        <span class=\"hljs-type\">size_t</span> ret = m_arr.<span class=\"hljs-built_in\">size</span>();<br>        m_mtx.<span class=\"hljs-built_in\">unlock_shared</span>();<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>在上锁时，指定需求是 <strong>读</strong> 或者\r\n<strong>写</strong>，负责调度的读写锁会帮助我们 判断是否需要等待。<br />\r\n</li>\r\n<li><code>push_back</code> 是写，所以使用 <code>lock</code> 和\r\n<code>unlock</code><br />\r\n</li>\r\n<li><code>size</code> 是读，使用 <code>lock_shared</code> 和\r\n<code>unlock_shared</code></li>\r\n</ul>\r\n<h3\r\nid=\"stdshared_lock-符合-raii-思想的-lock_shared\"><code>std::shared_lock</code>\r\n: 符合 RAII 思想的 <code>lock_shared()</code></h3>\r\n<ul>\r\n<li>我们用 <code>std::unique_lock</code> 封装 <code>lock()</code> 和\r\n<code>unlock()</code><br />\r\n对应的，<code>std::shared_lock</code> 封装了 <code>lock_shared()</code>\r\n和 <code>unlock_shared()</code><br />\r\n</li>\r\n<li><code>shared_lock</code> 也支持 <code>defer_lock</code>\r\n做参数，<code>owns_lock()</code> 判断等等。</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    <span class=\"hljs-keyword\">mutable</span> std::shared_mutex m_mutex;\t<span class=\"hljs-comment\">//</span><br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(val)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::unique_lock&lt;std::shared_mutex&gt;<span class=\"hljs-built_in\">grd</span>(m_mtx);\t<span class=\"hljs-comment\">// 注意这里是 unique_lock</span><br>        m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-function\">std::shared_lock <span class=\"hljs-title\">grd</span><span class=\"hljs-params\">(m_mtx)</span></span>;\t<span class=\"hljs-comment\">// 注意这里是 shared_lock</span><br>        <span class=\"hljs-type\">size_t</span> ret = m_arr.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"只需一次性上锁且符合-raii-思想访问者模式\">只需一次性上锁，且符合\r\nRAII 思想：访问者模式</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    std::mutex m_mtx;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Accessor</span><br>    &#123;<br>    \tMTVector &amp;m_that;<br>        std::unique_lock&lt;std::mutex&gt; m_guard;<br>        <br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-built_in\">Accessor</span>(MTVector &amp;that)<br>            : <span class=\"hljs-built_in\">m_that</span>(that), <span class=\"hljs-built_in\">m_guard</span>(that.m_mtx)<br>        &#123;<br>        <br>        &#125;<br>        <br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> val)</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">        </span>&#123;<br>            <span class=\"hljs-keyword\">return</span> m_that.m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>        &#125;<br>        <br>        <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">        </span>&#123;<br>            <span class=\"hljs-keyword\">return</span> m_that.m_arr.<span class=\"hljs-built_in\">size</span>();<br>        &#125;<br>    &#125;;<br>    <br>    <span class=\"hljs-function\">Accessor <span class=\"hljs-title\">access</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;*<span class=\"hljs-keyword\">this</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>Accessor access() 将 <code>MTVector</code> 的 <code>this</code>\r\n指针作为 Access 构造函数的参数<br />\r\n</li>\r\n<li>因为多次上锁解锁是存在性能消耗的</li>\r\n</ul>\r\n<p>如果使用 shared_mutex<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MTVector</span><br>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; m_arr;<br>    std::shared_mutex m_mtx;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Accessor</span><br>    &#123;<br>    \tMTVector &amp;m_that;<br>        std::unique_lock&lt;std::shared_mutex&gt; m_guard;<br>        <br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-built_in\">Accessor</span>(MTVector &amp;that)<br>            : <span class=\"hljs-built_in\">m_that</span>(that), <span class=\"hljs-built_in\">m_guard</span>(that.m_mtx)<br>        &#123;<br>        <br>        &#125;<br>        <br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> val)</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">        </span>&#123;<br>            <span class=\"hljs-keyword\">return</span> m_that.m_arr.<span class=\"hljs-built_in\">push_back</span>(val);<br>        &#125;<br>    &#125;;<br>    <br>    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConstAccessor</span><br>    &#123;<br>    \tMTVector &amp;m_that;<br>        std::shared_lock&lt;std::shared_mutex&gt; m_guard;<br>        <br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-built_in\">Accessor</span>(MTVector &amp;that)<br>            : <span class=\"hljs-built_in\">m_that</span>(that), <span class=\"hljs-built_in\">m_guard</span>(that.m_mtx)<br>        &#123;<br>        <br>        &#125;<br>        <br>        <span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">        </span>&#123;<br>            <span class=\"hljs-keyword\">return</span> m_that.m_arr.<span class=\"hljs-built_in\">size</span>();<br>        &#125;<br>    &#125;;<br>    <br>    <span class=\"hljs-function\">Accessor <span class=\"hljs-title\">access</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;*<span class=\"hljs-keyword\">this</span>&#125;;<br>    &#125;<br>    <br>    <span class=\"hljs-function\">ConstAccessor <span class=\"hljs-title\">const_access</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> &#123;*<span class=\"hljs-keyword\">this</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<h2 id=\"条件变量\">条件变量</h2>\r\n<p>之前的互斥量更多的是防止数据竞争<br />\r\n而条件变量就类似他的名字，更多的是一个条件，只有条件发生了，这个线程才会继续执行。</p>\r\n<h3 id=\"条件变量等待被唤醒\">条件变量：等待被唤醒</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::condition_variable cv;<br>    std:;mutex mtx;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt;lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T1 is awake.&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std::this_thread::<span class=\"hljs-built_in\">sleep_for</span>(std::chrono::<span class=\"hljs-built_in\">millionseconds</span>(<span class=\"hljs-number\">400</span>));<br>    <br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Notifying ...&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><code>cv.wait(lck)</code> 将会让当前线程陷入等待。<br />\r\n</li>\r\n<li>在其他线程中调用 <code>cv.notify_one()</code>\r\n则会唤醒那个陷入等待的线程。<br />\r\n</li>\r\n<li><code>std::condition_variable</code> 必须和\r\n<code>std:unique_lock&lt;std::mutex&gt;</code> 一起使用</li>\r\n</ul>\r\n<h3 id=\"条件变量等待某一变量成真\">条件变量：等待某一变量成真</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <span class=\"hljs-type\">bool</span> ready = <span class=\"hljs-literal\">false</span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck, [&amp;] &#123; <span class=\"hljs-keyword\">return</span> ready&#125;);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        lck.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T1 is awake.&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Notifying not ready!&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();<br>    <br>        <br>    ready = <span class=\"hljs-literal\">true</span>;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Notifying ready&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><code>cv.wait(lck, expr)</code> 中 <code>expr</code> 是一个 lambda\r\n表达式。<br />\r\n只有返回值为 true 时才会被唤醒，否则继续等待。</li>\r\n</ul>\r\n<h3 id=\"条件变量多个等待者\">条件变量：多个等待者</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T1 is awake!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T2 is awake!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t3</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T3 is awake!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    std::this_thread::<span class=\"hljs-built_in\">sleep_for</span>(std::chrono::<span class=\"hljs-built_in\">millionseconds</span>(<span class=\"hljs-number\">400</span>));<br>    <br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Notify One&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();\t<span class=\"hljs-comment\">// awake t1 only</span><br>    <br>    std::this_thread::<span class=\"hljs-built_in\">sleep_for</span>(std::chrono::<span class=\"hljs-built_in\">millionseconds</span>(<span class=\"hljs-number\">400</span>));<br>    <br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Notify One&quot;</span> &lt;&lt; std::endl;<br>    cv.<span class=\"hljs-built_in\">notify_all</span>();\t<span class=\"hljs-comment\">// awake t2 and t3</span><br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    t3.<span class=\"hljs-built_in\">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><code>cv.notify_one()</code> 只会唤醒其中一个等待的线程，而\r\n<code>cv.notify_all()</code> 会唤醒全部。<br />\r\n</li>\r\n<li>这就是为什么 <code>wait()</code> 需要有个 <code>unique_lock</code>\r\n作为参数，因为要保证多个线程同时唤醒时只有一个可以被启动。如果不需要这个锁，在\r\n<code>wait()</code> 返回后调用 <code>lck.unlock()</code> 即可。<br />\r\n</li>\r\n<li><code>wait()</code> 的过程中会暂时 <code>unlock()</code>\r\n这个锁。</li>\r\n</ul>\r\n<h3 id=\"实例实现生产者-消费者模式\">实例：实现生产者-消费者模式</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::condition_variable cv;<br>    std::mutex mtx;<br>    <br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; foods;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck, [&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            <span class=\"hljs-keyword\">return</span> foods.size() != <span class=\"hljs-number\">0</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">auto</span> food = foods.back();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        foods.pop_back();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        lck.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T1 get food: &quot;</span> &lt;&lt; food &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        cv.wait(lck, [&amp;]&#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            <span class=\"hljs-keyword\">return</span> foods.size() != <span class=\"hljs-number\">0</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;);</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">auto</span> food = foods.back();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        foods.pop_back();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        lck.unlock();</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T2 get food: &quot;</span> &lt;&lt; food &lt;&lt; std::endl;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    foods.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">42</span>);<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();<br>    foods.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">422</span>);<br>    cv.<span class=\"hljs-built_in\">notify_one</span>();<br>    <br>    foods.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">66</span>);<br>    foods.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">92</span>);<br>    cv.<span class=\"hljs-built_in\">notify_all</span>();<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"stdcondition_variable-tips\"><code>std::condition_variable</code>\r\ntips</h3>\r\n<ol type=\"1\">\r\n<li><code>std::condition_variable</code> 仅支持\r\n<code>std::unique_lock&lt;std::mutex&gt;</code>\r\n作为参数，如果需要其他类型的 mutex，使用\r\n<code>std::condition_variable_any</code><br />\r\n</li>\r\n<li>其还有 <code>wait_for()</code> 和 <code>wait_until()</code> 分别接受\r\nchrono 的时间段和时间点</li>\r\n</ol>\r\n<h2 id=\"原子操作\">原子操作</h2>\r\n<h3\r\nid=\"经典案例多个线程修改同一个计数器\">经典案例：多个线程修改同一个计数器</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> counter = <span class=\"hljs-number\">0</span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            counter += <span class=\"hljs-number\">1</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            counter += <span class=\"hljs-number\">1</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    std::cout &lt;&lt; counter&lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>这里即便是简单的 +1 操作也会冲突，因为对于 CPU\r\n而言会是多个指令，执行时会发生冲突。</p>\r\n<p>如果我们的操作不是原子的，就会造成数据冲入或者写入/读取错误。</p>\r\n<h4 id=\"暴力解决mutex-上锁\">暴力解决：mutex 上锁</h4>\r\n<ul>\r\n<li>能解决，但是这样操作系统来进行线程调度，会进入<strong>内核态</strong>再回到用户态，这样切换，有很大的开销。<br />\r\n</li>\r\n<li>归根结底就是 mutex 太昂贵了</li>\r\n</ul>\r\n<h4 id=\"建议使用-atomic有专门的硬件指令加持\">建议使用\r\natomic：有专门的硬件指令加持</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::atomic&lt;<span class=\"hljs-type\">int</span>&gt; counter = <span class=\"hljs-number\">0</span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t1</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            counter += <span class=\"hljs-number\">1</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    <span class=\"hljs-function\">std::thread <span class=\"hljs-title\">t2</span><span class=\"hljs-params\">([&amp;] &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++)</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#123;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">            counter += <span class=\"hljs-number\">1</span>;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        &#125;</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    &#125;)</span></span>;<br>    <br>    t1.<span class=\"hljs-built_in\">join</span>();<br>    t2.<span class=\"hljs-built_in\">join</span>();<br>    std::cout &lt;&lt; counter&lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>atomic 对 += 等操作会转换为专门的指令<br />\r\n</li>\r\n<li>CPU\r\n识别到对应的指令会锁住内存总线，放弃乱序执行的优化，强制同步之前的内存操作，保证操作的原子性。<br />\r\n</li>\r\n<li>注意，对 += 和 ++ 原子，但是分开写 c = c + 1 就不可以了</li>\r\n</ul>\r\n<h3 id=\"fetch_add和-等价\">fetch_add：和 += 等价</h3>\r\n<ul>\r\n<li><code>fetch_add</code> : +=<br />\r\n</li>\r\n<li><code>store</code> : =<br />\r\n</li>\r\n<li><code>load</code> 读取 <code>int</code> 值</li>\r\n</ul>\r\n<h3 id=\"fetch_add-能够返回旧值\">fetch_add 能够返回旧值</h3>\r\n<ul>\r\n<li>先 fetch 一个旧值，然后再 add<br />\r\n</li>\r\n<li>这个特点使其可以<strong>并行地往一个列表追加数据</strong></li>\r\n</ul>\r\n<h3 id=\"exchange读取的同时写入\">exchange：读取的同时写入</h3>\r\n<p>先取出来，然后再写入</p>\r\n<h3 id=\"compare_exchange_strong\">compare_exchange_strong</h3>\r\n<p>读取，比较是否相等，相等则写入</p>\r\n<p><code>counter.compare_exchange_strong(cmp,val)</code> counter 和 cmp\r\n比，相等就写入val值</p>"},{"title":"Hexo 主题变更","math":true,"index_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","banner_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","date":"2024-01-12T16:00:00.000Z","typora-root-url":"../","_content":"\n更换了Hexo 主题，之前 yilia 主题作者是不是开摆了……我看很久没更新.  \nnalama！答案只有一个了，我将向你—— Fluid 效忠！图源自Pix画师ID:67549695  \n<!--more-->\n\n# Hexo 主题切换\n\n这里以 yilia 切换到 Fluid 为例，我这里只是分享一下自己是怎么做的，遇到什么问题，  \n肯定有不对的地方，欢迎大家教我。\n\n## 准备工作\n\n鉴于前面我自己把 blog 干崩过，所有我强烈建议所有人都在 github 存一个仓库备份本地的 Blog  \n因为 Hexo 这种静态blog **本地磁盘的源文件**和**生成的网页**，是两个部分。\n\n你能不能说人话什么本地，网页的！  \n好好好，你先别急，我知道你很急，但是你先别急。\n\n* 本地的源文件：  \n  ![](/imgs/Hexo主题变更/deskt.png)  \n* 生成的网页：  \n  ![](/imgs/Hexo主题变更/web.png)\n  我们可以将本地文件存储到 github 备份，也方便 fallback 和 迁移。\n\n## 切换\n\n将 Hexo 博客主题从 yilia 切换到 Fluid 的步骤如下：\n\n1. 首先，您需要在本地安装 Fluid 主题。  \n   可以使用以下命令从 GitHub 上下载 Fluid 主题并将其保存到您的 Hexo 博客的 themes 文件夹中：\n  \n   ```  \n   git clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid  \n   ```\n  \n2. 下载完成后，进入 Hexo 博客的根目录，并打开 _config.yml 文件。  \n   将 theme 字段的值更改为 \"fluid\"，如下所示：\n   \n   ```  \n   theme: fluid  \n   ```\n\n### 修改主题配置\n\n主题配置指的是 hexo 所采用的 theme 所用配置，而并非对 Hexo blog 的配置\n\n> TIP[^1]  \n>  \n> 致主题的新用户：  \n>  \n> - 本指南经过数个版本打磨，  \n>   绝大部分的功能都有详细说明，请仔细阅读，节约自己和他人的时间；  \n> - 本指南中提到的：\"**站点配置**\" 指的 Hexo 博客目录下的 `_config.yml`，\"**主题配置**\" 指的是 `theme/fluid/_config.yml` 或者 `_config.fluid.yml` ，注意区分；  \n> - 本指南中提到的 `source` 目录都指的是博客目录下的 `source` 文件夹，不推荐修改主题内 `source` 目录；  \n> - 每次无论 `hexo g` 或 `hexo s`，都最好先使用 `hexo clean` 清除本地缓存；  \n> - 页面结果以本地 `hexo s` 为准，部署后的异常大部分是线上缓存原因，在确认没有报错的情况下，等待若干时间后即可正常；  \n> - 由于主题的不同版本会存在配置差异，本指南以最新版本为准。\n\n这里按照官方文档所说去做就行，为什么这么配文档也有说，我这里是 Hexo 6.1.0。[^2]  \n所以在Blog 根目录创建 `_config.fluid.yml`  \n![](/imgs/Hexo主题变更/Fluid_Config.png)  \n然后在该文件内，粘贴 Fluid 官方给定的配置[^3]就行，当然你可以根据他的自定义，  \n但是我不会，因为我不会……\n\n#### code，建议别从我这里复制，这个blog会崩溃，去官网吧[^5]\n\n~~~yaml\n#---------------------------\n# Hexo Theme Fluid\n# Author: Fluid-dev\n# Github: https://github.com/fluid-dev/hexo-theme-fluid\n#\n# 配置指南: https://hexo.fluid-dev.com/docs/guide/\n# 你可以从指南中获得更详细的说明\n#\n# Guide: https://hexo.fluid-dev.com/docs/en/guide/\n# You can get more detailed help from the guide\n#---------------------------\n\n\n#---------------------------\n# 全局\n# Global\n#---------------------------\n\n# 用于浏览器标签的图标\n# Icon for browser tab\nfavicon: /img/fluid.png\n\n# 用于苹果设备的图标\n# Icon for Apple touch\napple_touch_icon: /img/fluid.png\n\n# 浏览器标签页中的标题分隔符，效果： 文章名 - 站点名\n# Title separator in browser tab, eg: article - site\ntab_title_separator: \" - \"\n\n# 强制所有链接升级为 HTTPS（适用于图片等资源出现 HTTP 混入报错）\n# Force all links to be HTTPS (applicable to HTTP mixed error)\nforce_https: false\n\n# 代码块的增强配置\n# Enhancements to code blocks\ncode:\n  # 是否开启复制代码的按钮\n  # Enable copy code button\n  copy_btn: true\n\n  # 代码语言\n  # Code language\n  language:\n    enable: true\n    default: \"TEXT\"\n\n  # 代码高亮\n  # Code highlight\n  highlight:\n    enable: true\n\n    # 代码块是否显示行号\n    # If true, the code block display line numbers\n    line_number: true\n\n    # 实现高亮的库，对应下面的设置\n    # Highlight library\n    # Options: highlightjs | prismjs\n    lib: \"highlightjs\"\n\n    highlightjs:\n      # 在链接中挑选 style 填入\n      # Select a style in the link\n      # See: https://highlightjs.org/static/demo/\n      style: \"github gist\"\n      style_dark: \"dark\"\n\n    prismjs:\n      # 在下方链接页面右侧的圆形按钮挑选 style 填入，也可以直接填入 css 链接\n      # Select the style button on the right side of the link page, you can also set the CSS link\n      # See: https://prismjs.com/\n      style: \"default\"\n      style_dark: \"tomorrow night\"\n\n      # 设为 true 高亮将本地静态生成（但只支持部分 prismjs 插件），设为 false 高亮将在浏览器通过 js 生成\n      # If true, it will be generated locally (but some prismjs plugins are not supported). If false, it will be generated via JS in the browser\n      preprocess: true\n\n# 一些好玩的功能\n# Some fun features\nfun_features:\n  # 为 subtitle 添加打字机效果\n  # Typing animation for subtitle\n  typing:\n    enable: true\n\n    # 打印速度，数字越大越慢\n    # Typing speed, the larger the number, the slower\n    typeSpeed: 70\n\n    # 游标字符\n    # Cursor character\n    cursorChar: \"_\"\n\n    # 是否循环播放效果\n    # If true, loop animation\n    loop: false\n\n    # 在指定页面开启，不填则在所有页面开启\n    # Enable in specified page, all pages by default\n    # Options: home | post | tag | category | about | links | page | 404\n    scope: []\n\n  # 为文章内容中的标题添加锚图标\n  # Add an anchor icon to the title on the post page\n  anchorjs:\n    enable: true\n    element: h1,h2,h3,h4,h5,h6\n    # Options: left | right\n    placement: left\n    # Options: hover | always | touch\n    visible: hover\n    # Options: § | # | ❡\n    icon: \"\"\n\n  # 加载进度条\n  # Progress bar when loading\n  progressbar:\n    enable: true\n    height_px: 3\n    color: \"#29d\"\n    # See: https://github.com/rstacruz/nprogress\n    options: { showSpinner: false, trickleSpeed: 100 }\n\n# 主题暗色模式，开启后菜单中会出现切换按钮，用户浏览器会存储切换选项，并且会遵循 prefers-color-scheme 自动切换\n# Theme dark mode. If enable, a switch button will appear on the menu, each of the visitor's browser will store his switch option\ndark_mode:\n  enable: true\n  # 默认的选项（当用户手动切换后则不再按照默认模式），选择 `auto` 会优先遵循 prefers-color-scheme，其次按用户本地时间 18 点到次日 6 点之间进入暗色模式\n  # Default option (when the visitor switches manually, the default mode is no longer followed), choosing `auto` will give priority to prefers-color-scheme, and then enter the dark mode from 18:00 to 6:00 in the visitor’s local time\n  # Options: auto | light | dark\n  default: auto\n\n# 主题颜色配置，其他不生效的地方请使用自定义 css 解决，配色可以在下方链接中获得启发\n# Theme color, please use custom CSS to solve other colors, color schema can be inspired by the links below\n# See: https://www.webdesignrankings.com/resources/lolcolors/\ncolor:\n  # body 背景色\n  # Color of body background\n  body_bg_color: \"#eee\"\n  # 暗色模式下的 body 背景色，下同\n  # Color in dark mode, the same below\n  body_bg_color_dark: \"#181c27\"\n\n  # 顶部菜单背景色\n  # Color of navigation bar background\n  navbar_bg_color: \"#2f4154\"\n  navbar_bg_color_dark: \"#1f3144\"\n\n  # 顶部菜单字体色\n  # Color of navigation bar text\n  navbar_text_color: \"#fff\"\n  navbar_text_color_dark: \"#d0d0d0\"\n\n  # 副标题字体色\n  # Color of navigation bar text\n  subtitle_color: \"#fff\"\n  subtitle_color_dark: \"#d0d0d0\"\n\n  # 全局字体色\n  # Color of global text\n  text_color: \"#3c4858\"\n  text_color_dark: \"#c4c6c9\"\n\n  # 全局次级字体色（摘要、简介等位置）\n  # Color of global secondary text (excerpt, introduction, etc.)\n  sec_text_color: \"#718096\"\n  sec_text_color_dark: \"#a7a9ad\"\n\n  # 主面板背景色\n  # Color of main board\n  board_color: \"#fff\"\n  board_color_dark: \"#252d38\"\n\n  # 文章正文字体色\n  # Color of post text\n  post_text_color: \"#2c3e50\"\n  post_text_color_dark: \"#c4c6c9\"\n\n  # 文章正文字体色（h1 h2 h3...）\n  # Color of Article heading (h1 h2 h3...)\n  post_heading_color: \"#1a202c\"\n  post_heading_color_dark: \"#c4c6c9\"\n\n  # 文章超链接字体色\n  # Color of post link\n  post_link_color: \"#0366d6\"\n  post_link_color_dark: \"#1589e9\"\n\n  # 超链接悬浮时字体色\n  # Color of link when hovering\n  link_hover_color: \"#30a9de\"\n  link_hover_color_dark: \"#30a9de\"\n\n  # 超链接悬浮背景色\n  # Color of link background when hovering\n  link_hover_bg_color: \"#f8f9fa\"\n  link_hover_bg_color_dark: \"#364151\"\n\n  # 分隔线和表格边线的颜色\n  # Color of horizontal rule and table border\n  line_color: \"#eaecef\"\n  line_color_dark: \"#435266\"\n\n  # 滚动条颜色\n  # Color of scrollbar\n  scrollbar_color: \"#c4c6c9\"\n  scrollbar_color_dark: \"#687582\"\n  # 滚动条悬浮颜色\n  # Color of scrollbar when hovering\n  scrollbar_hover_color: \"#a6a6a6\"\n  scrollbar_hover_color_dark: \"#9da8b3\"\n\n  # 按钮背景色\n  # Color of button\n  button_bg_color: \"transparent\"\n  button_bg_color_dark: \"transparent\"\n  # 按钮悬浮背景色\n  # Color of button when hovering\n  button_hover_bg_color: \"#f2f3f5\"\n  button_hover_bg_color_dark: \"#46647e\"\n\n# 主题字体配置\n# Font\nfont:\n  font_size: 16px\n  font_family:\n  letter_spacing: 0.02em\n  code_font_size: 85%\n\n# 指定自定义 .js 文件路径，支持列表；路径是相对 source 目录，如 /js/custom.js 对应存放目录 source/js/custom.js\n# Specify the path of your custom js file, support list. The path is relative to the source directory, such as `/js/custom.js` corresponding to the directory `source/js/custom.js`\ncustom_js:\n\n# 指定自定义 .css 文件路径，用法和 custom_js 相同\n# The usage is the same as custom_js\ncustom_css:\n\n# 网页访问统计\n# Analysis of website visitors\nweb_analytics:  # 网页访问统计\n  enable: false\n\n  # 遵循访客浏览器\"请勿追踪\"的设置，如果开启则不统计其访问\n  # Follow the \"Do Not Track\" setting of the visitor's browser\n  # See: https://www.w3.org/TR/tracking-dnt/\n  follow_dnt: true\n\n  # 百度统计的 Key，值需要获取下方链接中 `hm.js?` 后边的字符串\n  # Baidu analytics, get the string behind `hm.js?`\n  # See: https://tongji.baidu.com/sc-web/10000033910/home/site/getjs?siteId=13751376\n  baidu:\n\n  # Google Analytics 4 的媒体资源 ID\n  # Google Analytics 4 MEASUREMENT_ID\n  # See: https://support.google.com/analytics/answer/9744165#zippy=%2Cin-this-article\n  google:\n    measurement_id:\n\n  # 腾讯统计的 H5 App ID，开启高级功能才有cid\n  # Tencent analytics, set APP ID\n  # See: https://mta.qq.com/h5/manage/ctr_app_manage\n  tencent:\n    sid:\n    cid:\n\n  # 51.la 站点统计 ID\n  # 51.la analytics\n  # See: https://www.51.la/user/site/index\n  woyaola:  # 51.la 站点统计 ID，参见\n\n  # 友盟/cnzz 站点统计 web_id\n  # cnzz analytics\n  # See: https://web.umeng.com/main.php?c=site&a=show\n  cnzz:\n\n  # LeanCloud 计数统计，可用于 PV UV 展示，如果 `web_analytics: enable` 没有开启，PV UV 展示只会查询不会增加\n  # LeanCloud count statistics, which can be used for PV UV display. If `web_analytics: enable` is false, PV UV display will only query and not increase\n  leancloud:\n    app_id:\n    app_key:\n    # REST API 服务器地址，国际版不填\n    # Only the Chinese mainland users need to set\n    server_url:\n    # 统计页面时获取路径的属性\n    # Get the attribute of the page path during statistics\n    path: window.location.pathname\n    # 开启后不统计本地路径( localhost 与 127.0.0.1 )\n    # If true, ignore localhost & 127.0.0.1\n    ignore_local: false\n\n# 对页面中的图片和评论插件进行懒加载处理，可见范围外的元素不会提前加载\n# Lazy loading of images and comment plugin on the page\nlazyload:\n  enable: true\n\n  # 加载时的占位图片\n  # The placeholder image when loading\n  loading_img: /img/loading.gif\n\n  # 开启后懒加载仅在文章页生效，如果自定义页面需要使用，可以在 Front-matter 里指定 `lazyload: true`\n  # If true, only enable lazyload on the post page. For custom pages, you can set 'lazyload: true' in front-matter\n  onlypost: false\n\n  # 触发加载的偏移倍数，基数是视窗高度，可根据部署环境的请求速度调节\n  # The factor of viewport height that triggers loading\n  offset_factor: 2\n\n# 图标库，包含了大量社交类图标，主题依赖的不包含在内，因此可自行修改，详见 https://hexo.fluid-dev.com/docs/icon/\n# Icon library, which includes many social icons, does not include those theme dependent, so your can modify link by yourself. See: https://hexo.fluid-dev.com/docs/en/icon/\niconfont: //at.alicdn.com/t/font_1736178_lbnruvf0jn.css\n\n\n#---------------------------\n# 页头\n# Header\n#---------------------------\n\n# 导航栏的相关配置\n# Navigation bar\nnavbar:\n  # 导航栏左侧的标题，为空则按 hexo config 中 `title` 显示\n  # The title on the left side of the navigation bar. If empty, it is based on `title` in hexo config\n  blog_title: \"Fluid\"\n\n  # 导航栏毛玻璃特效，实验性功能，可能会造成页面滚动掉帧和抖动，部分浏览器不支持会自动不生效\n  # Navigation bar frosted glass special animation. It is an experimental feature\n  ground_glass:\n    enable: false\n\n    # 模糊像素，只能为数字，数字越大模糊度越高\n    # Number of blurred pixel. the larger the number, the higher the blur\n    px: 3\n\n    # 不透明度，数字越大透明度越低，注意透明过度可能看不清菜单字体\n    # Ratio of opacity, 1.0 is completely opaque\n    # available: 0 - 1.0\n    alpha: 0.7\n\n  # 导航栏菜单，可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称\n  # Navigation bar menu. `key` is used to associate languages/*.yml. If there is no association, the value of `key` itself will be displayed; if `icon` is a css class, it can be omitted; adding `name` can force the display of the specified name\n  menu:\n    - { key: \"home\", link: \"/\", icon: \"iconfont icon-home-fill\" }\n    - { key: \"archive\", link: \"/archives/\", icon: \"iconfont icon-archive-fill\" }\n    - { key: \"category\", link: \"/categories/\", icon: \"iconfont icon-category-fill\" }\n    - { key: \"tag\", link: \"/tags/\", icon: \"iconfont icon-tags-fill\" }\n    - { key: \"about\", link: \"/about/\", icon: \"iconfont icon-user-fill\" }\n    #- { key: \"links\", link: \"/links/\", icon: \"iconfont icon-link-fill\" }\n\n# 搜索功能，基于 hexo-generator-search 插件，若已安装其他搜索插件请关闭此功能，以避免生成多余的索引文件\n# Search feature, based on hexo-generator-search. If you have installed other search plugins, please disable this feature to avoid generating redundant index files\nsearch:\n  enable: true\n\n  # 搜索索引文件的路径，可以是相对路径或外站的绝对路径\n  # Path for search index file, it can be a relative path or an absolute path\n  path: /local-search.xml\n\n  # 文件生成在本地的位置，必须是相对路径\n  # The location where the index file is generated locally, it must be a relative location\n  generate_path: /local-search.xml\n\n  # 搜索的范围\n  # Search field\n  # Options: post | page | all\n  field: post\n\n  # 搜索是否扫描正文\n  # If true, search will scan the post content\n  content: true\n\n# 首屏图片的相关配置\n# Config of the big image on the first screen\nbanner:\n  # 视差滚动，图片与板块会随着屏幕滚动产生视差效果\n  # Scrolling parallax\n  parallax: true\n\n  # 图片最小的宽高比，以免图片两边被过度裁剪，适用于移动端竖屏时，如需关闭设为 0\n  # Minimum ratio of width to height, applicable to the vertical screen of mobile device, if you need to close it, set it to 0\n  width_height_ratio: 1.0\n\n# 向下滚动的箭头\n# Scroll down arrow\nscroll_down_arrow:\n  enable: true\n\n  # 头图高度不小于指定比例，才显示箭头\n  # Only the height of the banner image is greater than the ratio, the arrow is displayed\n  # Available: 0 - 100\n  banner_height_limit: 80\n\n  # 翻页后自动滚动\n  # Auto scroll after page turning\n  scroll_after_turning_page: true\n\n# 向顶部滚动的箭头\n# Scroll top arrow\nscroll_top_arrow:\n  enable: true\n\n# Open Graph metadata\n# See: https://hexo.io/docs/helpers.html#open-graph\nopen_graph:\n  enable: true\n  twitter_card: summary_large_image\n  twitter_id:\n  twitter_site:\n  google_plus:\n  fb_admins:\n  fb_app_id:\n\n\n#---------------------------\n# 页脚\n# Footer\n#---------------------------\nfooter:\n  # 页脚第一行文字的 HTML，建议保留 Fluid 的链接，用于向更多人推广本主题\n  # HTML of the first line of the footer, it is recommended to keep the Fluid link to promote this theme to more people\n  content: '\n    <a href=\"https://hexo.io\" target=\"_blank\" rel=\"nofollow noopener\"><span>Hexo</span></a>\n    <i class=\"iconfont icon-love\"></i>\n    <a href=\"https://github.com/fluid-dev/hexo-theme-fluid\" target=\"_blank\" rel=\"nofollow noopener\"><span>Fluid</span></a>\n  '\n\n  # 展示网站的 PV、UV 统计数\n  # Display website PV and UV statistics\n  statistics:\n    enable: false\n\n    # 统计数据来源，使用 leancloud 需要设置 `web_analytics: leancloud` 中的参数；使用 busuanzi 不需要额外设置，但是有时不稳定，另外本地运行时 busuanzi 显示统计数据很大属于正常现象，部署后会正常\n    # Data source. If use leancloud, you need to set the parameter in `web_analytics: leancloud`\n    # Options: busuanzi | leancloud\n    source: \"busuanzi\"\n\n  # 国内大陆服务器的备案信息\n  # For Chinese mainland website policy, other areas keep disable\n  beian:\n    enable: false\n    # ICP证号\n    icp_text: 京ICP证123456号\n    # 公安备案号，不填则只显示ICP\n    police_text: 京公网安备12345678号\n    # 公安备案的编号，用于URL跳转查询\n    police_code: 12345678\n    # 公安备案的图片. 为空时不显示备案图片\n    police_icon: /img/police_beian.png\n\n\n#---------------------------\n# 首页\n# Home Page\n#---------------------------\nindex:\n  # 首页 Banner 头图，可以是相对路径或绝对路径，以下相同\n  # Path of Banner image, can be a relative path or an absolute path, the same on other pages\n  banner_img: /img/default.png\n\n  # 头图高度，屏幕百分比\n  # Height ratio of banner image\n  # Available: 0 - 100\n  banner_img_height: 100\n\n  # 头图黑色蒙版的不透明度，available: 0 - 1.0， 1 是完全不透明\n  # Opacity of the banner mask, 1.0 is completely opaque\n  # Available: 0 - 1.0\n  banner_mask_alpha: 0.3\n\n  # 首页副标题的独立设置\n  # Independent config of home page subtitle\n  slogan:\n    enable: true\n\n    # 为空则按 hexo config.subtitle 显示\n    # If empty, text based on `subtitle` in hexo config\n    text: \"An elegant Material-Design theme for Hexo\"\n\n    # 通过 API 接口作为首页副标题的内容，必须返回的是 JSON 格式，如果请求失败则按 text 字段显示，该功能必须先开启 typing 打字机功能\n    # Subtitle of the homepage through the API, must be returned a JSON. If the request fails, it will be displayed in `text` value. This feature must first enable the typing animation\n    api:\n      enable: false\n\n      # 请求地址\n      # Request url\n      url: \"\"\n\n      # 请求方法\n      # Request method\n      # Available: GET | POST | PUT\n      method: \"GET\"\n\n      # 请求头\n      # Request headers\n      headers: {}\n\n      # 从请求结果获取字符串的取值字段，最终必须是一个字符串，例如返回结果为 {\"data\": {\"author\": \"fluid\", \"content\": \"An elegant theme\"}}, 则取值字段为 ['data', 'content']；如果返回是列表则自动选择第一项\n      # The value field of the string obtained from the response. For example, the response content is {\"data\": {\"author\": \"fluid\", \"content\": \"An elegant theme\"}}, the expected `keys: ['data','content']`; if the return is a list, the first item is automatically selected\n      keys: []\n\n  # 自动截取文章摘要\n  # Auto extract post\n  auto_excerpt:\n    enable: true\n\n  # 打开文章的标签方式\n  # The browser tag to open the post\n  # Available: _blank | _self\n  post_url_target: _self\n\n  # 是否显示文章信息（时间、分类、标签）\n  # Meta information of post\n  post_meta:\n    date: true\n    category: true\n    tag: true\n\n  # 文章通过 sticky 排序后，在首页文章标题前显示图标\n  # If the posts are sorted by `sticky`, an icon is displayed in front of the post title\n  post_sticky:\n    enable: true\n    icon: \"iconfont icon-top\"\n\n\n#---------------------------\n# 文章页\n# Post Page\n#---------------------------\npost:\n  banner_img: /img/default.png\n  banner_img_height: 70\n  banner_mask_alpha: 0.3\n\n  # 文章在首页的默认封面图，当没有指定 index_img 时会使用该图片，若两者都为空则不显示任何图片\n  # Path of the default post cover when `index_img` is not set. If both are empty, no image will be displayed\n  default_index_img:\n\n  # 文章标题下方的元信息\n  # Meta information below title\n  meta:\n    # 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值\n    # Author, based on `author` field in front-matter, if not set, based on `author` value in hexo config\n    author:\n      enable: false\n\n    # 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期\n    # Post date, based on `date` field in front-matter, if not set, based on create date of .md file\n    date:\n      enable: true\n      # 格式参照 ISO-8601 日期格式化\n      # ISO-8601 date format\n      # See: http://momentjs.cn/docs/#/parsing/string-format/\n      format: \"LL a\"\n\n    # 字数统计\n    # Word count\n    wordcount:\n      enable: true\n\n    # 估计阅读全文需要的时长\n    # Estimated reading time\n    min2read:\n      enable: true\n      # 每个字词的长度，建议：中文≈2，英文≈5，中英混合可自行调节\n      # Average word length (chars count in word), ZH ≈ 2, EN ≈ 5\n      awl: 2\n      # 每分钟阅读字数，如果大部分是技术文章可适度调低\n      # Words per minute\n      wpm: 60\n\n    # 浏览量计数\n    # Number of visits\n    views:\n      enable: false\n      # 统计数据来源\n      # Data Source\n      # Options: busuanzi | leancloud\n      source: \"busuanzi\"\n\n  # 在文章开头显示文章更新时间，该时间默认是 md 文件更新时间，可通过 front-matter 中 `updated` 手动指定（和 date 一样格式）\n  # Update date is displayed at the beginning of the post. The default date is the update date of the md file, which can be manually specified by `updated` in front-matter (same format as date)\n  updated:\n    enable: false\n\n    # 格式参照 ISO-8601 日期格式化\n    # ISO-8601 date format\n    # See: http://momentjs.cn/docs/#/parsing/string-format/\n    date_format: \"LL a\"\n\n    # 是否使用相对时间表示，比如：\"3 天前\"\n    # If true, it will be a relative time, such as: \"3 days ago\"\n    relative: false\n\n    # 提示标签类型\n    # Note class\n    # Options: default | primary | info | success | warning | danger | light\n    note_class: info\n\n  # 侧边栏展示当前分类下的文章\n  # Sidebar of category\n  category_bar:\n    enable: true\n\n    # 开启后，只有在文章 Front-matter 里指定 `category_bar: true` 才会展示分类，也可以通过 `category_bar: [\"分类A\"]` 来指定分类\n    # If true, only set `category_bar: true` in Front-matter will enable sidebar of category, also set `category_bar: [\"CategoryA\"]` to specify categories\n    specific: true\n\n    # 置于板块的左侧或右侧\n    # place in the board\n    # Options: left | right\n    placement: left\n\n    # 文章的排序字段，前面带减号是倒序，不带减号是正序\n    # Sort field for posts, with a minus sign is reverse order\n    # Options: date | title | or other field of front-matter\n    post_order_by: \"title\"\n\n    # 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制\n    # The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit\n    post_limit: 0\n\n  # 侧边栏展示文章目录\n  # Table of contents (TOC) in the sidebar\n  toc:\n    enable: true\n\n    # 置于板块的左侧或右侧\n    # place in the board\n    # Options: left | right\n    placement: right\n\n    # 目录会选择这些节点作为标题\n    # TOC will select these nodes as headings\n    headingSelector: \"h1,h2,h3,h4,h5,h6\"\n\n    # 层级的折叠深度，0 是全部折叠，大于 0 后如果存在下级标题则默认展开\n    # Collapse depth. If 0, all headings collapsed. If greater than 0, it will be expanded by default if there are sub headings\n    collapseDepth: 0\n\n  # 版权声明，会显示在每篇文章的结尾\n  # Copyright, will be displayed at the end of each post\n  copyright:\n    enable: true\n\n    # CreativeCommons license\n    # Options: BY | BY-SA | BY-ND | BY-NC | BY-NC-SA | BY-NC-ND\n    license: 'BY'\n\n    # 显示作者\n    author:\n      enable: true\n\n    # 显示发布日期\n    # Show post date\n    post_date:\n      enable: true\n      format: \"LL\"\n\n    # 显示更新日期\n    # Show update date\n    update_date:\n      enable: false\n      format: \"LL\"\n\n  # 文章底部上一篇下一篇功能\n  # Link to previous/next post\n  prev_next:\n    enable: true\n\n  # 文章图片标题\n  # Image caption\n  image_caption:\n    enable: true\n\n  # 文章图片可点击放大\n  # Zoom feature of images\n  image_zoom:\n    enable: true\n    # 放大后图片链接替换规则，可用于将压缩图片链接替换为原图片链接，如 ['-slim', ''] 是将链接中 `-slim` 移除；如果想使用正则请使用 `re:` 前缀，如 ['re:\\\\d{3,4}\\\\/\\\\d{3,4}\\\\/', '']\n    # The image url replacement when zooming, the feature can be used to replace the compressed image to the original image, eg: ['-slim', ''] removes `-slim` from the image url when zooming; if you want to use regular, use prefix `re:`, eg: ['re:\\\\d{3,4}\\\\/\\\\d{3,4}\\\\/','']\n    img_url_replace: ['', '']\n\n  # 脚注语法，会在文章底部生成脚注，如果 Markdown 渲染器本身支持，则建议关闭，否则可能会冲突\n  # Support footnote syntax, footnotes will be generated at the bottom of the post page. If the Markdown renderer itself supports it, please disable it, otherwise it may conflict\n  footnote:\n    enable: true\n    # 脚注的节标题，也可以在 front-matter 中通过 `footnote: <h2>Reference</h2>` 这种形式修改单独页面的 header\n    # The section title of the footnote, you can also modify the header of a single page in the form of `footnote: <h2>Reference</h2>` in front-matter\n    header: ''\n\n  # 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式\n  # Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math\n  math:\n    # 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`\n    # If you want to use math on the custom page, you need to set `math: true` in Front-matter\n    enable: false\n\n    # 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度\n    # If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math\n    specific: false\n\n    # Options: mathjax | katex\n    engine: mathjax\n\n  # 流程图，基于 mermaid-js，具体请见：https://hexo.fluid-dev.com/docs/guide/#mermaid-流程图\n  # Flow chart, based on mermaid-js, see: https://hexo.fluid-dev.com/docs/en/guide/#mermaid\n  mermaid:\n    # 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `mermaid: true`\n    # If you want to use mermaid on the custom page, you need to set `mermaid: true` in Front-matter\n    enable: false\n\n    # 开启后，只有在文章 Front-matter 里指定 `mermaid: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度\n    # If true, only set `mermaid: true` in Front-matter will enable mermaid, to load faster when the page does not contain mermaid\n    specific: false\n\n    # See: http://mermaid-js.github.io/mermaid/\n    options: { theme: 'default' }\n\n  # 评论插件\n  # Comment plugin\n  comments:\n    enable: false\n    # 指定的插件，需要同时设置对应插件的必要参数\n    # The specified plugin needs to set the necessary parameters at the same time\n    # Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss\n    type: disqus\n\n\n#---------------------------\n# 评论插件\n# Comment plugins\n#\n# 开启评论需要先设置上方 `post: comments: enable: true`，然后根据 `type` 设置下方对应的评论插件参数\n# Enable comments need to be set `post: comments: enable: true`, then set the corresponding comment plugin parameters below according to `type`\n#---------------------------\n\n# Utterances\n# 基于 GitHub Issues\n# Based on GitHub Issues\n# See: https://utteranc.es\nutterances:\n  repo:\n  issue_term: pathname\n  label: utterances\n  theme: github-light\n  theme_dark: github-dark\n\n# Disqus\n# 基于第三方的服务，国内用户直接使用容易被墙，建议配合 Disqusjs\n# Based on third-party service\n# See: https://disqus.com\ndisqus:\n  shortname:\n  # 以下为 Disqusjs 支持, 国内用户如果想使用 Disqus 建议配合使用\n  # The following are Disqusjs configurations, please ignore if DisqusJS is not required\n  # See: https://github.com/SukkaW/DisqusJS\n  disqusjs: false\n  apikey:\n\n# Gitalk\n# 基于 GitHub Issues\n# Based on GitHub Issues\n# See: https://github.com/gitalk/gitalk#options\ngitalk:\n  clientID:\n  clientSecret:\n  repo:\n  owner:\n  admin: ['name']\n  language: zh-CN\n  labels: ['Gitalk']\n  perPage: 10\n  pagerDirection: last\n  distractionFreeMode: false\n  createIssueManually: true\n  # 默认 proxy 可能会失效，解决方法请见下方链接\n  # The default proxy may be invalid, refer to the links for solutions\n  # https://github.com/gitalk/gitalk/issues/429\n  # https://github.com/Zibri/cloudflare-cors-anywhere\n  proxy: https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token\n\n# Valine\n# 基于 LeanCloud\n# Based on LeanCloud\n# See: https://valine.js.org/\nvaline:\n  appId:\n  appKey:\n  path: window.location.pathname\n  placeholder:\n  avatar: 'retro'\n  meta: ['nick', 'mail', 'link']\n  requiredFields: []\n  pageSize: 10\n  lang: 'zh-CN'\n  highlight: false\n  recordIP: false\n  serverURLs: ''\n  emojiCDN:\n  emojiMaps:\n  enableQQ: false\n\n# Waline\n# 从 Valine 衍生而来，额外增加了服务端和多种功能\n# Derived from Valine, with self-hosted service and new features\n# See: https://waline.js.org/\nwaline:\n  serverURL: ''\n  path: window.location.pathname\n  meta: ['nick', 'mail', 'link']\n  requiredMeta: ['nick']\n  lang: 'zh-CN'\n  emoji: ['https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo']\n  dark: 'html[data-user-color-scheme=\"dark\"]'\n  wordLimit: 0\n  pageSize: 10\n\n# 畅言 Changyan\n# 基于第三方的服务\n# Based on third-party service, insufficient support for regions outside China\n# http://changyan.kuaizhan.com\nchangyan:\n  appid: ''\n  appkey: ''\n\n# 来必力 Livere\n# 基于第三方的服务\n# Based on third-party service\n# See: https://www.livere.com\nlivere:\n  uid: ''\n\n# Remark42\n# 需要自托管服务端\n# Based on self-hosted service\n# See: https://remark42.com\nremark42:\n  host:\n  site_id:\n  max_shown_comments: 10\n  locale: zh\n  components: ['embed']\n\n# Twikoo\n# 支持腾讯云、Vercel、Railway 等多种平台部署\n# Based on Tencent CloudBase\n# See: https://twikoo.js.org\ntwikoo:\n  envId:\n  region: ap-shanghai\n  path: window.location.pathname\n\n# Cusdis\n# 基于第三方服务或自托管服务\n# Based on third-party or self-hosted service\n# See https://cusdis.com\ncusdis:\n  host:\n  app_id:\n  lang: zh-cn\n\n# Giscus\n# 基于 GitHub Discussions，类似于 Utterances\n# Based on GitHub Discussions, similar to Utterances\n# See: https://giscus.app/\ngiscus:\n  repo:\n  repo-id:\n  category:\n  category-id:\n  theme-light: light\n  theme-dark: dark\n  mapping: pathname\n  reactions-enabled: 1\n  emit-metadata: 0\n  input-position: top\n  lang: zh-CN\n\n# Discuss\n# 多平台、多数据库、自托管、免费开源评论系统\n# Self-hosted, small size, multi-platform, multi-database, free and open source commenting system\n# See: https://discuss.js.org\ndiscuss:\n  serverURLs:\n  path: window.location.pathname\n\n\n#---------------------------\n# 归档页\n# Archive Page\n#---------------------------\narchive:\n  banner_img: /img/default.png\n  banner_img_height: 60\n  banner_mask_alpha: 0.3\n\n\n#---------------------------\n# 分类页\n# Category Page\n#---------------------------\ncategory:\n  enable: true\n  banner_img: /img/default.png\n  banner_img_height: 60\n  banner_mask_alpha: 0.3\n\n  # 分类的排序字段，前面带减号是倒序，不带减号是正序\n  # Sort field for categories, with a minus sign is reverse order\n  # Options: length | name\n  order_by: \"-length\"\n\n  # 层级的折叠深度，0 是全部折叠，大于 0 后如果存在子分类则默认展开\n  # Collapse depth. If 0, all posts collapsed. If greater than 0, it will be expanded by default if there are subcategories\n  collapse_depth: 0\n\n  # 文章的排序字段，前面带减号是倒序，不带减号是正序\n  # Sort field for posts, with a minus sign is reverse order\n  # Options: date | title | or other field of front-matter\n  post_order_by: \"-date\"\n\n  # 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制\n  # The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit\n  post_limit: 10\n\n\n#---------------------------\n# 标签页\n# Tag Page\n#---------------------------\ntag:\n  enable: true\n  banner_img: /img/default.png\n  banner_img_height: 80\n  banner_mask_alpha: 0.3\n  tagcloud:\n    min_font: 15\n    max_font: 30\n    unit: px\n    start_color: \"#BBBBEE\"\n    end_color: \"#337ab7\"\n\n\n#---------------------------\n# 关于页\n# About Page\n#---------------------------\nabout:\n  enable: true\n  banner_img: /img/default.png\n  banner_img_height: 60\n  banner_mask_alpha: 0.3\n  avatar: /img/avatar.png\n  name: \"Fluid\"\n  intro: \"An elegant theme for Hexo\"\n  # 更多图标可从 https://hexo.fluid-dev.com/docs/icon/ 查找，`class` 代表图标的 css class，添加 `qrcode` 后，图标不再是链接而是悬浮二维码\n  # More icons can be found from https://hexo.fluid-dev.com/docs/en/icon/  `class` is the css class of the icon. If adding `qrcode`, The icon is no longer a link, but a hovering QR code\n  icons:\n    - { class: \"iconfont icon-github-fill\", link: \"https://github.com\", tip: \"GitHub\" }\n    - { class: \"iconfont icon-douban-fill\", link: \"https://douban.com\", tip: \"豆瓣\" }\n    - { class: \"iconfont icon-wechat-fill\", qrcode: \"/img/favicon.png\" }\n\n\n#---------------------------\n# 自定义页\n# Custom Page\n#\n# 通过 hexo new page 命令创建的页面\n# Custom Page through `hexo new page`\n#---------------------------\npage:\n  banner_img: /img/default.png\n  banner_img_height: 60\n  banner_mask_alpha: 0.3\n\n\n#---------------------------\n# 404页\n# 404 Page\n#---------------------------\npage404:\n  enable: true\n  banner_img: /img/default.png\n  banner_img_height: 85\n  banner_mask_alpha: 0.3\n  # 重定向到首页的延迟(毫秒)\n  # Delay in redirecting to home page (milliseconds)\n  redirect_delay: 5000\n\n\n#---------------------------\n# 友链页\n# Links Page\n#---------------------------\nlinks:\n  enable: true\n  banner_img: /img/default.png\n  banner_img_height: 60\n  banner_mask_alpha: 0.3\n  # 友链的成员项\n  # Member item of page\n  items:\n    - {\n      title: \"Fluid Blog\",\n      intro: \"主题博客\",\n      link: \"https://hexo.fluid-dev.com/\",\n      avatar: \"/img/favicon.png\"\n    }\n    - {\n      title: \"Fluid Docs\",\n      intro: \"主题使用指南\",\n      link: \"https://hexo.fluid-dev.com/docs/\",\n      avatar: \"/img/favicon.png\"\n    }\n    - {\n      title: \"Fluid Repo\",\n      intro: \"主题 GitHub 仓库\",\n      link: \"https://github.com/fluid-dev/hexo-theme-fluid\",\n      avatar: \"/img/favicon.png\"\n    }\n\n  # 当成员头像加载失败时，替换为指定图片\n  # When the member avatar fails to load, replace the specified image\n  onerror_avatar: /img/avatar.png\n\n  # 友链下方自定义区域，支持 HTML，可插入例如申请友链的文字\n  # Custom content at the bottom of the links\n  custom:\n    enable: false\n    content: '<hr><p>在下方留言申请加入我的友链，按如下格式提供信息：</p><ul><li>博客名：Fluid</li><li>简介：Fluid 主题官方博客</li><li>链接：https://hexo.fluid-dev.com</li><li>图片：https://hexo.fluid-dev.com/img/favicon.png</li></ul>'\n\n  # 评论插件\n  # Comment plugin\n  comments:\n    enable: false\n    # 指定的插件，需要同时设置对应插件的必要参数\n    # The specified plugin needs to set the necessary parameters at the same time\n    # Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss\n    type: disqus\n\n\n#---------------------------\n# 以下是配置 JS CSS 等静态资源的 URL 前缀，可以自定义成 CDN 地址，\n# 如果需要修改，最好使用与默认配置相同的版本，以避免潜在的问题，\n# ** 如果你不知道如何设置，请不要做任何改动 **\n#\n# Here is the url prefix to configure the static assets. Set CDN addresses you want to customize.\n# Be aware that you would better use the same version as default ones to avoid potential problems.\n# DO NOT EDIT THE FOLLOWING SETTINGS UNLESS YOU KNOW WHAT YOU ARE DOING\n#---------------------------\n\nstatic_prefix:\n  # 内部静态\n  # Internal static\n  internal_js: /js\n  internal_css: /css\n  internal_img: /img\n\n  anchor: https://lib.baomitu.com/anchor-js/4.3.1/\n\n  github_markdown: https://lib.baomitu.com/github-markdown-css/4.0.0/\n\n  jquery: https://lib.baomitu.com/jquery/3.6.4/\n\n  bootstrap: https://lib.baomitu.com/twitter-bootstrap/4.6.1/\n\n  prismjs: https://lib.baomitu.com/prism/1.29.0/\n\n  tocbot: https://lib.baomitu.com/tocbot/4.20.1/\n\n  typed: https://lib.baomitu.com/typed.js/2.0.12/\n\n  fancybox: https://lib.baomitu.com/fancybox/3.5.7/\n\n  nprogress: https://lib.baomitu.com/nprogress/0.2.0/\n\n  mathjax: https://lib.baomitu.com/mathjax/3.2.2/\n\n  katex: https://lib.baomitu.com/KaTeX/0.16.2/\n\n  busuanzi: https://busuanzi.ibruce.info/busuanzi/2.3/\n\n  clipboard: https://lib.baomitu.com/clipboard.js/2.0.11/\n\n  mermaid: https://lib.baomitu.com/mermaid/8.14.0/\n\n  valine: https://lib.baomitu.com/valine/1.5.1/\n\n  waline: https://cdn.staticfile.org/waline/2.15.5/\n\n  gitalk: https://lib.baomitu.com/gitalk/1.8.0/\n\n  disqusjs: https://lib.baomitu.com/disqusjs/1.3.0/\n\n  twikoo: https://lib.baomitu.com/twikoo/1.6.8/\n\n  discuss: https://lib.baomitu.com/discuss/1.2.1/\n\n  hint: https://lib.baomitu.com/hint.css/2.7.0/\n\n  moment: https://lib.baomitu.com/moment.js/2.29.4/\n~~~\n\n### 站点配置\n\n现在对我而言还有两个问题，我换到 Fluid 就是为了 Latex  \n所以……  \n这里还是按官方来，[^4]\n\n1. **设置主题配置**  \n    $我这里使用的是\\;mathjax+pandoc,\\;$  \n    $好处是别人可以复制你写的\\;Latex$  \n    $\\begin{aligned}坏处是\\hspace{340px}\\\\  \n    他的换行不能像 typora的'\\backslash\\backslash'直接换行,\\hspace{115px}\\\\  \n    要使用\\backslash begin\\{aligned\\}\\backslash end\\{aligned\\}\\hspace{100px}\\\\  \n    才能'\\backslash\\backslash'换行\\hspace{300px}\\\\  \n    而且不能使用\\backslash hfill只能使用\\backslash hspace\\{num\\; cm/px\\}\\hspace{10px}  \n    \\end{aligned}$  \n    而且换行前必须打两个空格  \n\n    ~~~yaml\n    post:  \n      math:  \n       enable: true  \n       specific: false  \n    \t  engine: mathjax  \n    ~~~\n\n    `specific`: 建议开启。当为 true 时，只有在文章 [front-matter (opens new window)](https://hexo.io/zh-cn/docs/front-matter)里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。\n\n    `engine`: 公式引擎，目前支持 `mathjax` 或 `katex`。\n\n2. **更换 Markdown 渲染器**  \n    由于 Hexo 默认的 Markdown 渲染器不支持复杂公式，所以需要更换渲染器（mathjax 可选择性更换）。\n    然后根据上方配置不同的 `engine`，推荐更换如下渲染器：\n  \n    * mathjax\n      ~~~sh\n      npm uninstall hexo-renderer-marked --save\n      npm install hexo-renderer-pandoc --save\n      ~~~\n    \n      **并且还需[安装 Pandoc](https://github.com/jgm/pandoc/blob/master/INSTALL.md)**\n    \n    * katex\n\t  ~~~sh\n\t  npm uninstall hexo-renderer-marked --save\n\t  npm install hexo-renderer-markdown-it --save\n\t  npm install @traptitech/markdown-it-katex --save\n\t  ~~~\n\t  \n\t  然后在站点配置中添加：\n      ~~~yaml\n      markdown:\n        plugins:\n          - \"@traptitech/markdown-it-katex\"\n\t  ~~~\n### 我安装Pandoc过程\n\n环境说明：Windows11\n\n1. [下载 Pandoc](https://github.com/jgm/pandoc/blob/master/INSTALL.md)  \n   下载链接[download page](https://github.com/jgm/pandoc/releases/latest)  \n   ![](/imgs/Hexo主题变更/pandoc1.png)找到 window，我使用的是 msi：  \n   ![](/imgs/Hexo主题变更/pandoc1-1.png)  \n2. 按照提示安装就可以，这里可以自选目录  \n   pandoc 和 hexo-renderer-pandoc不一样，一个是程序，一个是hexo的渲染插件\n\n### 插入图片\n\n我还是用的老办法，`![](/imgs/xxxx)`，  \n想要在 typora 也显示，那就把文档的图片放到一个文件夹`/imgs/`内  \nFluid 会在`..\\Blog\\source`目录下寻找图片资源文件，其他类型应该也是一样。\n\n## 待解决问题\n\n* 换行异常：  \n  typora 可以换行，但是 web blog 不能换行只能换段  \n  latex 公式不能换行  \n  * 因为pandoc和typora语法不一样\n  * 这里给出修改代码  \n    这里的代码有问题哦，但是我不改了……也都有注释，如果你需要可以自行修改  \n    编译原理的自动机学过伐，一样的\n    \n    ~~~python  \n    import os\n    \n    # 指定需要修改的 Markdown 文件夹路径  \n    folder_path = '/path/to/markdown_folder/'\n    \n    def process_md_file(file_path):  \n        with open(file_path, 'r', encoding='utf-8') as f:  \n            content = f.readlines()\n    \n        modified_content = []  \n        code_block = False  \n        latex_block = False  \n        setting_block = False  \n        for i in range(len(content)):  \n            line = content[i].rstrip('\\n')\n    \n            # 判断是否进入或退出代码块  \n            if line.startswith('~~~'):  \n                code_block = not code_block\n    \n            # 判断是否进入或退出 LaTeX 段落  \n            if line.startswith('$$'):  \n                latex_block = not latex_block\n    \n            # 判断是否进入或退出设置段  \n            if line.startswith('---'):  \n                setting_block = not setting_block\n    \n            # 如果在代码块内、LaTeX 段落内或设置段内，则不做修改  \n            if code_block or latex_block or setting_block:  \n                modified_content.append(line)  \n            else:  \n                # 如果行首是标题，则不加空格  \n                if line.startswith('#'):  \n                    modified_content.append(line)  \n                # 如果行首以 <img 开头，则不做修改  \n                elif line.lstrip().startswith('<img'):  \n                    modified_content.append(line)  \n                # 如果行首以 < 开头，则不加空格（除了 <img 外）  \n                elif line.startswith('<'):  \n                    modified_content.append(line)  \n                else:  \n                    # 如果行尾已经有两个空格，则不做修改  \n                    if line.endswith('  '):  \n                        modified_content.append(line)  \n                    else:  \n                        # 判断下一行是否为空行  \n                        if i < len(content) - 1 and content[i+1].strip() == '':  \n                            modified_content.append(line)  \n                        else:  \n                            modified_content.append(line + '  ')\n    \n        with open(file_path, 'w', encoding='utf-8') as f:  \n            f.write('\\n'.join(modified_content))\n    \n        print(f'已修改文件: {file_path}')\n    \n    # 遍历 Markdown 文件夹下的所有文件  \n    for root, dirs, files in os.walk(folder_path):  \n        for file in files:  \n            if file.endswith('.md'):  \n                file_path = os.path.join(root, file)  \n                process_md_file(file_path)\n    \n    print('所有文件修改完成')  \n    ~~~\n  \n\n标题段落间隔大 : 主题问题\n\n## 参考\n\n[^0]:[图片搜索:saucenao](https://saucenao.com/)\n[^1]:[Hexo Fulid 官方Doc](https://hexo.fluid-dev.com/docs)\n[^2]:[配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/guide/#覆盖配置)\n[^3]:[主题配置](https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml)  \n[^4]:[配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/guide/#latex-数学公式)  \n[^5]:[hexo-theme-fluid/_config.yml at master · fluid-dev/hexo-theme-fluid (github.com)](https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml)\n\n[MathJax 文档 — MathJax 3.2 文档](https://docs.mathjax.org/en/latest/index.html)\n\n[Front-matter | Hexo](https://hexo.io/zh-cn/docs/front-matter)\n\n[hexojs/hexo-math: A hexo plugin that uses MathJax to render math equations. (github.com)](https://github.com/hexojs/hexo-math)\n\n[pandoc/INSTALL.md 在主 ·JGM/PANDOC的 (github.com)](https://github.com/jgm/pandoc/blob/main/INSTALL.md)  ","source":"_posts/Hexo主题更改.md","raw":"---\ntitle: Hexo 主题变更\ntags: [Hexo,主题变更]\nmath: true\nindex_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\nbanner_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\ndate: 2024-01-13\ntypora-root-url: ../\n---\n\n更换了Hexo 主题，之前 yilia 主题作者是不是开摆了……我看很久没更新.  \nnalama！答案只有一个了，我将向你—— Fluid 效忠！图源自Pix画师ID:67549695  \n<!--more-->\n\n# Hexo 主题切换\n\n这里以 yilia 切换到 Fluid 为例，我这里只是分享一下自己是怎么做的，遇到什么问题，  \n肯定有不对的地方，欢迎大家教我。\n\n## 准备工作\n\n鉴于前面我自己把 blog 干崩过，所有我强烈建议所有人都在 github 存一个仓库备份本地的 Blog  \n因为 Hexo 这种静态blog **本地磁盘的源文件**和**生成的网页**，是两个部分。\n\n你能不能说人话什么本地，网页的！  \n好好好，你先别急，我知道你很急，但是你先别急。\n\n* 本地的源文件：  \n  ![](/imgs/Hexo主题变更/deskt.png)  \n* 生成的网页：  \n  ![](/imgs/Hexo主题变更/web.png)\n  我们可以将本地文件存储到 github 备份，也方便 fallback 和 迁移。\n\n## 切换\n\n将 Hexo 博客主题从 yilia 切换到 Fluid 的步骤如下：\n\n1. 首先，您需要在本地安装 Fluid 主题。  \n   可以使用以下命令从 GitHub 上下载 Fluid 主题并将其保存到您的 Hexo 博客的 themes 文件夹中：\n  \n   ```  \n   git clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid  \n   ```\n  \n2. 下载完成后，进入 Hexo 博客的根目录，并打开 _config.yml 文件。  \n   将 theme 字段的值更改为 \"fluid\"，如下所示：\n   \n   ```  \n   theme: fluid  \n   ```\n\n### 修改主题配置\n\n主题配置指的是 hexo 所采用的 theme 所用配置，而并非对 Hexo blog 的配置\n\n> TIP[^1]  \n>  \n> 致主题的新用户：  \n>  \n> - 本指南经过数个版本打磨，  \n>   绝大部分的功能都有详细说明，请仔细阅读，节约自己和他人的时间；  \n> - 本指南中提到的：\"**站点配置**\" 指的 Hexo 博客目录下的 `_config.yml`，\"**主题配置**\" 指的是 `theme/fluid/_config.yml` 或者 `_config.fluid.yml` ，注意区分；  \n> - 本指南中提到的 `source` 目录都指的是博客目录下的 `source` 文件夹，不推荐修改主题内 `source` 目录；  \n> - 每次无论 `hexo g` 或 `hexo s`，都最好先使用 `hexo clean` 清除本地缓存；  \n> - 页面结果以本地 `hexo s` 为准，部署后的异常大部分是线上缓存原因，在确认没有报错的情况下，等待若干时间后即可正常；  \n> - 由于主题的不同版本会存在配置差异，本指南以最新版本为准。\n\n这里按照官方文档所说去做就行，为什么这么配文档也有说，我这里是 Hexo 6.1.0。[^2]  \n所以在Blog 根目录创建 `_config.fluid.yml`  \n![](/imgs/Hexo主题变更/Fluid_Config.png)  \n然后在该文件内，粘贴 Fluid 官方给定的配置[^3]就行，当然你可以根据他的自定义，  \n但是我不会，因为我不会……\n\n#### code，建议别从我这里复制，这个blog会崩溃，去官网吧[^5]\n\n~~~yaml\n#---------------------------\n# Hexo Theme Fluid\n# Author: Fluid-dev\n# Github: https://github.com/fluid-dev/hexo-theme-fluid\n#\n# 配置指南: https://hexo.fluid-dev.com/docs/guide/\n# 你可以从指南中获得更详细的说明\n#\n# Guide: https://hexo.fluid-dev.com/docs/en/guide/\n# You can get more detailed help from the guide\n#---------------------------\n\n\n#---------------------------\n# 全局\n# Global\n#---------------------------\n\n# 用于浏览器标签的图标\n# Icon for browser tab\nfavicon: /img/fluid.png\n\n# 用于苹果设备的图标\n# Icon for Apple touch\napple_touch_icon: /img/fluid.png\n\n# 浏览器标签页中的标题分隔符，效果： 文章名 - 站点名\n# Title separator in browser tab, eg: article - site\ntab_title_separator: \" - \"\n\n# 强制所有链接升级为 HTTPS（适用于图片等资源出现 HTTP 混入报错）\n# Force all links to be HTTPS (applicable to HTTP mixed error)\nforce_https: false\n\n# 代码块的增强配置\n# Enhancements to code blocks\ncode:\n  # 是否开启复制代码的按钮\n  # Enable copy code button\n  copy_btn: true\n\n  # 代码语言\n  # Code language\n  language:\n    enable: true\n    default: \"TEXT\"\n\n  # 代码高亮\n  # Code highlight\n  highlight:\n    enable: true\n\n    # 代码块是否显示行号\n    # If true, the code block display line numbers\n    line_number: true\n\n    # 实现高亮的库，对应下面的设置\n    # Highlight library\n    # Options: highlightjs | prismjs\n    lib: \"highlightjs\"\n\n    highlightjs:\n      # 在链接中挑选 style 填入\n      # Select a style in the link\n      # See: https://highlightjs.org/static/demo/\n      style: \"github gist\"\n      style_dark: \"dark\"\n\n    prismjs:\n      # 在下方链接页面右侧的圆形按钮挑选 style 填入，也可以直接填入 css 链接\n      # Select the style button on the right side of the link page, you can also set the CSS link\n      # See: https://prismjs.com/\n      style: \"default\"\n      style_dark: \"tomorrow night\"\n\n      # 设为 true 高亮将本地静态生成（但只支持部分 prismjs 插件），设为 false 高亮将在浏览器通过 js 生成\n      # If true, it will be generated locally (but some prismjs plugins are not supported). If false, it will be generated via JS in the browser\n      preprocess: true\n\n# 一些好玩的功能\n# Some fun features\nfun_features:\n  # 为 subtitle 添加打字机效果\n  # Typing animation for subtitle\n  typing:\n    enable: true\n\n    # 打印速度，数字越大越慢\n    # Typing speed, the larger the number, the slower\n    typeSpeed: 70\n\n    # 游标字符\n    # Cursor character\n    cursorChar: \"_\"\n\n    # 是否循环播放效果\n    # If true, loop animation\n    loop: false\n\n    # 在指定页面开启，不填则在所有页面开启\n    # Enable in specified page, all pages by default\n    # Options: home | post | tag | category | about | links | page | 404\n    scope: []\n\n  # 为文章内容中的标题添加锚图标\n  # Add an anchor icon to the title on the post page\n  anchorjs:\n    enable: true\n    element: h1,h2,h3,h4,h5,h6\n    # Options: left | right\n    placement: left\n    # Options: hover | always | touch\n    visible: hover\n    # Options: § | # | ❡\n    icon: \"\"\n\n  # 加载进度条\n  # Progress bar when loading\n  progressbar:\n    enable: true\n    height_px: 3\n    color: \"#29d\"\n    # See: https://github.com/rstacruz/nprogress\n    options: { showSpinner: false, trickleSpeed: 100 }\n\n# 主题暗色模式，开启后菜单中会出现切换按钮，用户浏览器会存储切换选项，并且会遵循 prefers-color-scheme 自动切换\n# Theme dark mode. If enable, a switch button will appear on the menu, each of the visitor's browser will store his switch option\ndark_mode:\n  enable: true\n  # 默认的选项（当用户手动切换后则不再按照默认模式），选择 `auto` 会优先遵循 prefers-color-scheme，其次按用户本地时间 18 点到次日 6 点之间进入暗色模式\n  # Default option (when the visitor switches manually, the default mode is no longer followed), choosing `auto` will give priority to prefers-color-scheme, and then enter the dark mode from 18:00 to 6:00 in the visitor’s local time\n  # Options: auto | light | dark\n  default: auto\n\n# 主题颜色配置，其他不生效的地方请使用自定义 css 解决，配色可以在下方链接中获得启发\n# Theme color, please use custom CSS to solve other colors, color schema can be inspired by the links below\n# See: https://www.webdesignrankings.com/resources/lolcolors/\ncolor:\n  # body 背景色\n  # Color of body background\n  body_bg_color: \"#eee\"\n  # 暗色模式下的 body 背景色，下同\n  # Color in dark mode, the same below\n  body_bg_color_dark: \"#181c27\"\n\n  # 顶部菜单背景色\n  # Color of navigation bar background\n  navbar_bg_color: \"#2f4154\"\n  navbar_bg_color_dark: \"#1f3144\"\n\n  # 顶部菜单字体色\n  # Color of navigation bar text\n  navbar_text_color: \"#fff\"\n  navbar_text_color_dark: \"#d0d0d0\"\n\n  # 副标题字体色\n  # Color of navigation bar text\n  subtitle_color: \"#fff\"\n  subtitle_color_dark: \"#d0d0d0\"\n\n  # 全局字体色\n  # Color of global text\n  text_color: \"#3c4858\"\n  text_color_dark: \"#c4c6c9\"\n\n  # 全局次级字体色（摘要、简介等位置）\n  # Color of global secondary text (excerpt, introduction, etc.)\n  sec_text_color: \"#718096\"\n  sec_text_color_dark: \"#a7a9ad\"\n\n  # 主面板背景色\n  # Color of main board\n  board_color: \"#fff\"\n  board_color_dark: \"#252d38\"\n\n  # 文章正文字体色\n  # Color of post text\n  post_text_color: \"#2c3e50\"\n  post_text_color_dark: \"#c4c6c9\"\n\n  # 文章正文字体色（h1 h2 h3...）\n  # Color of Article heading (h1 h2 h3...)\n  post_heading_color: \"#1a202c\"\n  post_heading_color_dark: \"#c4c6c9\"\n\n  # 文章超链接字体色\n  # Color of post link\n  post_link_color: \"#0366d6\"\n  post_link_color_dark: \"#1589e9\"\n\n  # 超链接悬浮时字体色\n  # Color of link when hovering\n  link_hover_color: \"#30a9de\"\n  link_hover_color_dark: \"#30a9de\"\n\n  # 超链接悬浮背景色\n  # Color of link background when hovering\n  link_hover_bg_color: \"#f8f9fa\"\n  link_hover_bg_color_dark: \"#364151\"\n\n  # 分隔线和表格边线的颜色\n  # Color of horizontal rule and table border\n  line_color: \"#eaecef\"\n  line_color_dark: \"#435266\"\n\n  # 滚动条颜色\n  # Color of scrollbar\n  scrollbar_color: \"#c4c6c9\"\n  scrollbar_color_dark: \"#687582\"\n  # 滚动条悬浮颜色\n  # Color of scrollbar when hovering\n  scrollbar_hover_color: \"#a6a6a6\"\n  scrollbar_hover_color_dark: \"#9da8b3\"\n\n  # 按钮背景色\n  # Color of button\n  button_bg_color: \"transparent\"\n  button_bg_color_dark: \"transparent\"\n  # 按钮悬浮背景色\n  # Color of button when hovering\n  button_hover_bg_color: \"#f2f3f5\"\n  button_hover_bg_color_dark: \"#46647e\"\n\n# 主题字体配置\n# Font\nfont:\n  font_size: 16px\n  font_family:\n  letter_spacing: 0.02em\n  code_font_size: 85%\n\n# 指定自定义 .js 文件路径，支持列表；路径是相对 source 目录，如 /js/custom.js 对应存放目录 source/js/custom.js\n# Specify the path of your custom js file, support list. The path is relative to the source directory, such as `/js/custom.js` corresponding to the directory `source/js/custom.js`\ncustom_js:\n\n# 指定自定义 .css 文件路径，用法和 custom_js 相同\n# The usage is the same as custom_js\ncustom_css:\n\n# 网页访问统计\n# Analysis of website visitors\nweb_analytics:  # 网页访问统计\n  enable: false\n\n  # 遵循访客浏览器\"请勿追踪\"的设置，如果开启则不统计其访问\n  # Follow the \"Do Not Track\" setting of the visitor's browser\n  # See: https://www.w3.org/TR/tracking-dnt/\n  follow_dnt: true\n\n  # 百度统计的 Key，值需要获取下方链接中 `hm.js?` 后边的字符串\n  # Baidu analytics, get the string behind `hm.js?`\n  # See: https://tongji.baidu.com/sc-web/10000033910/home/site/getjs?siteId=13751376\n  baidu:\n\n  # Google Analytics 4 的媒体资源 ID\n  # Google Analytics 4 MEASUREMENT_ID\n  # See: https://support.google.com/analytics/answer/9744165#zippy=%2Cin-this-article\n  google:\n    measurement_id:\n\n  # 腾讯统计的 H5 App ID，开启高级功能才有cid\n  # Tencent analytics, set APP ID\n  # See: https://mta.qq.com/h5/manage/ctr_app_manage\n  tencent:\n    sid:\n    cid:\n\n  # 51.la 站点统计 ID\n  # 51.la analytics\n  # See: https://www.51.la/user/site/index\n  woyaola:  # 51.la 站点统计 ID，参见\n\n  # 友盟/cnzz 站点统计 web_id\n  # cnzz analytics\n  # See: https://web.umeng.com/main.php?c=site&a=show\n  cnzz:\n\n  # LeanCloud 计数统计，可用于 PV UV 展示，如果 `web_analytics: enable` 没有开启，PV UV 展示只会查询不会增加\n  # LeanCloud count statistics, which can be used for PV UV display. If `web_analytics: enable` is false, PV UV display will only query and not increase\n  leancloud:\n    app_id:\n    app_key:\n    # REST API 服务器地址，国际版不填\n    # Only the Chinese mainland users need to set\n    server_url:\n    # 统计页面时获取路径的属性\n    # Get the attribute of the page path during statistics\n    path: window.location.pathname\n    # 开启后不统计本地路径( localhost 与 127.0.0.1 )\n    # If true, ignore localhost & 127.0.0.1\n    ignore_local: false\n\n# 对页面中的图片和评论插件进行懒加载处理，可见范围外的元素不会提前加载\n# Lazy loading of images and comment plugin on the page\nlazyload:\n  enable: true\n\n  # 加载时的占位图片\n  # The placeholder image when loading\n  loading_img: /img/loading.gif\n\n  # 开启后懒加载仅在文章页生效，如果自定义页面需要使用，可以在 Front-matter 里指定 `lazyload: true`\n  # If true, only enable lazyload on the post page. For custom pages, you can set 'lazyload: true' in front-matter\n  onlypost: false\n\n  # 触发加载的偏移倍数，基数是视窗高度，可根据部署环境的请求速度调节\n  # The factor of viewport height that triggers loading\n  offset_factor: 2\n\n# 图标库，包含了大量社交类图标，主题依赖的不包含在内，因此可自行修改，详见 https://hexo.fluid-dev.com/docs/icon/\n# Icon library, which includes many social icons, does not include those theme dependent, so your can modify link by yourself. See: https://hexo.fluid-dev.com/docs/en/icon/\niconfont: //at.alicdn.com/t/font_1736178_lbnruvf0jn.css\n\n\n#---------------------------\n# 页头\n# Header\n#---------------------------\n\n# 导航栏的相关配置\n# Navigation bar\nnavbar:\n  # 导航栏左侧的标题，为空则按 hexo config 中 `title` 显示\n  # The title on the left side of the navigation bar. If empty, it is based on `title` in hexo config\n  blog_title: \"Fluid\"\n\n  # 导航栏毛玻璃特效，实验性功能，可能会造成页面滚动掉帧和抖动，部分浏览器不支持会自动不生效\n  # Navigation bar frosted glass special animation. It is an experimental feature\n  ground_glass:\n    enable: false\n\n    # 模糊像素，只能为数字，数字越大模糊度越高\n    # Number of blurred pixel. the larger the number, the higher the blur\n    px: 3\n\n    # 不透明度，数字越大透明度越低，注意透明过度可能看不清菜单字体\n    # Ratio of opacity, 1.0 is completely opaque\n    # available: 0 - 1.0\n    alpha: 0.7\n\n  # 导航栏菜单，可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称\n  # Navigation bar menu. `key` is used to associate languages/*.yml. If there is no association, the value of `key` itself will be displayed; if `icon` is a css class, it can be omitted; adding `name` can force the display of the specified name\n  menu:\n    - { key: \"home\", link: \"/\", icon: \"iconfont icon-home-fill\" }\n    - { key: \"archive\", link: \"/archives/\", icon: \"iconfont icon-archive-fill\" }\n    - { key: \"category\", link: \"/categories/\", icon: \"iconfont icon-category-fill\" }\n    - { key: \"tag\", link: \"/tags/\", icon: \"iconfont icon-tags-fill\" }\n    - { key: \"about\", link: \"/about/\", icon: \"iconfont icon-user-fill\" }\n    #- { key: \"links\", link: \"/links/\", icon: \"iconfont icon-link-fill\" }\n\n# 搜索功能，基于 hexo-generator-search 插件，若已安装其他搜索插件请关闭此功能，以避免生成多余的索引文件\n# Search feature, based on hexo-generator-search. If you have installed other search plugins, please disable this feature to avoid generating redundant index files\nsearch:\n  enable: true\n\n  # 搜索索引文件的路径，可以是相对路径或外站的绝对路径\n  # Path for search index file, it can be a relative path or an absolute path\n  path: /local-search.xml\n\n  # 文件生成在本地的位置，必须是相对路径\n  # The location where the index file is generated locally, it must be a relative location\n  generate_path: /local-search.xml\n\n  # 搜索的范围\n  # Search field\n  # Options: post | page | all\n  field: post\n\n  # 搜索是否扫描正文\n  # If true, search will scan the post content\n  content: true\n\n# 首屏图片的相关配置\n# Config of the big image on the first screen\nbanner:\n  # 视差滚动，图片与板块会随着屏幕滚动产生视差效果\n  # Scrolling parallax\n  parallax: true\n\n  # 图片最小的宽高比，以免图片两边被过度裁剪，适用于移动端竖屏时，如需关闭设为 0\n  # Minimum ratio of width to height, applicable to the vertical screen of mobile device, if you need to close it, set it to 0\n  width_height_ratio: 1.0\n\n# 向下滚动的箭头\n# Scroll down arrow\nscroll_down_arrow:\n  enable: true\n\n  # 头图高度不小于指定比例，才显示箭头\n  # Only the height of the banner image is greater than the ratio, the arrow is displayed\n  # Available: 0 - 100\n  banner_height_limit: 80\n\n  # 翻页后自动滚动\n  # Auto scroll after page turning\n  scroll_after_turning_page: true\n\n# 向顶部滚动的箭头\n# Scroll top arrow\nscroll_top_arrow:\n  enable: true\n\n# Open Graph metadata\n# See: https://hexo.io/docs/helpers.html#open-graph\nopen_graph:\n  enable: true\n  twitter_card: summary_large_image\n  twitter_id:\n  twitter_site:\n  google_plus:\n  fb_admins:\n  fb_app_id:\n\n\n#---------------------------\n# 页脚\n# Footer\n#---------------------------\nfooter:\n  # 页脚第一行文字的 HTML，建议保留 Fluid 的链接，用于向更多人推广本主题\n  # HTML of the first line of the footer, it is recommended to keep the Fluid link to promote this theme to more people\n  content: '\n    <a href=\"https://hexo.io\" target=\"_blank\" rel=\"nofollow noopener\"><span>Hexo</span></a>\n    <i class=\"iconfont icon-love\"></i>\n    <a href=\"https://github.com/fluid-dev/hexo-theme-fluid\" target=\"_blank\" rel=\"nofollow noopener\"><span>Fluid</span></a>\n  '\n\n  # 展示网站的 PV、UV 统计数\n  # Display website PV and UV statistics\n  statistics:\n    enable: false\n\n    # 统计数据来源，使用 leancloud 需要设置 `web_analytics: leancloud` 中的参数；使用 busuanzi 不需要额外设置，但是有时不稳定，另外本地运行时 busuanzi 显示统计数据很大属于正常现象，部署后会正常\n    # Data source. If use leancloud, you need to set the parameter in `web_analytics: leancloud`\n    # Options: busuanzi | leancloud\n    source: \"busuanzi\"\n\n  # 国内大陆服务器的备案信息\n  # For Chinese mainland website policy, other areas keep disable\n  beian:\n    enable: false\n    # ICP证号\n    icp_text: 京ICP证123456号\n    # 公安备案号，不填则只显示ICP\n    police_text: 京公网安备12345678号\n    # 公安备案的编号，用于URL跳转查询\n    police_code: 12345678\n    # 公安备案的图片. 为空时不显示备案图片\n    police_icon: /img/police_beian.png\n\n\n#---------------------------\n# 首页\n# Home Page\n#---------------------------\nindex:\n  # 首页 Banner 头图，可以是相对路径或绝对路径，以下相同\n  # Path of Banner image, can be a relative path or an absolute path, the same on other pages\n  banner_img: /img/default.png\n\n  # 头图高度，屏幕百分比\n  # Height ratio of banner image\n  # Available: 0 - 100\n  banner_img_height: 100\n\n  # 头图黑色蒙版的不透明度，available: 0 - 1.0， 1 是完全不透明\n  # Opacity of the banner mask, 1.0 is completely opaque\n  # Available: 0 - 1.0\n  banner_mask_alpha: 0.3\n\n  # 首页副标题的独立设置\n  # Independent config of home page subtitle\n  slogan:\n    enable: true\n\n    # 为空则按 hexo config.subtitle 显示\n    # If empty, text based on `subtitle` in hexo config\n    text: \"An elegant Material-Design theme for Hexo\"\n\n    # 通过 API 接口作为首页副标题的内容，必须返回的是 JSON 格式，如果请求失败则按 text 字段显示，该功能必须先开启 typing 打字机功能\n    # Subtitle of the homepage through the API, must be returned a JSON. If the request fails, it will be displayed in `text` value. This feature must first enable the typing animation\n    api:\n      enable: false\n\n      # 请求地址\n      # Request url\n      url: \"\"\n\n      # 请求方法\n      # Request method\n      # Available: GET | POST | PUT\n      method: \"GET\"\n\n      # 请求头\n      # Request headers\n      headers: {}\n\n      # 从请求结果获取字符串的取值字段，最终必须是一个字符串，例如返回结果为 {\"data\": {\"author\": \"fluid\", \"content\": \"An elegant theme\"}}, 则取值字段为 ['data', 'content']；如果返回是列表则自动选择第一项\n      # The value field of the string obtained from the response. For example, the response content is {\"data\": {\"author\": \"fluid\", \"content\": \"An elegant theme\"}}, the expected `keys: ['data','content']`; if the return is a list, the first item is automatically selected\n      keys: []\n\n  # 自动截取文章摘要\n  # Auto extract post\n  auto_excerpt:\n    enable: true\n\n  # 打开文章的标签方式\n  # The browser tag to open the post\n  # Available: _blank | _self\n  post_url_target: _self\n\n  # 是否显示文章信息（时间、分类、标签）\n  # Meta information of post\n  post_meta:\n    date: true\n    category: true\n    tag: true\n\n  # 文章通过 sticky 排序后，在首页文章标题前显示图标\n  # If the posts are sorted by `sticky`, an icon is displayed in front of the post title\n  post_sticky:\n    enable: true\n    icon: \"iconfont icon-top\"\n\n\n#---------------------------\n# 文章页\n# Post Page\n#---------------------------\npost:\n  banner_img: /img/default.png\n  banner_img_height: 70\n  banner_mask_alpha: 0.3\n\n  # 文章在首页的默认封面图，当没有指定 index_img 时会使用该图片，若两者都为空则不显示任何图片\n  # Path of the default post cover when `index_img` is not set. If both are empty, no image will be displayed\n  default_index_img:\n\n  # 文章标题下方的元信息\n  # Meta information below title\n  meta:\n    # 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值\n    # Author, based on `author` field in front-matter, if not set, based on `author` value in hexo config\n    author:\n      enable: false\n\n    # 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期\n    # Post date, based on `date` field in front-matter, if not set, based on create date of .md file\n    date:\n      enable: true\n      # 格式参照 ISO-8601 日期格式化\n      # ISO-8601 date format\n      # See: http://momentjs.cn/docs/#/parsing/string-format/\n      format: \"LL a\"\n\n    # 字数统计\n    # Word count\n    wordcount:\n      enable: true\n\n    # 估计阅读全文需要的时长\n    # Estimated reading time\n    min2read:\n      enable: true\n      # 每个字词的长度，建议：中文≈2，英文≈5，中英混合可自行调节\n      # Average word length (chars count in word), ZH ≈ 2, EN ≈ 5\n      awl: 2\n      # 每分钟阅读字数，如果大部分是技术文章可适度调低\n      # Words per minute\n      wpm: 60\n\n    # 浏览量计数\n    # Number of visits\n    views:\n      enable: false\n      # 统计数据来源\n      # Data Source\n      # Options: busuanzi | leancloud\n      source: \"busuanzi\"\n\n  # 在文章开头显示文章更新时间，该时间默认是 md 文件更新时间，可通过 front-matter 中 `updated` 手动指定（和 date 一样格式）\n  # Update date is displayed at the beginning of the post. The default date is the update date of the md file, which can be manually specified by `updated` in front-matter (same format as date)\n  updated:\n    enable: false\n\n    # 格式参照 ISO-8601 日期格式化\n    # ISO-8601 date format\n    # See: http://momentjs.cn/docs/#/parsing/string-format/\n    date_format: \"LL a\"\n\n    # 是否使用相对时间表示，比如：\"3 天前\"\n    # If true, it will be a relative time, such as: \"3 days ago\"\n    relative: false\n\n    # 提示标签类型\n    # Note class\n    # Options: default | primary | info | success | warning | danger | light\n    note_class: info\n\n  # 侧边栏展示当前分类下的文章\n  # Sidebar of category\n  category_bar:\n    enable: true\n\n    # 开启后，只有在文章 Front-matter 里指定 `category_bar: true` 才会展示分类，也可以通过 `category_bar: [\"分类A\"]` 来指定分类\n    # If true, only set `category_bar: true` in Front-matter will enable sidebar of category, also set `category_bar: [\"CategoryA\"]` to specify categories\n    specific: true\n\n    # 置于板块的左侧或右侧\n    # place in the board\n    # Options: left | right\n    placement: left\n\n    # 文章的排序字段，前面带减号是倒序，不带减号是正序\n    # Sort field for posts, with a minus sign is reverse order\n    # Options: date | title | or other field of front-matter\n    post_order_by: \"title\"\n\n    # 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制\n    # The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit\n    post_limit: 0\n\n  # 侧边栏展示文章目录\n  # Table of contents (TOC) in the sidebar\n  toc:\n    enable: true\n\n    # 置于板块的左侧或右侧\n    # place in the board\n    # Options: left | right\n    placement: right\n\n    # 目录会选择这些节点作为标题\n    # TOC will select these nodes as headings\n    headingSelector: \"h1,h2,h3,h4,h5,h6\"\n\n    # 层级的折叠深度，0 是全部折叠，大于 0 后如果存在下级标题则默认展开\n    # Collapse depth. If 0, all headings collapsed. If greater than 0, it will be expanded by default if there are sub headings\n    collapseDepth: 0\n\n  # 版权声明，会显示在每篇文章的结尾\n  # Copyright, will be displayed at the end of each post\n  copyright:\n    enable: true\n\n    # CreativeCommons license\n    # Options: BY | BY-SA | BY-ND | BY-NC | BY-NC-SA | BY-NC-ND\n    license: 'BY'\n\n    # 显示作者\n    author:\n      enable: true\n\n    # 显示发布日期\n    # Show post date\n    post_date:\n      enable: true\n      format: \"LL\"\n\n    # 显示更新日期\n    # Show update date\n    update_date:\n      enable: false\n      format: \"LL\"\n\n  # 文章底部上一篇下一篇功能\n  # Link to previous/next post\n  prev_next:\n    enable: true\n\n  # 文章图片标题\n  # Image caption\n  image_caption:\n    enable: true\n\n  # 文章图片可点击放大\n  # Zoom feature of images\n  image_zoom:\n    enable: true\n    # 放大后图片链接替换规则，可用于将压缩图片链接替换为原图片链接，如 ['-slim', ''] 是将链接中 `-slim` 移除；如果想使用正则请使用 `re:` 前缀，如 ['re:\\\\d{3,4}\\\\/\\\\d{3,4}\\\\/', '']\n    # The image url replacement when zooming, the feature can be used to replace the compressed image to the original image, eg: ['-slim', ''] removes `-slim` from the image url when zooming; if you want to use regular, use prefix `re:`, eg: ['re:\\\\d{3,4}\\\\/\\\\d{3,4}\\\\/','']\n    img_url_replace: ['', '']\n\n  # 脚注语法，会在文章底部生成脚注，如果 Markdown 渲染器本身支持，则建议关闭，否则可能会冲突\n  # Support footnote syntax, footnotes will be generated at the bottom of the post page. If the Markdown renderer itself supports it, please disable it, otherwise it may conflict\n  footnote:\n    enable: true\n    # 脚注的节标题，也可以在 front-matter 中通过 `footnote: <h2>Reference</h2>` 这种形式修改单独页面的 header\n    # The section title of the footnote, you can also modify the header of a single page in the form of `footnote: <h2>Reference</h2>` in front-matter\n    header: ''\n\n  # 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式\n  # Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math\n  math:\n    # 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`\n    # If you want to use math on the custom page, you need to set `math: true` in Front-matter\n    enable: false\n\n    # 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度\n    # If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math\n    specific: false\n\n    # Options: mathjax | katex\n    engine: mathjax\n\n  # 流程图，基于 mermaid-js，具体请见：https://hexo.fluid-dev.com/docs/guide/#mermaid-流程图\n  # Flow chart, based on mermaid-js, see: https://hexo.fluid-dev.com/docs/en/guide/#mermaid\n  mermaid:\n    # 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `mermaid: true`\n    # If you want to use mermaid on the custom page, you need to set `mermaid: true` in Front-matter\n    enable: false\n\n    # 开启后，只有在文章 Front-matter 里指定 `mermaid: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度\n    # If true, only set `mermaid: true` in Front-matter will enable mermaid, to load faster when the page does not contain mermaid\n    specific: false\n\n    # See: http://mermaid-js.github.io/mermaid/\n    options: { theme: 'default' }\n\n  # 评论插件\n  # Comment plugin\n  comments:\n    enable: false\n    # 指定的插件，需要同时设置对应插件的必要参数\n    # The specified plugin needs to set the necessary parameters at the same time\n    # Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss\n    type: disqus\n\n\n#---------------------------\n# 评论插件\n# Comment plugins\n#\n# 开启评论需要先设置上方 `post: comments: enable: true`，然后根据 `type` 设置下方对应的评论插件参数\n# Enable comments need to be set `post: comments: enable: true`, then set the corresponding comment plugin parameters below according to `type`\n#---------------------------\n\n# Utterances\n# 基于 GitHub Issues\n# Based on GitHub Issues\n# See: https://utteranc.es\nutterances:\n  repo:\n  issue_term: pathname\n  label: utterances\n  theme: github-light\n  theme_dark: github-dark\n\n# Disqus\n# 基于第三方的服务，国内用户直接使用容易被墙，建议配合 Disqusjs\n# Based on third-party service\n# See: https://disqus.com\ndisqus:\n  shortname:\n  # 以下为 Disqusjs 支持, 国内用户如果想使用 Disqus 建议配合使用\n  # The following are Disqusjs configurations, please ignore if DisqusJS is not required\n  # See: https://github.com/SukkaW/DisqusJS\n  disqusjs: false\n  apikey:\n\n# Gitalk\n# 基于 GitHub Issues\n# Based on GitHub Issues\n# See: https://github.com/gitalk/gitalk#options\ngitalk:\n  clientID:\n  clientSecret:\n  repo:\n  owner:\n  admin: ['name']\n  language: zh-CN\n  labels: ['Gitalk']\n  perPage: 10\n  pagerDirection: last\n  distractionFreeMode: false\n  createIssueManually: true\n  # 默认 proxy 可能会失效，解决方法请见下方链接\n  # The default proxy may be invalid, refer to the links for solutions\n  # https://github.com/gitalk/gitalk/issues/429\n  # https://github.com/Zibri/cloudflare-cors-anywhere\n  proxy: https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token\n\n# Valine\n# 基于 LeanCloud\n# Based on LeanCloud\n# See: https://valine.js.org/\nvaline:\n  appId:\n  appKey:\n  path: window.location.pathname\n  placeholder:\n  avatar: 'retro'\n  meta: ['nick', 'mail', 'link']\n  requiredFields: []\n  pageSize: 10\n  lang: 'zh-CN'\n  highlight: false\n  recordIP: false\n  serverURLs: ''\n  emojiCDN:\n  emojiMaps:\n  enableQQ: false\n\n# Waline\n# 从 Valine 衍生而来，额外增加了服务端和多种功能\n# Derived from Valine, with self-hosted service and new features\n# See: https://waline.js.org/\nwaline:\n  serverURL: ''\n  path: window.location.pathname\n  meta: ['nick', 'mail', 'link']\n  requiredMeta: ['nick']\n  lang: 'zh-CN'\n  emoji: ['https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo']\n  dark: 'html[data-user-color-scheme=\"dark\"]'\n  wordLimit: 0\n  pageSize: 10\n\n# 畅言 Changyan\n# 基于第三方的服务\n# Based on third-party service, insufficient support for regions outside China\n# http://changyan.kuaizhan.com\nchangyan:\n  appid: ''\n  appkey: ''\n\n# 来必力 Livere\n# 基于第三方的服务\n# Based on third-party service\n# See: https://www.livere.com\nlivere:\n  uid: ''\n\n# Remark42\n# 需要自托管服务端\n# Based on self-hosted service\n# See: https://remark42.com\nremark42:\n  host:\n  site_id:\n  max_shown_comments: 10\n  locale: zh\n  components: ['embed']\n\n# Twikoo\n# 支持腾讯云、Vercel、Railway 等多种平台部署\n# Based on Tencent CloudBase\n# See: https://twikoo.js.org\ntwikoo:\n  envId:\n  region: ap-shanghai\n  path: window.location.pathname\n\n# Cusdis\n# 基于第三方服务或自托管服务\n# Based on third-party or self-hosted service\n# See https://cusdis.com\ncusdis:\n  host:\n  app_id:\n  lang: zh-cn\n\n# Giscus\n# 基于 GitHub Discussions，类似于 Utterances\n# Based on GitHub Discussions, similar to Utterances\n# See: https://giscus.app/\ngiscus:\n  repo:\n  repo-id:\n  category:\n  category-id:\n  theme-light: light\n  theme-dark: dark\n  mapping: pathname\n  reactions-enabled: 1\n  emit-metadata: 0\n  input-position: top\n  lang: zh-CN\n\n# Discuss\n# 多平台、多数据库、自托管、免费开源评论系统\n# Self-hosted, small size, multi-platform, multi-database, free and open source commenting system\n# See: https://discuss.js.org\ndiscuss:\n  serverURLs:\n  path: window.location.pathname\n\n\n#---------------------------\n# 归档页\n# Archive Page\n#---------------------------\narchive:\n  banner_img: /img/default.png\n  banner_img_height: 60\n  banner_mask_alpha: 0.3\n\n\n#---------------------------\n# 分类页\n# Category Page\n#---------------------------\ncategory:\n  enable: true\n  banner_img: /img/default.png\n  banner_img_height: 60\n  banner_mask_alpha: 0.3\n\n  # 分类的排序字段，前面带减号是倒序，不带减号是正序\n  # Sort field for categories, with a minus sign is reverse order\n  # Options: length | name\n  order_by: \"-length\"\n\n  # 层级的折叠深度，0 是全部折叠，大于 0 后如果存在子分类则默认展开\n  # Collapse depth. If 0, all posts collapsed. If greater than 0, it will be expanded by default if there are subcategories\n  collapse_depth: 0\n\n  # 文章的排序字段，前面带减号是倒序，不带减号是正序\n  # Sort field for posts, with a minus sign is reverse order\n  # Options: date | title | or other field of front-matter\n  post_order_by: \"-date\"\n\n  # 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制\n  # The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit\n  post_limit: 10\n\n\n#---------------------------\n# 标签页\n# Tag Page\n#---------------------------\ntag:\n  enable: true\n  banner_img: /img/default.png\n  banner_img_height: 80\n  banner_mask_alpha: 0.3\n  tagcloud:\n    min_font: 15\n    max_font: 30\n    unit: px\n    start_color: \"#BBBBEE\"\n    end_color: \"#337ab7\"\n\n\n#---------------------------\n# 关于页\n# About Page\n#---------------------------\nabout:\n  enable: true\n  banner_img: /img/default.png\n  banner_img_height: 60\n  banner_mask_alpha: 0.3\n  avatar: /img/avatar.png\n  name: \"Fluid\"\n  intro: \"An elegant theme for Hexo\"\n  # 更多图标可从 https://hexo.fluid-dev.com/docs/icon/ 查找，`class` 代表图标的 css class，添加 `qrcode` 后，图标不再是链接而是悬浮二维码\n  # More icons can be found from https://hexo.fluid-dev.com/docs/en/icon/  `class` is the css class of the icon. If adding `qrcode`, The icon is no longer a link, but a hovering QR code\n  icons:\n    - { class: \"iconfont icon-github-fill\", link: \"https://github.com\", tip: \"GitHub\" }\n    - { class: \"iconfont icon-douban-fill\", link: \"https://douban.com\", tip: \"豆瓣\" }\n    - { class: \"iconfont icon-wechat-fill\", qrcode: \"/img/favicon.png\" }\n\n\n#---------------------------\n# 自定义页\n# Custom Page\n#\n# 通过 hexo new page 命令创建的页面\n# Custom Page through `hexo new page`\n#---------------------------\npage:\n  banner_img: /img/default.png\n  banner_img_height: 60\n  banner_mask_alpha: 0.3\n\n\n#---------------------------\n# 404页\n# 404 Page\n#---------------------------\npage404:\n  enable: true\n  banner_img: /img/default.png\n  banner_img_height: 85\n  banner_mask_alpha: 0.3\n  # 重定向到首页的延迟(毫秒)\n  # Delay in redirecting to home page (milliseconds)\n  redirect_delay: 5000\n\n\n#---------------------------\n# 友链页\n# Links Page\n#---------------------------\nlinks:\n  enable: true\n  banner_img: /img/default.png\n  banner_img_height: 60\n  banner_mask_alpha: 0.3\n  # 友链的成员项\n  # Member item of page\n  items:\n    - {\n      title: \"Fluid Blog\",\n      intro: \"主题博客\",\n      link: \"https://hexo.fluid-dev.com/\",\n      avatar: \"/img/favicon.png\"\n    }\n    - {\n      title: \"Fluid Docs\",\n      intro: \"主题使用指南\",\n      link: \"https://hexo.fluid-dev.com/docs/\",\n      avatar: \"/img/favicon.png\"\n    }\n    - {\n      title: \"Fluid Repo\",\n      intro: \"主题 GitHub 仓库\",\n      link: \"https://github.com/fluid-dev/hexo-theme-fluid\",\n      avatar: \"/img/favicon.png\"\n    }\n\n  # 当成员头像加载失败时，替换为指定图片\n  # When the member avatar fails to load, replace the specified image\n  onerror_avatar: /img/avatar.png\n\n  # 友链下方自定义区域，支持 HTML，可插入例如申请友链的文字\n  # Custom content at the bottom of the links\n  custom:\n    enable: false\n    content: '<hr><p>在下方留言申请加入我的友链，按如下格式提供信息：</p><ul><li>博客名：Fluid</li><li>简介：Fluid 主题官方博客</li><li>链接：https://hexo.fluid-dev.com</li><li>图片：https://hexo.fluid-dev.com/img/favicon.png</li></ul>'\n\n  # 评论插件\n  # Comment plugin\n  comments:\n    enable: false\n    # 指定的插件，需要同时设置对应插件的必要参数\n    # The specified plugin needs to set the necessary parameters at the same time\n    # Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss\n    type: disqus\n\n\n#---------------------------\n# 以下是配置 JS CSS 等静态资源的 URL 前缀，可以自定义成 CDN 地址，\n# 如果需要修改，最好使用与默认配置相同的版本，以避免潜在的问题，\n# ** 如果你不知道如何设置，请不要做任何改动 **\n#\n# Here is the url prefix to configure the static assets. Set CDN addresses you want to customize.\n# Be aware that you would better use the same version as default ones to avoid potential problems.\n# DO NOT EDIT THE FOLLOWING SETTINGS UNLESS YOU KNOW WHAT YOU ARE DOING\n#---------------------------\n\nstatic_prefix:\n  # 内部静态\n  # Internal static\n  internal_js: /js\n  internal_css: /css\n  internal_img: /img\n\n  anchor: https://lib.baomitu.com/anchor-js/4.3.1/\n\n  github_markdown: https://lib.baomitu.com/github-markdown-css/4.0.0/\n\n  jquery: https://lib.baomitu.com/jquery/3.6.4/\n\n  bootstrap: https://lib.baomitu.com/twitter-bootstrap/4.6.1/\n\n  prismjs: https://lib.baomitu.com/prism/1.29.0/\n\n  tocbot: https://lib.baomitu.com/tocbot/4.20.1/\n\n  typed: https://lib.baomitu.com/typed.js/2.0.12/\n\n  fancybox: https://lib.baomitu.com/fancybox/3.5.7/\n\n  nprogress: https://lib.baomitu.com/nprogress/0.2.0/\n\n  mathjax: https://lib.baomitu.com/mathjax/3.2.2/\n\n  katex: https://lib.baomitu.com/KaTeX/0.16.2/\n\n  busuanzi: https://busuanzi.ibruce.info/busuanzi/2.3/\n\n  clipboard: https://lib.baomitu.com/clipboard.js/2.0.11/\n\n  mermaid: https://lib.baomitu.com/mermaid/8.14.0/\n\n  valine: https://lib.baomitu.com/valine/1.5.1/\n\n  waline: https://cdn.staticfile.org/waline/2.15.5/\n\n  gitalk: https://lib.baomitu.com/gitalk/1.8.0/\n\n  disqusjs: https://lib.baomitu.com/disqusjs/1.3.0/\n\n  twikoo: https://lib.baomitu.com/twikoo/1.6.8/\n\n  discuss: https://lib.baomitu.com/discuss/1.2.1/\n\n  hint: https://lib.baomitu.com/hint.css/2.7.0/\n\n  moment: https://lib.baomitu.com/moment.js/2.29.4/\n~~~\n\n### 站点配置\n\n现在对我而言还有两个问题，我换到 Fluid 就是为了 Latex  \n所以……  \n这里还是按官方来，[^4]\n\n1. **设置主题配置**  \n    $我这里使用的是\\;mathjax+pandoc,\\;$  \n    $好处是别人可以复制你写的\\;Latex$  \n    $\\begin{aligned}坏处是\\hspace{340px}\\\\  \n    他的换行不能像 typora的'\\backslash\\backslash'直接换行,\\hspace{115px}\\\\  \n    要使用\\backslash begin\\{aligned\\}\\backslash end\\{aligned\\}\\hspace{100px}\\\\  \n    才能'\\backslash\\backslash'换行\\hspace{300px}\\\\  \n    而且不能使用\\backslash hfill只能使用\\backslash hspace\\{num\\; cm/px\\}\\hspace{10px}  \n    \\end{aligned}$  \n    而且换行前必须打两个空格  \n\n    ~~~yaml\n    post:  \n      math:  \n       enable: true  \n       specific: false  \n    \t  engine: mathjax  \n    ~~~\n\n    `specific`: 建议开启。当为 true 时，只有在文章 [front-matter (opens new window)](https://hexo.io/zh-cn/docs/front-matter)里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。\n\n    `engine`: 公式引擎，目前支持 `mathjax` 或 `katex`。\n\n2. **更换 Markdown 渲染器**  \n    由于 Hexo 默认的 Markdown 渲染器不支持复杂公式，所以需要更换渲染器（mathjax 可选择性更换）。\n    然后根据上方配置不同的 `engine`，推荐更换如下渲染器：\n  \n    * mathjax\n      ~~~sh\n      npm uninstall hexo-renderer-marked --save\n      npm install hexo-renderer-pandoc --save\n      ~~~\n    \n      **并且还需[安装 Pandoc](https://github.com/jgm/pandoc/blob/master/INSTALL.md)**\n    \n    * katex\n\t  ~~~sh\n\t  npm uninstall hexo-renderer-marked --save\n\t  npm install hexo-renderer-markdown-it --save\n\t  npm install @traptitech/markdown-it-katex --save\n\t  ~~~\n\t  \n\t  然后在站点配置中添加：\n      ~~~yaml\n      markdown:\n        plugins:\n          - \"@traptitech/markdown-it-katex\"\n\t  ~~~\n### 我安装Pandoc过程\n\n环境说明：Windows11\n\n1. [下载 Pandoc](https://github.com/jgm/pandoc/blob/master/INSTALL.md)  \n   下载链接[download page](https://github.com/jgm/pandoc/releases/latest)  \n   ![](/imgs/Hexo主题变更/pandoc1.png)找到 window，我使用的是 msi：  \n   ![](/imgs/Hexo主题变更/pandoc1-1.png)  \n2. 按照提示安装就可以，这里可以自选目录  \n   pandoc 和 hexo-renderer-pandoc不一样，一个是程序，一个是hexo的渲染插件\n\n### 插入图片\n\n我还是用的老办法，`![](/imgs/xxxx)`，  \n想要在 typora 也显示，那就把文档的图片放到一个文件夹`/imgs/`内  \nFluid 会在`..\\Blog\\source`目录下寻找图片资源文件，其他类型应该也是一样。\n\n## 待解决问题\n\n* 换行异常：  \n  typora 可以换行，但是 web blog 不能换行只能换段  \n  latex 公式不能换行  \n  * 因为pandoc和typora语法不一样\n  * 这里给出修改代码  \n    这里的代码有问题哦，但是我不改了……也都有注释，如果你需要可以自行修改  \n    编译原理的自动机学过伐，一样的\n    \n    ~~~python  \n    import os\n    \n    # 指定需要修改的 Markdown 文件夹路径  \n    folder_path = '/path/to/markdown_folder/'\n    \n    def process_md_file(file_path):  \n        with open(file_path, 'r', encoding='utf-8') as f:  \n            content = f.readlines()\n    \n        modified_content = []  \n        code_block = False  \n        latex_block = False  \n        setting_block = False  \n        for i in range(len(content)):  \n            line = content[i].rstrip('\\n')\n    \n            # 判断是否进入或退出代码块  \n            if line.startswith('~~~'):  \n                code_block = not code_block\n    \n            # 判断是否进入或退出 LaTeX 段落  \n            if line.startswith('$$'):  \n                latex_block = not latex_block\n    \n            # 判断是否进入或退出设置段  \n            if line.startswith('---'):  \n                setting_block = not setting_block\n    \n            # 如果在代码块内、LaTeX 段落内或设置段内，则不做修改  \n            if code_block or latex_block or setting_block:  \n                modified_content.append(line)  \n            else:  \n                # 如果行首是标题，则不加空格  \n                if line.startswith('#'):  \n                    modified_content.append(line)  \n                # 如果行首以 <img 开头，则不做修改  \n                elif line.lstrip().startswith('<img'):  \n                    modified_content.append(line)  \n                # 如果行首以 < 开头，则不加空格（除了 <img 外）  \n                elif line.startswith('<'):  \n                    modified_content.append(line)  \n                else:  \n                    # 如果行尾已经有两个空格，则不做修改  \n                    if line.endswith('  '):  \n                        modified_content.append(line)  \n                    else:  \n                        # 判断下一行是否为空行  \n                        if i < len(content) - 1 and content[i+1].strip() == '':  \n                            modified_content.append(line)  \n                        else:  \n                            modified_content.append(line + '  ')\n    \n        with open(file_path, 'w', encoding='utf-8') as f:  \n            f.write('\\n'.join(modified_content))\n    \n        print(f'已修改文件: {file_path}')\n    \n    # 遍历 Markdown 文件夹下的所有文件  \n    for root, dirs, files in os.walk(folder_path):  \n        for file in files:  \n            if file.endswith('.md'):  \n                file_path = os.path.join(root, file)  \n                process_md_file(file_path)\n    \n    print('所有文件修改完成')  \n    ~~~\n  \n\n标题段落间隔大 : 主题问题\n\n## 参考\n\n[^0]:[图片搜索:saucenao](https://saucenao.com/)\n[^1]:[Hexo Fulid 官方Doc](https://hexo.fluid-dev.com/docs)\n[^2]:[配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/guide/#覆盖配置)\n[^3]:[主题配置](https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml)  \n[^4]:[配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/guide/#latex-数学公式)  \n[^5]:[hexo-theme-fluid/_config.yml at master · fluid-dev/hexo-theme-fluid (github.com)](https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml)\n\n[MathJax 文档 — MathJax 3.2 文档](https://docs.mathjax.org/en/latest/index.html)\n\n[Front-matter | Hexo](https://hexo.io/zh-cn/docs/front-matter)\n\n[hexojs/hexo-math: A hexo plugin that uses MathJax to render math equations. (github.com)](https://github.com/hexojs/hexo-math)\n\n[pandoc/INSTALL.md 在主 ·JGM/PANDOC的 (github.com)](https://github.com/jgm/pandoc/blob/main/INSTALL.md)  ","slug":"Hexo主题更改","published":1,"updated":"2025-08-12T15:42:15.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti00009bkbw43ov26em","content":"<p>更换了Hexo 主题，之前 yilia\r\n主题作者是不是开摆了……我看很久没更新.<br />\r\nnalama！答案只有一个了，我将向你—— Fluid\r\n效忠！图源自Pix画师ID:67549695<br />\r\n<span id=\"more\"></span></p>\r\n<h1 id=\"hexo-主题切换\">Hexo 主题切换</h1>\r\n<p>这里以 yilia 切换到 Fluid\r\n为例，我这里只是分享一下自己是怎么做的，遇到什么问题，<br />\r\n肯定有不对的地方，欢迎大家教我。</p>\r\n<h2 id=\"准备工作\">准备工作</h2>\r\n<p>鉴于前面我自己把 blog 干崩过，所有我强烈建议所有人都在 github\r\n存一个仓库备份本地的 Blog<br />\r\n因为 Hexo 这种静态blog\r\n<strong>本地磁盘的源文件</strong>和<strong>生成的网页</strong>，是两个部分。</p>\r\n<p>你能不能说人话什么本地，网页的！<br />\r\n好好好，你先别急，我知道你很急，但是你先别急。</p>\r\n<ul>\r\n<li>本地的源文件：<br />\r\n<img src=\"/imgs/Hexo主题变更/deskt.png\" /><br />\r\n</li>\r\n<li>生成的网页：<br />\r\n<img src=\"/imgs/Hexo主题变更/web.png\" /> 我们可以将本地文件存储到 github\r\n备份，也方便 fallback 和 迁移。</li>\r\n</ul>\r\n<h2 id=\"切换\">切换</h2>\r\n<p>将 Hexo 博客主题从 yilia 切换到 Fluid 的步骤如下：</p>\r\n<ol type=\"1\">\r\n<li><p>首先，您需要在本地安装 Fluid 主题。<br />\r\n可以使用以下命令从 GitHub 上下载 Fluid 主题并将其保存到您的 Hexo 博客的\r\nthemes 文件夹中：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>下载完成后，进入 Hexo 博客的根目录，并打开 _config.yml\r\n文件。<br />\r\n将 theme 字段的值更改为 \"fluid\"，如下所示：</p>\r\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">theme:</span> fluid  <br></code></pre></td></tr></table></figure></li>\r\n</ol>\r\n<h3 id=\"修改主题配置\">修改主题配置</h3>\r\n<p>主题配置指的是 hexo 所采用的 theme 所用配置，而并非对 Hexo blog\r\n的配置</p>\r\n<blockquote>\r\n<p>TIP<sup id=\"fnref:1\" class=\"footnote-ref\"><a href=\"#fn:1\" rel=\"footnote\"><span\r\nclass=\"hint--top hint--rounded\"\r\naria-label=\"[Hexo Fulid 官方Doc](https://hexo.fluid-dev.com/docs)\">[1]</span></a></sup></p>\r\n<p>致主题的新用户：</p>\r\n<ul>\r\n<li>本指南经过数个版本打磨，<br />\r\n绝大部分的功能都有详细说明，请仔细阅读，节约自己和他人的时间；<br />\r\n</li>\r\n<li>本指南中提到的：\"<strong>站点配置</strong>\" 指的 Hexo 博客目录下的\r\n<code>_config.yml</code>，\"<strong>主题配置</strong>\" 指的是\r\n<code>theme/fluid/_config.yml</code> 或者 <code>_config.fluid.yml</code>\r\n，注意区分；<br />\r\n</li>\r\n<li>本指南中提到的 <code>source</code> 目录都指的是博客目录下的\r\n<code>source</code> 文件夹，不推荐修改主题内 <code>source</code>\r\n目录；<br />\r\n</li>\r\n<li>每次无论 <code>hexo g</code> 或 <code>hexo s</code>，都最好先使用\r\n<code>hexo clean</code> 清除本地缓存；<br />\r\n</li>\r\n<li>页面结果以本地 <code>hexo s</code>\r\n为准，部署后的异常大部分是线上缓存原因，在确认没有报错的情况下，等待若干时间后即可正常；<br />\r\n</li>\r\n<li>由于主题的不同版本会存在配置差异，本指南以最新版本为准。</li>\r\n</ul>\r\n</blockquote>\r\n<p>这里按照官方文档所说去做就行，为什么这么配文档也有说，我这里是 Hexo\r\n6.1.0。<sup id=\"fnref:2\" class=\"footnote-ref\"><a href=\"#fn:2\" rel=\"footnote\"><span\r\nclass=\"hint--top hint--rounded\"\r\naria-label=\"[配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/guide/#覆盖配置)\">[2]</span></a></sup><br />\r\n所以在Blog 根目录创建 <code>_config.fluid.yml</code><br />\r\n<img src=\"/imgs/Hexo主题变更/Fluid_Config.png\" /><br />\r\n然后在该文件内，粘贴 Fluid\r\n官方给定的配置<sup id=\"fnref:3\" class=\"footnote-ref\"><a href=\"#fn:3\" rel=\"footnote\"><span\r\nclass=\"hint--top hint--rounded\"\r\naria-label=\"[主题配置](https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml)\">[3]</span></a></sup>就行，当然你可以根据他的自定义，<br />\r\n但是我不会，因为我不会……</p>\r\n<h4\r\nid=\"code建议别从我这里复制这个blog会崩溃去官网吧5\">code，建议别从我这里复制，这个blog会崩溃，去官网吧<sup id=\"fnref:5\" class=\"footnote-ref\"><a href=\"#fn:5\" rel=\"footnote\"><span\r\nclass=\"hint--top hint--rounded\"\r\naria-label=\"[hexo-theme-fluid/_config.yml at master · fluid-dev/hexo-theme-fluid (github.com)](https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml)\">[5]</span></a></sup></h4>\r\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br><span class=\"line\">558</span><br><span class=\"line\">559</span><br><span class=\"line\">560</span><br><span class=\"line\">561</span><br><span class=\"line\">562</span><br><span class=\"line\">563</span><br><span class=\"line\">564</span><br><span class=\"line\">565</span><br><span class=\"line\">566</span><br><span class=\"line\">567</span><br><span class=\"line\">568</span><br><span class=\"line\">569</span><br><span class=\"line\">570</span><br><span class=\"line\">571</span><br><span class=\"line\">572</span><br><span class=\"line\">573</span><br><span class=\"line\">574</span><br><span class=\"line\">575</span><br><span class=\"line\">576</span><br><span class=\"line\">577</span><br><span class=\"line\">578</span><br><span class=\"line\">579</span><br><span class=\"line\">580</span><br><span class=\"line\">581</span><br><span class=\"line\">582</span><br><span class=\"line\">583</span><br><span class=\"line\">584</span><br><span class=\"line\">585</span><br><span class=\"line\">586</span><br><span class=\"line\">587</span><br><span class=\"line\">588</span><br><span class=\"line\">589</span><br><span class=\"line\">590</span><br><span class=\"line\">591</span><br><span class=\"line\">592</span><br><span class=\"line\">593</span><br><span class=\"line\">594</span><br><span class=\"line\">595</span><br><span class=\"line\">596</span><br><span class=\"line\">597</span><br><span class=\"line\">598</span><br><span class=\"line\">599</span><br><span class=\"line\">600</span><br><span class=\"line\">601</span><br><span class=\"line\">602</span><br><span class=\"line\">603</span><br><span class=\"line\">604</span><br><span class=\"line\">605</span><br><span class=\"line\">606</span><br><span class=\"line\">607</span><br><span class=\"line\">608</span><br><span class=\"line\">609</span><br><span class=\"line\">610</span><br><span class=\"line\">611</span><br><span class=\"line\">612</span><br><span class=\"line\">613</span><br><span class=\"line\">614</span><br><span class=\"line\">615</span><br><span class=\"line\">616</span><br><span class=\"line\">617</span><br><span class=\"line\">618</span><br><span class=\"line\">619</span><br><span class=\"line\">620</span><br><span class=\"line\">621</span><br><span class=\"line\">622</span><br><span class=\"line\">623</span><br><span class=\"line\">624</span><br><span class=\"line\">625</span><br><span class=\"line\">626</span><br><span class=\"line\">627</span><br><span class=\"line\">628</span><br><span class=\"line\">629</span><br><span class=\"line\">630</span><br><span class=\"line\">631</span><br><span class=\"line\">632</span><br><span class=\"line\">633</span><br><span class=\"line\">634</span><br><span class=\"line\">635</span><br><span class=\"line\">636</span><br><span class=\"line\">637</span><br><span class=\"line\">638</span><br><span class=\"line\">639</span><br><span class=\"line\">640</span><br><span class=\"line\">641</span><br><span class=\"line\">642</span><br><span class=\"line\">643</span><br><span class=\"line\">644</span><br><span class=\"line\">645</span><br><span class=\"line\">646</span><br><span class=\"line\">647</span><br><span class=\"line\">648</span><br><span class=\"line\">649</span><br><span class=\"line\">650</span><br><span class=\"line\">651</span><br><span class=\"line\">652</span><br><span class=\"line\">653</span><br><span class=\"line\">654</span><br><span class=\"line\">655</span><br><span class=\"line\">656</span><br><span class=\"line\">657</span><br><span class=\"line\">658</span><br><span class=\"line\">659</span><br><span class=\"line\">660</span><br><span class=\"line\">661</span><br><span class=\"line\">662</span><br><span class=\"line\">663</span><br><span class=\"line\">664</span><br><span class=\"line\">665</span><br><span class=\"line\">666</span><br><span class=\"line\">667</span><br><span class=\"line\">668</span><br><span class=\"line\">669</span><br><span class=\"line\">670</span><br><span class=\"line\">671</span><br><span class=\"line\">672</span><br><span class=\"line\">673</span><br><span class=\"line\">674</span><br><span class=\"line\">675</span><br><span class=\"line\">676</span><br><span class=\"line\">677</span><br><span class=\"line\">678</span><br><span class=\"line\">679</span><br><span class=\"line\">680</span><br><span class=\"line\">681</span><br><span class=\"line\">682</span><br><span class=\"line\">683</span><br><span class=\"line\">684</span><br><span class=\"line\">685</span><br><span class=\"line\">686</span><br><span class=\"line\">687</span><br><span class=\"line\">688</span><br><span class=\"line\">689</span><br><span class=\"line\">690</span><br><span class=\"line\">691</span><br><span class=\"line\">692</span><br><span class=\"line\">693</span><br><span class=\"line\">694</span><br><span class=\"line\">695</span><br><span class=\"line\">696</span><br><span class=\"line\">697</span><br><span class=\"line\">698</span><br><span class=\"line\">699</span><br><span class=\"line\">700</span><br><span class=\"line\">701</span><br><span class=\"line\">702</span><br><span class=\"line\">703</span><br><span class=\"line\">704</span><br><span class=\"line\">705</span><br><span class=\"line\">706</span><br><span class=\"line\">707</span><br><span class=\"line\">708</span><br><span class=\"line\">709</span><br><span class=\"line\">710</span><br><span class=\"line\">711</span><br><span class=\"line\">712</span><br><span class=\"line\">713</span><br><span class=\"line\">714</span><br><span class=\"line\">715</span><br><span class=\"line\">716</span><br><span class=\"line\">717</span><br><span class=\"line\">718</span><br><span class=\"line\">719</span><br><span class=\"line\">720</span><br><span class=\"line\">721</span><br><span class=\"line\">722</span><br><span class=\"line\">723</span><br><span class=\"line\">724</span><br><span class=\"line\">725</span><br><span class=\"line\">726</span><br><span class=\"line\">727</span><br><span class=\"line\">728</span><br><span class=\"line\">729</span><br><span class=\"line\">730</span><br><span class=\"line\">731</span><br><span class=\"line\">732</span><br><span class=\"line\">733</span><br><span class=\"line\">734</span><br><span class=\"line\">735</span><br><span class=\"line\">736</span><br><span class=\"line\">737</span><br><span class=\"line\">738</span><br><span class=\"line\">739</span><br><span class=\"line\">740</span><br><span class=\"line\">741</span><br><span class=\"line\">742</span><br><span class=\"line\">743</span><br><span class=\"line\">744</span><br><span class=\"line\">745</span><br><span class=\"line\">746</span><br><span class=\"line\">747</span><br><span class=\"line\">748</span><br><span class=\"line\">749</span><br><span class=\"line\">750</span><br><span class=\"line\">751</span><br><span class=\"line\">752</span><br><span class=\"line\">753</span><br><span class=\"line\">754</span><br><span class=\"line\">755</span><br><span class=\"line\">756</span><br><span class=\"line\">757</span><br><span class=\"line\">758</span><br><span class=\"line\">759</span><br><span class=\"line\">760</span><br><span class=\"line\">761</span><br><span class=\"line\">762</span><br><span class=\"line\">763</span><br><span class=\"line\">764</span><br><span class=\"line\">765</span><br><span class=\"line\">766</span><br><span class=\"line\">767</span><br><span class=\"line\">768</span><br><span class=\"line\">769</span><br><span class=\"line\">770</span><br><span class=\"line\">771</span><br><span class=\"line\">772</span><br><span class=\"line\">773</span><br><span class=\"line\">774</span><br><span class=\"line\">775</span><br><span class=\"line\">776</span><br><span class=\"line\">777</span><br><span class=\"line\">778</span><br><span class=\"line\">779</span><br><span class=\"line\">780</span><br><span class=\"line\">781</span><br><span class=\"line\">782</span><br><span class=\"line\">783</span><br><span class=\"line\">784</span><br><span class=\"line\">785</span><br><span class=\"line\">786</span><br><span class=\"line\">787</span><br><span class=\"line\">788</span><br><span class=\"line\">789</span><br><span class=\"line\">790</span><br><span class=\"line\">791</span><br><span class=\"line\">792</span><br><span class=\"line\">793</span><br><span class=\"line\">794</span><br><span class=\"line\">795</span><br><span class=\"line\">796</span><br><span class=\"line\">797</span><br><span class=\"line\">798</span><br><span class=\"line\">799</span><br><span class=\"line\">800</span><br><span class=\"line\">801</span><br><span class=\"line\">802</span><br><span class=\"line\">803</span><br><span class=\"line\">804</span><br><span class=\"line\">805</span><br><span class=\"line\">806</span><br><span class=\"line\">807</span><br><span class=\"line\">808</span><br><span class=\"line\">809</span><br><span class=\"line\">810</span><br><span class=\"line\">811</span><br><span class=\"line\">812</span><br><span class=\"line\">813</span><br><span class=\"line\">814</span><br><span class=\"line\">815</span><br><span class=\"line\">816</span><br><span class=\"line\">817</span><br><span class=\"line\">818</span><br><span class=\"line\">819</span><br><span class=\"line\">820</span><br><span class=\"line\">821</span><br><span class=\"line\">822</span><br><span class=\"line\">823</span><br><span class=\"line\">824</span><br><span class=\"line\">825</span><br><span class=\"line\">826</span><br><span class=\"line\">827</span><br><span class=\"line\">828</span><br><span class=\"line\">829</span><br><span class=\"line\">830</span><br><span class=\"line\">831</span><br><span class=\"line\">832</span><br><span class=\"line\">833</span><br><span class=\"line\">834</span><br><span class=\"line\">835</span><br><span class=\"line\">836</span><br><span class=\"line\">837</span><br><span class=\"line\">838</span><br><span class=\"line\">839</span><br><span class=\"line\">840</span><br><span class=\"line\">841</span><br><span class=\"line\">842</span><br><span class=\"line\">843</span><br><span class=\"line\">844</span><br><span class=\"line\">845</span><br><span class=\"line\">846</span><br><span class=\"line\">847</span><br><span class=\"line\">848</span><br><span class=\"line\">849</span><br><span class=\"line\">850</span><br><span class=\"line\">851</span><br><span class=\"line\">852</span><br><span class=\"line\">853</span><br><span class=\"line\">854</span><br><span class=\"line\">855</span><br><span class=\"line\">856</span><br><span class=\"line\">857</span><br><span class=\"line\">858</span><br><span class=\"line\">859</span><br><span class=\"line\">860</span><br><span class=\"line\">861</span><br><span class=\"line\">862</span><br><span class=\"line\">863</span><br><span class=\"line\">864</span><br><span class=\"line\">865</span><br><span class=\"line\">866</span><br><span class=\"line\">867</span><br><span class=\"line\">868</span><br><span class=\"line\">869</span><br><span class=\"line\">870</span><br><span class=\"line\">871</span><br><span class=\"line\">872</span><br><span class=\"line\">873</span><br><span class=\"line\">874</span><br><span class=\"line\">875</span><br><span class=\"line\">876</span><br><span class=\"line\">877</span><br><span class=\"line\">878</span><br><span class=\"line\">879</span><br><span class=\"line\">880</span><br><span class=\"line\">881</span><br><span class=\"line\">882</span><br><span class=\"line\">883</span><br><span class=\"line\">884</span><br><span class=\"line\">885</span><br><span class=\"line\">886</span><br><span class=\"line\">887</span><br><span class=\"line\">888</span><br><span class=\"line\">889</span><br><span class=\"line\">890</span><br><span class=\"line\">891</span><br><span class=\"line\">892</span><br><span class=\"line\">893</span><br><span class=\"line\">894</span><br><span class=\"line\">895</span><br><span class=\"line\">896</span><br><span class=\"line\">897</span><br><span class=\"line\">898</span><br><span class=\"line\">899</span><br><span class=\"line\">900</span><br><span class=\"line\">901</span><br><span class=\"line\">902</span><br><span class=\"line\">903</span><br><span class=\"line\">904</span><br><span class=\"line\">905</span><br><span class=\"line\">906</span><br><span class=\"line\">907</span><br><span class=\"line\">908</span><br><span class=\"line\">909</span><br><span class=\"line\">910</span><br><span class=\"line\">911</span><br><span class=\"line\">912</span><br><span class=\"line\">913</span><br><span class=\"line\">914</span><br><span class=\"line\">915</span><br><span class=\"line\">916</span><br><span class=\"line\">917</span><br><span class=\"line\">918</span><br><span class=\"line\">919</span><br><span class=\"line\">920</span><br><span class=\"line\">921</span><br><span class=\"line\">922</span><br><span class=\"line\">923</span><br><span class=\"line\">924</span><br><span class=\"line\">925</span><br><span class=\"line\">926</span><br><span class=\"line\">927</span><br><span class=\"line\">928</span><br><span class=\"line\">929</span><br><span class=\"line\">930</span><br><span class=\"line\">931</span><br><span class=\"line\">932</span><br><span class=\"line\">933</span><br><span class=\"line\">934</span><br><span class=\"line\">935</span><br><span class=\"line\">936</span><br><span class=\"line\">937</span><br><span class=\"line\">938</span><br><span class=\"line\">939</span><br><span class=\"line\">940</span><br><span class=\"line\">941</span><br><span class=\"line\">942</span><br><span class=\"line\">943</span><br><span class=\"line\">944</span><br><span class=\"line\">945</span><br><span class=\"line\">946</span><br><span class=\"line\">947</span><br><span class=\"line\">948</span><br><span class=\"line\">949</span><br><span class=\"line\">950</span><br><span class=\"line\">951</span><br><span class=\"line\">952</span><br><span class=\"line\">953</span><br><span class=\"line\">954</span><br><span class=\"line\">955</span><br><span class=\"line\">956</span><br><span class=\"line\">957</span><br><span class=\"line\">958</span><br><span class=\"line\">959</span><br><span class=\"line\">960</span><br><span class=\"line\">961</span><br><span class=\"line\">962</span><br><span class=\"line\">963</span><br><span class=\"line\">964</span><br><span class=\"line\">965</span><br><span class=\"line\">966</span><br><span class=\"line\">967</span><br><span class=\"line\">968</span><br><span class=\"line\">969</span><br><span class=\"line\">970</span><br><span class=\"line\">971</span><br><span class=\"line\">972</span><br><span class=\"line\">973</span><br><span class=\"line\">974</span><br><span class=\"line\">975</span><br><span class=\"line\">976</span><br><span class=\"line\">977</span><br><span class=\"line\">978</span><br><span class=\"line\">979</span><br><span class=\"line\">980</span><br><span class=\"line\">981</span><br><span class=\"line\">982</span><br><span class=\"line\">983</span><br><span class=\"line\">984</span><br><span class=\"line\">985</span><br><span class=\"line\">986</span><br><span class=\"line\">987</span><br><span class=\"line\">988</span><br><span class=\"line\">989</span><br><span class=\"line\">990</span><br><span class=\"line\">991</span><br><span class=\"line\">992</span><br><span class=\"line\">993</span><br><span class=\"line\">994</span><br><span class=\"line\">995</span><br><span class=\"line\">996</span><br><span class=\"line\">997</span><br><span class=\"line\">998</span><br><span class=\"line\">999</span><br><span class=\"line\">1000</span><br><span class=\"line\">1001</span><br><span class=\"line\">1002</span><br><span class=\"line\">1003</span><br><span class=\"line\">1004</span><br><span class=\"line\">1005</span><br><span class=\"line\">1006</span><br><span class=\"line\">1007</span><br><span class=\"line\">1008</span><br><span class=\"line\">1009</span><br><span class=\"line\">1010</span><br><span class=\"line\">1011</span><br><span class=\"line\">1012</span><br><span class=\"line\">1013</span><br><span class=\"line\">1014</span><br><span class=\"line\">1015</span><br><span class=\"line\">1016</span><br><span class=\"line\">1017</span><br><span class=\"line\">1018</span><br><span class=\"line\">1019</span><br><span class=\"line\">1020</span><br><span class=\"line\">1021</span><br><span class=\"line\">1022</span><br><span class=\"line\">1023</span><br><span class=\"line\">1024</span><br><span class=\"line\">1025</span><br><span class=\"line\">1026</span><br><span class=\"line\">1027</span><br><span class=\"line\">1028</span><br><span class=\"line\">1029</span><br><span class=\"line\">1030</span><br><span class=\"line\">1031</span><br><span class=\"line\">1032</span><br><span class=\"line\">1033</span><br><span class=\"line\">1034</span><br><span class=\"line\">1035</span><br><span class=\"line\">1036</span><br><span class=\"line\">1037</span><br><span class=\"line\">1038</span><br><span class=\"line\">1039</span><br><span class=\"line\">1040</span><br><span class=\"line\">1041</span><br><span class=\"line\">1042</span><br><span class=\"line\">1043</span><br><span class=\"line\">1044</span><br><span class=\"line\">1045</span><br><span class=\"line\">1046</span><br><span class=\"line\">1047</span><br><span class=\"line\">1048</span><br><span class=\"line\">1049</span><br><span class=\"line\">1050</span><br><span class=\"line\">1051</span><br><span class=\"line\">1052</span><br><span class=\"line\">1053</span><br><span class=\"line\">1054</span><br><span class=\"line\">1055</span><br><span class=\"line\">1056</span><br><span class=\"line\">1057</span><br><span class=\"line\">1058</span><br><span class=\"line\">1059</span><br><span class=\"line\">1060</span><br><span class=\"line\">1061</span><br><span class=\"line\">1062</span><br><span class=\"line\">1063</span><br><span class=\"line\">1064</span><br><span class=\"line\">1065</span><br><span class=\"line\">1066</span><br><span class=\"line\">1067</span><br><span class=\"line\">1068</span><br><span class=\"line\">1069</span><br><span class=\"line\">1070</span><br><span class=\"line\">1071</span><br><span class=\"line\">1072</span><br><span class=\"line\">1073</span><br><span class=\"line\">1074</span><br><span class=\"line\">1075</span><br><span class=\"line\">1076</span><br><span class=\"line\">1077</span><br><span class=\"line\">1078</span><br><span class=\"line\">1079</span><br><span class=\"line\">1080</span><br><span class=\"line\">1081</span><br><span class=\"line\">1082</span><br><span class=\"line\">1083</span><br><span class=\"line\">1084</span><br><span class=\"line\">1085</span><br><span class=\"line\">1086</span><br><span class=\"line\">1087</span><br><span class=\"line\">1088</span><br><span class=\"line\">1089</span><br><span class=\"line\">1090</span><br><span class=\"line\">1091</span><br><span class=\"line\">1092</span><br><span class=\"line\">1093</span><br><span class=\"line\">1094</span><br><span class=\"line\">1095</span><br><span class=\"line\">1096</span><br><span class=\"line\">1097</span><br><span class=\"line\">1098</span><br><span class=\"line\">1099</span><br><span class=\"line\">1100</span><br><span class=\"line\">1101</span><br><span class=\"line\">1102</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># Hexo Theme Fluid</span><br><span class=\"hljs-comment\"># Author: Fluid-dev</span><br><span class=\"hljs-comment\"># Github: https://github.com/fluid-dev/hexo-theme-fluid</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># 配置指南: https://hexo.fluid-dev.com/docs/guide/</span><br><span class=\"hljs-comment\"># 你可以从指南中获得更详细的说明</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># Guide: https://hexo.fluid-dev.com/docs/en/guide/</span><br><span class=\"hljs-comment\"># You can get more detailed help from the guide</span><br><span class=\"hljs-comment\">#---------------------------</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 全局</span><br><span class=\"hljs-comment\"># Global</span><br><span class=\"hljs-comment\">#---------------------------</span><br><br><span class=\"hljs-comment\"># 用于浏览器标签的图标</span><br><span class=\"hljs-comment\"># Icon for browser tab</span><br><span class=\"hljs-attr\">favicon:</span> <span class=\"hljs-string\">/img/fluid.png</span><br><br><span class=\"hljs-comment\"># 用于苹果设备的图标</span><br><span class=\"hljs-comment\"># Icon for Apple touch</span><br><span class=\"hljs-attr\">apple_touch_icon:</span> <span class=\"hljs-string\">/img/fluid.png</span><br><br><span class=\"hljs-comment\"># 浏览器标签页中的标题分隔符，效果： 文章名 - 站点名</span><br><span class=\"hljs-comment\"># Title separator in browser tab, eg: article - site</span><br><span class=\"hljs-attr\">tab_title_separator:</span> <span class=\"hljs-string\">&quot; - &quot;</span><br><br><span class=\"hljs-comment\"># 强制所有链接升级为 HTTPS（适用于图片等资源出现 HTTP 混入报错）</span><br><span class=\"hljs-comment\"># Force all links to be HTTPS (applicable to HTTP mixed error)</span><br><span class=\"hljs-attr\">force_https:</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-comment\"># 代码块的增强配置</span><br><span class=\"hljs-comment\"># Enhancements to code blocks</span><br><span class=\"hljs-attr\">code:</span><br>  <span class=\"hljs-comment\"># 是否开启复制代码的按钮</span><br>  <span class=\"hljs-comment\"># Enable copy code button</span><br>  <span class=\"hljs-attr\">copy_btn:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 代码语言</span><br>  <span class=\"hljs-comment\"># Code language</span><br>  <span class=\"hljs-attr\">language:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">default:</span> <span class=\"hljs-string\">&quot;TEXT&quot;</span><br><br>  <span class=\"hljs-comment\"># 代码高亮</span><br>  <span class=\"hljs-comment\"># Code highlight</span><br>  <span class=\"hljs-attr\">highlight:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 代码块是否显示行号</span><br>    <span class=\"hljs-comment\"># If true, the code block display line numbers</span><br>    <span class=\"hljs-attr\">line_number:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 实现高亮的库，对应下面的设置</span><br>    <span class=\"hljs-comment\"># Highlight library</span><br>    <span class=\"hljs-comment\"># Options: highlightjs | prismjs</span><br>    <span class=\"hljs-attr\">lib:</span> <span class=\"hljs-string\">&quot;highlightjs&quot;</span><br><br>    <span class=\"hljs-attr\">highlightjs:</span><br>      <span class=\"hljs-comment\"># 在链接中挑选 style 填入</span><br>      <span class=\"hljs-comment\"># Select a style in the link</span><br>      <span class=\"hljs-comment\"># See: https://highlightjs.org/static/demo/</span><br>      <span class=\"hljs-attr\">style:</span> <span class=\"hljs-string\">&quot;github gist&quot;</span><br>      <span class=\"hljs-attr\">style_dark:</span> <span class=\"hljs-string\">&quot;dark&quot;</span><br><br>    <span class=\"hljs-attr\">prismjs:</span><br>      <span class=\"hljs-comment\"># 在下方链接页面右侧的圆形按钮挑选 style 填入，也可以直接填入 css 链接</span><br>      <span class=\"hljs-comment\"># Select the style button on the right side of the link page, you can also set the CSS link</span><br>      <span class=\"hljs-comment\"># See: https://prismjs.com/</span><br>      <span class=\"hljs-attr\">style:</span> <span class=\"hljs-string\">&quot;default&quot;</span><br>      <span class=\"hljs-attr\">style_dark:</span> <span class=\"hljs-string\">&quot;tomorrow night&quot;</span><br><br>      <span class=\"hljs-comment\"># 设为 true 高亮将本地静态生成（但只支持部分 prismjs 插件），设为 false 高亮将在浏览器通过 js 生成</span><br>      <span class=\"hljs-comment\"># If true, it will be generated locally (but some prismjs plugins are not supported). If false, it will be generated via JS in the browser</span><br>      <span class=\"hljs-attr\">preprocess:</span> <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\"># 一些好玩的功能</span><br><span class=\"hljs-comment\"># Some fun features</span><br><span class=\"hljs-attr\">fun_features:</span><br>  <span class=\"hljs-comment\"># 为 subtitle 添加打字机效果</span><br>  <span class=\"hljs-comment\"># Typing animation for subtitle</span><br>  <span class=\"hljs-attr\">typing:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 打印速度，数字越大越慢</span><br>    <span class=\"hljs-comment\"># Typing speed, the larger the number, the slower</span><br>    <span class=\"hljs-attr\">typeSpeed:</span> <span class=\"hljs-number\">70</span><br><br>    <span class=\"hljs-comment\"># 游标字符</span><br>    <span class=\"hljs-comment\"># Cursor character</span><br>    <span class=\"hljs-attr\">cursorChar:</span> <span class=\"hljs-string\">&quot;_&quot;</span><br><br>    <span class=\"hljs-comment\"># 是否循环播放效果</span><br>    <span class=\"hljs-comment\"># If true, loop animation</span><br>    <span class=\"hljs-attr\">loop:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 在指定页面开启，不填则在所有页面开启</span><br>    <span class=\"hljs-comment\"># Enable in specified page, all pages by default</span><br>    <span class=\"hljs-comment\"># Options: home | post | tag | category | about | links | page | 404</span><br>    <span class=\"hljs-attr\">scope:</span> []<br><br>  <span class=\"hljs-comment\"># 为文章内容中的标题添加锚图标</span><br>  <span class=\"hljs-comment\"># Add an anchor icon to the title on the post page</span><br>  <span class=\"hljs-attr\">anchorjs:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">element:</span> <span class=\"hljs-string\">h1,h2,h3,h4,h5,h6</span><br>    <span class=\"hljs-comment\"># Options: left | right</span><br>    <span class=\"hljs-attr\">placement:</span> <span class=\"hljs-string\">left</span><br>    <span class=\"hljs-comment\"># Options: hover | always | touch</span><br>    <span class=\"hljs-attr\">visible:</span> <span class=\"hljs-string\">hover</span><br>    <span class=\"hljs-comment\"># Options: § | # | ❡</span><br>    <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>  <span class=\"hljs-comment\"># 加载进度条</span><br>  <span class=\"hljs-comment\"># Progress bar when loading</span><br>  <span class=\"hljs-attr\">progressbar:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">height_px:</span> <span class=\"hljs-number\">3</span><br>    <span class=\"hljs-attr\">color:</span> <span class=\"hljs-string\">&quot;#29d&quot;</span><br>    <span class=\"hljs-comment\"># See: https://github.com/rstacruz/nprogress</span><br>    <span class=\"hljs-attr\">options:</span> &#123; <span class=\"hljs-attr\">showSpinner:</span> <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">trickleSpeed:</span> <span class=\"hljs-number\">100</span> &#125;<br><br><span class=\"hljs-comment\"># 主题暗色模式，开启后菜单中会出现切换按钮，用户浏览器会存储切换选项，并且会遵循 prefers-color-scheme 自动切换</span><br><span class=\"hljs-comment\"># Theme dark mode. If enable, a switch button will appear on the menu, each of the visitor&#x27;s browser will store his switch option</span><br><span class=\"hljs-attr\">dark_mode:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-comment\"># 默认的选项（当用户手动切换后则不再按照默认模式），选择 `auto` 会优先遵循 prefers-color-scheme，其次按用户本地时间 18 点到次日 6 点之间进入暗色模式</span><br>  <span class=\"hljs-comment\"># Default option (when the visitor switches manually, the default mode is no longer followed), choosing `auto` will give priority to prefers-color-scheme, and then enter the dark mode from 18:00 to 6:00 in the visitor’s local time</span><br>  <span class=\"hljs-comment\"># Options: auto | light | dark</span><br>  <span class=\"hljs-attr\">default:</span> <span class=\"hljs-string\">auto</span><br><br><span class=\"hljs-comment\"># 主题颜色配置，其他不生效的地方请使用自定义 css 解决，配色可以在下方链接中获得启发</span><br><span class=\"hljs-comment\"># Theme color, please use custom CSS to solve other colors, color schema can be inspired by the links below</span><br><span class=\"hljs-comment\"># See: https://www.webdesignrankings.com/resources/lolcolors/</span><br><span class=\"hljs-attr\">color:</span><br>  <span class=\"hljs-comment\"># body 背景色</span><br>  <span class=\"hljs-comment\"># Color of body background</span><br>  <span class=\"hljs-attr\">body_bg_color:</span> <span class=\"hljs-string\">&quot;#eee&quot;</span><br>  <span class=\"hljs-comment\"># 暗色模式下的 body 背景色，下同</span><br>  <span class=\"hljs-comment\"># Color in dark mode, the same below</span><br>  <span class=\"hljs-attr\">body_bg_color_dark:</span> <span class=\"hljs-string\">&quot;#181c27&quot;</span><br><br>  <span class=\"hljs-comment\"># 顶部菜单背景色</span><br>  <span class=\"hljs-comment\"># Color of navigation bar background</span><br>  <span class=\"hljs-attr\">navbar_bg_color:</span> <span class=\"hljs-string\">&quot;#2f4154&quot;</span><br>  <span class=\"hljs-attr\">navbar_bg_color_dark:</span> <span class=\"hljs-string\">&quot;#1f3144&quot;</span><br><br>  <span class=\"hljs-comment\"># 顶部菜单字体色</span><br>  <span class=\"hljs-comment\"># Color of navigation bar text</span><br>  <span class=\"hljs-attr\">navbar_text_color:</span> <span class=\"hljs-string\">&quot;#fff&quot;</span><br>  <span class=\"hljs-attr\">navbar_text_color_dark:</span> <span class=\"hljs-string\">&quot;#d0d0d0&quot;</span><br><br>  <span class=\"hljs-comment\"># 副标题字体色</span><br>  <span class=\"hljs-comment\"># Color of navigation bar text</span><br>  <span class=\"hljs-attr\">subtitle_color:</span> <span class=\"hljs-string\">&quot;#fff&quot;</span><br>  <span class=\"hljs-attr\">subtitle_color_dark:</span> <span class=\"hljs-string\">&quot;#d0d0d0&quot;</span><br><br>  <span class=\"hljs-comment\"># 全局字体色</span><br>  <span class=\"hljs-comment\"># Color of global text</span><br>  <span class=\"hljs-attr\">text_color:</span> <span class=\"hljs-string\">&quot;#3c4858&quot;</span><br>  <span class=\"hljs-attr\">text_color_dark:</span> <span class=\"hljs-string\">&quot;#c4c6c9&quot;</span><br><br>  <span class=\"hljs-comment\"># 全局次级字体色（摘要、简介等位置）</span><br>  <span class=\"hljs-comment\"># Color of global secondary text (excerpt, introduction, etc.)</span><br>  <span class=\"hljs-attr\">sec_text_color:</span> <span class=\"hljs-string\">&quot;#718096&quot;</span><br>  <span class=\"hljs-attr\">sec_text_color_dark:</span> <span class=\"hljs-string\">&quot;#a7a9ad&quot;</span><br><br>  <span class=\"hljs-comment\"># 主面板背景色</span><br>  <span class=\"hljs-comment\"># Color of main board</span><br>  <span class=\"hljs-attr\">board_color:</span> <span class=\"hljs-string\">&quot;#fff&quot;</span><br>  <span class=\"hljs-attr\">board_color_dark:</span> <span class=\"hljs-string\">&quot;#252d38&quot;</span><br><br>  <span class=\"hljs-comment\"># 文章正文字体色</span><br>  <span class=\"hljs-comment\"># Color of post text</span><br>  <span class=\"hljs-attr\">post_text_color:</span> <span class=\"hljs-string\">&quot;#2c3e50&quot;</span><br>  <span class=\"hljs-attr\">post_text_color_dark:</span> <span class=\"hljs-string\">&quot;#c4c6c9&quot;</span><br><br>  <span class=\"hljs-comment\"># 文章正文字体色（h1 h2 h3...）</span><br>  <span class=\"hljs-comment\"># Color of Article heading (h1 h2 h3...)</span><br>  <span class=\"hljs-attr\">post_heading_color:</span> <span class=\"hljs-string\">&quot;#1a202c&quot;</span><br>  <span class=\"hljs-attr\">post_heading_color_dark:</span> <span class=\"hljs-string\">&quot;#c4c6c9&quot;</span><br><br>  <span class=\"hljs-comment\"># 文章超链接字体色</span><br>  <span class=\"hljs-comment\"># Color of post link</span><br>  <span class=\"hljs-attr\">post_link_color:</span> <span class=\"hljs-string\">&quot;#0366d6&quot;</span><br>  <span class=\"hljs-attr\">post_link_color_dark:</span> <span class=\"hljs-string\">&quot;#1589e9&quot;</span><br><br>  <span class=\"hljs-comment\"># 超链接悬浮时字体色</span><br>  <span class=\"hljs-comment\"># Color of link when hovering</span><br>  <span class=\"hljs-attr\">link_hover_color:</span> <span class=\"hljs-string\">&quot;#30a9de&quot;</span><br>  <span class=\"hljs-attr\">link_hover_color_dark:</span> <span class=\"hljs-string\">&quot;#30a9de&quot;</span><br><br>  <span class=\"hljs-comment\"># 超链接悬浮背景色</span><br>  <span class=\"hljs-comment\"># Color of link background when hovering</span><br>  <span class=\"hljs-attr\">link_hover_bg_color:</span> <span class=\"hljs-string\">&quot;#f8f9fa&quot;</span><br>  <span class=\"hljs-attr\">link_hover_bg_color_dark:</span> <span class=\"hljs-string\">&quot;#364151&quot;</span><br><br>  <span class=\"hljs-comment\"># 分隔线和表格边线的颜色</span><br>  <span class=\"hljs-comment\"># Color of horizontal rule and table border</span><br>  <span class=\"hljs-attr\">line_color:</span> <span class=\"hljs-string\">&quot;#eaecef&quot;</span><br>  <span class=\"hljs-attr\">line_color_dark:</span> <span class=\"hljs-string\">&quot;#435266&quot;</span><br><br>  <span class=\"hljs-comment\"># 滚动条颜色</span><br>  <span class=\"hljs-comment\"># Color of scrollbar</span><br>  <span class=\"hljs-attr\">scrollbar_color:</span> <span class=\"hljs-string\">&quot;#c4c6c9&quot;</span><br>  <span class=\"hljs-attr\">scrollbar_color_dark:</span> <span class=\"hljs-string\">&quot;#687582&quot;</span><br>  <span class=\"hljs-comment\"># 滚动条悬浮颜色</span><br>  <span class=\"hljs-comment\"># Color of scrollbar when hovering</span><br>  <span class=\"hljs-attr\">scrollbar_hover_color:</span> <span class=\"hljs-string\">&quot;#a6a6a6&quot;</span><br>  <span class=\"hljs-attr\">scrollbar_hover_color_dark:</span> <span class=\"hljs-string\">&quot;#9da8b3&quot;</span><br><br>  <span class=\"hljs-comment\"># 按钮背景色</span><br>  <span class=\"hljs-comment\"># Color of button</span><br>  <span class=\"hljs-attr\">button_bg_color:</span> <span class=\"hljs-string\">&quot;transparent&quot;</span><br>  <span class=\"hljs-attr\">button_bg_color_dark:</span> <span class=\"hljs-string\">&quot;transparent&quot;</span><br>  <span class=\"hljs-comment\"># 按钮悬浮背景色</span><br>  <span class=\"hljs-comment\"># Color of button when hovering</span><br>  <span class=\"hljs-attr\">button_hover_bg_color:</span> <span class=\"hljs-string\">&quot;#f2f3f5&quot;</span><br>  <span class=\"hljs-attr\">button_hover_bg_color_dark:</span> <span class=\"hljs-string\">&quot;#46647e&quot;</span><br><br><span class=\"hljs-comment\"># 主题字体配置</span><br><span class=\"hljs-comment\"># Font</span><br><span class=\"hljs-attr\">font:</span><br>  <span class=\"hljs-attr\">font_size:</span> <span class=\"hljs-string\">16px</span><br>  <span class=\"hljs-attr\">font_family:</span><br>  <span class=\"hljs-attr\">letter_spacing:</span> <span class=\"hljs-number\">0.</span><span class=\"hljs-string\">02em</span><br>  <span class=\"hljs-attr\">code_font_size:</span> <span class=\"hljs-number\">85</span><span class=\"hljs-string\">%</span><br><br><span class=\"hljs-comment\"># 指定自定义 .js 文件路径，支持列表；路径是相对 source 目录，如 /js/custom.js 对应存放目录 source/js/custom.js</span><br><span class=\"hljs-comment\"># Specify the path of your custom js file, support list. The path is relative to the source directory, such as `/js/custom.js` corresponding to the directory `source/js/custom.js`</span><br><span class=\"hljs-attr\">custom_js:</span><br><br><span class=\"hljs-comment\"># 指定自定义 .css 文件路径，用法和 custom_js 相同</span><br><span class=\"hljs-comment\"># The usage is the same as custom_js</span><br><span class=\"hljs-attr\">custom_css:</span><br><br><span class=\"hljs-comment\"># 网页访问统计</span><br><span class=\"hljs-comment\"># Analysis of website visitors</span><br><span class=\"hljs-attr\">web_analytics:</span>  <span class=\"hljs-comment\"># 网页访问统计</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>  <span class=\"hljs-comment\"># 遵循访客浏览器&quot;请勿追踪&quot;的设置，如果开启则不统计其访问</span><br>  <span class=\"hljs-comment\"># Follow the &quot;Do Not Track&quot; setting of the visitor&#x27;s browser</span><br>  <span class=\"hljs-comment\"># See: https://www.w3.org/TR/tracking-dnt/</span><br>  <span class=\"hljs-attr\">follow_dnt:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 百度统计的 Key，值需要获取下方链接中 `hm.js?` 后边的字符串</span><br>  <span class=\"hljs-comment\"># Baidu analytics, get the string behind `hm.js?`</span><br>  <span class=\"hljs-comment\"># See: https://tongji.baidu.com/sc-web/10000033910/home/site/getjs?siteId=13751376</span><br>  <span class=\"hljs-attr\">baidu:</span><br><br>  <span class=\"hljs-comment\"># Google Analytics 4 的媒体资源 ID</span><br>  <span class=\"hljs-comment\"># Google Analytics 4 MEASUREMENT_ID</span><br>  <span class=\"hljs-comment\"># See: https://support.google.com/analytics/answer/9744165#zippy=%2Cin-this-article</span><br>  <span class=\"hljs-attr\">google:</span><br>    <span class=\"hljs-attr\">measurement_id:</span><br><br>  <span class=\"hljs-comment\"># 腾讯统计的 H5 App ID，开启高级功能才有cid</span><br>  <span class=\"hljs-comment\"># Tencent analytics, set APP ID</span><br>  <span class=\"hljs-comment\"># See: https://mta.qq.com/h5/manage/ctr_app_manage</span><br>  <span class=\"hljs-attr\">tencent:</span><br>    <span class=\"hljs-attr\">sid:</span><br>    <span class=\"hljs-attr\">cid:</span><br><br>  <span class=\"hljs-comment\"># 51.la 站点统计 ID</span><br>  <span class=\"hljs-comment\"># 51.la analytics</span><br>  <span class=\"hljs-comment\"># See: https://www.51.la/user/site/index</span><br>  <span class=\"hljs-attr\">woyaola:</span>  <span class=\"hljs-comment\"># 51.la 站点统计 ID，参见</span><br><br>  <span class=\"hljs-comment\"># 友盟/cnzz 站点统计 web_id</span><br>  <span class=\"hljs-comment\"># cnzz analytics</span><br>  <span class=\"hljs-comment\"># See: https://web.umeng.com/main.php?c=site&amp;a=show</span><br>  <span class=\"hljs-attr\">cnzz:</span><br><br>  <span class=\"hljs-comment\"># LeanCloud 计数统计，可用于 PV UV 展示，如果 `web_analytics: enable` 没有开启，PV UV 展示只会查询不会增加</span><br>  <span class=\"hljs-comment\"># LeanCloud count statistics, which can be used for PV UV display. If `web_analytics: enable` is false, PV UV display will only query and not increase</span><br>  <span class=\"hljs-attr\">leancloud:</span><br>    <span class=\"hljs-attr\">app_id:</span><br>    <span class=\"hljs-attr\">app_key:</span><br>    <span class=\"hljs-comment\"># REST API 服务器地址，国际版不填</span><br>    <span class=\"hljs-comment\"># Only the Chinese mainland users need to set</span><br>    <span class=\"hljs-attr\">server_url:</span><br>    <span class=\"hljs-comment\"># 统计页面时获取路径的属性</span><br>    <span class=\"hljs-comment\"># Get the attribute of the page path during statistics</span><br>    <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">window.location.pathname</span><br>    <span class=\"hljs-comment\"># 开启后不统计本地路径( localhost 与 127.0.0.1 )</span><br>    <span class=\"hljs-comment\"># If true, ignore localhost &amp; 127.0.0.1</span><br>    <span class=\"hljs-attr\">ignore_local:</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-comment\"># 对页面中的图片和评论插件进行懒加载处理，可见范围外的元素不会提前加载</span><br><span class=\"hljs-comment\"># Lazy loading of images and comment plugin on the page</span><br><span class=\"hljs-attr\">lazyload:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 加载时的占位图片</span><br>  <span class=\"hljs-comment\"># The placeholder image when loading</span><br>  <span class=\"hljs-attr\">loading_img:</span> <span class=\"hljs-string\">/img/loading.gif</span><br><br>  <span class=\"hljs-comment\"># 开启后懒加载仅在文章页生效，如果自定义页面需要使用，可以在 Front-matter 里指定 `lazyload: true`</span><br>  <span class=\"hljs-comment\"># If true, only enable lazyload on the post page. For custom pages, you can set &#x27;lazyload: true&#x27; in front-matter</span><br>  <span class=\"hljs-attr\">onlypost:</span> <span class=\"hljs-literal\">false</span><br><br>  <span class=\"hljs-comment\"># 触发加载的偏移倍数，基数是视窗高度，可根据部署环境的请求速度调节</span><br>  <span class=\"hljs-comment\"># The factor of viewport height that triggers loading</span><br>  <span class=\"hljs-attr\">offset_factor:</span> <span class=\"hljs-number\">2</span><br><br><span class=\"hljs-comment\"># 图标库，包含了大量社交类图标，主题依赖的不包含在内，因此可自行修改，详见 https://hexo.fluid-dev.com/docs/icon/</span><br><span class=\"hljs-comment\"># Icon library, which includes many social icons, does not include those theme dependent, so your can modify link by yourself. See: https://hexo.fluid-dev.com/docs/en/icon/</span><br><span class=\"hljs-attr\">iconfont:</span> <span class=\"hljs-string\">//at.alicdn.com/t/font_1736178_lbnruvf0jn.css</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 页头</span><br><span class=\"hljs-comment\"># Header</span><br><span class=\"hljs-comment\">#---------------------------</span><br><br><span class=\"hljs-comment\"># 导航栏的相关配置</span><br><span class=\"hljs-comment\"># Navigation bar</span><br><span class=\"hljs-attr\">navbar:</span><br>  <span class=\"hljs-comment\"># 导航栏左侧的标题，为空则按 hexo config 中 `title` 显示</span><br>  <span class=\"hljs-comment\"># The title on the left side of the navigation bar. If empty, it is based on `title` in hexo config</span><br>  <span class=\"hljs-attr\">blog_title:</span> <span class=\"hljs-string\">&quot;Fluid&quot;</span><br><br>  <span class=\"hljs-comment\"># 导航栏毛玻璃特效，实验性功能，可能会造成页面滚动掉帧和抖动，部分浏览器不支持会自动不生效</span><br>  <span class=\"hljs-comment\"># Navigation bar frosted glass special animation. It is an experimental feature</span><br>  <span class=\"hljs-attr\">ground_glass:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 模糊像素，只能为数字，数字越大模糊度越高</span><br>    <span class=\"hljs-comment\"># Number of blurred pixel. the larger the number, the higher the blur</span><br>    <span class=\"hljs-attr\">px:</span> <span class=\"hljs-number\">3</span><br><br>    <span class=\"hljs-comment\"># 不透明度，数字越大透明度越低，注意透明过度可能看不清菜单字体</span><br>    <span class=\"hljs-comment\"># Ratio of opacity, 1.0 is completely opaque</span><br>    <span class=\"hljs-comment\"># available: 0 - 1.0</span><br>    <span class=\"hljs-attr\">alpha:</span> <span class=\"hljs-number\">0.7</span><br><br>  <span class=\"hljs-comment\"># 导航栏菜单，可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称</span><br>  <span class=\"hljs-comment\"># Navigation bar menu. `key` is used to associate languages/*.yml. If there is no association, the value of `key` itself will be displayed; if `icon` is a css class, it can be omitted; adding `name` can force the display of the specified name</span><br>  <span class=\"hljs-attr\">menu:</span><br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">&quot;home&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-home-fill&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">&quot;archive&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;/archives/&quot;</span>, <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-archive-fill&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">&quot;category&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;/categories/&quot;</span>, <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-category-fill&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">&quot;tag&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;/tags/&quot;</span>, <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-tags-fill&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">&quot;about&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;/about/&quot;</span>, <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-user-fill&quot;</span> &#125;<br>    <span class=\"hljs-comment\">#- &#123; key: &quot;links&quot;, link: &quot;/links/&quot;, icon: &quot;iconfont icon-link-fill&quot; &#125;</span><br><br><span class=\"hljs-comment\"># 搜索功能，基于 hexo-generator-search 插件，若已安装其他搜索插件请关闭此功能，以避免生成多余的索引文件</span><br><span class=\"hljs-comment\"># Search feature, based on hexo-generator-search. If you have installed other search plugins, please disable this feature to avoid generating redundant index files</span><br><span class=\"hljs-attr\">search:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 搜索索引文件的路径，可以是相对路径或外站的绝对路径</span><br>  <span class=\"hljs-comment\"># Path for search index file, it can be a relative path or an absolute path</span><br>  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">/local-search.xml</span><br><br>  <span class=\"hljs-comment\"># 文件生成在本地的位置，必须是相对路径</span><br>  <span class=\"hljs-comment\"># The location where the index file is generated locally, it must be a relative location</span><br>  <span class=\"hljs-attr\">generate_path:</span> <span class=\"hljs-string\">/local-search.xml</span><br><br>  <span class=\"hljs-comment\"># 搜索的范围</span><br>  <span class=\"hljs-comment\"># Search field</span><br>  <span class=\"hljs-comment\"># Options: post | page | all</span><br>  <span class=\"hljs-attr\">field:</span> <span class=\"hljs-string\">post</span><br><br>  <span class=\"hljs-comment\"># 搜索是否扫描正文</span><br>  <span class=\"hljs-comment\"># If true, search will scan the post content</span><br>  <span class=\"hljs-attr\">content:</span> <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\"># 首屏图片的相关配置</span><br><span class=\"hljs-comment\"># Config of the big image on the first screen</span><br><span class=\"hljs-attr\">banner:</span><br>  <span class=\"hljs-comment\"># 视差滚动，图片与板块会随着屏幕滚动产生视差效果</span><br>  <span class=\"hljs-comment\"># Scrolling parallax</span><br>  <span class=\"hljs-attr\">parallax:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 图片最小的宽高比，以免图片两边被过度裁剪，适用于移动端竖屏时，如需关闭设为 0</span><br>  <span class=\"hljs-comment\"># Minimum ratio of width to height, applicable to the vertical screen of mobile device, if you need to close it, set it to 0</span><br>  <span class=\"hljs-attr\">width_height_ratio:</span> <span class=\"hljs-number\">1.0</span><br><br><span class=\"hljs-comment\"># 向下滚动的箭头</span><br><span class=\"hljs-comment\"># Scroll down arrow</span><br><span class=\"hljs-attr\">scroll_down_arrow:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 头图高度不小于指定比例，才显示箭头</span><br>  <span class=\"hljs-comment\"># Only the height of the banner image is greater than the ratio, the arrow is displayed</span><br>  <span class=\"hljs-comment\"># Available: 0 - 100</span><br>  <span class=\"hljs-attr\">banner_height_limit:</span> <span class=\"hljs-number\">80</span><br><br>  <span class=\"hljs-comment\"># 翻页后自动滚动</span><br>  <span class=\"hljs-comment\"># Auto scroll after page turning</span><br>  <span class=\"hljs-attr\">scroll_after_turning_page:</span> <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\"># 向顶部滚动的箭头</span><br><span class=\"hljs-comment\"># Scroll top arrow</span><br><span class=\"hljs-attr\">scroll_top_arrow:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\"># Open Graph metadata</span><br><span class=\"hljs-comment\"># See: https://hexo.io/docs/helpers.html#open-graph</span><br><span class=\"hljs-attr\">open_graph:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">twitter_card:</span> <span class=\"hljs-string\">summary_large_image</span><br>  <span class=\"hljs-attr\">twitter_id:</span><br>  <span class=\"hljs-attr\">twitter_site:</span><br>  <span class=\"hljs-attr\">google_plus:</span><br>  <span class=\"hljs-attr\">fb_admins:</span><br>  <span class=\"hljs-attr\">fb_app_id:</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 页脚</span><br><span class=\"hljs-comment\"># Footer</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">footer:</span><br>  <span class=\"hljs-comment\"># 页脚第一行文字的 HTML，建议保留 Fluid 的链接，用于向更多人推广本主题</span><br>  <span class=\"hljs-comment\"># HTML of the first line of the footer, it is recommended to keep the Fluid link to promote this theme to more people</span><br>  <span class=\"hljs-attr\">content:</span> <span class=\"hljs-string\">&#x27;</span><br><span class=\"hljs-string\">    &lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Hexo&lt;/span&gt;&lt;/a&gt;</span><br><span class=\"hljs-string\">    &lt;i class=&quot;iconfont icon-love&quot;&gt;&lt;/i&gt;</span><br><span class=\"hljs-string\">    &lt;a href=&quot;https://github.com/fluid-dev/hexo-theme-fluid&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Fluid&lt;/span&gt;&lt;/a&gt;</span><br><span class=\"hljs-string\">  &#x27;</span><br><br>  <span class=\"hljs-comment\"># 展示网站的 PV、UV 统计数</span><br>  <span class=\"hljs-comment\"># Display website PV and UV statistics</span><br>  <span class=\"hljs-attr\">statistics:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 统计数据来源，使用 leancloud 需要设置 `web_analytics: leancloud` 中的参数；使用 busuanzi 不需要额外设置，但是有时不稳定，另外本地运行时 busuanzi 显示统计数据很大属于正常现象，部署后会正常</span><br>    <span class=\"hljs-comment\"># Data source. If use leancloud, you need to set the parameter in `web_analytics: leancloud`</span><br>    <span class=\"hljs-comment\"># Options: busuanzi | leancloud</span><br>    <span class=\"hljs-attr\">source:</span> <span class=\"hljs-string\">&quot;busuanzi&quot;</span><br><br>  <span class=\"hljs-comment\"># 国内大陆服务器的备案信息</span><br>  <span class=\"hljs-comment\"># For Chinese mainland website policy, other areas keep disable</span><br>  <span class=\"hljs-attr\">beian:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-comment\"># ICP证号</span><br>    <span class=\"hljs-attr\">icp_text:</span> <span class=\"hljs-string\">京ICP证123456号</span><br>    <span class=\"hljs-comment\"># 公安备案号，不填则只显示ICP</span><br>    <span class=\"hljs-attr\">police_text:</span> <span class=\"hljs-string\">京公网安备12345678号</span><br>    <span class=\"hljs-comment\"># 公安备案的编号，用于URL跳转查询</span><br>    <span class=\"hljs-attr\">police_code:</span> <span class=\"hljs-number\">12345678</span><br>    <span class=\"hljs-comment\"># 公安备案的图片. 为空时不显示备案图片</span><br>    <span class=\"hljs-attr\">police_icon:</span> <span class=\"hljs-string\">/img/police_beian.png</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 首页</span><br><span class=\"hljs-comment\"># Home Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">index:</span><br>  <span class=\"hljs-comment\"># 首页 Banner 头图，可以是相对路径或绝对路径，以下相同</span><br>  <span class=\"hljs-comment\"># Path of Banner image, can be a relative path or an absolute path, the same on other pages</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br><br>  <span class=\"hljs-comment\"># 头图高度，屏幕百分比</span><br>  <span class=\"hljs-comment\"># Height ratio of banner image</span><br>  <span class=\"hljs-comment\"># Available: 0 - 100</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">100</span><br><br>  <span class=\"hljs-comment\"># 头图黑色蒙版的不透明度，available: 0 - 1.0， 1 是完全不透明</span><br>  <span class=\"hljs-comment\"># Opacity of the banner mask, 1.0 is completely opaque</span><br>  <span class=\"hljs-comment\"># Available: 0 - 1.0</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br><br>  <span class=\"hljs-comment\"># 首页副标题的独立设置</span><br>  <span class=\"hljs-comment\"># Independent config of home page subtitle</span><br>  <span class=\"hljs-attr\">slogan:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 为空则按 hexo config.subtitle 显示</span><br>    <span class=\"hljs-comment\"># If empty, text based on `subtitle` in hexo config</span><br>    <span class=\"hljs-attr\">text:</span> <span class=\"hljs-string\">&quot;An elegant Material-Design theme for Hexo&quot;</span><br><br>    <span class=\"hljs-comment\"># 通过 API 接口作为首页副标题的内容，必须返回的是 JSON 格式，如果请求失败则按 text 字段显示，该功能必须先开启 typing 打字机功能</span><br>    <span class=\"hljs-comment\"># Subtitle of the homepage through the API, must be returned a JSON. If the request fails, it will be displayed in `text` value. This feature must first enable the typing animation</span><br>    <span class=\"hljs-attr\">api:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>      <span class=\"hljs-comment\"># 请求地址</span><br>      <span class=\"hljs-comment\"># Request url</span><br>      <span class=\"hljs-attr\">url:</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>      <span class=\"hljs-comment\"># 请求方法</span><br>      <span class=\"hljs-comment\"># Request method</span><br>      <span class=\"hljs-comment\"># Available: GET | POST | PUT</span><br>      <span class=\"hljs-attr\">method:</span> <span class=\"hljs-string\">&quot;GET&quot;</span><br><br>      <span class=\"hljs-comment\"># 请求头</span><br>      <span class=\"hljs-comment\"># Request headers</span><br>      <span class=\"hljs-attr\">headers:</span> &#123;&#125;<br><br>      <span class=\"hljs-comment\"># 从请求结果获取字符串的取值字段，最终必须是一个字符串，例如返回结果为 &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, 则取值字段为 [&#x27;data&#x27;, &#x27;content&#x27;]；如果返回是列表则自动选择第一项</span><br>      <span class=\"hljs-comment\"># The value field of the string obtained from the response. For example, the response content is &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, the expected `keys: [&#x27;data&#x27;,&#x27;content&#x27;]`; if the return is a list, the first item is automatically selected</span><br>      <span class=\"hljs-attr\">keys:</span> []<br><br>  <span class=\"hljs-comment\"># 自动截取文章摘要</span><br>  <span class=\"hljs-comment\"># Auto extract post</span><br>  <span class=\"hljs-attr\">auto_excerpt:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 打开文章的标签方式</span><br>  <span class=\"hljs-comment\"># The browser tag to open the post</span><br>  <span class=\"hljs-comment\"># Available: _blank | _self</span><br>  <span class=\"hljs-attr\">post_url_target:</span> <span class=\"hljs-string\">_self</span><br><br>  <span class=\"hljs-comment\"># 是否显示文章信息（时间、分类、标签）</span><br>  <span class=\"hljs-comment\"># Meta information of post</span><br>  <span class=\"hljs-attr\">post_meta:</span><br>    <span class=\"hljs-attr\">date:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">category:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">tag:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 文章通过 sticky 排序后，在首页文章标题前显示图标</span><br>  <span class=\"hljs-comment\"># If the posts are sorted by `sticky`, an icon is displayed in front of the post title</span><br>  <span class=\"hljs-attr\">post_sticky:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-top&quot;</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 文章页</span><br><span class=\"hljs-comment\"># Post Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">post:</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">70</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br><br>  <span class=\"hljs-comment\"># 文章在首页的默认封面图，当没有指定 index_img 时会使用该图片，若两者都为空则不显示任何图片</span><br>  <span class=\"hljs-comment\"># Path of the default post cover when `index_img` is not set. If both are empty, no image will be displayed</span><br>  <span class=\"hljs-attr\">default_index_img:</span><br><br>  <span class=\"hljs-comment\"># 文章标题下方的元信息</span><br>  <span class=\"hljs-comment\"># Meta information below title</span><br>  <span class=\"hljs-attr\">meta:</span><br>    <span class=\"hljs-comment\"># 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值</span><br>    <span class=\"hljs-comment\"># Author, based on `author` field in front-matter, if not set, based on `author` value in hexo config</span><br>    <span class=\"hljs-attr\">author:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期</span><br>    <span class=\"hljs-comment\"># Post date, based on `date` field in front-matter, if not set, based on create date of .md file</span><br>    <span class=\"hljs-attr\">date:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>      <span class=\"hljs-comment\"># 格式参照 ISO-8601 日期格式化</span><br>      <span class=\"hljs-comment\"># ISO-8601 date format</span><br>      <span class=\"hljs-comment\"># See: http://momentjs.cn/docs/#/parsing/string-format/</span><br>      <span class=\"hljs-attr\">format:</span> <span class=\"hljs-string\">&quot;LL a&quot;</span><br><br>    <span class=\"hljs-comment\"># 字数统计</span><br>    <span class=\"hljs-comment\"># Word count</span><br>    <span class=\"hljs-attr\">wordcount:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 估计阅读全文需要的时长</span><br>    <span class=\"hljs-comment\"># Estimated reading time</span><br>    <span class=\"hljs-attr\">min2read:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>      <span class=\"hljs-comment\"># 每个字词的长度，建议：中文≈2，英文≈5，中英混合可自行调节</span><br>      <span class=\"hljs-comment\"># Average word length (chars count in word), ZH ≈ 2, EN ≈ 5</span><br>      <span class=\"hljs-attr\">awl:</span> <span class=\"hljs-number\">2</span><br>      <span class=\"hljs-comment\"># 每分钟阅读字数，如果大部分是技术文章可适度调低</span><br>      <span class=\"hljs-comment\"># Words per minute</span><br>      <span class=\"hljs-attr\">wpm:</span> <span class=\"hljs-number\">60</span><br><br>    <span class=\"hljs-comment\"># 浏览量计数</span><br>    <span class=\"hljs-comment\"># Number of visits</span><br>    <span class=\"hljs-attr\">views:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>      <span class=\"hljs-comment\"># 统计数据来源</span><br>      <span class=\"hljs-comment\"># Data Source</span><br>      <span class=\"hljs-comment\"># Options: busuanzi | leancloud</span><br>      <span class=\"hljs-attr\">source:</span> <span class=\"hljs-string\">&quot;busuanzi&quot;</span><br><br>  <span class=\"hljs-comment\"># 在文章开头显示文章更新时间，该时间默认是 md 文件更新时间，可通过 front-matter 中 `updated` 手动指定（和 date 一样格式）</span><br>  <span class=\"hljs-comment\"># Update date is displayed at the beginning of the post. The default date is the update date of the md file, which can be manually specified by `updated` in front-matter (same format as date)</span><br>  <span class=\"hljs-attr\">updated:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 格式参照 ISO-8601 日期格式化</span><br>    <span class=\"hljs-comment\"># ISO-8601 date format</span><br>    <span class=\"hljs-comment\"># See: http://momentjs.cn/docs/#/parsing/string-format/</span><br>    <span class=\"hljs-attr\">date_format:</span> <span class=\"hljs-string\">&quot;LL a&quot;</span><br><br>    <span class=\"hljs-comment\"># 是否使用相对时间表示，比如：&quot;3 天前&quot;</span><br>    <span class=\"hljs-comment\"># If true, it will be a relative time, such as: &quot;3 days ago&quot;</span><br>    <span class=\"hljs-attr\">relative:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 提示标签类型</span><br>    <span class=\"hljs-comment\"># Note class</span><br>    <span class=\"hljs-comment\"># Options: default | primary | info | success | warning | danger | light</span><br>    <span class=\"hljs-attr\">note_class:</span> <span class=\"hljs-string\">info</span><br><br>  <span class=\"hljs-comment\"># 侧边栏展示当前分类下的文章</span><br>  <span class=\"hljs-comment\"># Sidebar of category</span><br>  <span class=\"hljs-attr\">category_bar:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 开启后，只有在文章 Front-matter 里指定 `category_bar: true` 才会展示分类，也可以通过 `category_bar: [&quot;分类A&quot;]` 来指定分类</span><br>    <span class=\"hljs-comment\"># If true, only set `category_bar: true` in Front-matter will enable sidebar of category, also set `category_bar: [&quot;CategoryA&quot;]` to specify categories</span><br>    <span class=\"hljs-attr\">specific:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 置于板块的左侧或右侧</span><br>    <span class=\"hljs-comment\"># place in the board</span><br>    <span class=\"hljs-comment\"># Options: left | right</span><br>    <span class=\"hljs-attr\">placement:</span> <span class=\"hljs-string\">left</span><br><br>    <span class=\"hljs-comment\"># 文章的排序字段，前面带减号是倒序，不带减号是正序</span><br>    <span class=\"hljs-comment\"># Sort field for posts, with a minus sign is reverse order</span><br>    <span class=\"hljs-comment\"># Options: date | title | or other field of front-matter</span><br>    <span class=\"hljs-attr\">post_order_by:</span> <span class=\"hljs-string\">&quot;title&quot;</span><br><br>    <span class=\"hljs-comment\"># 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制</span><br>    <span class=\"hljs-comment\"># The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit</span><br>    <span class=\"hljs-attr\">post_limit:</span> <span class=\"hljs-number\">0</span><br><br>  <span class=\"hljs-comment\"># 侧边栏展示文章目录</span><br>  <span class=\"hljs-comment\"># Table of contents (TOC) in the sidebar</span><br>  <span class=\"hljs-attr\">toc:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 置于板块的左侧或右侧</span><br>    <span class=\"hljs-comment\"># place in the board</span><br>    <span class=\"hljs-comment\"># Options: left | right</span><br>    <span class=\"hljs-attr\">placement:</span> <span class=\"hljs-string\">right</span><br><br>    <span class=\"hljs-comment\"># 目录会选择这些节点作为标题</span><br>    <span class=\"hljs-comment\"># TOC will select these nodes as headings</span><br>    <span class=\"hljs-attr\">headingSelector:</span> <span class=\"hljs-string\">&quot;h1,h2,h3,h4,h5,h6&quot;</span><br><br>    <span class=\"hljs-comment\"># 层级的折叠深度，0 是全部折叠，大于 0 后如果存在下级标题则默认展开</span><br>    <span class=\"hljs-comment\"># Collapse depth. If 0, all headings collapsed. If greater than 0, it will be expanded by default if there are sub headings</span><br>    <span class=\"hljs-attr\">collapseDepth:</span> <span class=\"hljs-number\">0</span><br><br>  <span class=\"hljs-comment\"># 版权声明，会显示在每篇文章的结尾</span><br>  <span class=\"hljs-comment\"># Copyright, will be displayed at the end of each post</span><br>  <span class=\"hljs-attr\">copyright:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># CreativeCommons license</span><br>    <span class=\"hljs-comment\"># Options: BY | BY-SA | BY-ND | BY-NC | BY-NC-SA | BY-NC-ND</span><br>    <span class=\"hljs-attr\">license:</span> <span class=\"hljs-string\">&#x27;BY&#x27;</span><br><br>    <span class=\"hljs-comment\"># 显示作者</span><br>    <span class=\"hljs-attr\">author:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 显示发布日期</span><br>    <span class=\"hljs-comment\"># Show post date</span><br>    <span class=\"hljs-attr\">post_date:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>      <span class=\"hljs-attr\">format:</span> <span class=\"hljs-string\">&quot;LL&quot;</span><br><br>    <span class=\"hljs-comment\"># 显示更新日期</span><br>    <span class=\"hljs-comment\"># Show update date</span><br>    <span class=\"hljs-attr\">update_date:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>      <span class=\"hljs-attr\">format:</span> <span class=\"hljs-string\">&quot;LL&quot;</span><br><br>  <span class=\"hljs-comment\"># 文章底部上一篇下一篇功能</span><br>  <span class=\"hljs-comment\"># Link to previous/next post</span><br>  <span class=\"hljs-attr\">prev_next:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 文章图片标题</span><br>  <span class=\"hljs-comment\"># Image caption</span><br>  <span class=\"hljs-attr\">image_caption:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 文章图片可点击放大</span><br>  <span class=\"hljs-comment\"># Zoom feature of images</span><br>  <span class=\"hljs-attr\">image_zoom:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-comment\"># 放大后图片链接替换规则，可用于将压缩图片链接替换为原图片链接，如 [&#x27;-slim&#x27;, &#x27;&#x27;] 是将链接中 `-slim` 移除；如果想使用正则请使用 `re:` 前缀，如 [&#x27;re:\\\\d&#123;3,4&#125;\\\\/\\\\d&#123;3,4&#125;\\\\/&#x27;, &#x27;&#x27;]</span><br>    <span class=\"hljs-comment\"># The image url replacement when zooming, the feature can be used to replace the compressed image to the original image, eg: [&#x27;-slim&#x27;, &#x27;&#x27;] removes `-slim` from the image url when zooming; if you want to use regular, use prefix `re:`, eg: [&#x27;re:\\\\d&#123;3,4&#125;\\\\/\\\\d&#123;3,4&#125;\\\\/&#x27;,&#x27;&#x27;]</span><br>    <span class=\"hljs-attr\">img_url_replace:</span> [<span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>]<br><br>  <span class=\"hljs-comment\"># 脚注语法，会在文章底部生成脚注，如果 Markdown 渲染器本身支持，则建议关闭，否则可能会冲突</span><br>  <span class=\"hljs-comment\"># Support footnote syntax, footnotes will be generated at the bottom of the post page. If the Markdown renderer itself supports it, please disable it, otherwise it may conflict</span><br>  <span class=\"hljs-attr\">footnote:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-comment\"># 脚注的节标题，也可以在 front-matter 中通过 `foot<span class=\"hljs-doctag\">note:</span> &lt;h2&gt;Reference&lt;/h2&gt;` 这种形式修改单独页面的 header</span><br>    <span class=\"hljs-comment\"># The section title of the footnote, you can also modify the header of a single page in the form of `foot<span class=\"hljs-doctag\">note:</span> &lt;h2&gt;Reference&lt;/h2&gt;` in front-matter</span><br>    <span class=\"hljs-attr\">header:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><br>  <span class=\"hljs-comment\"># 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式</span><br>  <span class=\"hljs-comment\"># Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math</span><br>  <span class=\"hljs-attr\">math:</span><br>    <span class=\"hljs-comment\"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span><br>    <span class=\"hljs-comment\"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>    <span class=\"hljs-comment\"># If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math</span><br>    <span class=\"hljs-attr\">specific:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># Options: mathjax | katex</span><br>    <span class=\"hljs-attr\">engine:</span> <span class=\"hljs-string\">mathjax</span><br><br>  <span class=\"hljs-comment\"># 流程图，基于 mermaid-js，具体请见：https://hexo.fluid-dev.com/docs/guide/#mermaid-流程图</span><br>  <span class=\"hljs-comment\"># Flow chart, based on mermaid-js, see: https://hexo.fluid-dev.com/docs/en/guide/#mermaid</span><br>  <span class=\"hljs-attr\">mermaid:</span><br>    <span class=\"hljs-comment\"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `mermaid: true`</span><br>    <span class=\"hljs-comment\"># If you want to use mermaid on the custom page, you need to set `mermaid: true` in Front-matter</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 开启后，只有在文章 Front-matter 里指定 `mermaid: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>    <span class=\"hljs-comment\"># If true, only set `mermaid: true` in Front-matter will enable mermaid, to load faster when the page does not contain mermaid</span><br>    <span class=\"hljs-attr\">specific:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># See: http://mermaid-js.github.io/mermaid/</span><br>    <span class=\"hljs-attr\">options:</span> &#123; <span class=\"hljs-attr\">theme:</span> <span class=\"hljs-string\">&#x27;default&#x27;</span> &#125;<br><br>  <span class=\"hljs-comment\"># 评论插件</span><br>  <span class=\"hljs-comment\"># Comment plugin</span><br>  <span class=\"hljs-attr\">comments:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-comment\"># 指定的插件，需要同时设置对应插件的必要参数</span><br>    <span class=\"hljs-comment\"># The specified plugin needs to set the necessary parameters at the same time</span><br>    <span class=\"hljs-comment\"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>    <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">disqus</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 评论插件</span><br><span class=\"hljs-comment\"># Comment plugins</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># 开启评论需要先设置上方 `post: comments: enable: true`，然后根据 `type` 设置下方对应的评论插件参数</span><br><span class=\"hljs-comment\"># Enable comments need to be set `post: comments: enable: true`, then set the corresponding comment plugin parameters below according to `type`</span><br><span class=\"hljs-comment\">#---------------------------</span><br><br><span class=\"hljs-comment\"># Utterances</span><br><span class=\"hljs-comment\"># 基于 GitHub Issues</span><br><span class=\"hljs-comment\"># Based on GitHub Issues</span><br><span class=\"hljs-comment\"># See: https://utteranc.es</span><br><span class=\"hljs-attr\">utterances:</span><br>  <span class=\"hljs-attr\">repo:</span><br>  <span class=\"hljs-attr\">issue_term:</span> <span class=\"hljs-string\">pathname</span><br>  <span class=\"hljs-attr\">label:</span> <span class=\"hljs-string\">utterances</span><br>  <span class=\"hljs-attr\">theme:</span> <span class=\"hljs-string\">github-light</span><br>  <span class=\"hljs-attr\">theme_dark:</span> <span class=\"hljs-string\">github-dark</span><br><br><span class=\"hljs-comment\"># Disqus</span><br><span class=\"hljs-comment\"># 基于第三方的服务，国内用户直接使用容易被墙，建议配合 Disqusjs</span><br><span class=\"hljs-comment\"># Based on third-party service</span><br><span class=\"hljs-comment\"># See: https://disqus.com</span><br><span class=\"hljs-attr\">disqus:</span><br>  <span class=\"hljs-attr\">shortname:</span><br>  <span class=\"hljs-comment\"># 以下为 Disqusjs 支持, 国内用户如果想使用 Disqus 建议配合使用</span><br>  <span class=\"hljs-comment\"># The following are Disqusjs configurations, please ignore if DisqusJS is not required</span><br>  <span class=\"hljs-comment\"># See: https://github.com/SukkaW/DisqusJS</span><br>  <span class=\"hljs-attr\">disqusjs:</span> <span class=\"hljs-literal\">false</span><br>  <span class=\"hljs-attr\">apikey:</span><br><br><span class=\"hljs-comment\"># Gitalk</span><br><span class=\"hljs-comment\"># 基于 GitHub Issues</span><br><span class=\"hljs-comment\"># Based on GitHub Issues</span><br><span class=\"hljs-comment\"># See: https://github.com/gitalk/gitalk#options</span><br><span class=\"hljs-attr\">gitalk:</span><br>  <span class=\"hljs-attr\">clientID:</span><br>  <span class=\"hljs-attr\">clientSecret:</span><br>  <span class=\"hljs-attr\">repo:</span><br>  <span class=\"hljs-attr\">owner:</span><br>  <span class=\"hljs-attr\">admin:</span> [<span class=\"hljs-string\">&#x27;name&#x27;</span>]<br>  <span class=\"hljs-attr\">language:</span> <span class=\"hljs-string\">zh-CN</span><br>  <span class=\"hljs-attr\">labels:</span> [<span class=\"hljs-string\">&#x27;Gitalk&#x27;</span>]<br>  <span class=\"hljs-attr\">perPage:</span> <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-attr\">pagerDirection:</span> <span class=\"hljs-string\">last</span><br>  <span class=\"hljs-attr\">distractionFreeMode:</span> <span class=\"hljs-literal\">false</span><br>  <span class=\"hljs-attr\">createIssueManually:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-comment\"># 默认 proxy 可能会失效，解决方法请见下方链接</span><br>  <span class=\"hljs-comment\"># The default proxy may be invalid, refer to the links for solutions</span><br>  <span class=\"hljs-comment\"># https://github.com/gitalk/gitalk/issues/429</span><br>  <span class=\"hljs-comment\"># https://github.com/Zibri/cloudflare-cors-anywhere</span><br>  <span class=\"hljs-attr\">proxy:</span> <span class=\"hljs-string\">https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</span><br><br><span class=\"hljs-comment\"># Valine</span><br><span class=\"hljs-comment\"># 基于 LeanCloud</span><br><span class=\"hljs-comment\"># Based on LeanCloud</span><br><span class=\"hljs-comment\"># See: https://valine.js.org/</span><br><span class=\"hljs-attr\">valine:</span><br>  <span class=\"hljs-attr\">appId:</span><br>  <span class=\"hljs-attr\">appKey:</span><br>  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">window.location.pathname</span><br>  <span class=\"hljs-attr\">placeholder:</span><br>  <span class=\"hljs-attr\">avatar:</span> <span class=\"hljs-string\">&#x27;retro&#x27;</span><br>  <span class=\"hljs-attr\">meta:</span> [<span class=\"hljs-string\">&#x27;nick&#x27;</span>, <span class=\"hljs-string\">&#x27;mail&#x27;</span>, <span class=\"hljs-string\">&#x27;link&#x27;</span>]<br>  <span class=\"hljs-attr\">requiredFields:</span> []<br>  <span class=\"hljs-attr\">pageSize:</span> <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-attr\">lang:</span> <span class=\"hljs-string\">&#x27;zh-CN&#x27;</span><br>  <span class=\"hljs-attr\">highlight:</span> <span class=\"hljs-literal\">false</span><br>  <span class=\"hljs-attr\">recordIP:</span> <span class=\"hljs-literal\">false</span><br>  <span class=\"hljs-attr\">serverURLs:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br>  <span class=\"hljs-attr\">emojiCDN:</span><br>  <span class=\"hljs-attr\">emojiMaps:</span><br>  <span class=\"hljs-attr\">enableQQ:</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-comment\"># Waline</span><br><span class=\"hljs-comment\"># 从 Valine 衍生而来，额外增加了服务端和多种功能</span><br><span class=\"hljs-comment\"># Derived from Valine, with self-hosted service and new features</span><br><span class=\"hljs-comment\"># See: https://waline.js.org/</span><br><span class=\"hljs-attr\">waline:</span><br>  <span class=\"hljs-attr\">serverURL:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br>  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">window.location.pathname</span><br>  <span class=\"hljs-attr\">meta:</span> [<span class=\"hljs-string\">&#x27;nick&#x27;</span>, <span class=\"hljs-string\">&#x27;mail&#x27;</span>, <span class=\"hljs-string\">&#x27;link&#x27;</span>]<br>  <span class=\"hljs-attr\">requiredMeta:</span> [<span class=\"hljs-string\">&#x27;nick&#x27;</span>]<br>  <span class=\"hljs-attr\">lang:</span> <span class=\"hljs-string\">&#x27;zh-CN&#x27;</span><br>  <span class=\"hljs-attr\">emoji:</span> [<span class=\"hljs-string\">&#x27;https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo&#x27;</span>]<br>  <span class=\"hljs-attr\">dark:</span> <span class=\"hljs-string\">&#x27;html[data-user-color-scheme=&quot;dark&quot;]&#x27;</span><br>  <span class=\"hljs-attr\">wordLimit:</span> <span class=\"hljs-number\">0</span><br>  <span class=\"hljs-attr\">pageSize:</span> <span class=\"hljs-number\">10</span><br><br><span class=\"hljs-comment\"># 畅言 Changyan</span><br><span class=\"hljs-comment\"># 基于第三方的服务</span><br><span class=\"hljs-comment\"># Based on third-party service, insufficient support for regions outside China</span><br><span class=\"hljs-comment\"># http://changyan.kuaizhan.com</span><br><span class=\"hljs-attr\">changyan:</span><br>  <span class=\"hljs-attr\">appid:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br>  <span class=\"hljs-attr\">appkey:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><br><span class=\"hljs-comment\"># 来必力 Livere</span><br><span class=\"hljs-comment\"># 基于第三方的服务</span><br><span class=\"hljs-comment\"># Based on third-party service</span><br><span class=\"hljs-comment\"># See: https://www.livere.com</span><br><span class=\"hljs-attr\">livere:</span><br>  <span class=\"hljs-attr\">uid:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><br><span class=\"hljs-comment\"># Remark42</span><br><span class=\"hljs-comment\"># 需要自托管服务端</span><br><span class=\"hljs-comment\"># Based on self-hosted service</span><br><span class=\"hljs-comment\"># See: https://remark42.com</span><br><span class=\"hljs-attr\">remark42:</span><br>  <span class=\"hljs-attr\">host:</span><br>  <span class=\"hljs-attr\">site_id:</span><br>  <span class=\"hljs-attr\">max_shown_comments:</span> <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-attr\">locale:</span> <span class=\"hljs-string\">zh</span><br>  <span class=\"hljs-attr\">components:</span> [<span class=\"hljs-string\">&#x27;embed&#x27;</span>]<br><br><span class=\"hljs-comment\"># Twikoo</span><br><span class=\"hljs-comment\"># 支持腾讯云、Vercel、Railway 等多种平台部署</span><br><span class=\"hljs-comment\"># Based on Tencent CloudBase</span><br><span class=\"hljs-comment\"># See: https://twikoo.js.org</span><br><span class=\"hljs-attr\">twikoo:</span><br>  <span class=\"hljs-attr\">envId:</span><br>  <span class=\"hljs-attr\">region:</span> <span class=\"hljs-string\">ap-shanghai</span><br>  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">window.location.pathname</span><br><br><span class=\"hljs-comment\"># Cusdis</span><br><span class=\"hljs-comment\"># 基于第三方服务或自托管服务</span><br><span class=\"hljs-comment\"># Based on third-party or self-hosted service</span><br><span class=\"hljs-comment\"># See https://cusdis.com</span><br><span class=\"hljs-attr\">cusdis:</span><br>  <span class=\"hljs-attr\">host:</span><br>  <span class=\"hljs-attr\">app_id:</span><br>  <span class=\"hljs-attr\">lang:</span> <span class=\"hljs-string\">zh-cn</span><br><br><span class=\"hljs-comment\"># Giscus</span><br><span class=\"hljs-comment\"># 基于 GitHub Discussions，类似于 Utterances</span><br><span class=\"hljs-comment\"># Based on GitHub Discussions, similar to Utterances</span><br><span class=\"hljs-comment\"># See: https://giscus.app/</span><br><span class=\"hljs-attr\">giscus:</span><br>  <span class=\"hljs-attr\">repo:</span><br>  <span class=\"hljs-attr\">repo-id:</span><br>  <span class=\"hljs-attr\">category:</span><br>  <span class=\"hljs-attr\">category-id:</span><br>  <span class=\"hljs-attr\">theme-light:</span> <span class=\"hljs-string\">light</span><br>  <span class=\"hljs-attr\">theme-dark:</span> <span class=\"hljs-string\">dark</span><br>  <span class=\"hljs-attr\">mapping:</span> <span class=\"hljs-string\">pathname</span><br>  <span class=\"hljs-attr\">reactions-enabled:</span> <span class=\"hljs-number\">1</span><br>  <span class=\"hljs-attr\">emit-metadata:</span> <span class=\"hljs-number\">0</span><br>  <span class=\"hljs-attr\">input-position:</span> <span class=\"hljs-string\">top</span><br>  <span class=\"hljs-attr\">lang:</span> <span class=\"hljs-string\">zh-CN</span><br><br><span class=\"hljs-comment\"># Discuss</span><br><span class=\"hljs-comment\"># 多平台、多数据库、自托管、免费开源评论系统</span><br><span class=\"hljs-comment\"># Self-hosted, small size, multi-platform, multi-database, free and open source commenting system</span><br><span class=\"hljs-comment\"># See: https://discuss.js.org</span><br><span class=\"hljs-attr\">discuss:</span><br>  <span class=\"hljs-attr\">serverURLs:</span><br>  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">window.location.pathname</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 归档页</span><br><span class=\"hljs-comment\"># Archive Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">archive:</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">60</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 分类页</span><br><span class=\"hljs-comment\"># Category Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">category:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">60</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br><br>  <span class=\"hljs-comment\"># 分类的排序字段，前面带减号是倒序，不带减号是正序</span><br>  <span class=\"hljs-comment\"># Sort field for categories, with a minus sign is reverse order</span><br>  <span class=\"hljs-comment\"># Options: length | name</span><br>  <span class=\"hljs-attr\">order_by:</span> <span class=\"hljs-string\">&quot;-length&quot;</span><br><br>  <span class=\"hljs-comment\"># 层级的折叠深度，0 是全部折叠，大于 0 后如果存在子分类则默认展开</span><br>  <span class=\"hljs-comment\"># Collapse depth. If 0, all posts collapsed. If greater than 0, it will be expanded by default if there are subcategories</span><br>  <span class=\"hljs-attr\">collapse_depth:</span> <span class=\"hljs-number\">0</span><br><br>  <span class=\"hljs-comment\"># 文章的排序字段，前面带减号是倒序，不带减号是正序</span><br>  <span class=\"hljs-comment\"># Sort field for posts, with a minus sign is reverse order</span><br>  <span class=\"hljs-comment\"># Options: date | title | or other field of front-matter</span><br>  <span class=\"hljs-attr\">post_order_by:</span> <span class=\"hljs-string\">&quot;-date&quot;</span><br><br>  <span class=\"hljs-comment\"># 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制</span><br>  <span class=\"hljs-comment\"># The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit</span><br>  <span class=\"hljs-attr\">post_limit:</span> <span class=\"hljs-number\">10</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 标签页</span><br><span class=\"hljs-comment\"># Tag Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">tag:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">80</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br>  <span class=\"hljs-attr\">tagcloud:</span><br>    <span class=\"hljs-attr\">min_font:</span> <span class=\"hljs-number\">15</span><br>    <span class=\"hljs-attr\">max_font:</span> <span class=\"hljs-number\">30</span><br>    <span class=\"hljs-attr\">unit:</span> <span class=\"hljs-string\">px</span><br>    <span class=\"hljs-attr\">start_color:</span> <span class=\"hljs-string\">&quot;#BBBBEE&quot;</span><br>    <span class=\"hljs-attr\">end_color:</span> <span class=\"hljs-string\">&quot;#337ab7&quot;</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 关于页</span><br><span class=\"hljs-comment\"># About Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">about:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">60</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br>  <span class=\"hljs-attr\">avatar:</span> <span class=\"hljs-string\">/img/avatar.png</span><br>  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">&quot;Fluid&quot;</span><br>  <span class=\"hljs-attr\">intro:</span> <span class=\"hljs-string\">&quot;An elegant theme for Hexo&quot;</span><br>  <span class=\"hljs-comment\"># 更多图标可从 https://hexo.fluid-dev.com/docs/icon/ 查找，`class` 代表图标的 css class，添加 `qrcode` 后，图标不再是链接而是悬浮二维码</span><br>  <span class=\"hljs-comment\"># More icons can be found from https://hexo.fluid-dev.com/docs/en/icon/  `class` is the css class of the icon. If adding `qrcode`, The icon is no longer a link, but a hovering QR code</span><br>  <span class=\"hljs-attr\">icons:</span><br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">class:</span> <span class=\"hljs-string\">&quot;iconfont icon-github-fill&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;https://github.com&quot;</span>, <span class=\"hljs-attr\">tip:</span> <span class=\"hljs-string\">&quot;GitHub&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">class:</span> <span class=\"hljs-string\">&quot;iconfont icon-douban-fill&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;https://douban.com&quot;</span>, <span class=\"hljs-attr\">tip:</span> <span class=\"hljs-string\">&quot;豆瓣&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">class:</span> <span class=\"hljs-string\">&quot;iconfont icon-wechat-fill&quot;</span>, <span class=\"hljs-attr\">qrcode:</span> <span class=\"hljs-string\">&quot;/img/favicon.png&quot;</span> &#125;<br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 自定义页</span><br><span class=\"hljs-comment\"># Custom Page</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># 通过 hexo new page 命令创建的页面</span><br><span class=\"hljs-comment\"># Custom Page through `hexo new page`</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">page:</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">60</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 404页</span><br><span class=\"hljs-comment\"># 404 Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">page404:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">85</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br>  <span class=\"hljs-comment\"># 重定向到首页的延迟(毫秒)</span><br>  <span class=\"hljs-comment\"># Delay in redirecting to home page (milliseconds)</span><br>  <span class=\"hljs-attr\">redirect_delay:</span> <span class=\"hljs-number\">5000</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 友链页</span><br><span class=\"hljs-comment\"># Links Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">links:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">60</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br>  <span class=\"hljs-comment\"># 友链的成员项</span><br>  <span class=\"hljs-comment\"># Member item of page</span><br>  <span class=\"hljs-attr\">items:</span><br>    <span class=\"hljs-bullet\">-</span> &#123;<br>      <span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">&quot;Fluid Blog&quot;</span>,<br>      <span class=\"hljs-attr\">intro:</span> <span class=\"hljs-string\">&quot;主题博客&quot;</span>,<br>      <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;https://hexo.fluid-dev.com/&quot;</span>,<br>      <span class=\"hljs-attr\">avatar:</span> <span class=\"hljs-string\">&quot;/img/favicon.png&quot;</span><br>    &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123;<br>      <span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">&quot;Fluid Docs&quot;</span>,<br>      <span class=\"hljs-attr\">intro:</span> <span class=\"hljs-string\">&quot;主题使用指南&quot;</span>,<br>      <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;https://hexo.fluid-dev.com/docs/&quot;</span>,<br>      <span class=\"hljs-attr\">avatar:</span> <span class=\"hljs-string\">&quot;/img/favicon.png&quot;</span><br>    &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123;<br>      <span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">&quot;Fluid Repo&quot;</span>,<br>      <span class=\"hljs-attr\">intro:</span> <span class=\"hljs-string\">&quot;主题 GitHub 仓库&quot;</span>,<br>      <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;https://github.com/fluid-dev/hexo-theme-fluid&quot;</span>,<br>      <span class=\"hljs-attr\">avatar:</span> <span class=\"hljs-string\">&quot;/img/favicon.png&quot;</span><br>    &#125;<br><br>  <span class=\"hljs-comment\"># 当成员头像加载失败时，替换为指定图片</span><br>  <span class=\"hljs-comment\"># When the member avatar fails to load, replace the specified image</span><br>  <span class=\"hljs-attr\">onerror_avatar:</span> <span class=\"hljs-string\">/img/avatar.png</span><br><br>  <span class=\"hljs-comment\"># 友链下方自定义区域，支持 HTML，可插入例如申请友链的文字</span><br>  <span class=\"hljs-comment\"># Custom content at the bottom of the links</span><br>  <span class=\"hljs-attr\">custom:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-attr\">content:</span> <span class=\"hljs-string\">&#x27;&lt;hr&gt;&lt;p&gt;在下方留言申请加入我的友链，按如下格式提供信息：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;博客名：Fluid&lt;/li&gt;&lt;li&gt;简介：Fluid 主题官方博客&lt;/li&gt;&lt;li&gt;链接：https://hexo.fluid-dev.com&lt;/li&gt;&lt;li&gt;图片：https://hexo.fluid-dev.com/img/favicon.png&lt;/li&gt;&lt;/ul&gt;&#x27;</span><br><br>  <span class=\"hljs-comment\"># 评论插件</span><br>  <span class=\"hljs-comment\"># Comment plugin</span><br>  <span class=\"hljs-attr\">comments:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-comment\"># 指定的插件，需要同时设置对应插件的必要参数</span><br>    <span class=\"hljs-comment\"># The specified plugin needs to set the necessary parameters at the same time</span><br>    <span class=\"hljs-comment\"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>    <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">disqus</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 以下是配置 JS CSS 等静态资源的 URL 前缀，可以自定义成 CDN 地址，</span><br><span class=\"hljs-comment\"># 如果需要修改，最好使用与默认配置相同的版本，以避免潜在的问题，</span><br><span class=\"hljs-comment\"># ** 如果你不知道如何设置，请不要做任何改动 **</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># Here is the url prefix to configure the static assets. Set CDN addresses you want to customize.</span><br><span class=\"hljs-comment\"># Be aware that you would better use the same version as default ones to avoid potential problems.</span><br><span class=\"hljs-comment\"># DO NOT EDIT THE FOLLOWING SETTINGS UNLESS YOU KNOW WHAT YOU ARE DOING</span><br><span class=\"hljs-comment\">#---------------------------</span><br><br><span class=\"hljs-attr\">static_prefix:</span><br>  <span class=\"hljs-comment\"># 内部静态</span><br>  <span class=\"hljs-comment\"># Internal static</span><br>  <span class=\"hljs-attr\">internal_js:</span> <span class=\"hljs-string\">/js</span><br>  <span class=\"hljs-attr\">internal_css:</span> <span class=\"hljs-string\">/css</span><br>  <span class=\"hljs-attr\">internal_img:</span> <span class=\"hljs-string\">/img</span><br><br>  <span class=\"hljs-attr\">anchor:</span> <span class=\"hljs-string\">https://lib.baomitu.com/anchor-js/4.3.1/</span><br><br>  <span class=\"hljs-attr\">github_markdown:</span> <span class=\"hljs-string\">https://lib.baomitu.com/github-markdown-css/4.0.0/</span><br><br>  <span class=\"hljs-attr\">jquery:</span> <span class=\"hljs-string\">https://lib.baomitu.com/jquery/3.6.4/</span><br><br>  <span class=\"hljs-attr\">bootstrap:</span> <span class=\"hljs-string\">https://lib.baomitu.com/twitter-bootstrap/4.6.1/</span><br><br>  <span class=\"hljs-attr\">prismjs:</span> <span class=\"hljs-string\">https://lib.baomitu.com/prism/1.29.0/</span><br><br>  <span class=\"hljs-attr\">tocbot:</span> <span class=\"hljs-string\">https://lib.baomitu.com/tocbot/4.20.1/</span><br><br>  <span class=\"hljs-attr\">typed:</span> <span class=\"hljs-string\">https://lib.baomitu.com/typed.js/2.0.12/</span><br><br>  <span class=\"hljs-attr\">fancybox:</span> <span class=\"hljs-string\">https://lib.baomitu.com/fancybox/3.5.7/</span><br><br>  <span class=\"hljs-attr\">nprogress:</span> <span class=\"hljs-string\">https://lib.baomitu.com/nprogress/0.2.0/</span><br><br>  <span class=\"hljs-attr\">mathjax:</span> <span class=\"hljs-string\">https://lib.baomitu.com/mathjax/3.2.2/</span><br><br>  <span class=\"hljs-attr\">katex:</span> <span class=\"hljs-string\">https://lib.baomitu.com/KaTeX/0.16.2/</span><br><br>  <span class=\"hljs-attr\">busuanzi:</span> <span class=\"hljs-string\">https://busuanzi.ibruce.info/busuanzi/2.3/</span><br><br>  <span class=\"hljs-attr\">clipboard:</span> <span class=\"hljs-string\">https://lib.baomitu.com/clipboard.js/2.0.11/</span><br><br>  <span class=\"hljs-attr\">mermaid:</span> <span class=\"hljs-string\">https://lib.baomitu.com/mermaid/8.14.0/</span><br><br>  <span class=\"hljs-attr\">valine:</span> <span class=\"hljs-string\">https://lib.baomitu.com/valine/1.5.1/</span><br><br>  <span class=\"hljs-attr\">waline:</span> <span class=\"hljs-string\">https://cdn.staticfile.org/waline/2.15.5/</span><br><br>  <span class=\"hljs-attr\">gitalk:</span> <span class=\"hljs-string\">https://lib.baomitu.com/gitalk/1.8.0/</span><br><br>  <span class=\"hljs-attr\">disqusjs:</span> <span class=\"hljs-string\">https://lib.baomitu.com/disqusjs/1.3.0/</span><br><br>  <span class=\"hljs-attr\">twikoo:</span> <span class=\"hljs-string\">https://lib.baomitu.com/twikoo/1.6.8/</span><br><br>  <span class=\"hljs-attr\">discuss:</span> <span class=\"hljs-string\">https://lib.baomitu.com/discuss/1.2.1/</span><br><br>  <span class=\"hljs-attr\">hint:</span> <span class=\"hljs-string\">https://lib.baomitu.com/hint.css/2.7.0/</span><br><br>  <span class=\"hljs-attr\">moment:</span> <span class=\"hljs-string\">https://lib.baomitu.com/moment.js/2.29.4/</span><br></code></pre></td></tr></table></figure>\r\n<h3 id=\"站点配置\">站点配置</h3>\r\n<p>现在对我而言还有两个问题，我换到 Fluid 就是为了 Latex<br />\r\n所以……<br />\r\n这里还是按官方来，<sup id=\"fnref:4\" class=\"footnote-ref\"><a href=\"#fn:4\" rel=\"footnote\"><span\r\nclass=\"hint--top hint--rounded\"\r\naria-label=\"[配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/guide/#latex-数学公式)\">[4]</span></a></sup></p>\r\n<ol type=\"1\">\r\n<li><p><strong>设置主题配置</strong><br />\r\n<span\r\nclass=\"math inline\">\\(我这里使用的是\\;mathjax+pandoc,\\;\\)</span><br />\r\n<span\r\nclass=\"math inline\">\\(好处是别人可以复制你写的\\;Latex\\)</span><br />\r\n<span class=\"math inline\">\\(\\begin{aligned}坏处是\\hspace{340px}\\\\\r\n他的换行不能像\r\ntypora的&#39;\\backslash\\backslash&#39;直接换行,\\hspace{115px}\\\\\r\n要使用\\backslash begin\\{aligned\\}\\backslash\r\nend\\{aligned\\}\\hspace{100px}\\\\\r\n才能&#39;\\backslash\\backslash&#39;换行\\hspace{300px}\\\\\r\n而且不能使用\\backslash hfill只能使用\\backslash hspace\\{num\\;\r\ncm/px\\}\\hspace{10px}\r\n\\end{aligned}\\)</span><br />\r\n而且换行前必须打两个空格</p>\r\n<p><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">post:</span>  <br>  <span class=\"hljs-attr\">math:</span>  <br>   <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span>  <br>   <span class=\"hljs-attr\">specific:</span> <span class=\"hljs-literal\">false</span>  <br>\t  <span class=\"hljs-attr\">engine:</span> <span class=\"hljs-string\">mathjax</span>  <br></code></pre></td></tr></table></figure></p>\r\n<p><code>specific</code>: 建议开启。当为 true 时，只有在文章 <a\r\nhref=\"https://hexo.io/zh-cn/docs/front-matter\">front-matter (opens new\r\nwindow)</a>里指定 <code>math: true</code>\r\n才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p>\r\n<p><code>engine</code>: 公式引擎，目前支持 <code>mathjax</code> 或\r\n<code>katex</code>。</p></li>\r\n<li><p><strong>更换 Markdown 渲染器</strong><br />\r\n由于 Hexo 默认的 Markdown\r\n渲染器不支持复杂公式，所以需要更换渲染器（mathjax 可选择性更换）。\r\n然后根据上方配置不同的 <code>engine</code>，推荐更换如下渲染器：</p>\r\n<ul>\r\n<li><p>mathjax <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-pandoc --save<br></code></pre></td></tr></table></figure></p>\r\n<p><strong>并且还需<a\r\nhref=\"https://github.com/jgm/pandoc/blob/master/INSTALL.md\">安装\r\nPandoc</a></strong></p></li>\r\n<li><p>katex <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-markdown-it --save<br>npm install @traptitech/markdown-it-katex --save<br></code></pre></td></tr></table></figure></p>\r\n<p>然后在站点配置中添加： <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">markdown:</span><br>  <span class=\"hljs-attr\">plugins:</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;@traptitech/markdown-it-katex&quot;</span><br></code></pre></td></tr></table></figure> ### 我安装Pandoc过程</p></li>\r\n</ul></li>\r\n</ol>\r\n<p>环境说明：Windows11</p>\r\n<ol type=\"1\">\r\n<li><a href=\"https://github.com/jgm/pandoc/blob/master/INSTALL.md\">下载\r\nPandoc</a><br />\r\n下载链接<a href=\"https://github.com/jgm/pandoc/releases/latest\">download\r\npage</a><br />\r\n<img src=\"/imgs/Hexo主题变更/pandoc1.png\" />找到 window，我使用的是\r\nmsi：<br />\r\n<img src=\"/imgs/Hexo主题变更/pandoc1-1.png\" /><br />\r\n</li>\r\n<li>按照提示安装就可以，这里可以自选目录<br />\r\npandoc 和\r\nhexo-renderer-pandoc不一样，一个是程序，一个是hexo的渲染插件</li>\r\n</ol>\r\n<h3 id=\"插入图片\">插入图片</h3>\r\n<p>我还是用的老办法，<code>![](/imgs/xxxx)</code>，<br />\r\n想要在 typora\r\n也显示，那就把文档的图片放到一个文件夹<code>/imgs/</code>内<br />\r\nFluid\r\n会在<code>..\\Blog\\source</code>目录下寻找图片资源文件，其他类型应该也是一样。</p>\r\n<h2 id=\"待解决问题\">待解决问题</h2>\r\n<ul>\r\n<li>换行异常：<br />\r\ntypora 可以换行，但是 web blog 不能换行只能换段<br />\r\nlatex 公式不能换行\r\n<ul>\r\n<li><p>因为pandoc和typora语法不一样</p></li>\r\n<li><p>这里给出修改代码<br />\r\n这里的代码有问题哦，但是我不改了……也都有注释，如果你需要可以自行修改<br />\r\n编译原理的自动机学过伐，一样的</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br><br><span class=\"hljs-comment\"># 指定需要修改的 Markdown 文件夹路径  </span><br>folder_path = <span class=\"hljs-string\">&#x27;/path/to/markdown_folder/&#x27;</span><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">process_md_file</span>(<span class=\"hljs-params\">file_path</span>):  <br>    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(file_path, <span class=\"hljs-string\">&#x27;r&#x27;</span>, encoding=<span class=\"hljs-string\">&#x27;utf-8&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:  <br>        content = f.readlines()<br><br>    modified_content = []  <br>    code_block = <span class=\"hljs-literal\">False</span>  <br>    latex_block = <span class=\"hljs-literal\">False</span>  <br>    setting_block = <span class=\"hljs-literal\">False</span>  <br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(content)):  <br>        line = content[i].rstrip(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>)<br><br>        <span class=\"hljs-comment\"># 判断是否进入或退出代码块  </span><br>        <span class=\"hljs-keyword\">if</span> line.startswith(<span class=\"hljs-string\">&#x27;~~~&#x27;</span>):  <br>            code_block = <span class=\"hljs-keyword\">not</span> code_block<br><br>        <span class=\"hljs-comment\"># 判断是否进入或退出 LaTeX 段落  </span><br>        <span class=\"hljs-keyword\">if</span> line.startswith(<span class=\"hljs-string\">&#x27;$$&#x27;</span>):  <br>            latex_block = <span class=\"hljs-keyword\">not</span> latex_block<br><br>        <span class=\"hljs-comment\"># 判断是否进入或退出设置段  </span><br>        <span class=\"hljs-keyword\">if</span> line.startswith(<span class=\"hljs-string\">&#x27;---&#x27;</span>):  <br>            setting_block = <span class=\"hljs-keyword\">not</span> setting_block<br><br>        <span class=\"hljs-comment\"># 如果在代码块内、LaTeX 段落内或设置段内，则不做修改  </span><br>        <span class=\"hljs-keyword\">if</span> code_block <span class=\"hljs-keyword\">or</span> latex_block <span class=\"hljs-keyword\">or</span> setting_block:  <br>            modified_content.append(line)  <br>        <span class=\"hljs-keyword\">else</span>:  <br>            <span class=\"hljs-comment\"># 如果行首是标题，则不加空格  </span><br>            <span class=\"hljs-keyword\">if</span> line.startswith(<span class=\"hljs-string\">&#x27;#&#x27;</span>):  <br>                modified_content.append(line)  <br>            <span class=\"hljs-comment\"># 如果行首以 &lt;img 开头，则不做修改  </span><br>            <span class=\"hljs-keyword\">elif</span> line.lstrip().startswith(<span class=\"hljs-string\">&#x27;&lt;img&#x27;</span>):  <br>                modified_content.append(line)  <br>            <span class=\"hljs-comment\"># 如果行首以 &lt; 开头，则不加空格（除了 &lt;img 外）  </span><br>            <span class=\"hljs-keyword\">elif</span> line.startswith(<span class=\"hljs-string\">&#x27;&lt;&#x27;</span>):  <br>                modified_content.append(line)  <br>            <span class=\"hljs-keyword\">else</span>:  <br>                <span class=\"hljs-comment\"># 如果行尾已经有两个空格，则不做修改  </span><br>                <span class=\"hljs-keyword\">if</span> line.endswith(<span class=\"hljs-string\">&#x27;  &#x27;</span>):  <br>                    modified_content.append(line)  <br>                <span class=\"hljs-keyword\">else</span>:  <br>                    <span class=\"hljs-comment\"># 判断下一行是否为空行  </span><br>                    <span class=\"hljs-keyword\">if</span> i &lt; <span class=\"hljs-built_in\">len</span>(content) - <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">and</span> content[i+<span class=\"hljs-number\">1</span>].strip() == <span class=\"hljs-string\">&#x27;&#x27;</span>:  <br>                        modified_content.append(line)  <br>                    <span class=\"hljs-keyword\">else</span>:  <br>                        modified_content.append(line + <span class=\"hljs-string\">&#x27;  &#x27;</span>)<br><br>    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(file_path, <span class=\"hljs-string\">&#x27;w&#x27;</span>, encoding=<span class=\"hljs-string\">&#x27;utf-8&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:  <br>        f.write(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>.join(modified_content))<br><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&#x27;已修改文件: <span class=\"hljs-subst\">&#123;file_path&#125;</span>&#x27;</span>)<br><br><span class=\"hljs-comment\"># 遍历 Markdown 文件夹下的所有文件  </span><br><span class=\"hljs-keyword\">for</span> root, dirs, files <span class=\"hljs-keyword\">in</span> os.walk(folder_path):  <br>    <span class=\"hljs-keyword\">for</span> file <span class=\"hljs-keyword\">in</span> files:  <br>        <span class=\"hljs-keyword\">if</span> file.endswith(<span class=\"hljs-string\">&#x27;.md&#x27;</span>):  <br>            file_path = os.path.join(root, file)  <br>            process_md_file(file_path)<br><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;所有文件修改完成&#x27;</span>)  <br></code></pre></td></tr></table></figure></li>\r\n</ul></li>\r\n</ul>\r\n<p>标题段落间隔大 : 主题问题</p>\r\n<h2 id=\"参考\">参考</h2>\r\n<p><a href=\"https://docs.mathjax.org/en/latest/index.html\">MathJax 文档\r\n— MathJax 3.2 文档</a></p>\r\n<p><a href=\"https://hexo.io/zh-cn/docs/front-matter\">Front-matter |\r\nHexo</a></p>\r\n<p><a href=\"https://github.com/hexojs/hexo-math\">hexojs/hexo-math: A\r\nhexo plugin that uses MathJax to render math equations.\r\n(github.com)</a></p>\r\n<a\r\nhref=\"https://github.com/jgm/pandoc/blob/main/INSTALL.md\">pandoc/INSTALL.md\r\n在主 ·JGM/PANDOC的 (github.com)</a>\r\n<section class=\"footnotes\">\r\n<div class=\"footnote-list\">\r\n<ol>\r\n<li>\r\n<span id=\"fn:0\"\r\nclass=\"footnote-text\"><span><a href=\"https://saucenao.com/\">图片搜索:saucenao</a>\r\n<a href=\"#fnref:0\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n<li>\r\n<span id=\"fn:1\"\r\nclass=\"footnote-text\"><span><a href=\"https://hexo.fluid-dev.com/docs\">Hexo\r\nFulid 官方Doc</a>\r\n<a href=\"#fnref:1\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n<li>\r\n<span id=\"fn:2\"\r\nclass=\"footnote-text\"><span><a href=\"https://hexo.fluid-dev.com/docs/guide/#覆盖配置\">配置指南\r\n| Hexo Fluid 用户手册 (fluid-dev.com)</a>\r\n<a href=\"#fnref:2\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n<li>\r\n<span id=\"fn:3\" class=\"footnote-text\"><span><a\r\nhref=\"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml\">主题配置</a>\r\n<a href=\"#fnref:3\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n<li>\r\n<span id=\"fn:4\" class=\"footnote-text\"><span><a\r\nhref=\"https://hexo.fluid-dev.com/docs/guide/#latex-数学公式\">配置指南 |\r\nHexo Fluid 用户手册 (fluid-dev.com)</a>\r\n<a href=\"#fnref:4\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n<li>\r\n<span id=\"fn:5\" class=\"footnote-text\"><span><a\r\nhref=\"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml\">hexo-theme-fluid/_config.yml\r\nat master · fluid-dev/hexo-theme-fluid (github.com)</a>\r\n<a href=\"#fnref:5\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n</ol>\r\n</div>\r\n</section>\r\n","site":{"data":{}},"excerpt":"<p>更换了Hexo 主题，之前 yilia\r\n主题作者是不是开摆了……我看很久没更新.<br />\r\nnalama！答案只有一个了，我将向你—— Fluid\r\n效忠！图源自Pix画师ID:67549695<br />","more":"</p>\r\n<h1 id=\"hexo-主题切换\">Hexo 主题切换</h1>\r\n<p>这里以 yilia 切换到 Fluid\r\n为例，我这里只是分享一下自己是怎么做的，遇到什么问题，<br />\r\n肯定有不对的地方，欢迎大家教我。</p>\r\n<h2 id=\"准备工作\">准备工作</h2>\r\n<p>鉴于前面我自己把 blog 干崩过，所有我强烈建议所有人都在 github\r\n存一个仓库备份本地的 Blog<br />\r\n因为 Hexo 这种静态blog\r\n<strong>本地磁盘的源文件</strong>和<strong>生成的网页</strong>，是两个部分。</p>\r\n<p>你能不能说人话什么本地，网页的！<br />\r\n好好好，你先别急，我知道你很急，但是你先别急。</p>\r\n<ul>\r\n<li>本地的源文件：<br />\r\n<img src=\"/imgs/Hexo主题变更/deskt.png\" /><br />\r\n</li>\r\n<li>生成的网页：<br />\r\n<img src=\"/imgs/Hexo主题变更/web.png\" /> 我们可以将本地文件存储到 github\r\n备份，也方便 fallback 和 迁移。</li>\r\n</ul>\r\n<h2 id=\"切换\">切换</h2>\r\n<p>将 Hexo 博客主题从 yilia 切换到 Fluid 的步骤如下：</p>\r\n<ol type=\"1\">\r\n<li><p>首先，您需要在本地安装 Fluid 主题。<br />\r\n可以使用以下命令从 GitHub 上下载 Fluid 主题并将其保存到您的 Hexo 博客的\r\nthemes 文件夹中：</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>下载完成后，进入 Hexo 博客的根目录，并打开 _config.yml\r\n文件。<br />\r\n将 theme 字段的值更改为 \"fluid\"，如下所示：</p>\r\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">theme:</span> fluid  <br></code></pre></td></tr></table></figure></li>\r\n</ol>\r\n<h3 id=\"修改主题配置\">修改主题配置</h3>\r\n<p>主题配置指的是 hexo 所采用的 theme 所用配置，而并非对 Hexo blog\r\n的配置</p>\r\n<blockquote>\r\n<p>TIP<sup id=\"fnref:1\" class=\"footnote-ref\"><a href=\"#fn:1\" rel=\"footnote\"><span\r\nclass=\"hint--top hint--rounded\"\r\naria-label=\"[Hexo Fulid 官方Doc](https://hexo.fluid-dev.com/docs)\">[1]</span></a></sup></p>\r\n<p>致主题的新用户：</p>\r\n<ul>\r\n<li>本指南经过数个版本打磨，<br />\r\n绝大部分的功能都有详细说明，请仔细阅读，节约自己和他人的时间；<br />\r\n</li>\r\n<li>本指南中提到的：\"<strong>站点配置</strong>\" 指的 Hexo 博客目录下的\r\n<code>_config.yml</code>，\"<strong>主题配置</strong>\" 指的是\r\n<code>theme/fluid/_config.yml</code> 或者 <code>_config.fluid.yml</code>\r\n，注意区分；<br />\r\n</li>\r\n<li>本指南中提到的 <code>source</code> 目录都指的是博客目录下的\r\n<code>source</code> 文件夹，不推荐修改主题内 <code>source</code>\r\n目录；<br />\r\n</li>\r\n<li>每次无论 <code>hexo g</code> 或 <code>hexo s</code>，都最好先使用\r\n<code>hexo clean</code> 清除本地缓存；<br />\r\n</li>\r\n<li>页面结果以本地 <code>hexo s</code>\r\n为准，部署后的异常大部分是线上缓存原因，在确认没有报错的情况下，等待若干时间后即可正常；<br />\r\n</li>\r\n<li>由于主题的不同版本会存在配置差异，本指南以最新版本为准。</li>\r\n</ul>\r\n</blockquote>\r\n<p>这里按照官方文档所说去做就行，为什么这么配文档也有说，我这里是 Hexo\r\n6.1.0。<sup id=\"fnref:2\" class=\"footnote-ref\"><a href=\"#fn:2\" rel=\"footnote\"><span\r\nclass=\"hint--top hint--rounded\"\r\naria-label=\"[配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/guide/#覆盖配置)\">[2]</span></a></sup><br />\r\n所以在Blog 根目录创建 <code>_config.fluid.yml</code><br />\r\n<img src=\"/imgs/Hexo主题变更/Fluid_Config.png\" /><br />\r\n然后在该文件内，粘贴 Fluid\r\n官方给定的配置<sup id=\"fnref:3\" class=\"footnote-ref\"><a href=\"#fn:3\" rel=\"footnote\"><span\r\nclass=\"hint--top hint--rounded\"\r\naria-label=\"[主题配置](https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml)\">[3]</span></a></sup>就行，当然你可以根据他的自定义，<br />\r\n但是我不会，因为我不会……</p>\r\n<h4\r\nid=\"code建议别从我这里复制这个blog会崩溃去官网吧5\">code，建议别从我这里复制，这个blog会崩溃，去官网吧<sup id=\"fnref:5\" class=\"footnote-ref\"><a href=\"#fn:5\" rel=\"footnote\"><span\r\nclass=\"hint--top hint--rounded\"\r\naria-label=\"[hexo-theme-fluid/_config.yml at master · fluid-dev/hexo-theme-fluid (github.com)](https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml)\">[5]</span></a></sup></h4>\r\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br><span class=\"line\">558</span><br><span class=\"line\">559</span><br><span class=\"line\">560</span><br><span class=\"line\">561</span><br><span class=\"line\">562</span><br><span class=\"line\">563</span><br><span class=\"line\">564</span><br><span class=\"line\">565</span><br><span class=\"line\">566</span><br><span class=\"line\">567</span><br><span class=\"line\">568</span><br><span class=\"line\">569</span><br><span class=\"line\">570</span><br><span class=\"line\">571</span><br><span class=\"line\">572</span><br><span class=\"line\">573</span><br><span class=\"line\">574</span><br><span class=\"line\">575</span><br><span class=\"line\">576</span><br><span class=\"line\">577</span><br><span class=\"line\">578</span><br><span class=\"line\">579</span><br><span class=\"line\">580</span><br><span class=\"line\">581</span><br><span class=\"line\">582</span><br><span class=\"line\">583</span><br><span class=\"line\">584</span><br><span class=\"line\">585</span><br><span class=\"line\">586</span><br><span class=\"line\">587</span><br><span class=\"line\">588</span><br><span class=\"line\">589</span><br><span class=\"line\">590</span><br><span class=\"line\">591</span><br><span class=\"line\">592</span><br><span class=\"line\">593</span><br><span class=\"line\">594</span><br><span class=\"line\">595</span><br><span class=\"line\">596</span><br><span class=\"line\">597</span><br><span class=\"line\">598</span><br><span class=\"line\">599</span><br><span class=\"line\">600</span><br><span class=\"line\">601</span><br><span class=\"line\">602</span><br><span class=\"line\">603</span><br><span class=\"line\">604</span><br><span class=\"line\">605</span><br><span class=\"line\">606</span><br><span class=\"line\">607</span><br><span class=\"line\">608</span><br><span class=\"line\">609</span><br><span class=\"line\">610</span><br><span class=\"line\">611</span><br><span class=\"line\">612</span><br><span class=\"line\">613</span><br><span class=\"line\">614</span><br><span class=\"line\">615</span><br><span class=\"line\">616</span><br><span class=\"line\">617</span><br><span class=\"line\">618</span><br><span class=\"line\">619</span><br><span class=\"line\">620</span><br><span class=\"line\">621</span><br><span class=\"line\">622</span><br><span class=\"line\">623</span><br><span class=\"line\">624</span><br><span class=\"line\">625</span><br><span class=\"line\">626</span><br><span class=\"line\">627</span><br><span class=\"line\">628</span><br><span class=\"line\">629</span><br><span class=\"line\">630</span><br><span class=\"line\">631</span><br><span class=\"line\">632</span><br><span class=\"line\">633</span><br><span class=\"line\">634</span><br><span class=\"line\">635</span><br><span class=\"line\">636</span><br><span class=\"line\">637</span><br><span class=\"line\">638</span><br><span class=\"line\">639</span><br><span class=\"line\">640</span><br><span class=\"line\">641</span><br><span class=\"line\">642</span><br><span class=\"line\">643</span><br><span class=\"line\">644</span><br><span class=\"line\">645</span><br><span class=\"line\">646</span><br><span class=\"line\">647</span><br><span class=\"line\">648</span><br><span class=\"line\">649</span><br><span class=\"line\">650</span><br><span class=\"line\">651</span><br><span class=\"line\">652</span><br><span class=\"line\">653</span><br><span class=\"line\">654</span><br><span class=\"line\">655</span><br><span class=\"line\">656</span><br><span class=\"line\">657</span><br><span class=\"line\">658</span><br><span class=\"line\">659</span><br><span class=\"line\">660</span><br><span class=\"line\">661</span><br><span class=\"line\">662</span><br><span class=\"line\">663</span><br><span class=\"line\">664</span><br><span class=\"line\">665</span><br><span class=\"line\">666</span><br><span class=\"line\">667</span><br><span class=\"line\">668</span><br><span class=\"line\">669</span><br><span class=\"line\">670</span><br><span class=\"line\">671</span><br><span class=\"line\">672</span><br><span class=\"line\">673</span><br><span class=\"line\">674</span><br><span class=\"line\">675</span><br><span class=\"line\">676</span><br><span class=\"line\">677</span><br><span class=\"line\">678</span><br><span class=\"line\">679</span><br><span class=\"line\">680</span><br><span class=\"line\">681</span><br><span class=\"line\">682</span><br><span class=\"line\">683</span><br><span class=\"line\">684</span><br><span class=\"line\">685</span><br><span class=\"line\">686</span><br><span class=\"line\">687</span><br><span class=\"line\">688</span><br><span class=\"line\">689</span><br><span class=\"line\">690</span><br><span class=\"line\">691</span><br><span class=\"line\">692</span><br><span class=\"line\">693</span><br><span class=\"line\">694</span><br><span class=\"line\">695</span><br><span class=\"line\">696</span><br><span class=\"line\">697</span><br><span class=\"line\">698</span><br><span class=\"line\">699</span><br><span class=\"line\">700</span><br><span class=\"line\">701</span><br><span class=\"line\">702</span><br><span class=\"line\">703</span><br><span class=\"line\">704</span><br><span class=\"line\">705</span><br><span class=\"line\">706</span><br><span class=\"line\">707</span><br><span class=\"line\">708</span><br><span class=\"line\">709</span><br><span class=\"line\">710</span><br><span class=\"line\">711</span><br><span class=\"line\">712</span><br><span class=\"line\">713</span><br><span class=\"line\">714</span><br><span class=\"line\">715</span><br><span class=\"line\">716</span><br><span class=\"line\">717</span><br><span class=\"line\">718</span><br><span class=\"line\">719</span><br><span class=\"line\">720</span><br><span class=\"line\">721</span><br><span class=\"line\">722</span><br><span class=\"line\">723</span><br><span class=\"line\">724</span><br><span class=\"line\">725</span><br><span class=\"line\">726</span><br><span class=\"line\">727</span><br><span class=\"line\">728</span><br><span class=\"line\">729</span><br><span class=\"line\">730</span><br><span class=\"line\">731</span><br><span class=\"line\">732</span><br><span class=\"line\">733</span><br><span class=\"line\">734</span><br><span class=\"line\">735</span><br><span class=\"line\">736</span><br><span class=\"line\">737</span><br><span class=\"line\">738</span><br><span class=\"line\">739</span><br><span class=\"line\">740</span><br><span class=\"line\">741</span><br><span class=\"line\">742</span><br><span class=\"line\">743</span><br><span class=\"line\">744</span><br><span class=\"line\">745</span><br><span class=\"line\">746</span><br><span class=\"line\">747</span><br><span class=\"line\">748</span><br><span class=\"line\">749</span><br><span class=\"line\">750</span><br><span class=\"line\">751</span><br><span class=\"line\">752</span><br><span class=\"line\">753</span><br><span class=\"line\">754</span><br><span class=\"line\">755</span><br><span class=\"line\">756</span><br><span class=\"line\">757</span><br><span class=\"line\">758</span><br><span class=\"line\">759</span><br><span class=\"line\">760</span><br><span class=\"line\">761</span><br><span class=\"line\">762</span><br><span class=\"line\">763</span><br><span class=\"line\">764</span><br><span class=\"line\">765</span><br><span class=\"line\">766</span><br><span class=\"line\">767</span><br><span class=\"line\">768</span><br><span class=\"line\">769</span><br><span class=\"line\">770</span><br><span class=\"line\">771</span><br><span class=\"line\">772</span><br><span class=\"line\">773</span><br><span class=\"line\">774</span><br><span class=\"line\">775</span><br><span class=\"line\">776</span><br><span class=\"line\">777</span><br><span class=\"line\">778</span><br><span class=\"line\">779</span><br><span class=\"line\">780</span><br><span class=\"line\">781</span><br><span class=\"line\">782</span><br><span class=\"line\">783</span><br><span class=\"line\">784</span><br><span class=\"line\">785</span><br><span class=\"line\">786</span><br><span class=\"line\">787</span><br><span class=\"line\">788</span><br><span class=\"line\">789</span><br><span class=\"line\">790</span><br><span class=\"line\">791</span><br><span class=\"line\">792</span><br><span class=\"line\">793</span><br><span class=\"line\">794</span><br><span class=\"line\">795</span><br><span class=\"line\">796</span><br><span class=\"line\">797</span><br><span class=\"line\">798</span><br><span class=\"line\">799</span><br><span class=\"line\">800</span><br><span class=\"line\">801</span><br><span class=\"line\">802</span><br><span class=\"line\">803</span><br><span class=\"line\">804</span><br><span class=\"line\">805</span><br><span class=\"line\">806</span><br><span class=\"line\">807</span><br><span class=\"line\">808</span><br><span class=\"line\">809</span><br><span class=\"line\">810</span><br><span class=\"line\">811</span><br><span class=\"line\">812</span><br><span class=\"line\">813</span><br><span class=\"line\">814</span><br><span class=\"line\">815</span><br><span class=\"line\">816</span><br><span class=\"line\">817</span><br><span class=\"line\">818</span><br><span class=\"line\">819</span><br><span class=\"line\">820</span><br><span class=\"line\">821</span><br><span class=\"line\">822</span><br><span class=\"line\">823</span><br><span class=\"line\">824</span><br><span class=\"line\">825</span><br><span class=\"line\">826</span><br><span class=\"line\">827</span><br><span class=\"line\">828</span><br><span class=\"line\">829</span><br><span class=\"line\">830</span><br><span class=\"line\">831</span><br><span class=\"line\">832</span><br><span class=\"line\">833</span><br><span class=\"line\">834</span><br><span class=\"line\">835</span><br><span class=\"line\">836</span><br><span class=\"line\">837</span><br><span class=\"line\">838</span><br><span class=\"line\">839</span><br><span class=\"line\">840</span><br><span class=\"line\">841</span><br><span class=\"line\">842</span><br><span class=\"line\">843</span><br><span class=\"line\">844</span><br><span class=\"line\">845</span><br><span class=\"line\">846</span><br><span class=\"line\">847</span><br><span class=\"line\">848</span><br><span class=\"line\">849</span><br><span class=\"line\">850</span><br><span class=\"line\">851</span><br><span class=\"line\">852</span><br><span class=\"line\">853</span><br><span class=\"line\">854</span><br><span class=\"line\">855</span><br><span class=\"line\">856</span><br><span class=\"line\">857</span><br><span class=\"line\">858</span><br><span class=\"line\">859</span><br><span class=\"line\">860</span><br><span class=\"line\">861</span><br><span class=\"line\">862</span><br><span class=\"line\">863</span><br><span class=\"line\">864</span><br><span class=\"line\">865</span><br><span class=\"line\">866</span><br><span class=\"line\">867</span><br><span class=\"line\">868</span><br><span class=\"line\">869</span><br><span class=\"line\">870</span><br><span class=\"line\">871</span><br><span class=\"line\">872</span><br><span class=\"line\">873</span><br><span class=\"line\">874</span><br><span class=\"line\">875</span><br><span class=\"line\">876</span><br><span class=\"line\">877</span><br><span class=\"line\">878</span><br><span class=\"line\">879</span><br><span class=\"line\">880</span><br><span class=\"line\">881</span><br><span class=\"line\">882</span><br><span class=\"line\">883</span><br><span class=\"line\">884</span><br><span class=\"line\">885</span><br><span class=\"line\">886</span><br><span class=\"line\">887</span><br><span class=\"line\">888</span><br><span class=\"line\">889</span><br><span class=\"line\">890</span><br><span class=\"line\">891</span><br><span class=\"line\">892</span><br><span class=\"line\">893</span><br><span class=\"line\">894</span><br><span class=\"line\">895</span><br><span class=\"line\">896</span><br><span class=\"line\">897</span><br><span class=\"line\">898</span><br><span class=\"line\">899</span><br><span class=\"line\">900</span><br><span class=\"line\">901</span><br><span class=\"line\">902</span><br><span class=\"line\">903</span><br><span class=\"line\">904</span><br><span class=\"line\">905</span><br><span class=\"line\">906</span><br><span class=\"line\">907</span><br><span class=\"line\">908</span><br><span class=\"line\">909</span><br><span class=\"line\">910</span><br><span class=\"line\">911</span><br><span class=\"line\">912</span><br><span class=\"line\">913</span><br><span class=\"line\">914</span><br><span class=\"line\">915</span><br><span class=\"line\">916</span><br><span class=\"line\">917</span><br><span class=\"line\">918</span><br><span class=\"line\">919</span><br><span class=\"line\">920</span><br><span class=\"line\">921</span><br><span class=\"line\">922</span><br><span class=\"line\">923</span><br><span class=\"line\">924</span><br><span class=\"line\">925</span><br><span class=\"line\">926</span><br><span class=\"line\">927</span><br><span class=\"line\">928</span><br><span class=\"line\">929</span><br><span class=\"line\">930</span><br><span class=\"line\">931</span><br><span class=\"line\">932</span><br><span class=\"line\">933</span><br><span class=\"line\">934</span><br><span class=\"line\">935</span><br><span class=\"line\">936</span><br><span class=\"line\">937</span><br><span class=\"line\">938</span><br><span class=\"line\">939</span><br><span class=\"line\">940</span><br><span class=\"line\">941</span><br><span class=\"line\">942</span><br><span class=\"line\">943</span><br><span class=\"line\">944</span><br><span class=\"line\">945</span><br><span class=\"line\">946</span><br><span class=\"line\">947</span><br><span class=\"line\">948</span><br><span class=\"line\">949</span><br><span class=\"line\">950</span><br><span class=\"line\">951</span><br><span class=\"line\">952</span><br><span class=\"line\">953</span><br><span class=\"line\">954</span><br><span class=\"line\">955</span><br><span class=\"line\">956</span><br><span class=\"line\">957</span><br><span class=\"line\">958</span><br><span class=\"line\">959</span><br><span class=\"line\">960</span><br><span class=\"line\">961</span><br><span class=\"line\">962</span><br><span class=\"line\">963</span><br><span class=\"line\">964</span><br><span class=\"line\">965</span><br><span class=\"line\">966</span><br><span class=\"line\">967</span><br><span class=\"line\">968</span><br><span class=\"line\">969</span><br><span class=\"line\">970</span><br><span class=\"line\">971</span><br><span class=\"line\">972</span><br><span class=\"line\">973</span><br><span class=\"line\">974</span><br><span class=\"line\">975</span><br><span class=\"line\">976</span><br><span class=\"line\">977</span><br><span class=\"line\">978</span><br><span class=\"line\">979</span><br><span class=\"line\">980</span><br><span class=\"line\">981</span><br><span class=\"line\">982</span><br><span class=\"line\">983</span><br><span class=\"line\">984</span><br><span class=\"line\">985</span><br><span class=\"line\">986</span><br><span class=\"line\">987</span><br><span class=\"line\">988</span><br><span class=\"line\">989</span><br><span class=\"line\">990</span><br><span class=\"line\">991</span><br><span class=\"line\">992</span><br><span class=\"line\">993</span><br><span class=\"line\">994</span><br><span class=\"line\">995</span><br><span class=\"line\">996</span><br><span class=\"line\">997</span><br><span class=\"line\">998</span><br><span class=\"line\">999</span><br><span class=\"line\">1000</span><br><span class=\"line\">1001</span><br><span class=\"line\">1002</span><br><span class=\"line\">1003</span><br><span class=\"line\">1004</span><br><span class=\"line\">1005</span><br><span class=\"line\">1006</span><br><span class=\"line\">1007</span><br><span class=\"line\">1008</span><br><span class=\"line\">1009</span><br><span class=\"line\">1010</span><br><span class=\"line\">1011</span><br><span class=\"line\">1012</span><br><span class=\"line\">1013</span><br><span class=\"line\">1014</span><br><span class=\"line\">1015</span><br><span class=\"line\">1016</span><br><span class=\"line\">1017</span><br><span class=\"line\">1018</span><br><span class=\"line\">1019</span><br><span class=\"line\">1020</span><br><span class=\"line\">1021</span><br><span class=\"line\">1022</span><br><span class=\"line\">1023</span><br><span class=\"line\">1024</span><br><span class=\"line\">1025</span><br><span class=\"line\">1026</span><br><span class=\"line\">1027</span><br><span class=\"line\">1028</span><br><span class=\"line\">1029</span><br><span class=\"line\">1030</span><br><span class=\"line\">1031</span><br><span class=\"line\">1032</span><br><span class=\"line\">1033</span><br><span class=\"line\">1034</span><br><span class=\"line\">1035</span><br><span class=\"line\">1036</span><br><span class=\"line\">1037</span><br><span class=\"line\">1038</span><br><span class=\"line\">1039</span><br><span class=\"line\">1040</span><br><span class=\"line\">1041</span><br><span class=\"line\">1042</span><br><span class=\"line\">1043</span><br><span class=\"line\">1044</span><br><span class=\"line\">1045</span><br><span class=\"line\">1046</span><br><span class=\"line\">1047</span><br><span class=\"line\">1048</span><br><span class=\"line\">1049</span><br><span class=\"line\">1050</span><br><span class=\"line\">1051</span><br><span class=\"line\">1052</span><br><span class=\"line\">1053</span><br><span class=\"line\">1054</span><br><span class=\"line\">1055</span><br><span class=\"line\">1056</span><br><span class=\"line\">1057</span><br><span class=\"line\">1058</span><br><span class=\"line\">1059</span><br><span class=\"line\">1060</span><br><span class=\"line\">1061</span><br><span class=\"line\">1062</span><br><span class=\"line\">1063</span><br><span class=\"line\">1064</span><br><span class=\"line\">1065</span><br><span class=\"line\">1066</span><br><span class=\"line\">1067</span><br><span class=\"line\">1068</span><br><span class=\"line\">1069</span><br><span class=\"line\">1070</span><br><span class=\"line\">1071</span><br><span class=\"line\">1072</span><br><span class=\"line\">1073</span><br><span class=\"line\">1074</span><br><span class=\"line\">1075</span><br><span class=\"line\">1076</span><br><span class=\"line\">1077</span><br><span class=\"line\">1078</span><br><span class=\"line\">1079</span><br><span class=\"line\">1080</span><br><span class=\"line\">1081</span><br><span class=\"line\">1082</span><br><span class=\"line\">1083</span><br><span class=\"line\">1084</span><br><span class=\"line\">1085</span><br><span class=\"line\">1086</span><br><span class=\"line\">1087</span><br><span class=\"line\">1088</span><br><span class=\"line\">1089</span><br><span class=\"line\">1090</span><br><span class=\"line\">1091</span><br><span class=\"line\">1092</span><br><span class=\"line\">1093</span><br><span class=\"line\">1094</span><br><span class=\"line\">1095</span><br><span class=\"line\">1096</span><br><span class=\"line\">1097</span><br><span class=\"line\">1098</span><br><span class=\"line\">1099</span><br><span class=\"line\">1100</span><br><span class=\"line\">1101</span><br><span class=\"line\">1102</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># Hexo Theme Fluid</span><br><span class=\"hljs-comment\"># Author: Fluid-dev</span><br><span class=\"hljs-comment\"># Github: https://github.com/fluid-dev/hexo-theme-fluid</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># 配置指南: https://hexo.fluid-dev.com/docs/guide/</span><br><span class=\"hljs-comment\"># 你可以从指南中获得更详细的说明</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># Guide: https://hexo.fluid-dev.com/docs/en/guide/</span><br><span class=\"hljs-comment\"># You can get more detailed help from the guide</span><br><span class=\"hljs-comment\">#---------------------------</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 全局</span><br><span class=\"hljs-comment\"># Global</span><br><span class=\"hljs-comment\">#---------------------------</span><br><br><span class=\"hljs-comment\"># 用于浏览器标签的图标</span><br><span class=\"hljs-comment\"># Icon for browser tab</span><br><span class=\"hljs-attr\">favicon:</span> <span class=\"hljs-string\">/img/fluid.png</span><br><br><span class=\"hljs-comment\"># 用于苹果设备的图标</span><br><span class=\"hljs-comment\"># Icon for Apple touch</span><br><span class=\"hljs-attr\">apple_touch_icon:</span> <span class=\"hljs-string\">/img/fluid.png</span><br><br><span class=\"hljs-comment\"># 浏览器标签页中的标题分隔符，效果： 文章名 - 站点名</span><br><span class=\"hljs-comment\"># Title separator in browser tab, eg: article - site</span><br><span class=\"hljs-attr\">tab_title_separator:</span> <span class=\"hljs-string\">&quot; - &quot;</span><br><br><span class=\"hljs-comment\"># 强制所有链接升级为 HTTPS（适用于图片等资源出现 HTTP 混入报错）</span><br><span class=\"hljs-comment\"># Force all links to be HTTPS (applicable to HTTP mixed error)</span><br><span class=\"hljs-attr\">force_https:</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-comment\"># 代码块的增强配置</span><br><span class=\"hljs-comment\"># Enhancements to code blocks</span><br><span class=\"hljs-attr\">code:</span><br>  <span class=\"hljs-comment\"># 是否开启复制代码的按钮</span><br>  <span class=\"hljs-comment\"># Enable copy code button</span><br>  <span class=\"hljs-attr\">copy_btn:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 代码语言</span><br>  <span class=\"hljs-comment\"># Code language</span><br>  <span class=\"hljs-attr\">language:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">default:</span> <span class=\"hljs-string\">&quot;TEXT&quot;</span><br><br>  <span class=\"hljs-comment\"># 代码高亮</span><br>  <span class=\"hljs-comment\"># Code highlight</span><br>  <span class=\"hljs-attr\">highlight:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 代码块是否显示行号</span><br>    <span class=\"hljs-comment\"># If true, the code block display line numbers</span><br>    <span class=\"hljs-attr\">line_number:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 实现高亮的库，对应下面的设置</span><br>    <span class=\"hljs-comment\"># Highlight library</span><br>    <span class=\"hljs-comment\"># Options: highlightjs | prismjs</span><br>    <span class=\"hljs-attr\">lib:</span> <span class=\"hljs-string\">&quot;highlightjs&quot;</span><br><br>    <span class=\"hljs-attr\">highlightjs:</span><br>      <span class=\"hljs-comment\"># 在链接中挑选 style 填入</span><br>      <span class=\"hljs-comment\"># Select a style in the link</span><br>      <span class=\"hljs-comment\"># See: https://highlightjs.org/static/demo/</span><br>      <span class=\"hljs-attr\">style:</span> <span class=\"hljs-string\">&quot;github gist&quot;</span><br>      <span class=\"hljs-attr\">style_dark:</span> <span class=\"hljs-string\">&quot;dark&quot;</span><br><br>    <span class=\"hljs-attr\">prismjs:</span><br>      <span class=\"hljs-comment\"># 在下方链接页面右侧的圆形按钮挑选 style 填入，也可以直接填入 css 链接</span><br>      <span class=\"hljs-comment\"># Select the style button on the right side of the link page, you can also set the CSS link</span><br>      <span class=\"hljs-comment\"># See: https://prismjs.com/</span><br>      <span class=\"hljs-attr\">style:</span> <span class=\"hljs-string\">&quot;default&quot;</span><br>      <span class=\"hljs-attr\">style_dark:</span> <span class=\"hljs-string\">&quot;tomorrow night&quot;</span><br><br>      <span class=\"hljs-comment\"># 设为 true 高亮将本地静态生成（但只支持部分 prismjs 插件），设为 false 高亮将在浏览器通过 js 生成</span><br>      <span class=\"hljs-comment\"># If true, it will be generated locally (but some prismjs plugins are not supported). If false, it will be generated via JS in the browser</span><br>      <span class=\"hljs-attr\">preprocess:</span> <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\"># 一些好玩的功能</span><br><span class=\"hljs-comment\"># Some fun features</span><br><span class=\"hljs-attr\">fun_features:</span><br>  <span class=\"hljs-comment\"># 为 subtitle 添加打字机效果</span><br>  <span class=\"hljs-comment\"># Typing animation for subtitle</span><br>  <span class=\"hljs-attr\">typing:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 打印速度，数字越大越慢</span><br>    <span class=\"hljs-comment\"># Typing speed, the larger the number, the slower</span><br>    <span class=\"hljs-attr\">typeSpeed:</span> <span class=\"hljs-number\">70</span><br><br>    <span class=\"hljs-comment\"># 游标字符</span><br>    <span class=\"hljs-comment\"># Cursor character</span><br>    <span class=\"hljs-attr\">cursorChar:</span> <span class=\"hljs-string\">&quot;_&quot;</span><br><br>    <span class=\"hljs-comment\"># 是否循环播放效果</span><br>    <span class=\"hljs-comment\"># If true, loop animation</span><br>    <span class=\"hljs-attr\">loop:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 在指定页面开启，不填则在所有页面开启</span><br>    <span class=\"hljs-comment\"># Enable in specified page, all pages by default</span><br>    <span class=\"hljs-comment\"># Options: home | post | tag | category | about | links | page | 404</span><br>    <span class=\"hljs-attr\">scope:</span> []<br><br>  <span class=\"hljs-comment\"># 为文章内容中的标题添加锚图标</span><br>  <span class=\"hljs-comment\"># Add an anchor icon to the title on the post page</span><br>  <span class=\"hljs-attr\">anchorjs:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">element:</span> <span class=\"hljs-string\">h1,h2,h3,h4,h5,h6</span><br>    <span class=\"hljs-comment\"># Options: left | right</span><br>    <span class=\"hljs-attr\">placement:</span> <span class=\"hljs-string\">left</span><br>    <span class=\"hljs-comment\"># Options: hover | always | touch</span><br>    <span class=\"hljs-attr\">visible:</span> <span class=\"hljs-string\">hover</span><br>    <span class=\"hljs-comment\"># Options: § | # | ❡</span><br>    <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>  <span class=\"hljs-comment\"># 加载进度条</span><br>  <span class=\"hljs-comment\"># Progress bar when loading</span><br>  <span class=\"hljs-attr\">progressbar:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">height_px:</span> <span class=\"hljs-number\">3</span><br>    <span class=\"hljs-attr\">color:</span> <span class=\"hljs-string\">&quot;#29d&quot;</span><br>    <span class=\"hljs-comment\"># See: https://github.com/rstacruz/nprogress</span><br>    <span class=\"hljs-attr\">options:</span> &#123; <span class=\"hljs-attr\">showSpinner:</span> <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">trickleSpeed:</span> <span class=\"hljs-number\">100</span> &#125;<br><br><span class=\"hljs-comment\"># 主题暗色模式，开启后菜单中会出现切换按钮，用户浏览器会存储切换选项，并且会遵循 prefers-color-scheme 自动切换</span><br><span class=\"hljs-comment\"># Theme dark mode. If enable, a switch button will appear on the menu, each of the visitor&#x27;s browser will store his switch option</span><br><span class=\"hljs-attr\">dark_mode:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-comment\"># 默认的选项（当用户手动切换后则不再按照默认模式），选择 `auto` 会优先遵循 prefers-color-scheme，其次按用户本地时间 18 点到次日 6 点之间进入暗色模式</span><br>  <span class=\"hljs-comment\"># Default option (when the visitor switches manually, the default mode is no longer followed), choosing `auto` will give priority to prefers-color-scheme, and then enter the dark mode from 18:00 to 6:00 in the visitor’s local time</span><br>  <span class=\"hljs-comment\"># Options: auto | light | dark</span><br>  <span class=\"hljs-attr\">default:</span> <span class=\"hljs-string\">auto</span><br><br><span class=\"hljs-comment\"># 主题颜色配置，其他不生效的地方请使用自定义 css 解决，配色可以在下方链接中获得启发</span><br><span class=\"hljs-comment\"># Theme color, please use custom CSS to solve other colors, color schema can be inspired by the links below</span><br><span class=\"hljs-comment\"># See: https://www.webdesignrankings.com/resources/lolcolors/</span><br><span class=\"hljs-attr\">color:</span><br>  <span class=\"hljs-comment\"># body 背景色</span><br>  <span class=\"hljs-comment\"># Color of body background</span><br>  <span class=\"hljs-attr\">body_bg_color:</span> <span class=\"hljs-string\">&quot;#eee&quot;</span><br>  <span class=\"hljs-comment\"># 暗色模式下的 body 背景色，下同</span><br>  <span class=\"hljs-comment\"># Color in dark mode, the same below</span><br>  <span class=\"hljs-attr\">body_bg_color_dark:</span> <span class=\"hljs-string\">&quot;#181c27&quot;</span><br><br>  <span class=\"hljs-comment\"># 顶部菜单背景色</span><br>  <span class=\"hljs-comment\"># Color of navigation bar background</span><br>  <span class=\"hljs-attr\">navbar_bg_color:</span> <span class=\"hljs-string\">&quot;#2f4154&quot;</span><br>  <span class=\"hljs-attr\">navbar_bg_color_dark:</span> <span class=\"hljs-string\">&quot;#1f3144&quot;</span><br><br>  <span class=\"hljs-comment\"># 顶部菜单字体色</span><br>  <span class=\"hljs-comment\"># Color of navigation bar text</span><br>  <span class=\"hljs-attr\">navbar_text_color:</span> <span class=\"hljs-string\">&quot;#fff&quot;</span><br>  <span class=\"hljs-attr\">navbar_text_color_dark:</span> <span class=\"hljs-string\">&quot;#d0d0d0&quot;</span><br><br>  <span class=\"hljs-comment\"># 副标题字体色</span><br>  <span class=\"hljs-comment\"># Color of navigation bar text</span><br>  <span class=\"hljs-attr\">subtitle_color:</span> <span class=\"hljs-string\">&quot;#fff&quot;</span><br>  <span class=\"hljs-attr\">subtitle_color_dark:</span> <span class=\"hljs-string\">&quot;#d0d0d0&quot;</span><br><br>  <span class=\"hljs-comment\"># 全局字体色</span><br>  <span class=\"hljs-comment\"># Color of global text</span><br>  <span class=\"hljs-attr\">text_color:</span> <span class=\"hljs-string\">&quot;#3c4858&quot;</span><br>  <span class=\"hljs-attr\">text_color_dark:</span> <span class=\"hljs-string\">&quot;#c4c6c9&quot;</span><br><br>  <span class=\"hljs-comment\"># 全局次级字体色（摘要、简介等位置）</span><br>  <span class=\"hljs-comment\"># Color of global secondary text (excerpt, introduction, etc.)</span><br>  <span class=\"hljs-attr\">sec_text_color:</span> <span class=\"hljs-string\">&quot;#718096&quot;</span><br>  <span class=\"hljs-attr\">sec_text_color_dark:</span> <span class=\"hljs-string\">&quot;#a7a9ad&quot;</span><br><br>  <span class=\"hljs-comment\"># 主面板背景色</span><br>  <span class=\"hljs-comment\"># Color of main board</span><br>  <span class=\"hljs-attr\">board_color:</span> <span class=\"hljs-string\">&quot;#fff&quot;</span><br>  <span class=\"hljs-attr\">board_color_dark:</span> <span class=\"hljs-string\">&quot;#252d38&quot;</span><br><br>  <span class=\"hljs-comment\"># 文章正文字体色</span><br>  <span class=\"hljs-comment\"># Color of post text</span><br>  <span class=\"hljs-attr\">post_text_color:</span> <span class=\"hljs-string\">&quot;#2c3e50&quot;</span><br>  <span class=\"hljs-attr\">post_text_color_dark:</span> <span class=\"hljs-string\">&quot;#c4c6c9&quot;</span><br><br>  <span class=\"hljs-comment\"># 文章正文字体色（h1 h2 h3...）</span><br>  <span class=\"hljs-comment\"># Color of Article heading (h1 h2 h3...)</span><br>  <span class=\"hljs-attr\">post_heading_color:</span> <span class=\"hljs-string\">&quot;#1a202c&quot;</span><br>  <span class=\"hljs-attr\">post_heading_color_dark:</span> <span class=\"hljs-string\">&quot;#c4c6c9&quot;</span><br><br>  <span class=\"hljs-comment\"># 文章超链接字体色</span><br>  <span class=\"hljs-comment\"># Color of post link</span><br>  <span class=\"hljs-attr\">post_link_color:</span> <span class=\"hljs-string\">&quot;#0366d6&quot;</span><br>  <span class=\"hljs-attr\">post_link_color_dark:</span> <span class=\"hljs-string\">&quot;#1589e9&quot;</span><br><br>  <span class=\"hljs-comment\"># 超链接悬浮时字体色</span><br>  <span class=\"hljs-comment\"># Color of link when hovering</span><br>  <span class=\"hljs-attr\">link_hover_color:</span> <span class=\"hljs-string\">&quot;#30a9de&quot;</span><br>  <span class=\"hljs-attr\">link_hover_color_dark:</span> <span class=\"hljs-string\">&quot;#30a9de&quot;</span><br><br>  <span class=\"hljs-comment\"># 超链接悬浮背景色</span><br>  <span class=\"hljs-comment\"># Color of link background when hovering</span><br>  <span class=\"hljs-attr\">link_hover_bg_color:</span> <span class=\"hljs-string\">&quot;#f8f9fa&quot;</span><br>  <span class=\"hljs-attr\">link_hover_bg_color_dark:</span> <span class=\"hljs-string\">&quot;#364151&quot;</span><br><br>  <span class=\"hljs-comment\"># 分隔线和表格边线的颜色</span><br>  <span class=\"hljs-comment\"># Color of horizontal rule and table border</span><br>  <span class=\"hljs-attr\">line_color:</span> <span class=\"hljs-string\">&quot;#eaecef&quot;</span><br>  <span class=\"hljs-attr\">line_color_dark:</span> <span class=\"hljs-string\">&quot;#435266&quot;</span><br><br>  <span class=\"hljs-comment\"># 滚动条颜色</span><br>  <span class=\"hljs-comment\"># Color of scrollbar</span><br>  <span class=\"hljs-attr\">scrollbar_color:</span> <span class=\"hljs-string\">&quot;#c4c6c9&quot;</span><br>  <span class=\"hljs-attr\">scrollbar_color_dark:</span> <span class=\"hljs-string\">&quot;#687582&quot;</span><br>  <span class=\"hljs-comment\"># 滚动条悬浮颜色</span><br>  <span class=\"hljs-comment\"># Color of scrollbar when hovering</span><br>  <span class=\"hljs-attr\">scrollbar_hover_color:</span> <span class=\"hljs-string\">&quot;#a6a6a6&quot;</span><br>  <span class=\"hljs-attr\">scrollbar_hover_color_dark:</span> <span class=\"hljs-string\">&quot;#9da8b3&quot;</span><br><br>  <span class=\"hljs-comment\"># 按钮背景色</span><br>  <span class=\"hljs-comment\"># Color of button</span><br>  <span class=\"hljs-attr\">button_bg_color:</span> <span class=\"hljs-string\">&quot;transparent&quot;</span><br>  <span class=\"hljs-attr\">button_bg_color_dark:</span> <span class=\"hljs-string\">&quot;transparent&quot;</span><br>  <span class=\"hljs-comment\"># 按钮悬浮背景色</span><br>  <span class=\"hljs-comment\"># Color of button when hovering</span><br>  <span class=\"hljs-attr\">button_hover_bg_color:</span> <span class=\"hljs-string\">&quot;#f2f3f5&quot;</span><br>  <span class=\"hljs-attr\">button_hover_bg_color_dark:</span> <span class=\"hljs-string\">&quot;#46647e&quot;</span><br><br><span class=\"hljs-comment\"># 主题字体配置</span><br><span class=\"hljs-comment\"># Font</span><br><span class=\"hljs-attr\">font:</span><br>  <span class=\"hljs-attr\">font_size:</span> <span class=\"hljs-string\">16px</span><br>  <span class=\"hljs-attr\">font_family:</span><br>  <span class=\"hljs-attr\">letter_spacing:</span> <span class=\"hljs-number\">0.</span><span class=\"hljs-string\">02em</span><br>  <span class=\"hljs-attr\">code_font_size:</span> <span class=\"hljs-number\">85</span><span class=\"hljs-string\">%</span><br><br><span class=\"hljs-comment\"># 指定自定义 .js 文件路径，支持列表；路径是相对 source 目录，如 /js/custom.js 对应存放目录 source/js/custom.js</span><br><span class=\"hljs-comment\"># Specify the path of your custom js file, support list. The path is relative to the source directory, such as `/js/custom.js` corresponding to the directory `source/js/custom.js`</span><br><span class=\"hljs-attr\">custom_js:</span><br><br><span class=\"hljs-comment\"># 指定自定义 .css 文件路径，用法和 custom_js 相同</span><br><span class=\"hljs-comment\"># The usage is the same as custom_js</span><br><span class=\"hljs-attr\">custom_css:</span><br><br><span class=\"hljs-comment\"># 网页访问统计</span><br><span class=\"hljs-comment\"># Analysis of website visitors</span><br><span class=\"hljs-attr\">web_analytics:</span>  <span class=\"hljs-comment\"># 网页访问统计</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>  <span class=\"hljs-comment\"># 遵循访客浏览器&quot;请勿追踪&quot;的设置，如果开启则不统计其访问</span><br>  <span class=\"hljs-comment\"># Follow the &quot;Do Not Track&quot; setting of the visitor&#x27;s browser</span><br>  <span class=\"hljs-comment\"># See: https://www.w3.org/TR/tracking-dnt/</span><br>  <span class=\"hljs-attr\">follow_dnt:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 百度统计的 Key，值需要获取下方链接中 `hm.js?` 后边的字符串</span><br>  <span class=\"hljs-comment\"># Baidu analytics, get the string behind `hm.js?`</span><br>  <span class=\"hljs-comment\"># See: https://tongji.baidu.com/sc-web/10000033910/home/site/getjs?siteId=13751376</span><br>  <span class=\"hljs-attr\">baidu:</span><br><br>  <span class=\"hljs-comment\"># Google Analytics 4 的媒体资源 ID</span><br>  <span class=\"hljs-comment\"># Google Analytics 4 MEASUREMENT_ID</span><br>  <span class=\"hljs-comment\"># See: https://support.google.com/analytics/answer/9744165#zippy=%2Cin-this-article</span><br>  <span class=\"hljs-attr\">google:</span><br>    <span class=\"hljs-attr\">measurement_id:</span><br><br>  <span class=\"hljs-comment\"># 腾讯统计的 H5 App ID，开启高级功能才有cid</span><br>  <span class=\"hljs-comment\"># Tencent analytics, set APP ID</span><br>  <span class=\"hljs-comment\"># See: https://mta.qq.com/h5/manage/ctr_app_manage</span><br>  <span class=\"hljs-attr\">tencent:</span><br>    <span class=\"hljs-attr\">sid:</span><br>    <span class=\"hljs-attr\">cid:</span><br><br>  <span class=\"hljs-comment\"># 51.la 站点统计 ID</span><br>  <span class=\"hljs-comment\"># 51.la analytics</span><br>  <span class=\"hljs-comment\"># See: https://www.51.la/user/site/index</span><br>  <span class=\"hljs-attr\">woyaola:</span>  <span class=\"hljs-comment\"># 51.la 站点统计 ID，参见</span><br><br>  <span class=\"hljs-comment\"># 友盟/cnzz 站点统计 web_id</span><br>  <span class=\"hljs-comment\"># cnzz analytics</span><br>  <span class=\"hljs-comment\"># See: https://web.umeng.com/main.php?c=site&amp;a=show</span><br>  <span class=\"hljs-attr\">cnzz:</span><br><br>  <span class=\"hljs-comment\"># LeanCloud 计数统计，可用于 PV UV 展示，如果 `web_analytics: enable` 没有开启，PV UV 展示只会查询不会增加</span><br>  <span class=\"hljs-comment\"># LeanCloud count statistics, which can be used for PV UV display. If `web_analytics: enable` is false, PV UV display will only query and not increase</span><br>  <span class=\"hljs-attr\">leancloud:</span><br>    <span class=\"hljs-attr\">app_id:</span><br>    <span class=\"hljs-attr\">app_key:</span><br>    <span class=\"hljs-comment\"># REST API 服务器地址，国际版不填</span><br>    <span class=\"hljs-comment\"># Only the Chinese mainland users need to set</span><br>    <span class=\"hljs-attr\">server_url:</span><br>    <span class=\"hljs-comment\"># 统计页面时获取路径的属性</span><br>    <span class=\"hljs-comment\"># Get the attribute of the page path during statistics</span><br>    <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">window.location.pathname</span><br>    <span class=\"hljs-comment\"># 开启后不统计本地路径( localhost 与 127.0.0.1 )</span><br>    <span class=\"hljs-comment\"># If true, ignore localhost &amp; 127.0.0.1</span><br>    <span class=\"hljs-attr\">ignore_local:</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-comment\"># 对页面中的图片和评论插件进行懒加载处理，可见范围外的元素不会提前加载</span><br><span class=\"hljs-comment\"># Lazy loading of images and comment plugin on the page</span><br><span class=\"hljs-attr\">lazyload:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 加载时的占位图片</span><br>  <span class=\"hljs-comment\"># The placeholder image when loading</span><br>  <span class=\"hljs-attr\">loading_img:</span> <span class=\"hljs-string\">/img/loading.gif</span><br><br>  <span class=\"hljs-comment\"># 开启后懒加载仅在文章页生效，如果自定义页面需要使用，可以在 Front-matter 里指定 `lazyload: true`</span><br>  <span class=\"hljs-comment\"># If true, only enable lazyload on the post page. For custom pages, you can set &#x27;lazyload: true&#x27; in front-matter</span><br>  <span class=\"hljs-attr\">onlypost:</span> <span class=\"hljs-literal\">false</span><br><br>  <span class=\"hljs-comment\"># 触发加载的偏移倍数，基数是视窗高度，可根据部署环境的请求速度调节</span><br>  <span class=\"hljs-comment\"># The factor of viewport height that triggers loading</span><br>  <span class=\"hljs-attr\">offset_factor:</span> <span class=\"hljs-number\">2</span><br><br><span class=\"hljs-comment\"># 图标库，包含了大量社交类图标，主题依赖的不包含在内，因此可自行修改，详见 https://hexo.fluid-dev.com/docs/icon/</span><br><span class=\"hljs-comment\"># Icon library, which includes many social icons, does not include those theme dependent, so your can modify link by yourself. See: https://hexo.fluid-dev.com/docs/en/icon/</span><br><span class=\"hljs-attr\">iconfont:</span> <span class=\"hljs-string\">//at.alicdn.com/t/font_1736178_lbnruvf0jn.css</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 页头</span><br><span class=\"hljs-comment\"># Header</span><br><span class=\"hljs-comment\">#---------------------------</span><br><br><span class=\"hljs-comment\"># 导航栏的相关配置</span><br><span class=\"hljs-comment\"># Navigation bar</span><br><span class=\"hljs-attr\">navbar:</span><br>  <span class=\"hljs-comment\"># 导航栏左侧的标题，为空则按 hexo config 中 `title` 显示</span><br>  <span class=\"hljs-comment\"># The title on the left side of the navigation bar. If empty, it is based on `title` in hexo config</span><br>  <span class=\"hljs-attr\">blog_title:</span> <span class=\"hljs-string\">&quot;Fluid&quot;</span><br><br>  <span class=\"hljs-comment\"># 导航栏毛玻璃特效，实验性功能，可能会造成页面滚动掉帧和抖动，部分浏览器不支持会自动不生效</span><br>  <span class=\"hljs-comment\"># Navigation bar frosted glass special animation. It is an experimental feature</span><br>  <span class=\"hljs-attr\">ground_glass:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 模糊像素，只能为数字，数字越大模糊度越高</span><br>    <span class=\"hljs-comment\"># Number of blurred pixel. the larger the number, the higher the blur</span><br>    <span class=\"hljs-attr\">px:</span> <span class=\"hljs-number\">3</span><br><br>    <span class=\"hljs-comment\"># 不透明度，数字越大透明度越低，注意透明过度可能看不清菜单字体</span><br>    <span class=\"hljs-comment\"># Ratio of opacity, 1.0 is completely opaque</span><br>    <span class=\"hljs-comment\"># available: 0 - 1.0</span><br>    <span class=\"hljs-attr\">alpha:</span> <span class=\"hljs-number\">0.7</span><br><br>  <span class=\"hljs-comment\"># 导航栏菜单，可自行增减，key 用来关联 languages/*.yml，如不存在关联则显示 key 本身的值；icon 是 css class，可以省略；增加 name 可以强制显示指定名称</span><br>  <span class=\"hljs-comment\"># Navigation bar menu. `key` is used to associate languages/*.yml. If there is no association, the value of `key` itself will be displayed; if `icon` is a css class, it can be omitted; adding `name` can force the display of the specified name</span><br>  <span class=\"hljs-attr\">menu:</span><br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">&quot;home&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-home-fill&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">&quot;archive&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;/archives/&quot;</span>, <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-archive-fill&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">&quot;category&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;/categories/&quot;</span>, <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-category-fill&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">&quot;tag&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;/tags/&quot;</span>, <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-tags-fill&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">&quot;about&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;/about/&quot;</span>, <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-user-fill&quot;</span> &#125;<br>    <span class=\"hljs-comment\">#- &#123; key: &quot;links&quot;, link: &quot;/links/&quot;, icon: &quot;iconfont icon-link-fill&quot; &#125;</span><br><br><span class=\"hljs-comment\"># 搜索功能，基于 hexo-generator-search 插件，若已安装其他搜索插件请关闭此功能，以避免生成多余的索引文件</span><br><span class=\"hljs-comment\"># Search feature, based on hexo-generator-search. If you have installed other search plugins, please disable this feature to avoid generating redundant index files</span><br><span class=\"hljs-attr\">search:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 搜索索引文件的路径，可以是相对路径或外站的绝对路径</span><br>  <span class=\"hljs-comment\"># Path for search index file, it can be a relative path or an absolute path</span><br>  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">/local-search.xml</span><br><br>  <span class=\"hljs-comment\"># 文件生成在本地的位置，必须是相对路径</span><br>  <span class=\"hljs-comment\"># The location where the index file is generated locally, it must be a relative location</span><br>  <span class=\"hljs-attr\">generate_path:</span> <span class=\"hljs-string\">/local-search.xml</span><br><br>  <span class=\"hljs-comment\"># 搜索的范围</span><br>  <span class=\"hljs-comment\"># Search field</span><br>  <span class=\"hljs-comment\"># Options: post | page | all</span><br>  <span class=\"hljs-attr\">field:</span> <span class=\"hljs-string\">post</span><br><br>  <span class=\"hljs-comment\"># 搜索是否扫描正文</span><br>  <span class=\"hljs-comment\"># If true, search will scan the post content</span><br>  <span class=\"hljs-attr\">content:</span> <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\"># 首屏图片的相关配置</span><br><span class=\"hljs-comment\"># Config of the big image on the first screen</span><br><span class=\"hljs-attr\">banner:</span><br>  <span class=\"hljs-comment\"># 视差滚动，图片与板块会随着屏幕滚动产生视差效果</span><br>  <span class=\"hljs-comment\"># Scrolling parallax</span><br>  <span class=\"hljs-attr\">parallax:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 图片最小的宽高比，以免图片两边被过度裁剪，适用于移动端竖屏时，如需关闭设为 0</span><br>  <span class=\"hljs-comment\"># Minimum ratio of width to height, applicable to the vertical screen of mobile device, if you need to close it, set it to 0</span><br>  <span class=\"hljs-attr\">width_height_ratio:</span> <span class=\"hljs-number\">1.0</span><br><br><span class=\"hljs-comment\"># 向下滚动的箭头</span><br><span class=\"hljs-comment\"># Scroll down arrow</span><br><span class=\"hljs-attr\">scroll_down_arrow:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 头图高度不小于指定比例，才显示箭头</span><br>  <span class=\"hljs-comment\"># Only the height of the banner image is greater than the ratio, the arrow is displayed</span><br>  <span class=\"hljs-comment\"># Available: 0 - 100</span><br>  <span class=\"hljs-attr\">banner_height_limit:</span> <span class=\"hljs-number\">80</span><br><br>  <span class=\"hljs-comment\"># 翻页后自动滚动</span><br>  <span class=\"hljs-comment\"># Auto scroll after page turning</span><br>  <span class=\"hljs-attr\">scroll_after_turning_page:</span> <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\"># 向顶部滚动的箭头</span><br><span class=\"hljs-comment\"># Scroll top arrow</span><br><span class=\"hljs-attr\">scroll_top_arrow:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\"># Open Graph metadata</span><br><span class=\"hljs-comment\"># See: https://hexo.io/docs/helpers.html#open-graph</span><br><span class=\"hljs-attr\">open_graph:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">twitter_card:</span> <span class=\"hljs-string\">summary_large_image</span><br>  <span class=\"hljs-attr\">twitter_id:</span><br>  <span class=\"hljs-attr\">twitter_site:</span><br>  <span class=\"hljs-attr\">google_plus:</span><br>  <span class=\"hljs-attr\">fb_admins:</span><br>  <span class=\"hljs-attr\">fb_app_id:</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 页脚</span><br><span class=\"hljs-comment\"># Footer</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">footer:</span><br>  <span class=\"hljs-comment\"># 页脚第一行文字的 HTML，建议保留 Fluid 的链接，用于向更多人推广本主题</span><br>  <span class=\"hljs-comment\"># HTML of the first line of the footer, it is recommended to keep the Fluid link to promote this theme to more people</span><br>  <span class=\"hljs-attr\">content:</span> <span class=\"hljs-string\">&#x27;</span><br><span class=\"hljs-string\">    &lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Hexo&lt;/span&gt;&lt;/a&gt;</span><br><span class=\"hljs-string\">    &lt;i class=&quot;iconfont icon-love&quot;&gt;&lt;/i&gt;</span><br><span class=\"hljs-string\">    &lt;a href=&quot;https://github.com/fluid-dev/hexo-theme-fluid&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;span&gt;Fluid&lt;/span&gt;&lt;/a&gt;</span><br><span class=\"hljs-string\">  &#x27;</span><br><br>  <span class=\"hljs-comment\"># 展示网站的 PV、UV 统计数</span><br>  <span class=\"hljs-comment\"># Display website PV and UV statistics</span><br>  <span class=\"hljs-attr\">statistics:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 统计数据来源，使用 leancloud 需要设置 `web_analytics: leancloud` 中的参数；使用 busuanzi 不需要额外设置，但是有时不稳定，另外本地运行时 busuanzi 显示统计数据很大属于正常现象，部署后会正常</span><br>    <span class=\"hljs-comment\"># Data source. If use leancloud, you need to set the parameter in `web_analytics: leancloud`</span><br>    <span class=\"hljs-comment\"># Options: busuanzi | leancloud</span><br>    <span class=\"hljs-attr\">source:</span> <span class=\"hljs-string\">&quot;busuanzi&quot;</span><br><br>  <span class=\"hljs-comment\"># 国内大陆服务器的备案信息</span><br>  <span class=\"hljs-comment\"># For Chinese mainland website policy, other areas keep disable</span><br>  <span class=\"hljs-attr\">beian:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-comment\"># ICP证号</span><br>    <span class=\"hljs-attr\">icp_text:</span> <span class=\"hljs-string\">京ICP证123456号</span><br>    <span class=\"hljs-comment\"># 公安备案号，不填则只显示ICP</span><br>    <span class=\"hljs-attr\">police_text:</span> <span class=\"hljs-string\">京公网安备12345678号</span><br>    <span class=\"hljs-comment\"># 公安备案的编号，用于URL跳转查询</span><br>    <span class=\"hljs-attr\">police_code:</span> <span class=\"hljs-number\">12345678</span><br>    <span class=\"hljs-comment\"># 公安备案的图片. 为空时不显示备案图片</span><br>    <span class=\"hljs-attr\">police_icon:</span> <span class=\"hljs-string\">/img/police_beian.png</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 首页</span><br><span class=\"hljs-comment\"># Home Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">index:</span><br>  <span class=\"hljs-comment\"># 首页 Banner 头图，可以是相对路径或绝对路径，以下相同</span><br>  <span class=\"hljs-comment\"># Path of Banner image, can be a relative path or an absolute path, the same on other pages</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br><br>  <span class=\"hljs-comment\"># 头图高度，屏幕百分比</span><br>  <span class=\"hljs-comment\"># Height ratio of banner image</span><br>  <span class=\"hljs-comment\"># Available: 0 - 100</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">100</span><br><br>  <span class=\"hljs-comment\"># 头图黑色蒙版的不透明度，available: 0 - 1.0， 1 是完全不透明</span><br>  <span class=\"hljs-comment\"># Opacity of the banner mask, 1.0 is completely opaque</span><br>  <span class=\"hljs-comment\"># Available: 0 - 1.0</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br><br>  <span class=\"hljs-comment\"># 首页副标题的独立设置</span><br>  <span class=\"hljs-comment\"># Independent config of home page subtitle</span><br>  <span class=\"hljs-attr\">slogan:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 为空则按 hexo config.subtitle 显示</span><br>    <span class=\"hljs-comment\"># If empty, text based on `subtitle` in hexo config</span><br>    <span class=\"hljs-attr\">text:</span> <span class=\"hljs-string\">&quot;An elegant Material-Design theme for Hexo&quot;</span><br><br>    <span class=\"hljs-comment\"># 通过 API 接口作为首页副标题的内容，必须返回的是 JSON 格式，如果请求失败则按 text 字段显示，该功能必须先开启 typing 打字机功能</span><br>    <span class=\"hljs-comment\"># Subtitle of the homepage through the API, must be returned a JSON. If the request fails, it will be displayed in `text` value. This feature must first enable the typing animation</span><br>    <span class=\"hljs-attr\">api:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>      <span class=\"hljs-comment\"># 请求地址</span><br>      <span class=\"hljs-comment\"># Request url</span><br>      <span class=\"hljs-attr\">url:</span> <span class=\"hljs-string\">&quot;&quot;</span><br><br>      <span class=\"hljs-comment\"># 请求方法</span><br>      <span class=\"hljs-comment\"># Request method</span><br>      <span class=\"hljs-comment\"># Available: GET | POST | PUT</span><br>      <span class=\"hljs-attr\">method:</span> <span class=\"hljs-string\">&quot;GET&quot;</span><br><br>      <span class=\"hljs-comment\"># 请求头</span><br>      <span class=\"hljs-comment\"># Request headers</span><br>      <span class=\"hljs-attr\">headers:</span> &#123;&#125;<br><br>      <span class=\"hljs-comment\"># 从请求结果获取字符串的取值字段，最终必须是一个字符串，例如返回结果为 &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, 则取值字段为 [&#x27;data&#x27;, &#x27;content&#x27;]；如果返回是列表则自动选择第一项</span><br>      <span class=\"hljs-comment\"># The value field of the string obtained from the response. For example, the response content is &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, the expected `keys: [&#x27;data&#x27;,&#x27;content&#x27;]`; if the return is a list, the first item is automatically selected</span><br>      <span class=\"hljs-attr\">keys:</span> []<br><br>  <span class=\"hljs-comment\"># 自动截取文章摘要</span><br>  <span class=\"hljs-comment\"># Auto extract post</span><br>  <span class=\"hljs-attr\">auto_excerpt:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 打开文章的标签方式</span><br>  <span class=\"hljs-comment\"># The browser tag to open the post</span><br>  <span class=\"hljs-comment\"># Available: _blank | _self</span><br>  <span class=\"hljs-attr\">post_url_target:</span> <span class=\"hljs-string\">_self</span><br><br>  <span class=\"hljs-comment\"># 是否显示文章信息（时间、分类、标签）</span><br>  <span class=\"hljs-comment\"># Meta information of post</span><br>  <span class=\"hljs-attr\">post_meta:</span><br>    <span class=\"hljs-attr\">date:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">category:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">tag:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 文章通过 sticky 排序后，在首页文章标题前显示图标</span><br>  <span class=\"hljs-comment\"># If the posts are sorted by `sticky`, an icon is displayed in front of the post title</span><br>  <span class=\"hljs-attr\">post_sticky:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-attr\">icon:</span> <span class=\"hljs-string\">&quot;iconfont icon-top&quot;</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 文章页</span><br><span class=\"hljs-comment\"># Post Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">post:</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">70</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br><br>  <span class=\"hljs-comment\"># 文章在首页的默认封面图，当没有指定 index_img 时会使用该图片，若两者都为空则不显示任何图片</span><br>  <span class=\"hljs-comment\"># Path of the default post cover when `index_img` is not set. If both are empty, no image will be displayed</span><br>  <span class=\"hljs-attr\">default_index_img:</span><br><br>  <span class=\"hljs-comment\"># 文章标题下方的元信息</span><br>  <span class=\"hljs-comment\"># Meta information below title</span><br>  <span class=\"hljs-attr\">meta:</span><br>    <span class=\"hljs-comment\"># 作者，优先根据 front-matter 里 author 字段，其次是 hexo 配置中 author 值</span><br>    <span class=\"hljs-comment\"># Author, based on `author` field in front-matter, if not set, based on `author` value in hexo config</span><br>    <span class=\"hljs-attr\">author:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 文章日期，优先根据 front-matter 里 date 字段，其次是 md 文件日期</span><br>    <span class=\"hljs-comment\"># Post date, based on `date` field in front-matter, if not set, based on create date of .md file</span><br>    <span class=\"hljs-attr\">date:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>      <span class=\"hljs-comment\"># 格式参照 ISO-8601 日期格式化</span><br>      <span class=\"hljs-comment\"># ISO-8601 date format</span><br>      <span class=\"hljs-comment\"># See: http://momentjs.cn/docs/#/parsing/string-format/</span><br>      <span class=\"hljs-attr\">format:</span> <span class=\"hljs-string\">&quot;LL a&quot;</span><br><br>    <span class=\"hljs-comment\"># 字数统计</span><br>    <span class=\"hljs-comment\"># Word count</span><br>    <span class=\"hljs-attr\">wordcount:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 估计阅读全文需要的时长</span><br>    <span class=\"hljs-comment\"># Estimated reading time</span><br>    <span class=\"hljs-attr\">min2read:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>      <span class=\"hljs-comment\"># 每个字词的长度，建议：中文≈2，英文≈5，中英混合可自行调节</span><br>      <span class=\"hljs-comment\"># Average word length (chars count in word), ZH ≈ 2, EN ≈ 5</span><br>      <span class=\"hljs-attr\">awl:</span> <span class=\"hljs-number\">2</span><br>      <span class=\"hljs-comment\"># 每分钟阅读字数，如果大部分是技术文章可适度调低</span><br>      <span class=\"hljs-comment\"># Words per minute</span><br>      <span class=\"hljs-attr\">wpm:</span> <span class=\"hljs-number\">60</span><br><br>    <span class=\"hljs-comment\"># 浏览量计数</span><br>    <span class=\"hljs-comment\"># Number of visits</span><br>    <span class=\"hljs-attr\">views:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>      <span class=\"hljs-comment\"># 统计数据来源</span><br>      <span class=\"hljs-comment\"># Data Source</span><br>      <span class=\"hljs-comment\"># Options: busuanzi | leancloud</span><br>      <span class=\"hljs-attr\">source:</span> <span class=\"hljs-string\">&quot;busuanzi&quot;</span><br><br>  <span class=\"hljs-comment\"># 在文章开头显示文章更新时间，该时间默认是 md 文件更新时间，可通过 front-matter 中 `updated` 手动指定（和 date 一样格式）</span><br>  <span class=\"hljs-comment\"># Update date is displayed at the beginning of the post. The default date is the update date of the md file, which can be manually specified by `updated` in front-matter (same format as date)</span><br>  <span class=\"hljs-attr\">updated:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 格式参照 ISO-8601 日期格式化</span><br>    <span class=\"hljs-comment\"># ISO-8601 date format</span><br>    <span class=\"hljs-comment\"># See: http://momentjs.cn/docs/#/parsing/string-format/</span><br>    <span class=\"hljs-attr\">date_format:</span> <span class=\"hljs-string\">&quot;LL a&quot;</span><br><br>    <span class=\"hljs-comment\"># 是否使用相对时间表示，比如：&quot;3 天前&quot;</span><br>    <span class=\"hljs-comment\"># If true, it will be a relative time, such as: &quot;3 days ago&quot;</span><br>    <span class=\"hljs-attr\">relative:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 提示标签类型</span><br>    <span class=\"hljs-comment\"># Note class</span><br>    <span class=\"hljs-comment\"># Options: default | primary | info | success | warning | danger | light</span><br>    <span class=\"hljs-attr\">note_class:</span> <span class=\"hljs-string\">info</span><br><br>  <span class=\"hljs-comment\"># 侧边栏展示当前分类下的文章</span><br>  <span class=\"hljs-comment\"># Sidebar of category</span><br>  <span class=\"hljs-attr\">category_bar:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 开启后，只有在文章 Front-matter 里指定 `category_bar: true` 才会展示分类，也可以通过 `category_bar: [&quot;分类A&quot;]` 来指定分类</span><br>    <span class=\"hljs-comment\"># If true, only set `category_bar: true` in Front-matter will enable sidebar of category, also set `category_bar: [&quot;CategoryA&quot;]` to specify categories</span><br>    <span class=\"hljs-attr\">specific:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 置于板块的左侧或右侧</span><br>    <span class=\"hljs-comment\"># place in the board</span><br>    <span class=\"hljs-comment\"># Options: left | right</span><br>    <span class=\"hljs-attr\">placement:</span> <span class=\"hljs-string\">left</span><br><br>    <span class=\"hljs-comment\"># 文章的排序字段，前面带减号是倒序，不带减号是正序</span><br>    <span class=\"hljs-comment\"># Sort field for posts, with a minus sign is reverse order</span><br>    <span class=\"hljs-comment\"># Options: date | title | or other field of front-matter</span><br>    <span class=\"hljs-attr\">post_order_by:</span> <span class=\"hljs-string\">&quot;title&quot;</span><br><br>    <span class=\"hljs-comment\"># 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制</span><br>    <span class=\"hljs-comment\"># The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit</span><br>    <span class=\"hljs-attr\">post_limit:</span> <span class=\"hljs-number\">0</span><br><br>  <span class=\"hljs-comment\"># 侧边栏展示文章目录</span><br>  <span class=\"hljs-comment\"># Table of contents (TOC) in the sidebar</span><br>  <span class=\"hljs-attr\">toc:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 置于板块的左侧或右侧</span><br>    <span class=\"hljs-comment\"># place in the board</span><br>    <span class=\"hljs-comment\"># Options: left | right</span><br>    <span class=\"hljs-attr\">placement:</span> <span class=\"hljs-string\">right</span><br><br>    <span class=\"hljs-comment\"># 目录会选择这些节点作为标题</span><br>    <span class=\"hljs-comment\"># TOC will select these nodes as headings</span><br>    <span class=\"hljs-attr\">headingSelector:</span> <span class=\"hljs-string\">&quot;h1,h2,h3,h4,h5,h6&quot;</span><br><br>    <span class=\"hljs-comment\"># 层级的折叠深度，0 是全部折叠，大于 0 后如果存在下级标题则默认展开</span><br>    <span class=\"hljs-comment\"># Collapse depth. If 0, all headings collapsed. If greater than 0, it will be expanded by default if there are sub headings</span><br>    <span class=\"hljs-attr\">collapseDepth:</span> <span class=\"hljs-number\">0</span><br><br>  <span class=\"hljs-comment\"># 版权声明，会显示在每篇文章的结尾</span><br>  <span class=\"hljs-comment\"># Copyright, will be displayed at the end of each post</span><br>  <span class=\"hljs-attr\">copyright:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># CreativeCommons license</span><br>    <span class=\"hljs-comment\"># Options: BY | BY-SA | BY-ND | BY-NC | BY-NC-SA | BY-NC-ND</span><br>    <span class=\"hljs-attr\">license:</span> <span class=\"hljs-string\">&#x27;BY&#x27;</span><br><br>    <span class=\"hljs-comment\"># 显示作者</span><br>    <span class=\"hljs-attr\">author:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>    <span class=\"hljs-comment\"># 显示发布日期</span><br>    <span class=\"hljs-comment\"># Show post date</span><br>    <span class=\"hljs-attr\">post_date:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>      <span class=\"hljs-attr\">format:</span> <span class=\"hljs-string\">&quot;LL&quot;</span><br><br>    <span class=\"hljs-comment\"># 显示更新日期</span><br>    <span class=\"hljs-comment\"># Show update date</span><br>    <span class=\"hljs-attr\">update_date:</span><br>      <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>      <span class=\"hljs-attr\">format:</span> <span class=\"hljs-string\">&quot;LL&quot;</span><br><br>  <span class=\"hljs-comment\"># 文章底部上一篇下一篇功能</span><br>  <span class=\"hljs-comment\"># Link to previous/next post</span><br>  <span class=\"hljs-attr\">prev_next:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 文章图片标题</span><br>  <span class=\"hljs-comment\"># Image caption</span><br>  <span class=\"hljs-attr\">image_caption:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-comment\"># 文章图片可点击放大</span><br>  <span class=\"hljs-comment\"># Zoom feature of images</span><br>  <span class=\"hljs-attr\">image_zoom:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-comment\"># 放大后图片链接替换规则，可用于将压缩图片链接替换为原图片链接，如 [&#x27;-slim&#x27;, &#x27;&#x27;] 是将链接中 `-slim` 移除；如果想使用正则请使用 `re:` 前缀，如 [&#x27;re:\\\\d&#123;3,4&#125;\\\\/\\\\d&#123;3,4&#125;\\\\/&#x27;, &#x27;&#x27;]</span><br>    <span class=\"hljs-comment\"># The image url replacement when zooming, the feature can be used to replace the compressed image to the original image, eg: [&#x27;-slim&#x27;, &#x27;&#x27;] removes `-slim` from the image url when zooming; if you want to use regular, use prefix `re:`, eg: [&#x27;re:\\\\d&#123;3,4&#125;\\\\/\\\\d&#123;3,4&#125;\\\\/&#x27;,&#x27;&#x27;]</span><br>    <span class=\"hljs-attr\">img_url_replace:</span> [<span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>]<br><br>  <span class=\"hljs-comment\"># 脚注语法，会在文章底部生成脚注，如果 Markdown 渲染器本身支持，则建议关闭，否则可能会冲突</span><br>  <span class=\"hljs-comment\"># Support footnote syntax, footnotes will be generated at the bottom of the post page. If the Markdown renderer itself supports it, please disable it, otherwise it may conflict</span><br>  <span class=\"hljs-attr\">footnote:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>    <span class=\"hljs-comment\"># 脚注的节标题，也可以在 front-matter 中通过 `foot<span class=\"hljs-doctag\">note:</span> &lt;h2&gt;Reference&lt;/h2&gt;` 这种形式修改单独页面的 header</span><br>    <span class=\"hljs-comment\"># The section title of the footnote, you can also modify the header of a single page in the form of `foot<span class=\"hljs-doctag\">note:</span> &lt;h2&gt;Reference&lt;/h2&gt;` in front-matter</span><br>    <span class=\"hljs-attr\">header:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><br>  <span class=\"hljs-comment\"># 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式</span><br>  <span class=\"hljs-comment\"># Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math</span><br>  <span class=\"hljs-attr\">math:</span><br>    <span class=\"hljs-comment\"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span><br>    <span class=\"hljs-comment\"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>    <span class=\"hljs-comment\"># If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math</span><br>    <span class=\"hljs-attr\">specific:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># Options: mathjax | katex</span><br>    <span class=\"hljs-attr\">engine:</span> <span class=\"hljs-string\">mathjax</span><br><br>  <span class=\"hljs-comment\"># 流程图，基于 mermaid-js，具体请见：https://hexo.fluid-dev.com/docs/guide/#mermaid-流程图</span><br>  <span class=\"hljs-comment\"># Flow chart, based on mermaid-js, see: https://hexo.fluid-dev.com/docs/en/guide/#mermaid</span><br>  <span class=\"hljs-attr\">mermaid:</span><br>    <span class=\"hljs-comment\"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `mermaid: true`</span><br>    <span class=\"hljs-comment\"># If you want to use mermaid on the custom page, you need to set `mermaid: true` in Front-matter</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># 开启后，只有在文章 Front-matter 里指定 `mermaid: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>    <span class=\"hljs-comment\"># If true, only set `mermaid: true` in Front-matter will enable mermaid, to load faster when the page does not contain mermaid</span><br>    <span class=\"hljs-attr\">specific:</span> <span class=\"hljs-literal\">false</span><br><br>    <span class=\"hljs-comment\"># See: http://mermaid-js.github.io/mermaid/</span><br>    <span class=\"hljs-attr\">options:</span> &#123; <span class=\"hljs-attr\">theme:</span> <span class=\"hljs-string\">&#x27;default&#x27;</span> &#125;<br><br>  <span class=\"hljs-comment\"># 评论插件</span><br>  <span class=\"hljs-comment\"># Comment plugin</span><br>  <span class=\"hljs-attr\">comments:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-comment\"># 指定的插件，需要同时设置对应插件的必要参数</span><br>    <span class=\"hljs-comment\"># The specified plugin needs to set the necessary parameters at the same time</span><br>    <span class=\"hljs-comment\"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>    <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">disqus</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 评论插件</span><br><span class=\"hljs-comment\"># Comment plugins</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># 开启评论需要先设置上方 `post: comments: enable: true`，然后根据 `type` 设置下方对应的评论插件参数</span><br><span class=\"hljs-comment\"># Enable comments need to be set `post: comments: enable: true`, then set the corresponding comment plugin parameters below according to `type`</span><br><span class=\"hljs-comment\">#---------------------------</span><br><br><span class=\"hljs-comment\"># Utterances</span><br><span class=\"hljs-comment\"># 基于 GitHub Issues</span><br><span class=\"hljs-comment\"># Based on GitHub Issues</span><br><span class=\"hljs-comment\"># See: https://utteranc.es</span><br><span class=\"hljs-attr\">utterances:</span><br>  <span class=\"hljs-attr\">repo:</span><br>  <span class=\"hljs-attr\">issue_term:</span> <span class=\"hljs-string\">pathname</span><br>  <span class=\"hljs-attr\">label:</span> <span class=\"hljs-string\">utterances</span><br>  <span class=\"hljs-attr\">theme:</span> <span class=\"hljs-string\">github-light</span><br>  <span class=\"hljs-attr\">theme_dark:</span> <span class=\"hljs-string\">github-dark</span><br><br><span class=\"hljs-comment\"># Disqus</span><br><span class=\"hljs-comment\"># 基于第三方的服务，国内用户直接使用容易被墙，建议配合 Disqusjs</span><br><span class=\"hljs-comment\"># Based on third-party service</span><br><span class=\"hljs-comment\"># See: https://disqus.com</span><br><span class=\"hljs-attr\">disqus:</span><br>  <span class=\"hljs-attr\">shortname:</span><br>  <span class=\"hljs-comment\"># 以下为 Disqusjs 支持, 国内用户如果想使用 Disqus 建议配合使用</span><br>  <span class=\"hljs-comment\"># The following are Disqusjs configurations, please ignore if DisqusJS is not required</span><br>  <span class=\"hljs-comment\"># See: https://github.com/SukkaW/DisqusJS</span><br>  <span class=\"hljs-attr\">disqusjs:</span> <span class=\"hljs-literal\">false</span><br>  <span class=\"hljs-attr\">apikey:</span><br><br><span class=\"hljs-comment\"># Gitalk</span><br><span class=\"hljs-comment\"># 基于 GitHub Issues</span><br><span class=\"hljs-comment\"># Based on GitHub Issues</span><br><span class=\"hljs-comment\"># See: https://github.com/gitalk/gitalk#options</span><br><span class=\"hljs-attr\">gitalk:</span><br>  <span class=\"hljs-attr\">clientID:</span><br>  <span class=\"hljs-attr\">clientSecret:</span><br>  <span class=\"hljs-attr\">repo:</span><br>  <span class=\"hljs-attr\">owner:</span><br>  <span class=\"hljs-attr\">admin:</span> [<span class=\"hljs-string\">&#x27;name&#x27;</span>]<br>  <span class=\"hljs-attr\">language:</span> <span class=\"hljs-string\">zh-CN</span><br>  <span class=\"hljs-attr\">labels:</span> [<span class=\"hljs-string\">&#x27;Gitalk&#x27;</span>]<br>  <span class=\"hljs-attr\">perPage:</span> <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-attr\">pagerDirection:</span> <span class=\"hljs-string\">last</span><br>  <span class=\"hljs-attr\">distractionFreeMode:</span> <span class=\"hljs-literal\">false</span><br>  <span class=\"hljs-attr\">createIssueManually:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-comment\"># 默认 proxy 可能会失效，解决方法请见下方链接</span><br>  <span class=\"hljs-comment\"># The default proxy may be invalid, refer to the links for solutions</span><br>  <span class=\"hljs-comment\"># https://github.com/gitalk/gitalk/issues/429</span><br>  <span class=\"hljs-comment\"># https://github.com/Zibri/cloudflare-cors-anywhere</span><br>  <span class=\"hljs-attr\">proxy:</span> <span class=\"hljs-string\">https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</span><br><br><span class=\"hljs-comment\"># Valine</span><br><span class=\"hljs-comment\"># 基于 LeanCloud</span><br><span class=\"hljs-comment\"># Based on LeanCloud</span><br><span class=\"hljs-comment\"># See: https://valine.js.org/</span><br><span class=\"hljs-attr\">valine:</span><br>  <span class=\"hljs-attr\">appId:</span><br>  <span class=\"hljs-attr\">appKey:</span><br>  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">window.location.pathname</span><br>  <span class=\"hljs-attr\">placeholder:</span><br>  <span class=\"hljs-attr\">avatar:</span> <span class=\"hljs-string\">&#x27;retro&#x27;</span><br>  <span class=\"hljs-attr\">meta:</span> [<span class=\"hljs-string\">&#x27;nick&#x27;</span>, <span class=\"hljs-string\">&#x27;mail&#x27;</span>, <span class=\"hljs-string\">&#x27;link&#x27;</span>]<br>  <span class=\"hljs-attr\">requiredFields:</span> []<br>  <span class=\"hljs-attr\">pageSize:</span> <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-attr\">lang:</span> <span class=\"hljs-string\">&#x27;zh-CN&#x27;</span><br>  <span class=\"hljs-attr\">highlight:</span> <span class=\"hljs-literal\">false</span><br>  <span class=\"hljs-attr\">recordIP:</span> <span class=\"hljs-literal\">false</span><br>  <span class=\"hljs-attr\">serverURLs:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br>  <span class=\"hljs-attr\">emojiCDN:</span><br>  <span class=\"hljs-attr\">emojiMaps:</span><br>  <span class=\"hljs-attr\">enableQQ:</span> <span class=\"hljs-literal\">false</span><br><br><span class=\"hljs-comment\"># Waline</span><br><span class=\"hljs-comment\"># 从 Valine 衍生而来，额外增加了服务端和多种功能</span><br><span class=\"hljs-comment\"># Derived from Valine, with self-hosted service and new features</span><br><span class=\"hljs-comment\"># See: https://waline.js.org/</span><br><span class=\"hljs-attr\">waline:</span><br>  <span class=\"hljs-attr\">serverURL:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br>  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">window.location.pathname</span><br>  <span class=\"hljs-attr\">meta:</span> [<span class=\"hljs-string\">&#x27;nick&#x27;</span>, <span class=\"hljs-string\">&#x27;mail&#x27;</span>, <span class=\"hljs-string\">&#x27;link&#x27;</span>]<br>  <span class=\"hljs-attr\">requiredMeta:</span> [<span class=\"hljs-string\">&#x27;nick&#x27;</span>]<br>  <span class=\"hljs-attr\">lang:</span> <span class=\"hljs-string\">&#x27;zh-CN&#x27;</span><br>  <span class=\"hljs-attr\">emoji:</span> [<span class=\"hljs-string\">&#x27;https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo&#x27;</span>]<br>  <span class=\"hljs-attr\">dark:</span> <span class=\"hljs-string\">&#x27;html[data-user-color-scheme=&quot;dark&quot;]&#x27;</span><br>  <span class=\"hljs-attr\">wordLimit:</span> <span class=\"hljs-number\">0</span><br>  <span class=\"hljs-attr\">pageSize:</span> <span class=\"hljs-number\">10</span><br><br><span class=\"hljs-comment\"># 畅言 Changyan</span><br><span class=\"hljs-comment\"># 基于第三方的服务</span><br><span class=\"hljs-comment\"># Based on third-party service, insufficient support for regions outside China</span><br><span class=\"hljs-comment\"># http://changyan.kuaizhan.com</span><br><span class=\"hljs-attr\">changyan:</span><br>  <span class=\"hljs-attr\">appid:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br>  <span class=\"hljs-attr\">appkey:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><br><span class=\"hljs-comment\"># 来必力 Livere</span><br><span class=\"hljs-comment\"># 基于第三方的服务</span><br><span class=\"hljs-comment\"># Based on third-party service</span><br><span class=\"hljs-comment\"># See: https://www.livere.com</span><br><span class=\"hljs-attr\">livere:</span><br>  <span class=\"hljs-attr\">uid:</span> <span class=\"hljs-string\">&#x27;&#x27;</span><br><br><span class=\"hljs-comment\"># Remark42</span><br><span class=\"hljs-comment\"># 需要自托管服务端</span><br><span class=\"hljs-comment\"># Based on self-hosted service</span><br><span class=\"hljs-comment\"># See: https://remark42.com</span><br><span class=\"hljs-attr\">remark42:</span><br>  <span class=\"hljs-attr\">host:</span><br>  <span class=\"hljs-attr\">site_id:</span><br>  <span class=\"hljs-attr\">max_shown_comments:</span> <span class=\"hljs-number\">10</span><br>  <span class=\"hljs-attr\">locale:</span> <span class=\"hljs-string\">zh</span><br>  <span class=\"hljs-attr\">components:</span> [<span class=\"hljs-string\">&#x27;embed&#x27;</span>]<br><br><span class=\"hljs-comment\"># Twikoo</span><br><span class=\"hljs-comment\"># 支持腾讯云、Vercel、Railway 等多种平台部署</span><br><span class=\"hljs-comment\"># Based on Tencent CloudBase</span><br><span class=\"hljs-comment\"># See: https://twikoo.js.org</span><br><span class=\"hljs-attr\">twikoo:</span><br>  <span class=\"hljs-attr\">envId:</span><br>  <span class=\"hljs-attr\">region:</span> <span class=\"hljs-string\">ap-shanghai</span><br>  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">window.location.pathname</span><br><br><span class=\"hljs-comment\"># Cusdis</span><br><span class=\"hljs-comment\"># 基于第三方服务或自托管服务</span><br><span class=\"hljs-comment\"># Based on third-party or self-hosted service</span><br><span class=\"hljs-comment\"># See https://cusdis.com</span><br><span class=\"hljs-attr\">cusdis:</span><br>  <span class=\"hljs-attr\">host:</span><br>  <span class=\"hljs-attr\">app_id:</span><br>  <span class=\"hljs-attr\">lang:</span> <span class=\"hljs-string\">zh-cn</span><br><br><span class=\"hljs-comment\"># Giscus</span><br><span class=\"hljs-comment\"># 基于 GitHub Discussions，类似于 Utterances</span><br><span class=\"hljs-comment\"># Based on GitHub Discussions, similar to Utterances</span><br><span class=\"hljs-comment\"># See: https://giscus.app/</span><br><span class=\"hljs-attr\">giscus:</span><br>  <span class=\"hljs-attr\">repo:</span><br>  <span class=\"hljs-attr\">repo-id:</span><br>  <span class=\"hljs-attr\">category:</span><br>  <span class=\"hljs-attr\">category-id:</span><br>  <span class=\"hljs-attr\">theme-light:</span> <span class=\"hljs-string\">light</span><br>  <span class=\"hljs-attr\">theme-dark:</span> <span class=\"hljs-string\">dark</span><br>  <span class=\"hljs-attr\">mapping:</span> <span class=\"hljs-string\">pathname</span><br>  <span class=\"hljs-attr\">reactions-enabled:</span> <span class=\"hljs-number\">1</span><br>  <span class=\"hljs-attr\">emit-metadata:</span> <span class=\"hljs-number\">0</span><br>  <span class=\"hljs-attr\">input-position:</span> <span class=\"hljs-string\">top</span><br>  <span class=\"hljs-attr\">lang:</span> <span class=\"hljs-string\">zh-CN</span><br><br><span class=\"hljs-comment\"># Discuss</span><br><span class=\"hljs-comment\"># 多平台、多数据库、自托管、免费开源评论系统</span><br><span class=\"hljs-comment\"># Self-hosted, small size, multi-platform, multi-database, free and open source commenting system</span><br><span class=\"hljs-comment\"># See: https://discuss.js.org</span><br><span class=\"hljs-attr\">discuss:</span><br>  <span class=\"hljs-attr\">serverURLs:</span><br>  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">window.location.pathname</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 归档页</span><br><span class=\"hljs-comment\"># Archive Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">archive:</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">60</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 分类页</span><br><span class=\"hljs-comment\"># Category Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">category:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">60</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br><br>  <span class=\"hljs-comment\"># 分类的排序字段，前面带减号是倒序，不带减号是正序</span><br>  <span class=\"hljs-comment\"># Sort field for categories, with a minus sign is reverse order</span><br>  <span class=\"hljs-comment\"># Options: length | name</span><br>  <span class=\"hljs-attr\">order_by:</span> <span class=\"hljs-string\">&quot;-length&quot;</span><br><br>  <span class=\"hljs-comment\"># 层级的折叠深度，0 是全部折叠，大于 0 后如果存在子分类则默认展开</span><br>  <span class=\"hljs-comment\"># Collapse depth. If 0, all posts collapsed. If greater than 0, it will be expanded by default if there are subcategories</span><br>  <span class=\"hljs-attr\">collapse_depth:</span> <span class=\"hljs-number\">0</span><br><br>  <span class=\"hljs-comment\"># 文章的排序字段，前面带减号是倒序，不带减号是正序</span><br>  <span class=\"hljs-comment\"># Sort field for posts, with a minus sign is reverse order</span><br>  <span class=\"hljs-comment\"># Options: date | title | or other field of front-matter</span><br>  <span class=\"hljs-attr\">post_order_by:</span> <span class=\"hljs-string\">&quot;-date&quot;</span><br><br>  <span class=\"hljs-comment\"># 单个分类中折叠展示文章数的最大值，超过限制会显示 More，0 则不限制</span><br>  <span class=\"hljs-comment\"># The maximum number of posts in a single category. If the limit is exceeded, it will be displayed More. If 0 no limit</span><br>  <span class=\"hljs-attr\">post_limit:</span> <span class=\"hljs-number\">10</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 标签页</span><br><span class=\"hljs-comment\"># Tag Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">tag:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">80</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br>  <span class=\"hljs-attr\">tagcloud:</span><br>    <span class=\"hljs-attr\">min_font:</span> <span class=\"hljs-number\">15</span><br>    <span class=\"hljs-attr\">max_font:</span> <span class=\"hljs-number\">30</span><br>    <span class=\"hljs-attr\">unit:</span> <span class=\"hljs-string\">px</span><br>    <span class=\"hljs-attr\">start_color:</span> <span class=\"hljs-string\">&quot;#BBBBEE&quot;</span><br>    <span class=\"hljs-attr\">end_color:</span> <span class=\"hljs-string\">&quot;#337ab7&quot;</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 关于页</span><br><span class=\"hljs-comment\"># About Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">about:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">60</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br>  <span class=\"hljs-attr\">avatar:</span> <span class=\"hljs-string\">/img/avatar.png</span><br>  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">&quot;Fluid&quot;</span><br>  <span class=\"hljs-attr\">intro:</span> <span class=\"hljs-string\">&quot;An elegant theme for Hexo&quot;</span><br>  <span class=\"hljs-comment\"># 更多图标可从 https://hexo.fluid-dev.com/docs/icon/ 查找，`class` 代表图标的 css class，添加 `qrcode` 后，图标不再是链接而是悬浮二维码</span><br>  <span class=\"hljs-comment\"># More icons can be found from https://hexo.fluid-dev.com/docs/en/icon/  `class` is the css class of the icon. If adding `qrcode`, The icon is no longer a link, but a hovering QR code</span><br>  <span class=\"hljs-attr\">icons:</span><br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">class:</span> <span class=\"hljs-string\">&quot;iconfont icon-github-fill&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;https://github.com&quot;</span>, <span class=\"hljs-attr\">tip:</span> <span class=\"hljs-string\">&quot;GitHub&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">class:</span> <span class=\"hljs-string\">&quot;iconfont icon-douban-fill&quot;</span>, <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;https://douban.com&quot;</span>, <span class=\"hljs-attr\">tip:</span> <span class=\"hljs-string\">&quot;豆瓣&quot;</span> &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123; <span class=\"hljs-attr\">class:</span> <span class=\"hljs-string\">&quot;iconfont icon-wechat-fill&quot;</span>, <span class=\"hljs-attr\">qrcode:</span> <span class=\"hljs-string\">&quot;/img/favicon.png&quot;</span> &#125;<br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 自定义页</span><br><span class=\"hljs-comment\"># Custom Page</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># 通过 hexo new page 命令创建的页面</span><br><span class=\"hljs-comment\"># Custom Page through `hexo new page`</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">page:</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">60</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 404页</span><br><span class=\"hljs-comment\"># 404 Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">page404:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">85</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br>  <span class=\"hljs-comment\"># 重定向到首页的延迟(毫秒)</span><br>  <span class=\"hljs-comment\"># Delay in redirecting to home page (milliseconds)</span><br>  <span class=\"hljs-attr\">redirect_delay:</span> <span class=\"hljs-number\">5000</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 友链页</span><br><span class=\"hljs-comment\"># Links Page</span><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-attr\">links:</span><br>  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-attr\">banner_img:</span> <span class=\"hljs-string\">/img/default.png</span><br>  <span class=\"hljs-attr\">banner_img_height:</span> <span class=\"hljs-number\">60</span><br>  <span class=\"hljs-attr\">banner_mask_alpha:</span> <span class=\"hljs-number\">0.3</span><br>  <span class=\"hljs-comment\"># 友链的成员项</span><br>  <span class=\"hljs-comment\"># Member item of page</span><br>  <span class=\"hljs-attr\">items:</span><br>    <span class=\"hljs-bullet\">-</span> &#123;<br>      <span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">&quot;Fluid Blog&quot;</span>,<br>      <span class=\"hljs-attr\">intro:</span> <span class=\"hljs-string\">&quot;主题博客&quot;</span>,<br>      <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;https://hexo.fluid-dev.com/&quot;</span>,<br>      <span class=\"hljs-attr\">avatar:</span> <span class=\"hljs-string\">&quot;/img/favicon.png&quot;</span><br>    &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123;<br>      <span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">&quot;Fluid Docs&quot;</span>,<br>      <span class=\"hljs-attr\">intro:</span> <span class=\"hljs-string\">&quot;主题使用指南&quot;</span>,<br>      <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;https://hexo.fluid-dev.com/docs/&quot;</span>,<br>      <span class=\"hljs-attr\">avatar:</span> <span class=\"hljs-string\">&quot;/img/favicon.png&quot;</span><br>    &#125;<br>    <span class=\"hljs-bullet\">-</span> &#123;<br>      <span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">&quot;Fluid Repo&quot;</span>,<br>      <span class=\"hljs-attr\">intro:</span> <span class=\"hljs-string\">&quot;主题 GitHub 仓库&quot;</span>,<br>      <span class=\"hljs-attr\">link:</span> <span class=\"hljs-string\">&quot;https://github.com/fluid-dev/hexo-theme-fluid&quot;</span>,<br>      <span class=\"hljs-attr\">avatar:</span> <span class=\"hljs-string\">&quot;/img/favicon.png&quot;</span><br>    &#125;<br><br>  <span class=\"hljs-comment\"># 当成员头像加载失败时，替换为指定图片</span><br>  <span class=\"hljs-comment\"># When the member avatar fails to load, replace the specified image</span><br>  <span class=\"hljs-attr\">onerror_avatar:</span> <span class=\"hljs-string\">/img/avatar.png</span><br><br>  <span class=\"hljs-comment\"># 友链下方自定义区域，支持 HTML，可插入例如申请友链的文字</span><br>  <span class=\"hljs-comment\"># Custom content at the bottom of the links</span><br>  <span class=\"hljs-attr\">custom:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-attr\">content:</span> <span class=\"hljs-string\">&#x27;&lt;hr&gt;&lt;p&gt;在下方留言申请加入我的友链，按如下格式提供信息：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;博客名：Fluid&lt;/li&gt;&lt;li&gt;简介：Fluid 主题官方博客&lt;/li&gt;&lt;li&gt;链接：https://hexo.fluid-dev.com&lt;/li&gt;&lt;li&gt;图片：https://hexo.fluid-dev.com/img/favicon.png&lt;/li&gt;&lt;/ul&gt;&#x27;</span><br><br>  <span class=\"hljs-comment\"># 评论插件</span><br>  <span class=\"hljs-comment\"># Comment plugin</span><br>  <span class=\"hljs-attr\">comments:</span><br>    <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-comment\"># 指定的插件，需要同时设置对应插件的必要参数</span><br>    <span class=\"hljs-comment\"># The specified plugin needs to set the necessary parameters at the same time</span><br>    <span class=\"hljs-comment\"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>    <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">disqus</span><br><br><br><span class=\"hljs-comment\">#---------------------------</span><br><span class=\"hljs-comment\"># 以下是配置 JS CSS 等静态资源的 URL 前缀，可以自定义成 CDN 地址，</span><br><span class=\"hljs-comment\"># 如果需要修改，最好使用与默认配置相同的版本，以避免潜在的问题，</span><br><span class=\"hljs-comment\"># ** 如果你不知道如何设置，请不要做任何改动 **</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># Here is the url prefix to configure the static assets. Set CDN addresses you want to customize.</span><br><span class=\"hljs-comment\"># Be aware that you would better use the same version as default ones to avoid potential problems.</span><br><span class=\"hljs-comment\"># DO NOT EDIT THE FOLLOWING SETTINGS UNLESS YOU KNOW WHAT YOU ARE DOING</span><br><span class=\"hljs-comment\">#---------------------------</span><br><br><span class=\"hljs-attr\">static_prefix:</span><br>  <span class=\"hljs-comment\"># 内部静态</span><br>  <span class=\"hljs-comment\"># Internal static</span><br>  <span class=\"hljs-attr\">internal_js:</span> <span class=\"hljs-string\">/js</span><br>  <span class=\"hljs-attr\">internal_css:</span> <span class=\"hljs-string\">/css</span><br>  <span class=\"hljs-attr\">internal_img:</span> <span class=\"hljs-string\">/img</span><br><br>  <span class=\"hljs-attr\">anchor:</span> <span class=\"hljs-string\">https://lib.baomitu.com/anchor-js/4.3.1/</span><br><br>  <span class=\"hljs-attr\">github_markdown:</span> <span class=\"hljs-string\">https://lib.baomitu.com/github-markdown-css/4.0.0/</span><br><br>  <span class=\"hljs-attr\">jquery:</span> <span class=\"hljs-string\">https://lib.baomitu.com/jquery/3.6.4/</span><br><br>  <span class=\"hljs-attr\">bootstrap:</span> <span class=\"hljs-string\">https://lib.baomitu.com/twitter-bootstrap/4.6.1/</span><br><br>  <span class=\"hljs-attr\">prismjs:</span> <span class=\"hljs-string\">https://lib.baomitu.com/prism/1.29.0/</span><br><br>  <span class=\"hljs-attr\">tocbot:</span> <span class=\"hljs-string\">https://lib.baomitu.com/tocbot/4.20.1/</span><br><br>  <span class=\"hljs-attr\">typed:</span> <span class=\"hljs-string\">https://lib.baomitu.com/typed.js/2.0.12/</span><br><br>  <span class=\"hljs-attr\">fancybox:</span> <span class=\"hljs-string\">https://lib.baomitu.com/fancybox/3.5.7/</span><br><br>  <span class=\"hljs-attr\">nprogress:</span> <span class=\"hljs-string\">https://lib.baomitu.com/nprogress/0.2.0/</span><br><br>  <span class=\"hljs-attr\">mathjax:</span> <span class=\"hljs-string\">https://lib.baomitu.com/mathjax/3.2.2/</span><br><br>  <span class=\"hljs-attr\">katex:</span> <span class=\"hljs-string\">https://lib.baomitu.com/KaTeX/0.16.2/</span><br><br>  <span class=\"hljs-attr\">busuanzi:</span> <span class=\"hljs-string\">https://busuanzi.ibruce.info/busuanzi/2.3/</span><br><br>  <span class=\"hljs-attr\">clipboard:</span> <span class=\"hljs-string\">https://lib.baomitu.com/clipboard.js/2.0.11/</span><br><br>  <span class=\"hljs-attr\">mermaid:</span> <span class=\"hljs-string\">https://lib.baomitu.com/mermaid/8.14.0/</span><br><br>  <span class=\"hljs-attr\">valine:</span> <span class=\"hljs-string\">https://lib.baomitu.com/valine/1.5.1/</span><br><br>  <span class=\"hljs-attr\">waline:</span> <span class=\"hljs-string\">https://cdn.staticfile.org/waline/2.15.5/</span><br><br>  <span class=\"hljs-attr\">gitalk:</span> <span class=\"hljs-string\">https://lib.baomitu.com/gitalk/1.8.0/</span><br><br>  <span class=\"hljs-attr\">disqusjs:</span> <span class=\"hljs-string\">https://lib.baomitu.com/disqusjs/1.3.0/</span><br><br>  <span class=\"hljs-attr\">twikoo:</span> <span class=\"hljs-string\">https://lib.baomitu.com/twikoo/1.6.8/</span><br><br>  <span class=\"hljs-attr\">discuss:</span> <span class=\"hljs-string\">https://lib.baomitu.com/discuss/1.2.1/</span><br><br>  <span class=\"hljs-attr\">hint:</span> <span class=\"hljs-string\">https://lib.baomitu.com/hint.css/2.7.0/</span><br><br>  <span class=\"hljs-attr\">moment:</span> <span class=\"hljs-string\">https://lib.baomitu.com/moment.js/2.29.4/</span><br></code></pre></td></tr></table></figure>\r\n<h3 id=\"站点配置\">站点配置</h3>\r\n<p>现在对我而言还有两个问题，我换到 Fluid 就是为了 Latex<br />\r\n所以……<br />\r\n这里还是按官方来，<sup id=\"fnref:4\" class=\"footnote-ref\"><a href=\"#fn:4\" rel=\"footnote\"><span\r\nclass=\"hint--top hint--rounded\"\r\naria-label=\"[配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)](https://hexo.fluid-dev.com/docs/guide/#latex-数学公式)\">[4]</span></a></sup></p>\r\n<ol type=\"1\">\r\n<li><p><strong>设置主题配置</strong><br />\r\n<span\r\nclass=\"math inline\">\\(我这里使用的是\\;mathjax+pandoc,\\;\\)</span><br />\r\n<span\r\nclass=\"math inline\">\\(好处是别人可以复制你写的\\;Latex\\)</span><br />\r\n<span class=\"math inline\">\\(\\begin{aligned}坏处是\\hspace{340px}\\\\\r\n他的换行不能像\r\ntypora的&#39;\\backslash\\backslash&#39;直接换行,\\hspace{115px}\\\\\r\n要使用\\backslash begin\\{aligned\\}\\backslash\r\nend\\{aligned\\}\\hspace{100px}\\\\\r\n才能&#39;\\backslash\\backslash&#39;换行\\hspace{300px}\\\\\r\n而且不能使用\\backslash hfill只能使用\\backslash hspace\\{num\\;\r\ncm/px\\}\\hspace{10px}\r\n\\end{aligned}\\)</span><br />\r\n而且换行前必须打两个空格</p>\r\n<p><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">post:</span>  <br>  <span class=\"hljs-attr\">math:</span>  <br>   <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span>  <br>   <span class=\"hljs-attr\">specific:</span> <span class=\"hljs-literal\">false</span>  <br>\t  <span class=\"hljs-attr\">engine:</span> <span class=\"hljs-string\">mathjax</span>  <br></code></pre></td></tr></table></figure></p>\r\n<p><code>specific</code>: 建议开启。当为 true 时，只有在文章 <a\r\nhref=\"https://hexo.io/zh-cn/docs/front-matter\">front-matter (opens new\r\nwindow)</a>里指定 <code>math: true</code>\r\n才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p>\r\n<p><code>engine</code>: 公式引擎，目前支持 <code>mathjax</code> 或\r\n<code>katex</code>。</p></li>\r\n<li><p><strong>更换 Markdown 渲染器</strong><br />\r\n由于 Hexo 默认的 Markdown\r\n渲染器不支持复杂公式，所以需要更换渲染器（mathjax 可选择性更换）。\r\n然后根据上方配置不同的 <code>engine</code>，推荐更换如下渲染器：</p>\r\n<ul>\r\n<li><p>mathjax <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-pandoc --save<br></code></pre></td></tr></table></figure></p>\r\n<p><strong>并且还需<a\r\nhref=\"https://github.com/jgm/pandoc/blob/master/INSTALL.md\">安装\r\nPandoc</a></strong></p></li>\r\n<li><p>katex <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-markdown-it --save<br>npm install @traptitech/markdown-it-katex --save<br></code></pre></td></tr></table></figure></p>\r\n<p>然后在站点配置中添加： <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">markdown:</span><br>  <span class=\"hljs-attr\">plugins:</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;@traptitech/markdown-it-katex&quot;</span><br></code></pre></td></tr></table></figure> ### 我安装Pandoc过程</p></li>\r\n</ul></li>\r\n</ol>\r\n<p>环境说明：Windows11</p>\r\n<ol type=\"1\">\r\n<li><a href=\"https://github.com/jgm/pandoc/blob/master/INSTALL.md\">下载\r\nPandoc</a><br />\r\n下载链接<a href=\"https://github.com/jgm/pandoc/releases/latest\">download\r\npage</a><br />\r\n<img src=\"/imgs/Hexo主题变更/pandoc1.png\" />找到 window，我使用的是\r\nmsi：<br />\r\n<img src=\"/imgs/Hexo主题变更/pandoc1-1.png\" /><br />\r\n</li>\r\n<li>按照提示安装就可以，这里可以自选目录<br />\r\npandoc 和\r\nhexo-renderer-pandoc不一样，一个是程序，一个是hexo的渲染插件</li>\r\n</ol>\r\n<h3 id=\"插入图片\">插入图片</h3>\r\n<p>我还是用的老办法，<code>![](/imgs/xxxx)</code>，<br />\r\n想要在 typora\r\n也显示，那就把文档的图片放到一个文件夹<code>/imgs/</code>内<br />\r\nFluid\r\n会在<code>..\\Blog\\source</code>目录下寻找图片资源文件，其他类型应该也是一样。</p>\r\n<h2 id=\"待解决问题\">待解决问题</h2>\r\n<ul>\r\n<li>换行异常：<br />\r\ntypora 可以换行，但是 web blog 不能换行只能换段<br />\r\nlatex 公式不能换行\r\n<ul>\r\n<li><p>因为pandoc和typora语法不一样</p></li>\r\n<li><p>这里给出修改代码<br />\r\n这里的代码有问题哦，但是我不改了……也都有注释，如果你需要可以自行修改<br />\r\n编译原理的自动机学过伐，一样的</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br><br><span class=\"hljs-comment\"># 指定需要修改的 Markdown 文件夹路径  </span><br>folder_path = <span class=\"hljs-string\">&#x27;/path/to/markdown_folder/&#x27;</span><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">process_md_file</span>(<span class=\"hljs-params\">file_path</span>):  <br>    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(file_path, <span class=\"hljs-string\">&#x27;r&#x27;</span>, encoding=<span class=\"hljs-string\">&#x27;utf-8&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:  <br>        content = f.readlines()<br><br>    modified_content = []  <br>    code_block = <span class=\"hljs-literal\">False</span>  <br>    latex_block = <span class=\"hljs-literal\">False</span>  <br>    setting_block = <span class=\"hljs-literal\">False</span>  <br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(content)):  <br>        line = content[i].rstrip(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>)<br><br>        <span class=\"hljs-comment\"># 判断是否进入或退出代码块  </span><br>        <span class=\"hljs-keyword\">if</span> line.startswith(<span class=\"hljs-string\">&#x27;~~~&#x27;</span>):  <br>            code_block = <span class=\"hljs-keyword\">not</span> code_block<br><br>        <span class=\"hljs-comment\"># 判断是否进入或退出 LaTeX 段落  </span><br>        <span class=\"hljs-keyword\">if</span> line.startswith(<span class=\"hljs-string\">&#x27;$$&#x27;</span>):  <br>            latex_block = <span class=\"hljs-keyword\">not</span> latex_block<br><br>        <span class=\"hljs-comment\"># 判断是否进入或退出设置段  </span><br>        <span class=\"hljs-keyword\">if</span> line.startswith(<span class=\"hljs-string\">&#x27;---&#x27;</span>):  <br>            setting_block = <span class=\"hljs-keyword\">not</span> setting_block<br><br>        <span class=\"hljs-comment\"># 如果在代码块内、LaTeX 段落内或设置段内，则不做修改  </span><br>        <span class=\"hljs-keyword\">if</span> code_block <span class=\"hljs-keyword\">or</span> latex_block <span class=\"hljs-keyword\">or</span> setting_block:  <br>            modified_content.append(line)  <br>        <span class=\"hljs-keyword\">else</span>:  <br>            <span class=\"hljs-comment\"># 如果行首是标题，则不加空格  </span><br>            <span class=\"hljs-keyword\">if</span> line.startswith(<span class=\"hljs-string\">&#x27;#&#x27;</span>):  <br>                modified_content.append(line)  <br>            <span class=\"hljs-comment\"># 如果行首以 &lt;img 开头，则不做修改  </span><br>            <span class=\"hljs-keyword\">elif</span> line.lstrip().startswith(<span class=\"hljs-string\">&#x27;&lt;img&#x27;</span>):  <br>                modified_content.append(line)  <br>            <span class=\"hljs-comment\"># 如果行首以 &lt; 开头，则不加空格（除了 &lt;img 外）  </span><br>            <span class=\"hljs-keyword\">elif</span> line.startswith(<span class=\"hljs-string\">&#x27;&lt;&#x27;</span>):  <br>                modified_content.append(line)  <br>            <span class=\"hljs-keyword\">else</span>:  <br>                <span class=\"hljs-comment\"># 如果行尾已经有两个空格，则不做修改  </span><br>                <span class=\"hljs-keyword\">if</span> line.endswith(<span class=\"hljs-string\">&#x27;  &#x27;</span>):  <br>                    modified_content.append(line)  <br>                <span class=\"hljs-keyword\">else</span>:  <br>                    <span class=\"hljs-comment\"># 判断下一行是否为空行  </span><br>                    <span class=\"hljs-keyword\">if</span> i &lt; <span class=\"hljs-built_in\">len</span>(content) - <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">and</span> content[i+<span class=\"hljs-number\">1</span>].strip() == <span class=\"hljs-string\">&#x27;&#x27;</span>:  <br>                        modified_content.append(line)  <br>                    <span class=\"hljs-keyword\">else</span>:  <br>                        modified_content.append(line + <span class=\"hljs-string\">&#x27;  &#x27;</span>)<br><br>    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(file_path, <span class=\"hljs-string\">&#x27;w&#x27;</span>, encoding=<span class=\"hljs-string\">&#x27;utf-8&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:  <br>        f.write(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>.join(modified_content))<br><br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&#x27;已修改文件: <span class=\"hljs-subst\">&#123;file_path&#125;</span>&#x27;</span>)<br><br><span class=\"hljs-comment\"># 遍历 Markdown 文件夹下的所有文件  </span><br><span class=\"hljs-keyword\">for</span> root, dirs, files <span class=\"hljs-keyword\">in</span> os.walk(folder_path):  <br>    <span class=\"hljs-keyword\">for</span> file <span class=\"hljs-keyword\">in</span> files:  <br>        <span class=\"hljs-keyword\">if</span> file.endswith(<span class=\"hljs-string\">&#x27;.md&#x27;</span>):  <br>            file_path = os.path.join(root, file)  <br>            process_md_file(file_path)<br><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;所有文件修改完成&#x27;</span>)  <br></code></pre></td></tr></table></figure></li>\r\n</ul></li>\r\n</ul>\r\n<p>标题段落间隔大 : 主题问题</p>\r\n<h2 id=\"参考\">参考</h2>\r\n<p><a href=\"https://docs.mathjax.org/en/latest/index.html\">MathJax 文档\r\n— MathJax 3.2 文档</a></p>\r\n<p><a href=\"https://hexo.io/zh-cn/docs/front-matter\">Front-matter |\r\nHexo</a></p>\r\n<p><a href=\"https://github.com/hexojs/hexo-math\">hexojs/hexo-math: A\r\nhexo plugin that uses MathJax to render math equations.\r\n(github.com)</a></p>\r\n<a\r\nhref=\"https://github.com/jgm/pandoc/blob/main/INSTALL.md\">pandoc/INSTALL.md\r\n在主 ·JGM/PANDOC的 (github.com)</a>\r\n<section class=\"footnotes\">\r\n<div class=\"footnote-list\">\r\n<ol>\r\n<li>\r\n<span id=\"fn:0\"\r\nclass=\"footnote-text\"><span><a href=\"https://saucenao.com/\">图片搜索:saucenao</a>\r\n<a href=\"#fnref:0\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n<li>\r\n<span id=\"fn:1\"\r\nclass=\"footnote-text\"><span><a href=\"https://hexo.fluid-dev.com/docs\">Hexo\r\nFulid 官方Doc</a>\r\n<a href=\"#fnref:1\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n<li>\r\n<span id=\"fn:2\"\r\nclass=\"footnote-text\"><span><a href=\"https://hexo.fluid-dev.com/docs/guide/#覆盖配置\">配置指南\r\n| Hexo Fluid 用户手册 (fluid-dev.com)</a>\r\n<a href=\"#fnref:2\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n<li>\r\n<span id=\"fn:3\" class=\"footnote-text\"><span><a\r\nhref=\"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml\">主题配置</a>\r\n<a href=\"#fnref:3\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n<li>\r\n<span id=\"fn:4\" class=\"footnote-text\"><span><a\r\nhref=\"https://hexo.fluid-dev.com/docs/guide/#latex-数学公式\">配置指南 |\r\nHexo Fluid 用户手册 (fluid-dev.com)</a>\r\n<a href=\"#fnref:4\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n<li>\r\n<span id=\"fn:5\" class=\"footnote-text\"><span><a\r\nhref=\"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml\">hexo-theme-fluid/_config.yml\r\nat master · fluid-dev/hexo-theme-fluid (github.com)</a>\r\n<a href=\"#fnref:5\" rev=\"footnote\" class=\"footnote-backref\">\r\n↩︎</a></span></span>\r\n</li>\r\n</ol>\r\n</div>\r\n</section>"},{"title":"摸鱼画图","date":"2022-04-01T04:24:22.000Z","typora-root-url":"./..","_content":"  \n只是偷偷放一下自己平时摸鱼的\"产物\"。\n  \n<!--more-->\n  \n###### 卷发，长直\n  \n<div style=\"width:45%;margin:left\"><img src=\"/imgs/MoyuPics/卷发5.26.jpg\"/></div>\n  \n好像还是不行，感觉自己画的头发像是一张纸，薄薄的，没有质感……还是要继续摸鱼啊!(\n  \n<div style=\"width:45%;margin:left\"><img src=\"/imgs/MoyuPics/5.29.jpg\" alt=\"mole\"></div>\n  \n为什么没有下半身？因为我摸崩了(\n  \n22/6/4 今天看到极乐迪斯科的边缘层次结构理论，主创团队认为在画面中并不是所有物体的边缘都是必须可见的，一些边甚至可以柔化甚至完全消失，而在实际生活中物体是没有界限的，我们所观测到的边界是由光线和对比度等造成的视觉效果。主创团队所营造的美术效果更加注重氛围和环境，相比常规的边缘清晰的美术作品，游戏内呈现的更加\"油画风\"，人们更能进行整体感知，如果着重边缘某种程度上分离了物体和环境的关系，一副优秀的美术作品不能忽略物体与环境，当物体与环境相近我们的视觉就会忽略物体的边缘。正式由于这样的美术理念，极乐迪斯科造就了一个迷幻的世界，一个充满绘画风格的世界。\n  \n<div style=\"width:45%;margin:left\"><img src=\"/imgs/MoyuPics/边缘.jpg\"/></div>\n  \n<div style=\"width:45%;margin:left\"><img src=\"/imgs/MoyuPics/eye614.jpg\"/></div>\n  \n其实眼睛才是我摸鱼时画的最多的，好久不摸手都生了。\n  \n<div style=\"width:45%;margin:left\"><img src=\"/imgs/MoyuPics/2022.6.15.jpg\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/starve.jpg\" alt=\"饥饿,消瘦的男孩\"></div>\n\n\n  \n<div style=\"width:15%;margin:left\"><img src=\"/imgs/MoyuPics/617e.jpg\" alt=\"普通的眼睛\"></div>\n  \n<div style=\"width:15%;margin:left\"><img src=\"/imgs/MoyuPics/617m.jpg\" alt=\"普通的嘴\"></div>\n  \n<div style=\"width:25%;margin:left\"><img src=\"/imgs/MoyuPics/617w.jpg\" alt=\"普通的人\"></div>\n\n\n  \n<div style=\"width:25%;margin:left\"><img src=\"/imgs/MoyuPics/220630jo.jpg\" alt=\"普通的jio\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702光头.jpg\"  alt=\"光头\" ></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702CF.jpg\" alt=\"光头变长发\" ></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702P1.jpg\" alt=\"摸鱼P1\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702P2.jpg\" alt=\"摸鱼P2\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702P3.jpg\" alt=\"摸鱼P3\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702P4.jpg\" alt=\"摸鱼P4\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/20221114EyeCue.jpg\" alt=\"摸鱼P3\"></div>","source":"_posts/MoyuPics.md","raw":"---\ntitle: 摸鱼画图\ndate: 2022-04-01 12:24:22\ntags: \ntypora-root-url: ./..\n---\n  \n只是偷偷放一下自己平时摸鱼的\"产物\"。\n  \n<!--more-->\n  \n###### 卷发，长直\n  \n<div style=\"width:45%;margin:left\"><img src=\"/imgs/MoyuPics/卷发5.26.jpg\"/></div>\n  \n好像还是不行，感觉自己画的头发像是一张纸，薄薄的，没有质感……还是要继续摸鱼啊!(\n  \n<div style=\"width:45%;margin:left\"><img src=\"/imgs/MoyuPics/5.29.jpg\" alt=\"mole\"></div>\n  \n为什么没有下半身？因为我摸崩了(\n  \n22/6/4 今天看到极乐迪斯科的边缘层次结构理论，主创团队认为在画面中并不是所有物体的边缘都是必须可见的，一些边甚至可以柔化甚至完全消失，而在实际生活中物体是没有界限的，我们所观测到的边界是由光线和对比度等造成的视觉效果。主创团队所营造的美术效果更加注重氛围和环境，相比常规的边缘清晰的美术作品，游戏内呈现的更加\"油画风\"，人们更能进行整体感知，如果着重边缘某种程度上分离了物体和环境的关系，一副优秀的美术作品不能忽略物体与环境，当物体与环境相近我们的视觉就会忽略物体的边缘。正式由于这样的美术理念，极乐迪斯科造就了一个迷幻的世界，一个充满绘画风格的世界。\n  \n<div style=\"width:45%;margin:left\"><img src=\"/imgs/MoyuPics/边缘.jpg\"/></div>\n  \n<div style=\"width:45%;margin:left\"><img src=\"/imgs/MoyuPics/eye614.jpg\"/></div>\n  \n其实眼睛才是我摸鱼时画的最多的，好久不摸手都生了。\n  \n<div style=\"width:45%;margin:left\"><img src=\"/imgs/MoyuPics/2022.6.15.jpg\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/starve.jpg\" alt=\"饥饿,消瘦的男孩\"></div>\n\n\n  \n<div style=\"width:15%;margin:left\"><img src=\"/imgs/MoyuPics/617e.jpg\" alt=\"普通的眼睛\"></div>\n  \n<div style=\"width:15%;margin:left\"><img src=\"/imgs/MoyuPics/617m.jpg\" alt=\"普通的嘴\"></div>\n  \n<div style=\"width:25%;margin:left\"><img src=\"/imgs/MoyuPics/617w.jpg\" alt=\"普通的人\"></div>\n\n\n  \n<div style=\"width:25%;margin:left\"><img src=\"/imgs/MoyuPics/220630jo.jpg\" alt=\"普通的jio\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702光头.jpg\"  alt=\"光头\" ></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702CF.jpg\" alt=\"光头变长发\" ></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702P1.jpg\" alt=\"摸鱼P1\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702P2.jpg\" alt=\"摸鱼P2\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702P3.jpg\" alt=\"摸鱼P3\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/220702P4.jpg\" alt=\"摸鱼P4\"></div>\n  \n<div style=\"width:30%;margin:left\"><img src=\"/imgs/MoyuPics/20221114EyeCue.jpg\" alt=\"摸鱼P3\"></div>","slug":"MoyuPics","published":1,"updated":"2024-01-14T08:13:08.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti1000abkbw9ju689bd","content":"<p>只是偷偷放一下自己平时摸鱼的\"产物\"。</p>\r\n<span id=\"more\"></span>\r\n<h6 id=\"卷发长直\">卷发，长直</h6>\r\n<div style=\"width:45%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/卷发5.26.jpg\"/>\r\n</div>\r\n<p>好像还是不行，感觉自己画的头发像是一张纸，薄薄的，没有质感……还是要继续摸鱼啊!(</p>\r\n<div style=\"width:45%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/5.29.jpg\" alt=\"mole\">\r\n</div>\r\n<p>为什么没有下半身？因为我摸崩了(</p>\r\n<p>22/6/4\r\n今天看到极乐迪斯科的边缘层次结构理论，主创团队认为在画面中并不是所有物体的边缘都是必须可见的，一些边甚至可以柔化甚至完全消失，而在实际生活中物体是没有界限的，我们所观测到的边界是由光线和对比度等造成的视觉效果。主创团队所营造的美术效果更加注重氛围和环境，相比常规的边缘清晰的美术作品，游戏内呈现的更加\"油画风\"，人们更能进行整体感知，如果着重边缘某种程度上分离了物体和环境的关系，一副优秀的美术作品不能忽略物体与环境，当物体与环境相近我们的视觉就会忽略物体的边缘。正式由于这样的美术理念，极乐迪斯科造就了一个迷幻的世界，一个充满绘画风格的世界。</p>\r\n<div style=\"width:45%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/边缘.jpg\"/>\r\n</div>\r\n<div style=\"width:45%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/eye614.jpg\"/>\r\n</div>\r\n<p>其实眼睛才是我摸鱼时画的最多的，好久不摸手都生了。</p>\r\n<div style=\"width:45%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/2022.6.15.jpg\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/starve.jpg\" alt=\"饥饿,消瘦的男孩\">\r\n</div>\r\n<div style=\"width:15%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/617e.jpg\" alt=\"普通的眼睛\">\r\n</div>\r\n<div style=\"width:15%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/617m.jpg\" alt=\"普通的嘴\">\r\n</div>\r\n<div style=\"width:25%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/617w.jpg\" alt=\"普通的人\">\r\n</div>\r\n<div style=\"width:25%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220630jo.jpg\" alt=\"普通的jio\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702光头.jpg\"  alt=\"光头\" >\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702CF.jpg\" alt=\"光头变长发\" >\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702P1.jpg\" alt=\"摸鱼P1\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702P2.jpg\" alt=\"摸鱼P2\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702P3.jpg\" alt=\"摸鱼P3\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702P4.jpg\" alt=\"摸鱼P4\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/20221114EyeCue.jpg\" alt=\"摸鱼P3\">\r\n</div>\r\n","site":{"data":{}},"excerpt":"<p>只是偷偷放一下自己平时摸鱼的\"产物\"。</p>","more":"<h6 id=\"卷发长直\">卷发，长直</h6>\r\n<div style=\"width:45%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/卷发5.26.jpg\"/>\r\n</div>\r\n<p>好像还是不行，感觉自己画的头发像是一张纸，薄薄的，没有质感……还是要继续摸鱼啊!(</p>\r\n<div style=\"width:45%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/5.29.jpg\" alt=\"mole\">\r\n</div>\r\n<p>为什么没有下半身？因为我摸崩了(</p>\r\n<p>22/6/4\r\n今天看到极乐迪斯科的边缘层次结构理论，主创团队认为在画面中并不是所有物体的边缘都是必须可见的，一些边甚至可以柔化甚至完全消失，而在实际生活中物体是没有界限的，我们所观测到的边界是由光线和对比度等造成的视觉效果。主创团队所营造的美术效果更加注重氛围和环境，相比常规的边缘清晰的美术作品，游戏内呈现的更加\"油画风\"，人们更能进行整体感知，如果着重边缘某种程度上分离了物体和环境的关系，一副优秀的美术作品不能忽略物体与环境，当物体与环境相近我们的视觉就会忽略物体的边缘。正式由于这样的美术理念，极乐迪斯科造就了一个迷幻的世界，一个充满绘画风格的世界。</p>\r\n<div style=\"width:45%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/边缘.jpg\"/>\r\n</div>\r\n<div style=\"width:45%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/eye614.jpg\"/>\r\n</div>\r\n<p>其实眼睛才是我摸鱼时画的最多的，好久不摸手都生了。</p>\r\n<div style=\"width:45%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/2022.6.15.jpg\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/starve.jpg\" alt=\"饥饿,消瘦的男孩\">\r\n</div>\r\n<div style=\"width:15%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/617e.jpg\" alt=\"普通的眼睛\">\r\n</div>\r\n<div style=\"width:15%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/617m.jpg\" alt=\"普通的嘴\">\r\n</div>\r\n<div style=\"width:25%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/617w.jpg\" alt=\"普通的人\">\r\n</div>\r\n<div style=\"width:25%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220630jo.jpg\" alt=\"普通的jio\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702光头.jpg\"  alt=\"光头\" >\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702CF.jpg\" alt=\"光头变长发\" >\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702P1.jpg\" alt=\"摸鱼P1\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702P2.jpg\" alt=\"摸鱼P2\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702P3.jpg\" alt=\"摸鱼P3\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/220702P4.jpg\" alt=\"摸鱼P4\">\r\n</div>\r\n<div style=\"width:30%;margin:left\">\r\n<img src=\"/imgs/MoyuPics/20221114EyeCue.jpg\" alt=\"摸鱼P3\">\r\n</div>"},{"title":"我的CMake学习","date":"2023-03-10T05:15:23.000Z","typora-root-url":"./..","_content":"  \n对 CMake 粗浅的学习，之前看一个up的讲的一般，后来看了小彭老师，的确不错，因为官方文档看起来有点吃力，所以就……  \n学习过程中把知识点做了一点笔记方便后续复习\n  \n<!--more-->\n  \n# CMake\n  \n本文档为学习笔记，该部分内容来源[b站Up刘贝斯的CMake教学](https://www.bilibili.com/video/BV1vR4y1u77h/?p=2&spm_id_from=pageDriver&vd_source=1fa1b82383f6efb8a2632316da9afad0)。\n  \n## What is CMake?\n  \nCMake 是一种高级编译配置工具。\n  \n当多人使用一种或不同种语言、编译器开发一个项目时，最终需要输出一个**可执行文件**或者**共享库**(dll, so等等)，此时——CMake就可以帮助到我们，不必用G++或GCC逐个编译我们所写过的代码。  \n所有操作都是通过编译CMakeLists.txt完成的。  \n使用CMake来处理大型的C/C++/Java等项目。\n  \n## CMake 安装\n  \n* Linux大多都有安装。  \n* Windows, 下载网站(https://cmake.org/download/)\n  \n## CMake: Hello World\n  \n1.首先写一个C/C++的hello world\n  \n~~~c++\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Hello World!\" << std::endl;\n}\n~~~\n  \n2.编写`CmakeLists.txt`\n  \n~~~cmake\nPROJECT (HELLOW)\n\nSET(SRC_LIST main.cpp)\n\nMESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINAR_DIR})\n\nMESSAGE(STATUS \"This is SOURCE dir \" ${HELLO_SOURCE_DIR})\n\nADD_EXECUTABLE{hello $(SRC_LIST)}\n~~~\n  \n3.使用CMake，生成`makefile`文件\n  \n~~~cmake\ncmake .  \n~~~\n  \n### CMake: Hello World语法介绍\n  \n#### `PROJECT`关键字 —— [简书CMake命令之project](https://www.jianshu.com/p/cdd6e56c2422)\n  \n可以用来**指定工程的名字和支持的语言**，默认支持所有语言。  \nPROJECT (HELLO) 指定了工程的名字——HELLO，并且支持所有语言。\n  \n# [**CMake教程**](https://www.bilibili.com/video/BV16P4y1g7MH)\n  \n## 第一章 添加源文件\n  \n* 第一种，添加名为 *main* 的 *executable* ，源文件为 *main.cpp* 。\n  \n~~~cmake\nadd_executable(main main.cpp)\n~~~\n  \n* 第二种，先创建 **目标( executable )**，稍后再添加源文件。\n  \n~~~cmake\nadd_executable(main)\ntarget_sources(main PUBLIC main.cpp)\n~~~\n  \n### 若有多个源文件呢？\n  \n逐个添加即可\n  \n~~~cmake\nadd_executable(main)\ntarget_sources(main PUBLIC main.cpp other.cpp)\n~~~\n  \n或者使用**变量**来存储\n  \n~~~cmake\nadd_executable(main)\nset(sources main.cpp other.cpp)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n建议把头文件也加上，这样在VS中可以出现在 \"Header Flies\" 一栏\n  \n~~~cmake\nadd_executable(main)\nset(sources main.cpp other.cpp other.h)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n我们还可以使用 **GLOB** 自动查找当前目录下指定拓展名的文件，实现批量添加源文件\n  \n~~~cmake\nadd_executable(main)\nfile(GLOB sources *.cpp *.h)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n但是使用 **GLOB** 需要注意，如果我们增添新的源文件时，CMake可能不会更新，所以要启用 **CONFIGURE_DEPENDS** 选项，当添加新文件时，**在 Build 时进行检测**，自动更新变量\n  \n~~~cmake\nadd_executable(main)\nfile(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n### 源码在子文件夹中？\n  \n#### 例子：\n  \n* mylib  \n  * other.cpp  \n  * other.h  \n* CMakeLists.txt  \n* main.cpp\n  \n将**路径名、后缀名全部**写出来\n  \n~~~cmake\nadd_executable(main)\nfile(GLOB sources CONFIGURE_DEPENDS *.cpp *.h mylib/*.cpp mylib/*.h)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n然鹅，dark不必，我们可以使用 **aux_source_directory** , 自动搜集需要的文件后缀名  \n本例中`aux_source_directory(. sources)`和`aux_source_directory(mylib sources)`  表示**当前目录**和 **mylib 目录** 全部加入项目中。\n  \n~~~cmake\nadd_executable(main)\naux_source_directory(. sources)\naux_source_directory(mylib sources)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n更进一步：**GLOB_RECURES** 能够自动包含所有子文件夹下的文件  \n但是注意，**GLOB_RECURES** 会把 **build 目录**下的临时 .cpp 文件( 这些临时文件是 CMake 为了测试编译器 )也加进来。  \n解决办法：一种，可以把源码统一放到 src 目录下。二种，要求使用者不要把 build 放到和源码同一个目录里。这两种之间前者好一点。\n  \n~~~cmake\nadd_executable(main)\nfile(GLOB_RECURES sources CONFIGURE_DEPENDS *.cpp *.h)\ntarget_source(main PUBLIC ${sources})\n~~~\n  \n## 第二章 项目配置变量——BUILD_TYPE\n  \n### CMAKE_BUILD_TYPE 构建的类型，调试模式 or 发布模式 \n  \n* CMAKE_BUILD_TYPE 是 CMake 中一个特殊的变量， 用于控制构建类型，他的值可以是：  \n  * Debug 调试模式，完全不进行优化，生成调试信息，方便调试程序  \n  * Release 发布模式，优化程度最高，性能最佳，但是编译比 Debug 慢  \n  * MinsizeRel 最小体积发布，生成的文件比 Release 更小，不完全优化，减少二进制体积。  \n  * RelWithDebInfo 带调试信息发布，生成的文件比 Release 更大，因为带有调试的符号信息。  \n* 默认情况下，CMAKE_BUILD_TYPE 为空字符，这时相当于 Debug。\n  \n~~~cmake\ncmake_minimun_required(VERSION 3.15)\nproject(hellowcmake LANGUAGES CXX)\n\nset(CMAKE_BUILD_TYPE Release)\n\nadd_executable(main main.cpp)\n~~~\n  \n各种构建模式在编译器选项上的区别\n  \n* 在 Release 模式下，追求的是程序最佳的性能表现，在此情况下编译器会对程序做最大的代码优化以达到最快的运行速度。另一方面，由于代码优化后不与源代码一致，此模式下一般会丢失大量的调试信息。\n  \n在编译器上各种构建类型的体现：\n  \n* Debug : '-O0 -g'  \n* Release : '-O3 -DNDEBUG'  \n* MinSizeRel : '-Os -DNDEBUG'  \n* RelWithDebInfo : '-O2 -g -DNDEBUG'\n  \n此外，定义 NDEBUG 宏会使 assert 被去除掉。\n  \n因为默认情况下是 Debug 导致生成程序的效率很低。  \n小技巧：设定一个变量的默认值\n  \n如何让 CMAKE_BUILD_TYPE 在用户没有指定的情况时为 Release，指定的时候保持用户的指定的值不变？  \n即 CMake 默认情况下 CMAKE_BUILD_TYPE 是一个空字符串。  \n因此可以通过 `if( NOT CMAKE_BUILD_TYPE )`判断是否为空，空则自动设置为 Release 模式。  \n大多数 CMakeLists.txt 开头都会有这样三行，目的是让默认的构建类型为发布模式 (高度优化) 而不是默认的调试模式 (不会优化) 。\n  \n~~~cmake\nif( NOT CMAKE_BUILD_TYPE )\n\tset(CMAKE_BUILD_TYPE Release)\nendif()\n~~~\n  \n### Project\n  \nproject : 初始化项目信息，并把当前 CMakeLists.txt 所在位置作为根目录\n  \n这里初始化名为 hellocmake 的项目；为什么一定需要项目名？  \n因为对于 MSVC，他会在 build 里生成 hellocmake.sln 作为 IDE 眼中的项目。  \nCMAKE_CURRENT_SOURCE_DIR 表示**当前源码目录**的位置，例如 ~/hellocmake  \nCMAKE_CURRENT_BINARY_DIR 表示**当前输出目录**的位置，例如 ~/hellocmake/build\n  \n~~~cmake\ncmake_minumum_required(VERSION 3.15)\nproject(hellocmake)\n\nmessage(\"PROJECT_NAME: ${PROJECT_NAME}\")\nmessage(\"PROJECT_SOURCE_DIR: ${PROECJR_SOURCE_DIR}\")\nmessage(\"PROJECT_BINARY_DIR: ${PROJECT_BINARY_DIR}\")\nmessage(\"CMAKE_CURRENT_SOURCE_DIR: ${CMAKE_CURRENT_SOURCE_DIR}\")\nmessage(\"CMAKE_CURRENT_BINARY_DIR: ${CMAKE_CURRENT_BINARY_DIR}\")\nadd_executable(main main.cpp)\n~~~\n  \n#### 和子模块的关系：PROJECT_X_DIR 和 CMAKE_CURRENT_x_DIR\n  \nPROJECT_SOURCE_DIR 表示最近一次调用 project 的 CMakeLists.txt 所在的源码目录。  \nCMAKE_CURRENT_SOURCE_DIR 表示当前 CMakeLists.txt 所在的源码目录。  \nCMAKE_SOURCE_DIR 表示最为外层 CMakeLists.txt 的源码根目录。  \n利用 PROJECT_SOURCE_DIR 可以实现从子模块直接获取项目最外层的路径。  \n**不建议使用 CMAKE_SOURCE_DIR , 那样会让你的项目无法被人作为子模块使用。**\n  \n>mylib got PORJECT_SOURCE_DIR: /home/bate/Codes/course/11/template  \n>  \n>mylib got CMAKE_CURRENT_SOURCE_DIR: /home/bate/Codes/course/11/template/mylib\n  \n#### 其他相关变量\n  \n* PROJECT_SOURCE_DIR : 当前项目源码路径( 存放 main.cpp 的地方)  \n* PROJECT_BINARY_DIR : 当前项目输出路径 ( 存放 main.exe 的地方 )  \n* CMAKE_SOURCE_DIR : 根项目源码路径 ( 存放 main.cpp 的地方 )  \n* CMAKE_BINARY_DIR : 根项目输出路径 ( 存放 main.cpp 的地方 )  \n* PROJECT_IS_TOP_LEVEL : BOOL 类型，表示当前项目是否是 ( 最顶层的 ) 根项目  \n* PROJECT_NAME : 当前项目名  \n* CMAKE_PROJECT_NAME : 根项目的项目名  \n* 详见 : [CMake之Project](https://cmake.org/cmake/help/latest/command/project.html)\n  \n#### 子模块也可使用 project 命令，将当前目录作为一个独立的子项目\n  \n这样 PROJECT_SOURCE_DIR 就会是子模块的源码目录而不是外层了。  \n这时候 CMake 会认为这个子模块是一个独立的项目，会额外做一些初始化。  \n他的构建目录 PROJECR_BINARY_DIR 也会变成 build/<源码相对路径>  \n这样在 MSVC 上也会看见 build/mylib.vcxproj 的生成\n  \n>PORJECT_NAME : hellowcmake  \n>  \n>PROJECT_SOURCE_DIR : /home/bate/Codes/course/11/template  \n>  \n>PROJECT_BINARY_DIR : /home/bate/Codes/course/11/template/build  \n>  \n>CMAKE_CURRENT_SOURCE_DIR : /home/bate/Codes/course/11/template  \n>  \n>CMAKE_CURRENT_BINARY_DIR : /home/bate/Codes/course/11/template/build  \n>  \n>mylib got PROJECT_NAME : mylib  \n>  \n>mylib got CMAKE_SOURCE_DIR : /home/bate/Codes/course/11/template  \n>  \n>mylib got CMAKE_BINARY_DIR : /home/bate/Codes/course/11/template/build  \n>  \n>mylib got PROJECT_SOURCE_DIR : /home/bate/Codes/course/11/template/mylib  \n>  \n>mylib got PROJECT_BINARY_DIR : /home/bate/Codes/course/11/build/mylib  \n>  \n>mylib got CMAKE_CURRENT_SOURCE_DIR : /home/bate/Codes/course/11/template/mylib  \n>  \n>mylib got CMAKE_CURRENT_BINARY_DIR : /home/bate/Codes/course/11/template/build/mylib\n  \n#### project 的初始化 : LANGUAGES 字段\n  \n* project( 项目名 LANGUAGES 使用的语言列表...) 指定了该项目使用了那种编程语言  \n  目前支持的语言：  \n  * C : C语言  \n  * CXX : C++  \n  * ASM : 汇编  \n  * Fortran : 老年人的编程语言(雾)，IBM  \n  * CUDA : 英伟达的黑科技 CUDA ( 需要 CMake 3.8 版本 )  \n  * OBJC : 苹果的 Objective-C ( 需要 CMake 3.16 版本 )  \n  * OBJCXX : 苹果的 Objective-C++ ( 需要 CMake 3.16 版本 )  \n  * ISPC : 一种英特尔的自动 SIMD 编程语言 ( 需要 CMake 3.18 版本 )  \n* 如果不指定 LANGUAGES, 默认为 C 和 CXX。\n  \n##### 常见问题：LANGUAGES 中没有启用 C 语言，但却用到了 C 语言\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\nproject(hellocmake LANGUAGES CXX)\n\nadd_executable(main main.c)\n~~~\n  \n~~~c\n#include <stdio.h>\n\nint main(void)\n{\n    printf(\"Hello world from Cmake!\\n\");\n    return 0;\n}\n~~~\n  \n这样不行滴哥们，会报错，因为你在 CMakeLists.txt 的设置中没有启用 C 语言。  \n解决办法：\n  \n~~~cmake\ncmake_minimum_required(VERSiON 3.15)\nproject(hellocmake LANGUAGES C CXX)\n\nadd_executable(main main.c)\n~~~\n  \n这次启用了 C 和 C++ 就不会报错力。\n  \n##### 也可以先设置 LANGUAGES NONE, 之后调用 enable_language(CXX)\n  \n这样可以把 enable_language 放到 if 语句中，从而只有某些选项开启才启用某语言类似的操作。\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\nproject(hellocmake LANGUAGES NONE)\nenable_language(CXX)\n\nadd_executable(main main.cpp)\n~~~\n  \n#### 设置 C++ 标准：CMAKE_CXX_STANDARD 变量\n  \n* CMAKE_CXX_STANDARD 是一个整数，表示要用的 C++ 标准。  \n  比如需要 C++17 即设为 17。  \n* CMAKE_CXX_STANDARD_REQUIRED 是 BOOL 型，可以为 ON / OFF , 默认为 OFF。  \n  表示是否一定要支持指定的 C++ 标准，如果为 OFF 则CMake 检测到编译器不支持 C++17 时不报错，而是将设置调整为 C++14 让开发人员使用；为 ON 时，不支持会报错，具有更好的安全性。  \n* CMAKE_CXX_EXTENSIONS 是 BOOL 变量，默认为 ON。为 ON 表示启用 GCC 特有的一些拓展功能；OFF 则关闭 GCC 的拓展功能，只使用标准的 C++。  \n  要兼容其他编译器( 如 MSVC )的项目都会将其设为 OFF，以防使用了 GCC 特有的特性。  \n* 注意，最好在 project 命令前设置 CMAKE_CXX_STANDARD 一系列变量，这样一来 CMAKE 可以在 project 函数内对编译器进行一些检测，查看是否能支持对应版本C++的特性。\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS ON)\n\nproject(hellocmake LANGUAGES CXX)\n~~~\n  \n##### 常见误区 : 小彭老师，我手动加 -std=c++17 行不得行\n  \n* 不要直接修改 CMAKE_CXX_FLAGS 来添加 -std=c++17  \n  使用 CMake 封装好的 CMAKE_CXX_STANDARD  \n  前者为什么不好，GCC 用户一旦手动指定 -std=c++17, 就是使用了 GCC 的特性，而 MSVC 的用户就无法使用了。   \n  而且 CMake 已经自动根据 CMAKE_CXX_STANDARD 的默认值 11 添加了 -std=c++11，之后你再手动添加 -std=c++17 选项就发生了冲突。  \n  所以一定要使用 CMake 已经封装好的 CMAKE_CXX_STANDARD !\n  \n### projec 的初始化：VERSION 字段\n  \n* project(项目名 VERSION x.y.z) 可以将当前项目的版本号设定为 x.y.z  \n  之后可以使用 PROJECT_VERSION 获取当前项目的版本号  \n* PROJECT_VERSION_MAJOR 获取 x ( 主版本号 )  \n  PROJECT_VERSION_MINOR 获取 y ( 次版本号 )  \n  PROJECT_VERSION_PATCH 获取 z ( 补丁版本号 )\n  \n#### 项目名的另一个作用 : 会设置另外 <项目名>_SOURCE_DIR 等变量\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\nproject(hellocmake VERSION 2.7.1)\n\nmessage(\"PROJECT_NAME: ${PROJECT_NAME}\")\nmessage(\"PROJECT_VERSION: ${PROJECT_VERSION}\")\nmessage(\"PROJECT_SOURCE_DIR: ${PROJECT_SOURCE_DIR}\")\nmessage(\"PROJECT_BINARY_DIR: ${PROJECT_BINARY_DIR}\")\nmessage(\"hellocmake_VERSION: ${hellocmake_VERSION}\")\nmessage(\"hellocmake_SOURCE_DIR: ${hellocmake_SOURCE_DIR}\")\nmessage(\"hellocmake_BINARY_DIR: ${hellocmake_BINARY_DIR}\")\n~~~\n  \n>PROJECT_NAME: hellocmake  \n>PROJECT_VERSION: 2.7.1  \n>PROJECT_SOURCE_DIR: /home/bate/Codes/course/11/templa  \n>PROJECT_BINARY_DIR: /tmp/build/home/bate/Codes/course/11/templa  \n>hellocmake_VERSION: 2.7.1  \n>hellocmake_SOURCE_DIR: /home/bate/Codes/course/11/templa  \n>hellocmake_BINARY_DIR: /tmp/build/home/bate/Codes/course/11/templa\n  \n这个功能可以让我们在当前项目去查询别的项目的版本号比如在 hellocmake 查询 helloworld 的版本号或者其他信息。\n  \n#### 小技巧 : CMake 的 ${} 表达式可以嵌套\n  \n因为 ${PROJECT_NAME} 的值是 hellocmake  \n所以 ${${PROJECT_NAME}_VERSION} 相当于 ${hellocmake_VERSION} 即 2.7.1  \n[CMake 其他关键字](https://blog.csdn.net/fuyajun01/article/details/8891749)\n  \n#### 一个标准的 CMakeLists.txt 模板\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nproject(zeno LANGUAGES C CXX)\n\nif(PROJECT_BINARY_DIR STREQUAL PROJECT_SOURCE_DIR)\n\tmessage(WARING \"The binary directory of CMake cannot be the same as source directory!\")\nendif()\n\nif(NOT CMAKE_BUILD_TYPE)\n\tset(CMAKE_BUILD_TYPE Release)\nendif()\n\nif(WIN32)\n\tadd_definitions(-DNOMINMAX -D_USE_MATH_DEFINES)\nendif()\n\nif(NOT MSVC)\n\tfind_program(CCACHE_PROGRAM ccache)\n\tif(CCACHE_PROGRAM)\n\t\tmessage(STATUS \"Found CCache: ${CCACHE_PROGRAM}\")\n\t\tset_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_PROGRAM})\n\t\tset_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ${CCACHE_PROGRAM})\n\tendif()\nendif()\n~~~\n  \n## 第三章：链接库文件\n  \n### main.cpp 调用 mylib.cpp 里的 say_hello 函数\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executable(main main.cpp mylib.cpp)  \n  ~~~\n  \n* main.cpp\n  \n  ~~~c++  \n  #include \"mylib.h\"\n  \n  int main()  \n  {  \n  \tsay_hello();  \n  }  \n  ~~~\n  \n* mylib.cpp  \n  ~~~cpp  \n  #include \"mylib.h\"  \n  #include <cstdio>\n  \n  void say_hello()  \n  {  \n      printf(\"Hello, mylib!\\n\");  \n  }  \n  ~~~\n  \n#### 改进：mylib 作为静态库\n  \n> [《静态库和动态库》](https://www.jianshu.com/p/090e1c0310ab) , [《CMake | 编译静态库、动态库和对象库》](https://blog.csdn.net/weixin_39766005/article/details/122368414)  \n> 静态库会在*链接时*完整的复制到每一个可执行文件，被多次使用时就会造成多分冗余。  \n> 动态库在*链接时*不复制，程序运行时由系统动态加载到内存中，供程序调用，系统仅需加载一次，多个程序公用，节省内存。\n  \n* CMakeLists.txt\n  \n  ~~~cmake  \n  add_library(mylib STATIC mylib.cpp)\n  \n  add_executable(main main.cpp)\n  \n  target_link_libraries(main PUBLIC mylib)  \n  ~~~\n  \n#### 改进：mylib 作为一个动态库\n  \n* CMakeLists.txt ( 动态库在Windows上有坑 )  \n  ~~~cmake  \n  add_library(mylib SHARED mylib.cpp)\n  \n  add_executable(main main.cpp)\n  \n  target_link_libraries(main PUBLIC mylib)  \n  ~~~\n\n  \n#### 改进：mylib 作为一个对象库\n  \n对象库类似于静态库，但不生成 .a 文件，只由 CMake 记住该库生成了那些对象文件  \n~~~cmake\nadd_libraty(mylib OBJECT mylib.cpp)\n\nadd_executable(main main.cpp)\n\ntarget_link_libraries(main PUBLIC mylib)\n~~~\n  \n对象库是 CMake 自创的，绕开了编译器和操作系统的各种繁琐规则，保证了跨平台统一性。  \n在自己的项目中，推荐全部使用对象库( OBJECT ) 替代静态库 ( STATIC ) 避免跨平台的麻烦。  \n对象库仅仅作为组织代码的方式，而实际生成的可执行文件只有一个，减轻了部署的困难。\n  \n#### 静态库的麻烦：GCC 编译器会自作聪明，将自动剔除没有引用符号的对象\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_library(mylib STATIC mylib.cpp)  \n  ~~~\n  \n* mylib.cpp  \n  ~~~cpp  \n  #include <cstdio>  \n  // 静态初始化  \n  static int unused = printf(\"My initialized\\n\");\t// 会在主函数前被执行  \n  ~~~\n  \n* main.cpp  \n  ~~~c++  \n  #include <cstdio>\n  \n  int main()  \n  {  \n      printf(\"Main function\\n\");  \n  }  \n  ~~~\n  \n* Output  \n  >main function\n  \n这里就是 GCC 看到没有引用人 mylib ，就会删掉 mylib.o 但是恰恰遇到了静待初始化，GCC 就做错了。\n  \n#### 对象库就可以绕开编译器的不统一：保证不会自动剔除没有用到的对象文件\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_library(mylib OBJECT mylib.cpp)  \n  ~~~\n  \n* mylib.cpp\n  \n  ~~~c++  \n  #include <cstdio>\n  \n  static int unused = printf(\"Mylib Function\\n\");  \n  ~~~\n  \n* main.cpp  \n  ~~~c++  \n  #include <cstdio>\n  \n  int main()  \n  {  \n      printf(\"Main Function\\n\");  \n  }  \n  ~~~\n  \n* Output  \n  >Mylib Function  \n  >Main Function\n  \n#### add_library 无参数时，是静态库还是动态库\n  \n会根据 BUILD_SHARED_LIBS 这个变量的值决定是动态库还是静态库。  \nON 则相当于 SHARED, OFF 则相当于 STATIC  \n如果未指定 BUILD_SHARED_LIBS 变量，则默认为 STATIC。  \n因此，如果发现一个项目内的 add_library 都是无参的，意味着我们可以使用：  \n`cmake -B build -DBUILD_SHARD_LIBS:BOOL=ON`  \n来让他全部生成为动态库，这里涉及到*命令行传递变量的规则。*\n  \n~~~cmake\nset(BUILD_SHARED_LIBS ON)\n\nadd_library(mylib mylib.cpp)\n~~~\n  \n#### 小技巧：设定一个变量的默认值\n  \n要让 BUILD_SHARED_LIBS 默认为 ON，可以用之前类似的思路  \n如果该变量没有定义，则设为 ON，否则保持用户指定的值不变  \n这样用户没有指定 BUILD_SHARED_LIBS 时，会默认变成ON。  \n只有用户指定 BUILD_SHARED_LIBS 为 OFF 即 `-DBUILD_SHARED_LIBS:BOOL:OFF`  \n才会生成静态库，否则默认生成动态库。\n  \n~~~cmake\nif(NOT DEFINED BUILD_SHARED_LIBS)\n\tset(BUILD_SHARED_LIBS ON)\nendif()\n~~~\n  \n#### 常见坑点：动态库无法链接静态库\n  \n~~~cmake\nadd_library(otherlib STATIC otherlib.cpp)\n\nadd_library(mylib SHARED mylib.cpp)\ntarget_link_libraries(mylib PUBLIC otherlib)\n\nadd_executable(main main.cpp)\ntarget_link_libraries(main PUBLIC mylib)\n~~~\n  \n`target_link_libraries(mylib PUBLIC otherlib)`试图将静态库`otherlib`链接到`mylib`中，发生错误。*静态库`otherlib`误以为用户将其连接到一个可执行文件上*，但用户却连接到动态库上。动态库在内存中的地址会变化的，在编译时会指定一个`fPIC`选项，但是静态库没有`fPIC`选项，静态库的地址并不想变化，而动态库本身却想改变地址，二者会发生冲突。\n  \n##### 解决办法：\n  \n1、将`otherlib`变为对象库\n  \n~~~cmake\nadd_library(otherlib OBJECT otherlib.cpp)\n\nadd_library(mylib SHARED mylib.cpp)\ntarget_link_libraries(mylib PUBLIC otherlib)\n\nadd_executable(main main.cpp)\ntarget_link_libraties(main PUBLIC mylib)\n~~~\n  \n2、让静态库编译也生成位置无关的代码( PIC )，这样才能装在动态库中\n  \n~~~cmake\nset(CMAKE_POSITION_INDEPENDENT_CODE ON)\n\nadd_library(otherlib STATIC otherlib.cpp)\n\nadd_library(mylib SHARED mylib.cpp)\ntarget_link_libraries(mylib PUBLIC otherlib)\n\nadd_executable(main main.cpp)\ntarget_link_libraries(main PUBLIC mylib)\n~~~\n  \n但是这样处理会导致本来不需要为静态 PIC 的静态库也变成 PIC 了，**所以我们可以只针对一个库，只对他启用位置无关的代码( PIC )**  \n~~~cmake\nadd_library(otherlib STATIC otherib.cpp)\nset_property(TARGET otherlib PROPERTY POSITION_INDEPENDENT_CODE ON)\n\nadd_library(mylib SHARED mylib.cpp)\ntarget_link_libraries(mylib PUBLIC otherlib)\n\nadd_executable(main main.cpp)\ntarget_link_libraried(main PUBLIC mylib)\n~~~\n  \n**注意，add_library() 是要指定头文件的，这里偷懒没加，指定头文件后其就会出现在IDE中。**\n\n\n  \n## 第四章 : 对象的属性\n  \n前面提到的 `POSITION_INDEPENDENT_CODE` 就是一个属性。  \n### 除了 `POSITION_INDEPENDENT_CODE` 还有哪些属性呢？\n  \n~~~cmake\nadd_executable(main main.cpp)\n\nset_property(TARGET main PROPERTY CXX_STANDARD 17)\t# 采用 C++17 标准编译( 默认为11 )\nset_property(TARGET main PROPERTY CXX_STANDARD_REQUIRED ON)\t# 如果编译器不支持 C++17，则直接报错( 默认为 OFF )\nset_property(TARGET main PROPERTY WIN32_EXECUTABLE ON)\t# 在 Windows 系统中运行时不启动控制台窗口，只有 GUI 界面 (默认 OFF)\nset_property(TARGET main PROPERTY LINK_WHAT_YOU_USE ON)\t# 告诉编译器不要自动剔除没有引用符号的链接库(默认 OFF)\nset_property(TARGET main PROPERTY LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib)\t# 设置动态链接库的输出路径(默认 ${CMAKE_BINARY_DIR})\nset_property(TARGET main PROPERTY ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib)\t# 设置静态链接库的输出路径(默认 ${CMAKE_BINARY_DIR})\nset_property(TARGET main PROPERTY RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)\t# 设置可执行文件的输出路径(默认 ${CMAKE_BINARY_DIR})\n~~~\n  \n这样一个一个 `set_property` 好麻烦啊！要是有更简单的写法就好了，于是……\n  \n### 另一个方法 : `set_target_properties` 批量设置多个属性\n  \n~~~cmake\nadd_executable(main main.cpp)\n\nset_target_properties(main PROPERTIES\n\tCXX_STANDARD 17\n\tCXX_STANDARD_REQUIRED ON\n\tWIN32_EXECUTABLE ON\n\tLINK_WHAT_YOU_USE ON\n\tLIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib\n\tARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib\n\tRUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin\n)\n~~~\n  \n### 另一种方法：通过全局的变量，让之后创建的所有对象都享有同样的属性\n  \n相当于改变了各属性的默认初始值，要注意*此时* `set(CMAKE_xxx)` *必须在* `add_executable` *之前才有效*。  \n~~~cmake\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_WIN32_EXECUTABLE ON)\nset(CMAKE_LINK_WHAT_YOU_USE ON)\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib)\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)\n\nadd_executbale(main main.cpp) # 这里需要放在后面\n~~~\n  \n### 百度常见的错误！！！\n  \n对于 `CXX_STANDARD` 这种 CMake 本身提供了变量进行配置设置的，不要自己去设置 -std=c++17 选项，会和 CMake 自己设置好的产生冲突，导致出错！  \n请始终使用 `CXX_STANDARD` 或者全局变量 `CMAKE_CXX_STANDARD` 来设置 -std=c++17 这个 flag，CMake 会在配置阶段进行编译器检测是否支持 C++17。  \nCUDA 的 -arch=sm_75 也是同样的道理，请使用 `CUDA_ARCHITECTURES` 属性。  \n再者说 -std=c++17 只是 GCC 编译器的选项，也不能进行跨平台适用于 MSVC 编译器啊！！！\n  \n~~~cmake\nadd_executable(main main.cpp)\n\nset_property(TARGET main PROPERTY CXX_STANDARD 17)\t# 正确\ntarget_compile_options(main PUBLIC \"-std=c++17\")\t# 错误！！！！\nset_property(TARGET main PROPERTY CUDA_ARCHITECTURES 75)\t# 正确\ntarget_compile_options(main PUBLIC \"-arch=sm_75\")\t# 错误！！！\n~~~\n  \n### 假如在 Windows 使用动态链接库，需要额外操作\n  \n`m/mylib.cpp`\n  \n~~~c++\n#include <cstdio>\n// 需要手动加入这几句，在实现处加入dllexport\n#ifdef _MSC_VER\n__declspec(dllexport)\n#endif\nvoid say_hello(){\n    printf(\"Hello, world!\\n\");\n}\n~~~\n  \n`m/mylib.h`\n  \n~~~c++\n#pragma once\n// 在声明处，加入import\n#ifdef _MSC_VER\n__declspec(dllimport)\n#endif\nvoid say_hello();\n~~~\n  \n根目录下的 `CMakeLists.txt`  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\n\nadd_subdirectory(mylib)\n\nadd_executable(main main.cpp)\ntarget_link_libraries(main PUBLIC mylib)\n~~~\n  \n子目录`m`下的`CMakeLists.txt`, `m/CMakeLists.txt`  \n~~~cmake\nadd_library(mylib SHARED mylib.cpp mylib.h)\n~~~\n  \n#### 常见问题：链接了自己的 dll，但是运行时会找不到\n  \n* 这是因为 dll 和 exe 不在用一个目录，而愚蠢的 Windows 只会在**当前 exe 所在目录查找**，**然后查找 *PATH环境变量***，找不到就报错。而 dll 在其他目录，因此 Windows 找不到。  \n  * **解决办法1**：把 dll 所在位置加到 *PATH环境变量* 里，一劳永逸。  \n  * **结局办法2**：把这个 dll，以及这个 dll 依赖的其他所有 dll，全部拷贝到和 exe 文件同一目录下。\n  \n#### 手动拷贝 dll 好麻烦，CMake 能不能救一下！把 dll 自动生成在 exe 同一目录下\n  \n* 说到底还是因为 CMake 把定义在顶层模块里的 main 放在 `build/main.exe`  \n  而 mylib 因为是定义在 mylib 这个子模块里的，因此被放到了 `build/mylib/mylib.dll`\n  \n##### 解决1：设置 mylib 对象的 xx_OUTPUT_DEIRECTORY 系列属性\n  \n* 所以，可以设置 mylib 的这些属性，让 mylib.dll 文件输出到 PROJECT_BINARY_DIR，也就是项目根目录( main 所在的位置 )，这样 main.exe 在运行时就能找到 mylib.dll\n  \n* 为了侍奉 Windows，要设置全部的 6个属性！很烦！  \n  `m/CMakeLists.txt`\n  \n  ~~~cmake  \n  add_library(mylib SHARED mylib.cpp mylib.h)\n  \n  set_property(TARGET mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_DEBUG ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_DEBUG ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_DEBUG ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_RELEASE ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_RELEASE ${PROJECT_BINARY_DIR})  \n  ~~~\n  \n  这样就会输出到项目根目录 build 目录下\n  \n##### 而在 Linux 系统下就显得简便了\n  \n* Linux 系统支持 RPATH，CMake 会让生成出来可执行文件的 RPATH 指向他链接了的 .so 文件所在目录，运行时会优先从 RPATH 里找链接库，所以即使不在同目录也能找到。  \n  所以**第三种解决办法**，卸载 Windows 安装 Linux。  \n* 需要手动修改或者查看一个 ELF 文件的 RPATH，可以用 chrpath 或者 pathchelf 命令。\n\n\n  \n## 第五章：连接第三方库\n  \n### 例子：需要使用 tbb 库\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executable(main main.cpp)  \n  target_link_libraries(main PUBLIC tbb)\t# Linux 上直接链接 tbb 是可以的，但是 Windows 可能不行。  \n  ~~~\n  \n* main.cpp  \n  ~~~c++  \n  #include <tbb/parallel_for.h>\n  \n  int main(){  \n  \ttbb::parallel_for(0,4,[&](int i){  \n          printf(\"Hello, %d!\\n\", i);  \n      });  \n  }  \n  ~~~\n  \n* OutPut  \n  >Hello, 0!  \n  >Hello, 1!  \n  >Hello, 2!  \n  >Hello, 3!\n  \n#### 直接链接 tbb 的缺点\n  \nLinux 可以直接链接，是因为其有默认的库目录 `usr/lib` ，但是 Windows 没有一个固定的库安装位置。Linux 因为 `usr/lib/`, Linux 可以找到 `usr/lib/libtbb.so`  \n如果这样直接指定 tbb，CMake 会让连接器在系统的库目录里查找 tbb，他会找到 `usr/lib/libtbb.so` 这个系统自带的，但是对于没有一个固定库安装位置的 Windows 系统并不适用。  \n此外，他还要求 tbb 的头文件就在 `usr/include` 这个系统默认的头文件目录，  \n这样才能 `#include <tbb/parallel_for.h` 不报错，如果 tbb 的头文件在其他地方  \n就需要再加一个 `target_include_directories` 设置额外的头文件查找目录。\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executable(main main.cpp)  \n  target_link_libraries(main PUBLIC tbb)  \n  ~~~\n  \n#### Windows 可以直接写出全部的绝对路径，十分的硬核\n  \n也可以直接写出全部的路径，这样就能让没有默认系统路径的 Windows 系统找到安装在不知何处的 tbb，不过这样就不能跨平台了，如果其他人安装在不同位置就会发生错误。  \n**顺便一提，CMake 的路径分隔符始终是`/`。即使在 Windows 上，也要把所有的 `\\` 改成 `/`**，这是为了跨平台考量。请放心，CMake 会自动在调用 MSVC时转换成 `\\` ，可以放心的用 `${x}/bin` 来实现和 Python 的 [`os.path.join(x, 'bin')`](https://blog.csdn.net/swan777/article/details/89040802) 一样的效果。\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executable(main main.cpp)  \n  target_link_libraries(main PUBLIC C:/User/archibate/installed/tbb/tbb.dll)  \n  ~~~\n  \n  > 大多数操作系统都是 Unix-like，只有 Windows 搞特殊。  \n  > `cd /d C:\\\\Program\\ Files\\\\(x86\\)\\\\Micsoft\\ Visual\\ Studio\\\\2019\\\\`  \n  > 在路径中动不动就放一堆转移符、空格、特殊符号  \n  > 高情商：Windows 是最适合练习 C 语言转移符使用水平的平台！\n  \n#### 终于！`find_package`\n  \n更通用的方式：find_package  \n更好的办法就是使用 CMake 的 `find_package` 命令。  \n`find_package(TBB REQUIRED)` 会查找 `/usr/lib/cmake/TBB/TBBConfig.cmake` 这个配置文件，根据里面的配置信息创建 `TBB::tbb` 这个伪对象( 实际它指向真正的 tbb 库文件路径 `usr/lib/libtbb.so` )，之后通过 `target_link_libraries` 链接 `TBB::tbb` 就可以正常工作。\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executbale(main main.cpp)\n  \n  find_package(TBB REQUIRED)  \n  target_link_libraries(main PUBLIC TBB::tbb)\t# TBB 包下的 tbb 库  \n  ~~~\n  \n##### `TBB::tbb` 的秘密：自带了一些 PUBLIC 属性\n  \n`TBB::tbb` 是一个伪对象( imported )，他除了会指向 `/usr/lib/libtbb.so`，TBBConfig.cmake 还会给 TBB::tbb 添加一些 PUBLIC 属性，用于让链接了他的对象带上一些 flag 之类的。  \n比如，TBB 安装在 `/opt/tbb` 目录下，头文件在 `/opt/tbb/include` 里，那么这时 TBBConfig.cmake 里就会有 : `target_include_directories(TBB::tbb PUBLIC /opt/tbb/include)`  \n这样 main 在链接了 TBB::tbb 时也会被“传染”上 `/opt/tbb/include` 这个目录，无需手动添加。  \n再比如，TBB::tbb 链接了另一个库 Blosc::blosc，那么这个库也会自动连接到 main 上，无需调用者手动添加。\n  \n> 比如 spdlog 的 spdlog-config.cmake 就会定义 SPDLOG_NOT_HEADER_ONLY 这个宏为 PUBLIC 。从而实现直接 #include <spdlog/spdlog.h> 时候时纯头文件，而 find_package(spdlog REQUIRED) 时却变成预编译链接库的版本。( 其实不是 PUBLIC 而是 INTERFACE，因为伪对象没有实体 )\n  \n##### 和 `find_package(TBB CONFIG REQUIRED)` 有什么区别\n  \n其实更好的是通过 `find_package(TBB CONFIG REQUIRED)`，添加一个 CONFIG 选项。  \n这样他会优先查找 TBBConfig.cmake ( 系统自动的 ) 而不是 FindTBB.cmake ( 项目作者常把他塞在 cmake/ 目录里并添加到 CMAKE_MODULE_PATH )。这样能保证寻找包的这个 .cmake 脚本是和系统自带的 tbb 版本是适配的，而不是项目作者当年下载的那个版本的 .cmake 脚本。\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executable(main main.cpp)\n  \n  find_package(TBB CONFIG REQUIRED)  \n  target_link_libraries(main PUBLIC TBB::tbb)  \n  ~~~\n  \n当然如果坚持要用 find_package(TBB REQUIRED) 也是可以的。  \n没有 CONFIG 选项：先找 FindTBB.cmake，再找 TBBConfig.cmake，找不到就报错。  \n有 CONFIG 选项：只会找 TBBConfig.cmake，找不到则报错。  \n此外有一些老年项目( 比如 OpenVDB ) 只提供 Find 而没有 Config 文件，这时候只能用 find_package(OpenVDB REQUIRED) 而不能带 CONFIG 选项。\n  \n#### /usr/lib/cmake/TBB/TBBConfig.cmake 长什么样？\n  \n不论 TBBConfig.cmake 还是 FindTBB.cmake，这个文件通常由库的作者提供，在 Linux 的包管理器安装 tbb 后也会自动安装这个文件。少部分对 CMake 不友好的第三方库，需要自己写 FindXXX.cmake 才能使用。\n  \n* TBBConfig.cmake  \n  ~~~cmake  \n  # Create imported target TBB::tbb  \n  add_library(TBB::tbb SHARED IMPORTED)\n  \n  set_target_properties(TBB::tbb PROPERTIES  \n  \tINTERFACE_COMPILE_DEFINITIONS \"\\$<\\$<CONFIG:DEBUG>:TBB_USE_DEBUG>\"  \n  \tINTERFACE_INCLUDE_DIRECTORIES \"${_IMPORT_PREFIX}/include\"  \n  )\n  \n  # Create imported target TBB::tbbmalloc  \n  add_library(TBB::tbbmalloc SHARED IMPORTED)\n  \n  set_target_proerties(TBB::tbbmalloc PROPERTIES  \n  \tINTERFACE_COMPILE_DEFINITIONS \"\\$<\\$<CONFIG:DEBUG>:TBB_USE_DEBUG>\"  \n  \tINTERFACE_INCLUDE_DIRECTORIES \"${_IMPORT_PREFIX}/include\"  \n  )\n  \n  # Create imported target TBB::tbbmalloc_proxy  \n  add_library(TBB::tbbmalloc_proxy SHARED IMPORTED)\n  \n  set_target_properties(TBB::tbbmalloc_proxy PROPERTIES  \n  \tINTERFACE_COMPILE_DEFINITIONS \"\\$<\\$<CONFIG:DEBUG>:TBB_USE_DEBUG>\"  \n  \tINTERFACE_INCLUDE_DIRECTORIES \"${_IMPORT_PREFIX}/include\"  \n  )  \n  ~~~\n  \n  \n#### find_package(Qt5 REQUIRED) 出错\n  \n~~~cmake\nfind_package(Qt5 REQUIRED)\ntarget_link_libraries(main PUBLIC Qt5::Widgets Qt5::Gui)\n~~~\n  \n* **ERROR**  \n  <img src=\"/imgs/CMake Note/Qt5Error.png\" alt=\"Qt5报错\">  \n  这里是说( 看最后一句 ) Qt5 包至少需要一个组件。  \n  Qt5 有很多组件，但是直接 `find_package(Qt5 REQUIRED)` 他不知道用户需要哪些组件。\n  \n##### 原因：Qt5 具有多个组件，你必须指定你需要哪些组件\n  \nfind_package 生成的伪对象 (imported target) 都按照 “包名::组件名” 的格式命名。  \n可以在 find_package 中通过 **COMPONENTS** 选项，后面跟随一个列表表示需要用的组件。\n  \n~~~cmake\nfind_package(Qt5 COMPONENTS Widgets Gui REQUIRED)\ntarget_link_libraries(main PUBLIC Qt5::Widgets Qt5::Gui)\n~~~\n  \n~~~cmake\nfind_package(TBB COMPONENTS tbb tbbmalloc tbbmalloc_proxy REQUIRED)\ntarget_link_libraries(main PUBLIC TBB::tbb TBB::tbbmalloc TBB::tbbmalloc_proxy)\n~~~\n  \n##### 常见错误：Windows 找不到 Qt5\n  \n因为 Windows 系统安装路径混乱没有固定的 /usr/lib 之类的默认路径能供CMake搜索所以报错了。  \n<img src=\"/imgs/CMake Note/Qt5CannotFound.png\" alt=\"Qt5找不到\">\n  \n* 假设 Qt5 安装在 C:\\Qt\\Qt5.14.2，去找这个目录  \n  C:\\Qt\\Qt5.14.2\\msvc2019_64\\lib\\cmake\\\n  \n* 会有一个 Qt5Config.cmake，现在有四种办法可以让CMake找到他\n  \n  * **第一种**：设置 CMAKE_MODULE_PATH 变量，添加一下包含 Qt5Config.cmake 这个文件的目录路径 C:\\Qt\\Qt5.14.2\\msvc2019_64\\lib\\cmake，当然这里也要把 `\\` 换成 `/`，因为 CMake 是倾向 Unix 的构建，*<del>这是派别和历史问题了</del>*。这种方法相当于在 CMake 搜索目录里加上这个路径，其他包在搜索遍历时也会遍历过这个路径，后面会有更好的办法。\n  \n    ~~~cmake  \n    set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} C:/Qt/Qt5.14.2/msvc2019_64/lib/cmake)\n    \n    find_package(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)  \n    target_link_libraries(main PUBLIC Qt5::Widgets Qt5::Gui)  \n    ~~~\n  \n  * **第二种(更好的办法)：设置<包名>_DIR 变量指向 <包名>Config.cmake 所在位置**  \n    设置 Qt5_DIR 这个变量为 C:\\Qt\\Qt5.14.2\\msvc2019_64\\lib\\cmake  \n    这样只有 Qt5 这个包会去这个目录里搜索 Qt5Config.cmake 更有针对性。\n  \n    ~~~cmake  \n    set(Qt5_Dir C:/Qt/Qt5.14.2/msvc2019_64/lib/cmake)\n    \n    find_package(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)  \n    target_link_libraries(main PUBLIC Qt5::Widgets Qt5::Gui)  \n    ~~~\n\n  \n  * 第三种(推荐)，直接在命令行通过 `-DQt5_DIR=\"xxx\"` 指定，这样不用修改 CMakeLists.txt  \n    `cmake -B build -DQt5_DIR=\"C:/Qt/Qt5.14.2/msvc2019_64/lib/cmake\"`  \n  * 第四种，还可以设置环境变量 Qt5_DIR 也是可以的，就是对 Windows 用户比较困难  \n    `export Qt5_DIR=\"/opt/Qt5.14.2/lib/cmake\"`\n  \n### 不指定 REQUIRED 找不到时不报错，只会设置 TBB_FOUND 为 FALSE\n  \n ~~~cmake  \n find_package(TBB)  \n if(TBB_FOUND)  \n \tmessage(STATUS \"TBB found at:${TBB_DIR}\")  \n \ttarget_link_libraries(main PUBLIC TBB::tbb)  \n \ttarget_compile_definitions(main PUBLIC WITH_TBB)  \n else()  \n \tmessage(WARNING \"TBB not found! using serial for\")  \n endif()  \n ~~~\n  \n前面很多例子都在 find_package() 加上 REQUIRED 选项。  \n如果我们不加 REQUIRED，在找不到对应 package 时不会报错。  \n这样的设计目的在于，当我们添加一些可选的依赖，如果没有也不会影响程序基本运行，我们找不到可选项，就可以向用户抛出一个警告。  \n找到了会把 TBB_FOUND 设为 TRUE，TBB_DIR 也会设置为 TBBConfig.cmake 所在目录。  \n找不到会把 TBB_FOUND 设为 FASLE，TBB_DIR 也会为空。  \n这里我们在找到 TBB 的 if 里定义一个 WITH_TBB 宏，稍后在 .cpp 里就可以根据这个判断。  \n如果找不到 TBB 可以 fallback 到保守的实现方式。  \n`-- TBB found at: /usr/lib64/cmake/TBB`\n  \n#### 在 C++ 中判断 WITH_TBB 宏，找不到 TBB 则退化到串行 for 循环\n  \n~~~c++\n#include <cstdio>\n#ifdef WITH_TBB\n#include <tbb/parallel_for.h>\n#endif\n\nint main()\n{\n#ifdef WITH_TBB\n\ttbb::parallel_for(0,4,[&](int i){\n#else\n        for(int i = 0; i < 4; i++){\n#endif\n\t\t\tprintf(\"hello, %d!\\n\",i);\n#ifdef WITH_TBB\n    });\n#else\n    }\n#endif\n}\n~~~\n  \n### 也可以使用 TARGET 判断是否存在 TBB::tbb 这个伪对象，实现 TBB_FOUND 的效果\n  \n~~~cmake\nfind_package(TBB)\nif(TARGET TBB::tbb)\n\tmessage(STATUS \"TBB found at:${TBB_DIR}\")\n\ttarget_link_libraries(main PUBLIC TBB::tbb)\n\ttarget_compile_definitions(main PUBLIC WITH_TBB)\nelse()\n\tmessage(WARNING \"TBB not found! using serial for\")\nendif()\n~~~\n  \n同时也可以在 if 进行复合语句判断  \n`NOT TARGET TBB::tbb AND TARGET Eigen3::eigen`  \n表示找得到 TBB 但是找不到 Eigen3。\n  \n## 第六章：输出与变量\n  \n### 在运行 cmake -B build 时，打印字符串用于调试程序 \n  \n~~~cmake\nmessage(\"Hello World\")\n~~~\n  \n>Hello world\n  \nmessage 会把字符串打在命令行。\n  \n#### message(STATUS \"...\")\n  \n~~~cmake\nmessage(STATUS \"Hello World\")\n~~~\n  \n>-- Hello world\n  \n不带 `STATUS` 选项，cmake 认为：“哦，你的需求很紧急，你只想调试程序。”，被认为是调试信息。  \n带上 `STATUS` 表示是状态信息，告诉用户做了这件事。\n  \n#### message(WARING \"...\") 表示警告信息\n  \n~~~cmake\nmessage(STATUS \"Hello world\")\nmessage(WARNING \"This is a warning sign\")\n~~~\n  \n>CMake Warning at CMakeLists.txt:2 (message):  \n>  This is a warning sign!\n  \n#### message(AUTHOR_WARNING \"...\") 表示仅仅是给项目作者看的警告\n  \n~~~cmake\nmessage(STATUS \"Hello world\")\nmessage(AUTHOR_WARNING \"Hollow Knight is the best!\")\n~~~\n  \n>-- Hello world  \n>CMake Warning (dev) at CMakeLists.txt:2 (message):  \n>  Hollow Knight is the best!  \n>This warning is for project developers. Use -Wno-dev suppress it.\n  \n**AUTHOR_WARNING 可以通过 -Wno-dev 关闭**\n  \n`cmake -B build -Wno-dev`\n  \n#### message(FATAL_ERROR \"...\") 表示是错误信息，会终止 CMake 的运行\n  \n~~~cmake\nmessage(STATUS \"Hello world\")\nmessage(FATAL_ERROR \"This is an error message!\")\nmessage(STATUS \"After Error\")\n~~~\n  \n>-- Hello world  \n>CMake Error at CMakeLists.txt:2 (message):  \n>  This is an error message!\n  \n因为程序被中断所以 Hello world 被打印，Error 有执行，但是 After Error 没有执行，因为在 Error message 处被中断运行了。\n  \n#### message(SEND_ERROR \"...\") 表示错误信息，但之后的语句仍继续执行\n  \n~~~cmake\nmessage(STATUS \"Hello world\")\nmessage(SEND_ERROR \"This is an error message!\")\nmessage(STATUS \"After Error\")\n~~~\n  \n>-- Hello world  \n>CMake Error at CMakeLists.txt:2 (message) :  \n>  This is an error message  \n>  \n>After Error\n  \n可以看到 After Error 正常运行。\n  \n### message 可以用于打印变量\n  \n~~~cmake\nset(myvar \"Hello world\")\nmessage(\"myvar is: ${myvar}\")\n~~~\n  \n>myvar is: Hello world  \n>-- Configuring done  \n>-- Generating done\n  \n#### 如果 set 没加引号会怎么样？\n  \n**会变成分号分隔的列表。**  \n这时候 set(myvar Hello world) 等价于 set(myvar \"Hello;world\")\n  \n~~~cmake\nset(myvar Hello world)\nmessage(\"myvar is: ${myvar}\")\n~~~\n  \n>myvar is: Hello;world  \n>-- Configuring done  \n>-- Generating done\n  \n#### 如果 message 没加引号会怎么样？\n  \n**会把列表里的字符串当作他的关键字**  \n结论：除非实在实在需要列表，不然建议始终在你不确定的地方加上引号，例如：  \nset(source \"main.cpp\" \"mylib.cpp\" \"C:/Program Files/a.cpp\")  \nmessage(\"${source}\")  \n这里的 `C:/Program Files/a.cpp` 有空格所以最好使用引号，这也是为什么CMake用 `;` 做分割，因为 ` ` 可能出现在路径中，而 `;` 不会出现在文件路径中。\n  \n~~~cmake\nset(myvar FATAL_ERROR hello)\nmessage(${myvar})\n# 这样${myvar} 会变成 FATAL_ERROR hello\n~~~\n  \n>CMake Error at CMakeLists.txt:2 (message) :  \n>  hello\n  \n## 第七章：变量与缓存(最大坑点)\n  \n### 重复执行 cmake -B build 会有什么区别\n  \n假如多次执行后几次执行会比第一次执行输出少很多。  \n这是因为 CMake 第一遍需要检测编译器和 C++ 特性等比较耗时，检测完后会把结果存储的**缓存**中，这样第二遍运行cmake -B build 时就可以直接使用缓存的值，就不需要在检测一遍了。\n  \n### 如何清理缓存？删 build 大法\n  \n虽然 CMake 缓存为了加快编译的出发点是好的，但是有问题。比如有时候外部的情况有所更新比如原来的编译器被卸载或者更改，这时候 CMake 缓存内却还存储的是旧的值，就会导致一些问题。  \n最简单的解决办法就是删除 build 文件夹，然后重新运行 cmake -B build。  \n缓存是很多 CMake 出错的根源，因此如果出现诡异的错误，可以先试着删除 build 重新构建看看。  \n删除了缓存就会重新跑一边检测，写新缓存。  \n所以有了经典的 CMake 笑话：\n  \n>99%的 cmake 错误都可以用删 build 解决  \n>删 build 大法好  \n>rm -rf build\n  \n### 清除缓存，其实只需删除 build/CMakeCache.txt 就可以了\n  \n删除 build 虽然简单粗暴彻底，但是这会导致编译产生的中间结果 (.o文件) 也都被删除了，重新编译需要花费很长时间。  \n如果只想清除缓存，不想从头重新编译，可以只删除 build/CMakeCache.txt 这个文件。  \n它存储了缓存的变量，删除它就可以让 CMake 强制重新检测一遍所有的库和编译器。  \n但是有些错误是中间文件的问题还是要删除 build  \n### find_package 就用到了缓存机制\n  \n变量缓存的意义在于能把 find_package 找到的库文件位置等信息，存储起来。  \n这下下次 find_package 时就会利用上缓存的变量，直接返回。  \n避免重复执行 cmake -B 时速度变慢的问题。\n  \n但是会有这样一个问题，假如第一次 build，没有 TBB 库  \n然后我们安装 TBB 后，再次进行build  \n这时候 CMake 读了缓存发现：“哦，我之前找过 TBB，没找到，那不用找了没有 TBB 库”  \n这时候 CMake 就不会去找了……  \n这时候就要 rm -rf build/CMakeCache.txt，删除缓存文件让 CMake 强行重新配置。\n  \n### 设置缓存变量\n  \n语法是：`set(变量名 \"变量值\" CACHE 变量类型 \"注释\")`\n  \n~~~cmake\nset(myvar \"hello\" CACHE STRING \"this is the docstring.\")\nmessage(\"myvar is: ${myvar}\")\n~~~\n  \n**缓存的 myvar 会出现在 build/CMakeCache.txt 里。**\n  \n### 常见问题：我修改了 CMakeLists.txt 里 set 的值，却没有更新。\n  \n为了更新缓存变量，经常有人偷懒直接修改 CMakeLists.txt 里的值，这是没用的。  \n因为 set(...CACHE..) 在缓存变量已经存在的时候，不会去更新缓存的值。  \nCMakeLists.txt 里 set 的值被认为是“默认值”，因此不会在第二次 set 的时候更新。  \n比如上面我们设置过 myvar 的内容是 hello，然后 build，现在改成 world，但是 CMakeCaChe.txt 内的 myvar 还会是 hello\n  \n~~~cmake\nset(myvar \"world\" CACHE STRING \"This is the docstring!\")\nmessage(\"myvar is: ${myvar}\")\n~~~\n  \n### 缓存变量如何更新？标准解法：通过命令行 -D参数\n  \n当然可以使用 ”删 build 大法“，但是有更好的。  \n更新缓存变量正确的方式，通过命令行参数：`cmake -B build -Dmyvar=world`\n  \n#### 命令行 -D 太硬核了，有没有图形化的缓存编译器？\n  \n* 在 Linux 中，可以运行 ccmake -B build 启动基于终端的可视化缓存编辑菜单。  \n* 在 Windows 中，可以 cmake-gui -B build 来启动图形界面编辑各个缓存选项。  \n* 当然，可以直接用编辑器打开 build/CMakeCaChe.txt 修改后保存。  \n  CMakeCaChe.txt 用文本文件存储的目的就是可供用户手动编辑，或者被第三方软件打开并解析的。\n  \n### 也可以通过指定 FORCE 来强制 set 更新缓存\n  \nset 可以在后面加一个 FORCE 选项，表示无论缓存存在与否，都强制更新缓存。  \n不过这样就会导致没办法用 -Dmyvar=othervalue 来更新缓存变量。\n  \n~~~cmake\nset(myvar \"world\" CACHE STRING \"This is the docstring\" FORCE)\nmessage(\"mtvar is: ${myvar}\")\n~~~\n  \n### 缓存变量除了 STRING 还有哪些类型？\n  \n* STRING 字符串，比如：\"hello\",\"world\"  \n* FILEPATH 文件路径，例如：\"C:/vcpkg/scripts/buildsystems/vcpkg.cmake\"  \n* PATH 目录路径，例如：\"C:/Qt/Qt5.14.2/msvc2019_64/cmake/\"  \n* BOOL 布尔值，只有两个取值：ON 或 OFF  \n  注意：TRUE 和 ON 等价，FALSE 和 OFF 等价；YES 和 ON 等价，NO 和 OFF 等价。\n  \n#### 添加一个 BOOL 类型变量，用于控制是否启用某些特性\n  \n~~~cmake\nadd_executable(main main.cpp)\n\nset(WITH_TBB ON CACHR BOOL \"set to ON to enable TBB, OFF to disable TBB.\")\n\nif(WITH_TBB)\n\ttarget_compile_definitions(main PUBLIC WITH_TBB)\n\tfind_package(TBB REQUIRED)\n\ttarget_link_libraries(main PUBLIC TBB::tbb)\nendif()\n~~~\n  \n这里就是用 CACHE变量 控制是否启用 TBB。\n  \n#### CMake 对 BOOL 类型缓存的 set 提供了简写：option\n  \n`option(变量名 \"描述\" 变量值)`  \n等价于  \n`set(变量名 CACHE BOOL 变量值 \"描述\")`\n  \n~~~cmake\nadd_executable(main main.cpp)\n\noption(WITH_TBB \"set to ON to enable TBB, OFF to disable TBB.\")\nif(WITH_TBB)\n\ttarget_compile_definitions(main PUBLIC WITH_TBB)\n\tfind_package(TBB REQUIRED)\n\ttarget_link_libraries(main PUBLIC TBB::tbb)\nendif()\n~~~\n  \noption 的本质还是 set CACHE  \n所以还会有和 set CACHE 一样的问题：option 设置成了 OFF，但是还是 ON。\n  \n#### 常见问题：在 CMakeLists.txt 里修改了 option 为 OFF，但是运行出来还是 ON\n  \n因为 option 本质就是 set CACHE，  \n虽然修改了，但是 CMakeCaChe.txt 内还是 ON\n  \n#### 解决办法还是 -D参数 来修改\n  \n-D变量名:BOOL=ON/OFF  \n`cmake -B build -DWITH_TBB:BOOL=OFF`\n  \n#### 或者改用 set 然后 Force\n  \n#### 绕靠缓存：使用普通变量，但仅当没有定义时设定为默认值\n  \n一般而言，CMake 自带的变量( 如 CMAKE_BUILD_TYPE )都这样设置。  \n**这样项目的使用者还是可以用 -D来指示参数，**只不过不会在 ccmake 里被显示。(ccmake是查询缓存的)\n  \n~~~cmake\nif(NOT DEFINED WITH_TBB)\n\tset(WITH_TBB ON)\nendif()\nmessage(\"WITH_TBB: ${WITH_TBB}\")\nif(WITH_TBB)\n\ttarget_compile_definition(main PUBLIC WITH_TBB)\n\tfind_package(TBB REQUIRED)\n\ttarget_link_libraries(main PUBLIC TBB::tbb)\nendif()\n~~~\n  \n## 第八章：跨平台和编译器\n  \n### 在CMake 中给 .cpp 定义一个宏\n  \n~~~cpp\n#include <cstdio>\n\nint main()\n{\n#ifdef MY_MACRO\n    printf(\"MY_MACRO defined! value: %d\\n\", MY_MACRO);\n#else\n    printf(\"MY_MACRO not defined!\\n\");\n#endif\n}\n~~~\n  \n~~~cmake\nadd_executable(main)\nfile(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)\ntarget_sources(main PUBLIC ${sources})\ntarget_compile_definitions(main PUBLIC MY_MACRO=233)\t# 相当于 gcc -DMY_MACRO=233\n~~~\n  \n> MY_MACRO defined! value: 233\n  \n### 根据不同的操作系统，把宏定义为不同的值\n  \n~~~c++\n#include <cstdio>\n\nint main()\n{\n#ifdef MY_NAME\n    printf(\"Hello, %s!\\n\", MY_NAME);\n#else\n    printf(\"I don`t know your name!\\n\");\n#endif\n}\n~~~\n  \n~~~cmake\nif(CMAKE_SYSTEM_NAME MATCHES \"Windows\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Bill Gates\")\nelseif(CMAKE_SYSTEM_NAME MATCHES \"Linux\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Linus Torvalds\")\nelseif(CMAKE_SYSTEM_NAME MATCHES \"Darwin\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Steve Jobs\")\nelseif()\n~~~\n  \n### CMake 提供了一些简写变量：WIN32, APPLE, UNIX, ANDROID, IOS等等\n  \n虽然是 WIN32 但是对 32位和 64位Windows一样适用  \nAPPLE 对所有苹果产品 MacOS/IOS 都为真  \nUNIX 对所有 Unix 类系统( FreeBSD, Linux, Android, MacOS, IOS ) 都为真\n  \n~~~cmake\nif(WIN32)\t# WIN32 这些是 bool 类型\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Bill Gates\")\nelseif(UNIX AND NOT APPLE)\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Linus Torvalds\")\nelseif(APPLE)\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Steve Jobs\")\nelseif()\n~~~\n  \n### 使用生成器表达式，简化指令\n  \n语法：`$<$<类型:值>:为真时表达式>`  \n比如`$<$<PLATFORM_ID:Windows>:MY_NAME=\"Bill Gates\">`  \n在 Windows 平台上还会变成 MY_NAME=\"Bill Gates\"  \n其他平台则为空字符。\n  \n~~~cmake\ntarget_compile_definitions(main PUBLIC\n\t$<$<PLATFROM_ID:Windows>:MY_NAME=\"Bill Gates\">\n\t$<$<PLATFROM_ID:Linux>:MY_NAME=\"Linus Torvalds\">\n\t$<$<PLATFROM_ID:Darwin>:MY_NAME=\"Steve Jobs\">\n)\n~~~\n  \n### 生成器表达式：如需多个平台可以用逗号分隔\n  \n~~~cmake\ntarget_compile_definitions(main PUBLIC\n\t$<$<PLATFORM_ID:Windows>:MY_NAME=\"DOS-like\">\n\t$<$<PLATFROM_ID:Linux,Darwin,FreeBSD>:MY_NAME=\"Unix-like\">\n)\n~~~\n  \n相关参考：[CMake : PLATFROM_ID](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#genex:PLATFROM_ID)\n  \n### 判断当前是哪一款 C++ 编译器\n  \n~~~cmake\nif(CMAKE_CXX_COMPILER_ID MATCHES \"GNU\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"gcc\")\nelseif(CMAKE_CXX_COMPILER_ID MATCHES \"NVIDIA\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"nvcc\")\nelseif(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n\ttarget_compile_difinitions(mian PUBLIC MY_NAME=\"clang\")\nelseif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"msvc\")\nendif()\n~~~\n  \n### 也同样可以使用生成器表达式\n  \n~~~cmake\ntarget_compile_definitions(main PUBLIC\n\t$<$<CXX_COMPILER_ID:GNU,Clang>:MY_NAME=\"Open-source\">\n\t$<$<CXX_COMPILER_ID:MSVC,NVIDIA>:MY_NAME=\"Commercial\">\n)\n~~~\n  \n### 生成器表达式可以做复杂的逻辑判断\n  \n~~~cmake\ntarget_compile_definitions(main PUBLIC\n\t$<$<AND:$<CXX_COMPILER_ID:GNU,Clang>,$<PLATFROM_ID:Linux,FreeBSD>>:MY_NAME=\"Open-source\">\n)\n~~~\n  \n### CMake 还提供了一些简写变量：MSVC, CMAKE_COMPILER_IS_GNUCC\n  \n~~~cmake\nif(MSVC)\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"MSVC\")\nelseif(CMAKE_COMPILER_IS_GNUCC)\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"GCC\")\nelse()\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Other compiler\")\nendif()\n~~~\n  \n### CMAKE_CXX_COMPILER_ID 直接作为字符串变量\n  \n~~~cmake\ntarget_compile_definitions(main PUBLIC MY_NAME=\"The ${CMAKE_CXX_COMPILER_ID} Compiler\")\n~~~\n  \n### 从命令行参数指定编译器\n  \n`cmake -B build -DCMAKE_CXX_COMPILER=\"/usr/bin/clang++\"`  \n当然这个得第一次就定义，如果第二次使用这个命令需要 删build 清除缓存。\n  \n### 也可以通过环境变量 CXX 指定\n  \n`CXX='which clang' cmake -B build`\n  \n### CMAKE_GENERATOR 也可以了解一下\n  \n~~~cmake\nmessage(\"Generator:${CMAKE_GENERATOR}\")\nmessage(\"C++ compiler: ${CMAKE_CXX_COMPILER}\")\nmessage(\"C compiler: ${CMAKE_C_COMPILER}\")\n~~~\n  \n## 第九章：分支和判断\n  \n### BOOL 类型的值\n  \n* 通常来讲只有 ON/OFF 两个取值  \n  但是由于历史问题，TRUE/FALSE 和 YES/NO 也可以表示 BOOL 类型  \n* 但是推荐只使用 ON/OFF 避免混淆\n  \n### if 的特点：不需要加 ${}, 会自动尝试作为变量名求值\n  \n由于历史问题，if 的括号中有着特殊的语法，如果是一个字符串，比如 MYVAR，则他会先看是否有 ${MYVAR} 这个变量，如果有则被替换为变量的值来进行接下来的比较，否则保持原来的字符串不变。  \n~~~cmake\nset(MYVAR Hello)\nif(MYVAR MATCHES Hello)\n\tmessage(\"MYVAR is Hello\")\nelse()\n\tmessage(\"MYVAR is not hello\")\nendif()\n~~~\n  \n### 如果加上 ${} 也没区别\n  \n`if(${MYVAR} MATCHES \"Hello\")` 会展开成 `if(Hello MACHES \"Hello\")`  \n因为没有 Hello 变量所以被视为字符串正常进行匹配。\n  \n### 万一定义了 Hello 变量那就寄了\n  \n~~~cmake\nset(MYVAR Hello)\nset(Hello world)\nif(${MYVAR} MATCHES \"Hello\")\n\tmessage(\"MYVAR is Hello!\")\nelse()\n\tmessage(\"MYVAR is not Hello!\")\nendif()\t\n~~~\n  \n`if(${MYVAR} MATCHES \"Hello\")` 变成 `if(Hello MATCHES \"Hello\")`  \nif 认为用户要使用 Hello 变量，然后就出错了。  \n这里不要自作聪明加 ${} 就好了。\n  \n### 解决：用引号包裹，防止被当作变量名\n  \n~~~cmake\nset(MYVAR Hello)\nset(Hello world)\nif(\"${MYVAR}\" MATCHES \"Hello\")\n\tmessage(\"MYVAR is Hello!\")\nelse()\n\tmessage(\"MYVAR is not Hello!\")\nendif()\t\n~~~\n  \n但是你不觉得麻烦吗？直接变量名就好了。  \n**另外：CMake 仅仅是指令( set,message 这些 )不分大小写，但变量名什么的是分大小写的！**\n  \n## 第十章：变量和作用域\n  \n### 变量的传递规则：父传子\n  \n* 父模块内容会传递给子模块\n  \n* CMakeLists.txt\n  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)\n  \n  set(MYVAR ON)  \n  add_executable(main main.cpp)  \n  ~~~\n  \n* m/CMakeLists.txt  \n  ~~~cmake  \n  message(\"MYVAR is ${MYVAR}\")  \n  ~~~\n  \n* Output  \n  >MYVAR is ON\n  \n### 变量传递规则：子不传父\n  \n* 如果父模块本来就定义同名变量，则离开子模块后仍保持父模块原来设置的值。\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)\n  \n  set(MYVAR OFF)  \n  add_subdirectory(mylib)  \n  message(\"MYVAR:${MYVAR}\")  \n  ~~~\n  \n* m/CMakeLists.txt\n  \n  ~~~cmake  \n  set(MYVAR ON)  \n  ~~~\n  \n* Output\n  \n  >MYVAR:OFF\n  \n### 若子模块想向父模块传递变量该怎么办？\n  \n* 可以使用 set 的 PARENT_SCOPE 选项把一个变量传递到上一层作用域\n  \n* CMakeLists.txt\n  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)\n  \n  set(MYVAR OFF)  \n  add_subdirectory(mylib)  \n  message(\"MYVAR:${MYVAR}\")  \n  ~~~\n  \n* m/CMakeLists.txt\n  \n  ~~~cmake  \n  set(MYVAR ON PARENT_SCOPE)  \n  ~~~\n  \n* Output\n  \n  >MYVAR:ON\n  \n* 如果父模块没有定义 MYVAR，也可以使用缓存变量向外传递( 不建议, 这样很不安全 )，但是因为缓存变量是全局的，这样不仅父模块可见，父模块的父模块也可见。\n  \n  * CMakeLists.txt\n  \n    ~~~cmake  \n    cmake_minimum_required(VERSION 3.15)\n    \n    add_subdirectory(mylib)  \n    message(\"MYVAR:${MYVAR}\")  \n    ~~~\n  \n  * m/CMakeLists.txt\n  \n    ~~~cmake  \n    set(MYVAR ON CACHE BOOL \"\" FORCE)  \n    ~~~\n  \n  * Output\n  \n    >MYVAR:ON\n  \n### 除了父模块还有哪些是带有独立作用域的\n  \n* include 的 XXX.cmake **没有**独立作用域  \n* add_subdirectory 的 CMakeLists.txt 有独立作用域  \n* macro **没有**独立作用域，插入执行，变量会暴露出来  \n* function **有**独立作用域，变量不会暴露出来  \n* 因此 PARENT_SCORE 也可以用于 function 的返回值\n  \n### 环境变量的访问方式：$ENV{xx}\n  \n* 用 ${xx} 访问的是局部变量，局部变量服从刚刚说的父子模块传递规则。\n  \n* 而还有一种特殊的方式可以访问系统的环境变量( enviroment variable ) : $ENV{xx}\n  \n* 比如 $ENV{PATH} 获取的就是 PATH 这个环境变量的值  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)  \n  project(helloCMake)\n  \n  message(\"PATH:$ENV{PATH}\")  \n  ~~~\n  \n### 缓存变量的访问方式：$CACHE{xx}\n  \n* 还可以用 $CACHE{xx} 访问缓存变量  \n  缓存变量和环境变量都是全局的，没有作用域一说\n  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)  \n  project(helloCMake)\n  \n  message(\"CMAKE_BUILD_TYPE:$CACHE{CMAKE_BUILD_TYPE}\")  \n  ~~~\n  \n### ${xx} 找不到局部变量时，会自动去找缓存变量\n  \n* 当 ${xx} 在局部变量找不到时，回去查询名为 xx 缓存变量\n  \n* 所以这里虽然没有定义 CMAKE_BUILD_TYPE，但是 ${} 在缓存变量中找到了  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)  \n  projecr(helloCMake)\n  \n  message(\"CMAKE_BUILD_TYPE:${CMAKE_BUILD_TYPE}\")\n  \n  add_executable(main main.cpp)  \n  ~~~\n  \n### if(DEFINED XX) 判断变量是否存在\n  \nif(DEFINED MYVAR) 可以判断是否定义了 MYVAR 变量，判断的是**局部变量**和**缓存变量**  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\nprojecr(helloCMake)\n\nif(DEFINED MYVAR)\n\tmessage(\"MYVAR:${MYVAR}\")\nelse()\n\tmessage(\"MYVAR not defined\")\nendif()\n~~~\n  \n需要注意的是即便变量是空字符串也是被认为存在的，因为 DEFINED 判断的是*是否被定义*。\n  \n### if(xx) 就可以判断是否存在且不为空\n  \n可以直接用 if(xx) 来判断空字符串，因为空字符串等于 OFF  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\nprojecr(helloCMake)\n\nset(MYVAR \"\")\nif(MYVAR)\n\tmessage(\"MYVAR is:${MYVAR}\")\nelse()\n\tmessage(\"MYVAR is empty or not defined\")\nendif()\n~~~\n  \n### if(DEFINED ENV{xx}) 判断环境变量是否存在\n  \n* 因为 $ENV{xx} 代表环境变量，因此在 set 和 if 中也可以用 ENV{xx} 来表示环境变量  \n  因为 set 的第一参数和 if 的参数都是不加 $ 的，  \n  所以要设置 ${x} 就变成了 set(x ...);  \n  设置 $ENV{x} 就变成了 set( ENV{x} ...)  \n  同理还可以用 if(DEFINED CACHE{x} ) 判断是否存在 缓存变量x  \n  但是 set( CACHE{x} ...) 不行，别搞错了。\n  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)  \n  project(helloCMake)\n  \n  set(ENV{MYVAR} \"hello\")  \n  if(DEFINED ENV{MYVAR})  \n  \tmessage(\"MYVAR:$ENV{MYVAR}\")  \n  else()  \n  \tmessage(\"MYVAR is not defined!\")  \n  endif()  \n  ~~~\n  \n### 第十一章：小建议\n  \n### CCache：编译加速缓存\n  \n* 用法：把 gcc -c main.cpp -o main 换成 ccache gcc -c main.cpp -o main 即可  \n  在 CMake 中，可这样来启用 ccache ( 就是给每个编译和链接命令前面加上 ccache )\n  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)  \n  project(helloCMake)\n  \n  find_program(CCACHE_PROGRAM ccache)  \n  if(CCACHE_PROGRAM)  \n  \tmessage(STATUS \"Found CCache:${CCACHE_PROGRAM}\")  \n  \tset_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_PROGRAM})  \n  \tset_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ${CCACHE_PROGRAM})  \n  endif()  \n  ~~~\n  \n* CCache 官网：https://ccache.dev/ ( 不过好像不支持 MSVC )\n  \n### 添加一个 run 伪目标，用于启动主程序( 可执行文件 )\n  \n* 创建一个 run 伪目标，其执行 main 的可执行文件  \n  这里用了生成器表达式 `$<TARGET_FILE:main>` 会自动让 run 依赖 main  \n  如果自动依赖失败，可以手动加上 add_dependencies(run main) 也是可以的。\n  \n* 这样就可以在命令行运行 cmake --build build --target run 来启动 main.exe 运行了。而不必根据不同的平台，手动写出 build/main 或者 build\\main.exe  \n  ~~~cmake  \n  add_executable(main main.cpp)\n  \n  add_custom_target(run COMMAND $<TARGET_FILR:main>)  \n  ~~~\n  \n### 再加一个 configure 伪目标，用于可视化地修改缓存变量\n  \n* 这样就可以 cmake  --build build --target configure 来启动 ccmake 修改缓存了  \n  Linux 上相当于 ccmake -B build，Windows 则是 cmake-gui -B build\n  \n  ~~~cmake  \n  add_custom_target(run COMMAND $<TARGET_FILE:main>)  \n  if(CMAKE_EDIT_COMMAND)  \n  \tadd_custom_target(configure COMMAND ${CMAKE_EDIT_COMMAND} -B ${CMAKE_BINARY_DIR})  \n  endif()  \n  ~~~\n\n  \n  \n## [文件目录组织规范](https://www.bilibili.com/video/BV1V84y117YU)\n  \n基于CMake的项目组织。\n  \n### 推荐的目录组织\n  \n* project_name/include/project_name/module_name.h  \n* project_name/src/module_name.cpp\n  \n将头文件放在include/project_name目录下是防止**不同子项目**或**项目**与**系统头文件**相冲突。\n  \n**在CMakeLists.txt中**使用\n  \n`target_include_directories(project_name PUBLIC include)`\n  \n指定项目名project_name, PUBLIC导入include文件\n  \n**源文件中**\n  \n* #include<project_name/module_name>  \n* project_name::func();\n  \n**头文件中(project_name/include/project_name/module_name.h)**\n  \n~~~c++\n#pragma once\nnamespace project_name{\n    void func();\n}\n~~~\n  \n**实现文件(projecr_name/src/module_name.cpp)**\n  \n~~~c++\n#include <project_name/module.h>\nnamespace project_name{\n    void func()\n    {\n        int a;\n\t}\n}\n~~~\n  \n#### 例子\n  \n* biology  \n  * CMakeLists.txt  \n  * include  \n    * biology  \n      * Animal.h  \n  * src  \n    * Animal.cpp  \n* CMakeList.txt  \n* pybmain  \n  * CMakeLists.txt  \n  * include  \n    * pybmain  \n      * myutils.h  \n  * src  \n    * main.cpp\n  \n有点抽象……\n  \n<img src=\"D:\\Book\\C++\\MyC++Note\\CMake.png\" alt=\"CMake\" style=\"zoom:67%;\" />\n  \n### 划分子项目\n  \n一个大型的项目不可能是仅仅一个项目，往往是要分成多个子项目。\n  \n通常分为库文件，可执行文件两个部分，**库文件**主要负责逻辑运算、数据处理诸如此类的**代码逻辑**；**可执行文件**主要是和**用户的交互逻辑**。\n  \n### 根项目的 CMakeLists.txt 配置\n  \n* 在根项目的 CMakeLists.txt 中，设置了该项目默认的构建模式，设置了统一的 C++ 版本等各种选项。然后通过 `project` 命令初始化了根项目。  \n* 随后通过 `add_subdirectory` 把子项目添加进来( 顺序无关紧要 )，这会调用子项目的 CMakeLists.txt 。  \n  比如调用 biology/CMakeLists.txt 和 pybmain/CMakeLists.txt\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.18)\n\nif (NOT CMAKE_BUILD_TYPE)\n\tset(CMAKE_BUILD_TYPE Release)\nendif()\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n\nproject(CppCMakeDemo LANGUAGES CXX)\n\nadd_subdirectory(pybmain)\nadd_subdirectory(biology)\n~~~\n  \n# 我遇到的实际问题\n  \n## 将资源拷贝到Build目录，供可执行文件读取\n  \n~~~cmake\nadd_custom_command(\n\tTARGET main POST_BUILD\n\tCOMMAND ${CMAKE_COMMAND} -E copy_directory\n\t\t\t${CMAKE_CURRENT_SOURCE_DIR}/obj\n\t\t\t${CMAKE_CURRENT_BINARY_DIR}/obj\n)\n~~~\n  \n[CMake官方：add_custom_command](https://cmake.org/cmake/help/latest/command/add_custom_command.html?highlight=add_custom_command)  \n[Post copy files to currently building target directory.](https://discourse.cmake.org/t/post-copy-files-to-currently-building-target-directory/6027)在这个问题中：“For example, if I’m building demo1 I want the output dir to be demo1s binary dir, if I’m building demo2, demo2’s binary dir etc.”有点意思但是我没想到解决思路用`${PROJECT_SOURCE_DIR}`和`${PROJECT_BINARY_DIR}`不行吗？  ","source":"_posts/CMake Note.md","raw":"---\ntitle: 我的CMake学习\ndate: 2023-03-10 13:15:23\ntags:\ntypora-root-url: ./..\n---\n  \n对 CMake 粗浅的学习，之前看一个up的讲的一般，后来看了小彭老师，的确不错，因为官方文档看起来有点吃力，所以就……  \n学习过程中把知识点做了一点笔记方便后续复习\n  \n<!--more-->\n  \n# CMake\n  \n本文档为学习笔记，该部分内容来源[b站Up刘贝斯的CMake教学](https://www.bilibili.com/video/BV1vR4y1u77h/?p=2&spm_id_from=pageDriver&vd_source=1fa1b82383f6efb8a2632316da9afad0)。\n  \n## What is CMake?\n  \nCMake 是一种高级编译配置工具。\n  \n当多人使用一种或不同种语言、编译器开发一个项目时，最终需要输出一个**可执行文件**或者**共享库**(dll, so等等)，此时——CMake就可以帮助到我们，不必用G++或GCC逐个编译我们所写过的代码。  \n所有操作都是通过编译CMakeLists.txt完成的。  \n使用CMake来处理大型的C/C++/Java等项目。\n  \n## CMake 安装\n  \n* Linux大多都有安装。  \n* Windows, 下载网站(https://cmake.org/download/)\n  \n## CMake: Hello World\n  \n1.首先写一个C/C++的hello world\n  \n~~~c++\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Hello World!\" << std::endl;\n}\n~~~\n  \n2.编写`CmakeLists.txt`\n  \n~~~cmake\nPROJECT (HELLOW)\n\nSET(SRC_LIST main.cpp)\n\nMESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINAR_DIR})\n\nMESSAGE(STATUS \"This is SOURCE dir \" ${HELLO_SOURCE_DIR})\n\nADD_EXECUTABLE{hello $(SRC_LIST)}\n~~~\n  \n3.使用CMake，生成`makefile`文件\n  \n~~~cmake\ncmake .  \n~~~\n  \n### CMake: Hello World语法介绍\n  \n#### `PROJECT`关键字 —— [简书CMake命令之project](https://www.jianshu.com/p/cdd6e56c2422)\n  \n可以用来**指定工程的名字和支持的语言**，默认支持所有语言。  \nPROJECT (HELLO) 指定了工程的名字——HELLO，并且支持所有语言。\n  \n# [**CMake教程**](https://www.bilibili.com/video/BV16P4y1g7MH)\n  \n## 第一章 添加源文件\n  \n* 第一种，添加名为 *main* 的 *executable* ，源文件为 *main.cpp* 。\n  \n~~~cmake\nadd_executable(main main.cpp)\n~~~\n  \n* 第二种，先创建 **目标( executable )**，稍后再添加源文件。\n  \n~~~cmake\nadd_executable(main)\ntarget_sources(main PUBLIC main.cpp)\n~~~\n  \n### 若有多个源文件呢？\n  \n逐个添加即可\n  \n~~~cmake\nadd_executable(main)\ntarget_sources(main PUBLIC main.cpp other.cpp)\n~~~\n  \n或者使用**变量**来存储\n  \n~~~cmake\nadd_executable(main)\nset(sources main.cpp other.cpp)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n建议把头文件也加上，这样在VS中可以出现在 \"Header Flies\" 一栏\n  \n~~~cmake\nadd_executable(main)\nset(sources main.cpp other.cpp other.h)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n我们还可以使用 **GLOB** 自动查找当前目录下指定拓展名的文件，实现批量添加源文件\n  \n~~~cmake\nadd_executable(main)\nfile(GLOB sources *.cpp *.h)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n但是使用 **GLOB** 需要注意，如果我们增添新的源文件时，CMake可能不会更新，所以要启用 **CONFIGURE_DEPENDS** 选项，当添加新文件时，**在 Build 时进行检测**，自动更新变量\n  \n~~~cmake\nadd_executable(main)\nfile(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n### 源码在子文件夹中？\n  \n#### 例子：\n  \n* mylib  \n  * other.cpp  \n  * other.h  \n* CMakeLists.txt  \n* main.cpp\n  \n将**路径名、后缀名全部**写出来\n  \n~~~cmake\nadd_executable(main)\nfile(GLOB sources CONFIGURE_DEPENDS *.cpp *.h mylib/*.cpp mylib/*.h)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n然鹅，dark不必，我们可以使用 **aux_source_directory** , 自动搜集需要的文件后缀名  \n本例中`aux_source_directory(. sources)`和`aux_source_directory(mylib sources)`  表示**当前目录**和 **mylib 目录** 全部加入项目中。\n  \n~~~cmake\nadd_executable(main)\naux_source_directory(. sources)\naux_source_directory(mylib sources)\ntarget_sources(main PUBLIC ${sources})\n~~~\n  \n更进一步：**GLOB_RECURES** 能够自动包含所有子文件夹下的文件  \n但是注意，**GLOB_RECURES** 会把 **build 目录**下的临时 .cpp 文件( 这些临时文件是 CMake 为了测试编译器 )也加进来。  \n解决办法：一种，可以把源码统一放到 src 目录下。二种，要求使用者不要把 build 放到和源码同一个目录里。这两种之间前者好一点。\n  \n~~~cmake\nadd_executable(main)\nfile(GLOB_RECURES sources CONFIGURE_DEPENDS *.cpp *.h)\ntarget_source(main PUBLIC ${sources})\n~~~\n  \n## 第二章 项目配置变量——BUILD_TYPE\n  \n### CMAKE_BUILD_TYPE 构建的类型，调试模式 or 发布模式 \n  \n* CMAKE_BUILD_TYPE 是 CMake 中一个特殊的变量， 用于控制构建类型，他的值可以是：  \n  * Debug 调试模式，完全不进行优化，生成调试信息，方便调试程序  \n  * Release 发布模式，优化程度最高，性能最佳，但是编译比 Debug 慢  \n  * MinsizeRel 最小体积发布，生成的文件比 Release 更小，不完全优化，减少二进制体积。  \n  * RelWithDebInfo 带调试信息发布，生成的文件比 Release 更大，因为带有调试的符号信息。  \n* 默认情况下，CMAKE_BUILD_TYPE 为空字符，这时相当于 Debug。\n  \n~~~cmake\ncmake_minimun_required(VERSION 3.15)\nproject(hellowcmake LANGUAGES CXX)\n\nset(CMAKE_BUILD_TYPE Release)\n\nadd_executable(main main.cpp)\n~~~\n  \n各种构建模式在编译器选项上的区别\n  \n* 在 Release 模式下，追求的是程序最佳的性能表现，在此情况下编译器会对程序做最大的代码优化以达到最快的运行速度。另一方面，由于代码优化后不与源代码一致，此模式下一般会丢失大量的调试信息。\n  \n在编译器上各种构建类型的体现：\n  \n* Debug : '-O0 -g'  \n* Release : '-O3 -DNDEBUG'  \n* MinSizeRel : '-Os -DNDEBUG'  \n* RelWithDebInfo : '-O2 -g -DNDEBUG'\n  \n此外，定义 NDEBUG 宏会使 assert 被去除掉。\n  \n因为默认情况下是 Debug 导致生成程序的效率很低。  \n小技巧：设定一个变量的默认值\n  \n如何让 CMAKE_BUILD_TYPE 在用户没有指定的情况时为 Release，指定的时候保持用户的指定的值不变？  \n即 CMake 默认情况下 CMAKE_BUILD_TYPE 是一个空字符串。  \n因此可以通过 `if( NOT CMAKE_BUILD_TYPE )`判断是否为空，空则自动设置为 Release 模式。  \n大多数 CMakeLists.txt 开头都会有这样三行，目的是让默认的构建类型为发布模式 (高度优化) 而不是默认的调试模式 (不会优化) 。\n  \n~~~cmake\nif( NOT CMAKE_BUILD_TYPE )\n\tset(CMAKE_BUILD_TYPE Release)\nendif()\n~~~\n  \n### Project\n  \nproject : 初始化项目信息，并把当前 CMakeLists.txt 所在位置作为根目录\n  \n这里初始化名为 hellocmake 的项目；为什么一定需要项目名？  \n因为对于 MSVC，他会在 build 里生成 hellocmake.sln 作为 IDE 眼中的项目。  \nCMAKE_CURRENT_SOURCE_DIR 表示**当前源码目录**的位置，例如 ~/hellocmake  \nCMAKE_CURRENT_BINARY_DIR 表示**当前输出目录**的位置，例如 ~/hellocmake/build\n  \n~~~cmake\ncmake_minumum_required(VERSION 3.15)\nproject(hellocmake)\n\nmessage(\"PROJECT_NAME: ${PROJECT_NAME}\")\nmessage(\"PROJECT_SOURCE_DIR: ${PROECJR_SOURCE_DIR}\")\nmessage(\"PROJECT_BINARY_DIR: ${PROJECT_BINARY_DIR}\")\nmessage(\"CMAKE_CURRENT_SOURCE_DIR: ${CMAKE_CURRENT_SOURCE_DIR}\")\nmessage(\"CMAKE_CURRENT_BINARY_DIR: ${CMAKE_CURRENT_BINARY_DIR}\")\nadd_executable(main main.cpp)\n~~~\n  \n#### 和子模块的关系：PROJECT_X_DIR 和 CMAKE_CURRENT_x_DIR\n  \nPROJECT_SOURCE_DIR 表示最近一次调用 project 的 CMakeLists.txt 所在的源码目录。  \nCMAKE_CURRENT_SOURCE_DIR 表示当前 CMakeLists.txt 所在的源码目录。  \nCMAKE_SOURCE_DIR 表示最为外层 CMakeLists.txt 的源码根目录。  \n利用 PROJECT_SOURCE_DIR 可以实现从子模块直接获取项目最外层的路径。  \n**不建议使用 CMAKE_SOURCE_DIR , 那样会让你的项目无法被人作为子模块使用。**\n  \n>mylib got PORJECT_SOURCE_DIR: /home/bate/Codes/course/11/template  \n>  \n>mylib got CMAKE_CURRENT_SOURCE_DIR: /home/bate/Codes/course/11/template/mylib\n  \n#### 其他相关变量\n  \n* PROJECT_SOURCE_DIR : 当前项目源码路径( 存放 main.cpp 的地方)  \n* PROJECT_BINARY_DIR : 当前项目输出路径 ( 存放 main.exe 的地方 )  \n* CMAKE_SOURCE_DIR : 根项目源码路径 ( 存放 main.cpp 的地方 )  \n* CMAKE_BINARY_DIR : 根项目输出路径 ( 存放 main.cpp 的地方 )  \n* PROJECT_IS_TOP_LEVEL : BOOL 类型，表示当前项目是否是 ( 最顶层的 ) 根项目  \n* PROJECT_NAME : 当前项目名  \n* CMAKE_PROJECT_NAME : 根项目的项目名  \n* 详见 : [CMake之Project](https://cmake.org/cmake/help/latest/command/project.html)\n  \n#### 子模块也可使用 project 命令，将当前目录作为一个独立的子项目\n  \n这样 PROJECT_SOURCE_DIR 就会是子模块的源码目录而不是外层了。  \n这时候 CMake 会认为这个子模块是一个独立的项目，会额外做一些初始化。  \n他的构建目录 PROJECR_BINARY_DIR 也会变成 build/<源码相对路径>  \n这样在 MSVC 上也会看见 build/mylib.vcxproj 的生成\n  \n>PORJECT_NAME : hellowcmake  \n>  \n>PROJECT_SOURCE_DIR : /home/bate/Codes/course/11/template  \n>  \n>PROJECT_BINARY_DIR : /home/bate/Codes/course/11/template/build  \n>  \n>CMAKE_CURRENT_SOURCE_DIR : /home/bate/Codes/course/11/template  \n>  \n>CMAKE_CURRENT_BINARY_DIR : /home/bate/Codes/course/11/template/build  \n>  \n>mylib got PROJECT_NAME : mylib  \n>  \n>mylib got CMAKE_SOURCE_DIR : /home/bate/Codes/course/11/template  \n>  \n>mylib got CMAKE_BINARY_DIR : /home/bate/Codes/course/11/template/build  \n>  \n>mylib got PROJECT_SOURCE_DIR : /home/bate/Codes/course/11/template/mylib  \n>  \n>mylib got PROJECT_BINARY_DIR : /home/bate/Codes/course/11/build/mylib  \n>  \n>mylib got CMAKE_CURRENT_SOURCE_DIR : /home/bate/Codes/course/11/template/mylib  \n>  \n>mylib got CMAKE_CURRENT_BINARY_DIR : /home/bate/Codes/course/11/template/build/mylib\n  \n#### project 的初始化 : LANGUAGES 字段\n  \n* project( 项目名 LANGUAGES 使用的语言列表...) 指定了该项目使用了那种编程语言  \n  目前支持的语言：  \n  * C : C语言  \n  * CXX : C++  \n  * ASM : 汇编  \n  * Fortran : 老年人的编程语言(雾)，IBM  \n  * CUDA : 英伟达的黑科技 CUDA ( 需要 CMake 3.8 版本 )  \n  * OBJC : 苹果的 Objective-C ( 需要 CMake 3.16 版本 )  \n  * OBJCXX : 苹果的 Objective-C++ ( 需要 CMake 3.16 版本 )  \n  * ISPC : 一种英特尔的自动 SIMD 编程语言 ( 需要 CMake 3.18 版本 )  \n* 如果不指定 LANGUAGES, 默认为 C 和 CXX。\n  \n##### 常见问题：LANGUAGES 中没有启用 C 语言，但却用到了 C 语言\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\nproject(hellocmake LANGUAGES CXX)\n\nadd_executable(main main.c)\n~~~\n  \n~~~c\n#include <stdio.h>\n\nint main(void)\n{\n    printf(\"Hello world from Cmake!\\n\");\n    return 0;\n}\n~~~\n  \n这样不行滴哥们，会报错，因为你在 CMakeLists.txt 的设置中没有启用 C 语言。  \n解决办法：\n  \n~~~cmake\ncmake_minimum_required(VERSiON 3.15)\nproject(hellocmake LANGUAGES C CXX)\n\nadd_executable(main main.c)\n~~~\n  \n这次启用了 C 和 C++ 就不会报错力。\n  \n##### 也可以先设置 LANGUAGES NONE, 之后调用 enable_language(CXX)\n  \n这样可以把 enable_language 放到 if 语句中，从而只有某些选项开启才启用某语言类似的操作。\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\nproject(hellocmake LANGUAGES NONE)\nenable_language(CXX)\n\nadd_executable(main main.cpp)\n~~~\n  \n#### 设置 C++ 标准：CMAKE_CXX_STANDARD 变量\n  \n* CMAKE_CXX_STANDARD 是一个整数，表示要用的 C++ 标准。  \n  比如需要 C++17 即设为 17。  \n* CMAKE_CXX_STANDARD_REQUIRED 是 BOOL 型，可以为 ON / OFF , 默认为 OFF。  \n  表示是否一定要支持指定的 C++ 标准，如果为 OFF 则CMake 检测到编译器不支持 C++17 时不报错，而是将设置调整为 C++14 让开发人员使用；为 ON 时，不支持会报错，具有更好的安全性。  \n* CMAKE_CXX_EXTENSIONS 是 BOOL 变量，默认为 ON。为 ON 表示启用 GCC 特有的一些拓展功能；OFF 则关闭 GCC 的拓展功能，只使用标准的 C++。  \n  要兼容其他编译器( 如 MSVC )的项目都会将其设为 OFF，以防使用了 GCC 特有的特性。  \n* 注意，最好在 project 命令前设置 CMAKE_CXX_STANDARD 一系列变量，这样一来 CMAKE 可以在 project 函数内对编译器进行一些检测，查看是否能支持对应版本C++的特性。\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS ON)\n\nproject(hellocmake LANGUAGES CXX)\n~~~\n  \n##### 常见误区 : 小彭老师，我手动加 -std=c++17 行不得行\n  \n* 不要直接修改 CMAKE_CXX_FLAGS 来添加 -std=c++17  \n  使用 CMake 封装好的 CMAKE_CXX_STANDARD  \n  前者为什么不好，GCC 用户一旦手动指定 -std=c++17, 就是使用了 GCC 的特性，而 MSVC 的用户就无法使用了。   \n  而且 CMake 已经自动根据 CMAKE_CXX_STANDARD 的默认值 11 添加了 -std=c++11，之后你再手动添加 -std=c++17 选项就发生了冲突。  \n  所以一定要使用 CMake 已经封装好的 CMAKE_CXX_STANDARD !\n  \n### projec 的初始化：VERSION 字段\n  \n* project(项目名 VERSION x.y.z) 可以将当前项目的版本号设定为 x.y.z  \n  之后可以使用 PROJECT_VERSION 获取当前项目的版本号  \n* PROJECT_VERSION_MAJOR 获取 x ( 主版本号 )  \n  PROJECT_VERSION_MINOR 获取 y ( 次版本号 )  \n  PROJECT_VERSION_PATCH 获取 z ( 补丁版本号 )\n  \n#### 项目名的另一个作用 : 会设置另外 <项目名>_SOURCE_DIR 等变量\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\nproject(hellocmake VERSION 2.7.1)\n\nmessage(\"PROJECT_NAME: ${PROJECT_NAME}\")\nmessage(\"PROJECT_VERSION: ${PROJECT_VERSION}\")\nmessage(\"PROJECT_SOURCE_DIR: ${PROJECT_SOURCE_DIR}\")\nmessage(\"PROJECT_BINARY_DIR: ${PROJECT_BINARY_DIR}\")\nmessage(\"hellocmake_VERSION: ${hellocmake_VERSION}\")\nmessage(\"hellocmake_SOURCE_DIR: ${hellocmake_SOURCE_DIR}\")\nmessage(\"hellocmake_BINARY_DIR: ${hellocmake_BINARY_DIR}\")\n~~~\n  \n>PROJECT_NAME: hellocmake  \n>PROJECT_VERSION: 2.7.1  \n>PROJECT_SOURCE_DIR: /home/bate/Codes/course/11/templa  \n>PROJECT_BINARY_DIR: /tmp/build/home/bate/Codes/course/11/templa  \n>hellocmake_VERSION: 2.7.1  \n>hellocmake_SOURCE_DIR: /home/bate/Codes/course/11/templa  \n>hellocmake_BINARY_DIR: /tmp/build/home/bate/Codes/course/11/templa\n  \n这个功能可以让我们在当前项目去查询别的项目的版本号比如在 hellocmake 查询 helloworld 的版本号或者其他信息。\n  \n#### 小技巧 : CMake 的 ${} 表达式可以嵌套\n  \n因为 ${PROJECT_NAME} 的值是 hellocmake  \n所以 ${${PROJECT_NAME}_VERSION} 相当于 ${hellocmake_VERSION} 即 2.7.1  \n[CMake 其他关键字](https://blog.csdn.net/fuyajun01/article/details/8891749)\n  \n#### 一个标准的 CMakeLists.txt 模板\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nproject(zeno LANGUAGES C CXX)\n\nif(PROJECT_BINARY_DIR STREQUAL PROJECT_SOURCE_DIR)\n\tmessage(WARING \"The binary directory of CMake cannot be the same as source directory!\")\nendif()\n\nif(NOT CMAKE_BUILD_TYPE)\n\tset(CMAKE_BUILD_TYPE Release)\nendif()\n\nif(WIN32)\n\tadd_definitions(-DNOMINMAX -D_USE_MATH_DEFINES)\nendif()\n\nif(NOT MSVC)\n\tfind_program(CCACHE_PROGRAM ccache)\n\tif(CCACHE_PROGRAM)\n\t\tmessage(STATUS \"Found CCache: ${CCACHE_PROGRAM}\")\n\t\tset_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_PROGRAM})\n\t\tset_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ${CCACHE_PROGRAM})\n\tendif()\nendif()\n~~~\n  \n## 第三章：链接库文件\n  \n### main.cpp 调用 mylib.cpp 里的 say_hello 函数\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executable(main main.cpp mylib.cpp)  \n  ~~~\n  \n* main.cpp\n  \n  ~~~c++  \n  #include \"mylib.h\"\n  \n  int main()  \n  {  \n  \tsay_hello();  \n  }  \n  ~~~\n  \n* mylib.cpp  \n  ~~~cpp  \n  #include \"mylib.h\"  \n  #include <cstdio>\n  \n  void say_hello()  \n  {  \n      printf(\"Hello, mylib!\\n\");  \n  }  \n  ~~~\n  \n#### 改进：mylib 作为静态库\n  \n> [《静态库和动态库》](https://www.jianshu.com/p/090e1c0310ab) , [《CMake | 编译静态库、动态库和对象库》](https://blog.csdn.net/weixin_39766005/article/details/122368414)  \n> 静态库会在*链接时*完整的复制到每一个可执行文件，被多次使用时就会造成多分冗余。  \n> 动态库在*链接时*不复制，程序运行时由系统动态加载到内存中，供程序调用，系统仅需加载一次，多个程序公用，节省内存。\n  \n* CMakeLists.txt\n  \n  ~~~cmake  \n  add_library(mylib STATIC mylib.cpp)\n  \n  add_executable(main main.cpp)\n  \n  target_link_libraries(main PUBLIC mylib)  \n  ~~~\n  \n#### 改进：mylib 作为一个动态库\n  \n* CMakeLists.txt ( 动态库在Windows上有坑 )  \n  ~~~cmake  \n  add_library(mylib SHARED mylib.cpp)\n  \n  add_executable(main main.cpp)\n  \n  target_link_libraries(main PUBLIC mylib)  \n  ~~~\n\n  \n#### 改进：mylib 作为一个对象库\n  \n对象库类似于静态库，但不生成 .a 文件，只由 CMake 记住该库生成了那些对象文件  \n~~~cmake\nadd_libraty(mylib OBJECT mylib.cpp)\n\nadd_executable(main main.cpp)\n\ntarget_link_libraries(main PUBLIC mylib)\n~~~\n  \n对象库是 CMake 自创的，绕开了编译器和操作系统的各种繁琐规则，保证了跨平台统一性。  \n在自己的项目中，推荐全部使用对象库( OBJECT ) 替代静态库 ( STATIC ) 避免跨平台的麻烦。  \n对象库仅仅作为组织代码的方式，而实际生成的可执行文件只有一个，减轻了部署的困难。\n  \n#### 静态库的麻烦：GCC 编译器会自作聪明，将自动剔除没有引用符号的对象\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_library(mylib STATIC mylib.cpp)  \n  ~~~\n  \n* mylib.cpp  \n  ~~~cpp  \n  #include <cstdio>  \n  // 静态初始化  \n  static int unused = printf(\"My initialized\\n\");\t// 会在主函数前被执行  \n  ~~~\n  \n* main.cpp  \n  ~~~c++  \n  #include <cstdio>\n  \n  int main()  \n  {  \n      printf(\"Main function\\n\");  \n  }  \n  ~~~\n  \n* Output  \n  >main function\n  \n这里就是 GCC 看到没有引用人 mylib ，就会删掉 mylib.o 但是恰恰遇到了静待初始化，GCC 就做错了。\n  \n#### 对象库就可以绕开编译器的不统一：保证不会自动剔除没有用到的对象文件\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_library(mylib OBJECT mylib.cpp)  \n  ~~~\n  \n* mylib.cpp\n  \n  ~~~c++  \n  #include <cstdio>\n  \n  static int unused = printf(\"Mylib Function\\n\");  \n  ~~~\n  \n* main.cpp  \n  ~~~c++  \n  #include <cstdio>\n  \n  int main()  \n  {  \n      printf(\"Main Function\\n\");  \n  }  \n  ~~~\n  \n* Output  \n  >Mylib Function  \n  >Main Function\n  \n#### add_library 无参数时，是静态库还是动态库\n  \n会根据 BUILD_SHARED_LIBS 这个变量的值决定是动态库还是静态库。  \nON 则相当于 SHARED, OFF 则相当于 STATIC  \n如果未指定 BUILD_SHARED_LIBS 变量，则默认为 STATIC。  \n因此，如果发现一个项目内的 add_library 都是无参的，意味着我们可以使用：  \n`cmake -B build -DBUILD_SHARD_LIBS:BOOL=ON`  \n来让他全部生成为动态库，这里涉及到*命令行传递变量的规则。*\n  \n~~~cmake\nset(BUILD_SHARED_LIBS ON)\n\nadd_library(mylib mylib.cpp)\n~~~\n  \n#### 小技巧：设定一个变量的默认值\n  \n要让 BUILD_SHARED_LIBS 默认为 ON，可以用之前类似的思路  \n如果该变量没有定义，则设为 ON，否则保持用户指定的值不变  \n这样用户没有指定 BUILD_SHARED_LIBS 时，会默认变成ON。  \n只有用户指定 BUILD_SHARED_LIBS 为 OFF 即 `-DBUILD_SHARED_LIBS:BOOL:OFF`  \n才会生成静态库，否则默认生成动态库。\n  \n~~~cmake\nif(NOT DEFINED BUILD_SHARED_LIBS)\n\tset(BUILD_SHARED_LIBS ON)\nendif()\n~~~\n  \n#### 常见坑点：动态库无法链接静态库\n  \n~~~cmake\nadd_library(otherlib STATIC otherlib.cpp)\n\nadd_library(mylib SHARED mylib.cpp)\ntarget_link_libraries(mylib PUBLIC otherlib)\n\nadd_executable(main main.cpp)\ntarget_link_libraries(main PUBLIC mylib)\n~~~\n  \n`target_link_libraries(mylib PUBLIC otherlib)`试图将静态库`otherlib`链接到`mylib`中，发生错误。*静态库`otherlib`误以为用户将其连接到一个可执行文件上*，但用户却连接到动态库上。动态库在内存中的地址会变化的，在编译时会指定一个`fPIC`选项，但是静态库没有`fPIC`选项，静态库的地址并不想变化，而动态库本身却想改变地址，二者会发生冲突。\n  \n##### 解决办法：\n  \n1、将`otherlib`变为对象库\n  \n~~~cmake\nadd_library(otherlib OBJECT otherlib.cpp)\n\nadd_library(mylib SHARED mylib.cpp)\ntarget_link_libraries(mylib PUBLIC otherlib)\n\nadd_executable(main main.cpp)\ntarget_link_libraties(main PUBLIC mylib)\n~~~\n  \n2、让静态库编译也生成位置无关的代码( PIC )，这样才能装在动态库中\n  \n~~~cmake\nset(CMAKE_POSITION_INDEPENDENT_CODE ON)\n\nadd_library(otherlib STATIC otherlib.cpp)\n\nadd_library(mylib SHARED mylib.cpp)\ntarget_link_libraries(mylib PUBLIC otherlib)\n\nadd_executable(main main.cpp)\ntarget_link_libraries(main PUBLIC mylib)\n~~~\n  \n但是这样处理会导致本来不需要为静态 PIC 的静态库也变成 PIC 了，**所以我们可以只针对一个库，只对他启用位置无关的代码( PIC )**  \n~~~cmake\nadd_library(otherlib STATIC otherib.cpp)\nset_property(TARGET otherlib PROPERTY POSITION_INDEPENDENT_CODE ON)\n\nadd_library(mylib SHARED mylib.cpp)\ntarget_link_libraries(mylib PUBLIC otherlib)\n\nadd_executable(main main.cpp)\ntarget_link_libraried(main PUBLIC mylib)\n~~~\n  \n**注意，add_library() 是要指定头文件的，这里偷懒没加，指定头文件后其就会出现在IDE中。**\n\n\n  \n## 第四章 : 对象的属性\n  \n前面提到的 `POSITION_INDEPENDENT_CODE` 就是一个属性。  \n### 除了 `POSITION_INDEPENDENT_CODE` 还有哪些属性呢？\n  \n~~~cmake\nadd_executable(main main.cpp)\n\nset_property(TARGET main PROPERTY CXX_STANDARD 17)\t# 采用 C++17 标准编译( 默认为11 )\nset_property(TARGET main PROPERTY CXX_STANDARD_REQUIRED ON)\t# 如果编译器不支持 C++17，则直接报错( 默认为 OFF )\nset_property(TARGET main PROPERTY WIN32_EXECUTABLE ON)\t# 在 Windows 系统中运行时不启动控制台窗口，只有 GUI 界面 (默认 OFF)\nset_property(TARGET main PROPERTY LINK_WHAT_YOU_USE ON)\t# 告诉编译器不要自动剔除没有引用符号的链接库(默认 OFF)\nset_property(TARGET main PROPERTY LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib)\t# 设置动态链接库的输出路径(默认 ${CMAKE_BINARY_DIR})\nset_property(TARGET main PROPERTY ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib)\t# 设置静态链接库的输出路径(默认 ${CMAKE_BINARY_DIR})\nset_property(TARGET main PROPERTY RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)\t# 设置可执行文件的输出路径(默认 ${CMAKE_BINARY_DIR})\n~~~\n  \n这样一个一个 `set_property` 好麻烦啊！要是有更简单的写法就好了，于是……\n  \n### 另一个方法 : `set_target_properties` 批量设置多个属性\n  \n~~~cmake\nadd_executable(main main.cpp)\n\nset_target_properties(main PROPERTIES\n\tCXX_STANDARD 17\n\tCXX_STANDARD_REQUIRED ON\n\tWIN32_EXECUTABLE ON\n\tLINK_WHAT_YOU_USE ON\n\tLIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib\n\tARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib\n\tRUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin\n)\n~~~\n  \n### 另一种方法：通过全局的变量，让之后创建的所有对象都享有同样的属性\n  \n相当于改变了各属性的默认初始值，要注意*此时* `set(CMAKE_xxx)` *必须在* `add_executable` *之前才有效*。  \n~~~cmake\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_WIN32_EXECUTABLE ON)\nset(CMAKE_LINK_WHAT_YOU_USE ON)\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib)\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/lib)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)\n\nadd_executbale(main main.cpp) # 这里需要放在后面\n~~~\n  \n### 百度常见的错误！！！\n  \n对于 `CXX_STANDARD` 这种 CMake 本身提供了变量进行配置设置的，不要自己去设置 -std=c++17 选项，会和 CMake 自己设置好的产生冲突，导致出错！  \n请始终使用 `CXX_STANDARD` 或者全局变量 `CMAKE_CXX_STANDARD` 来设置 -std=c++17 这个 flag，CMake 会在配置阶段进行编译器检测是否支持 C++17。  \nCUDA 的 -arch=sm_75 也是同样的道理，请使用 `CUDA_ARCHITECTURES` 属性。  \n再者说 -std=c++17 只是 GCC 编译器的选项，也不能进行跨平台适用于 MSVC 编译器啊！！！\n  \n~~~cmake\nadd_executable(main main.cpp)\n\nset_property(TARGET main PROPERTY CXX_STANDARD 17)\t# 正确\ntarget_compile_options(main PUBLIC \"-std=c++17\")\t# 错误！！！！\nset_property(TARGET main PROPERTY CUDA_ARCHITECTURES 75)\t# 正确\ntarget_compile_options(main PUBLIC \"-arch=sm_75\")\t# 错误！！！\n~~~\n  \n### 假如在 Windows 使用动态链接库，需要额外操作\n  \n`m/mylib.cpp`\n  \n~~~c++\n#include <cstdio>\n// 需要手动加入这几句，在实现处加入dllexport\n#ifdef _MSC_VER\n__declspec(dllexport)\n#endif\nvoid say_hello(){\n    printf(\"Hello, world!\\n\");\n}\n~~~\n  \n`m/mylib.h`\n  \n~~~c++\n#pragma once\n// 在声明处，加入import\n#ifdef _MSC_VER\n__declspec(dllimport)\n#endif\nvoid say_hello();\n~~~\n  \n根目录下的 `CMakeLists.txt`  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\n\nadd_subdirectory(mylib)\n\nadd_executable(main main.cpp)\ntarget_link_libraries(main PUBLIC mylib)\n~~~\n  \n子目录`m`下的`CMakeLists.txt`, `m/CMakeLists.txt`  \n~~~cmake\nadd_library(mylib SHARED mylib.cpp mylib.h)\n~~~\n  \n#### 常见问题：链接了自己的 dll，但是运行时会找不到\n  \n* 这是因为 dll 和 exe 不在用一个目录，而愚蠢的 Windows 只会在**当前 exe 所在目录查找**，**然后查找 *PATH环境变量***，找不到就报错。而 dll 在其他目录，因此 Windows 找不到。  \n  * **解决办法1**：把 dll 所在位置加到 *PATH环境变量* 里，一劳永逸。  \n  * **结局办法2**：把这个 dll，以及这个 dll 依赖的其他所有 dll，全部拷贝到和 exe 文件同一目录下。\n  \n#### 手动拷贝 dll 好麻烦，CMake 能不能救一下！把 dll 自动生成在 exe 同一目录下\n  \n* 说到底还是因为 CMake 把定义在顶层模块里的 main 放在 `build/main.exe`  \n  而 mylib 因为是定义在 mylib 这个子模块里的，因此被放到了 `build/mylib/mylib.dll`\n  \n##### 解决1：设置 mylib 对象的 xx_OUTPUT_DEIRECTORY 系列属性\n  \n* 所以，可以设置 mylib 的这些属性，让 mylib.dll 文件输出到 PROJECT_BINARY_DIR，也就是项目根目录( main 所在的位置 )，这样 main.exe 在运行时就能找到 mylib.dll\n  \n* 为了侍奉 Windows，要设置全部的 6个属性！很烦！  \n  `m/CMakeLists.txt`\n  \n  ~~~cmake  \n  add_library(mylib SHARED mylib.cpp mylib.h)\n  \n  set_property(TARGET mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_DEBUG ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_DEBUG ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_DEBUG ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_RELEASE ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${PROJECT_BINARY_DIR})  \n  set_property(TARGET mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_RELEASE ${PROJECT_BINARY_DIR})  \n  ~~~\n  \n  这样就会输出到项目根目录 build 目录下\n  \n##### 而在 Linux 系统下就显得简便了\n  \n* Linux 系统支持 RPATH，CMake 会让生成出来可执行文件的 RPATH 指向他链接了的 .so 文件所在目录，运行时会优先从 RPATH 里找链接库，所以即使不在同目录也能找到。  \n  所以**第三种解决办法**，卸载 Windows 安装 Linux。  \n* 需要手动修改或者查看一个 ELF 文件的 RPATH，可以用 chrpath 或者 pathchelf 命令。\n\n\n  \n## 第五章：连接第三方库\n  \n### 例子：需要使用 tbb 库\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executable(main main.cpp)  \n  target_link_libraries(main PUBLIC tbb)\t# Linux 上直接链接 tbb 是可以的，但是 Windows 可能不行。  \n  ~~~\n  \n* main.cpp  \n  ~~~c++  \n  #include <tbb/parallel_for.h>\n  \n  int main(){  \n  \ttbb::parallel_for(0,4,[&](int i){  \n          printf(\"Hello, %d!\\n\", i);  \n      });  \n  }  \n  ~~~\n  \n* OutPut  \n  >Hello, 0!  \n  >Hello, 1!  \n  >Hello, 2!  \n  >Hello, 3!\n  \n#### 直接链接 tbb 的缺点\n  \nLinux 可以直接链接，是因为其有默认的库目录 `usr/lib` ，但是 Windows 没有一个固定的库安装位置。Linux 因为 `usr/lib/`, Linux 可以找到 `usr/lib/libtbb.so`  \n如果这样直接指定 tbb，CMake 会让连接器在系统的库目录里查找 tbb，他会找到 `usr/lib/libtbb.so` 这个系统自带的，但是对于没有一个固定库安装位置的 Windows 系统并不适用。  \n此外，他还要求 tbb 的头文件就在 `usr/include` 这个系统默认的头文件目录，  \n这样才能 `#include <tbb/parallel_for.h` 不报错，如果 tbb 的头文件在其他地方  \n就需要再加一个 `target_include_directories` 设置额外的头文件查找目录。\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executable(main main.cpp)  \n  target_link_libraries(main PUBLIC tbb)  \n  ~~~\n  \n#### Windows 可以直接写出全部的绝对路径，十分的硬核\n  \n也可以直接写出全部的路径，这样就能让没有默认系统路径的 Windows 系统找到安装在不知何处的 tbb，不过这样就不能跨平台了，如果其他人安装在不同位置就会发生错误。  \n**顺便一提，CMake 的路径分隔符始终是`/`。即使在 Windows 上，也要把所有的 `\\` 改成 `/`**，这是为了跨平台考量。请放心，CMake 会自动在调用 MSVC时转换成 `\\` ，可以放心的用 `${x}/bin` 来实现和 Python 的 [`os.path.join(x, 'bin')`](https://blog.csdn.net/swan777/article/details/89040802) 一样的效果。\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executable(main main.cpp)  \n  target_link_libraries(main PUBLIC C:/User/archibate/installed/tbb/tbb.dll)  \n  ~~~\n  \n  > 大多数操作系统都是 Unix-like，只有 Windows 搞特殊。  \n  > `cd /d C:\\\\Program\\ Files\\\\(x86\\)\\\\Micsoft\\ Visual\\ Studio\\\\2019\\\\`  \n  > 在路径中动不动就放一堆转移符、空格、特殊符号  \n  > 高情商：Windows 是最适合练习 C 语言转移符使用水平的平台！\n  \n#### 终于！`find_package`\n  \n更通用的方式：find_package  \n更好的办法就是使用 CMake 的 `find_package` 命令。  \n`find_package(TBB REQUIRED)` 会查找 `/usr/lib/cmake/TBB/TBBConfig.cmake` 这个配置文件，根据里面的配置信息创建 `TBB::tbb` 这个伪对象( 实际它指向真正的 tbb 库文件路径 `usr/lib/libtbb.so` )，之后通过 `target_link_libraries` 链接 `TBB::tbb` 就可以正常工作。\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executbale(main main.cpp)\n  \n  find_package(TBB REQUIRED)  \n  target_link_libraries(main PUBLIC TBB::tbb)\t# TBB 包下的 tbb 库  \n  ~~~\n  \n##### `TBB::tbb` 的秘密：自带了一些 PUBLIC 属性\n  \n`TBB::tbb` 是一个伪对象( imported )，他除了会指向 `/usr/lib/libtbb.so`，TBBConfig.cmake 还会给 TBB::tbb 添加一些 PUBLIC 属性，用于让链接了他的对象带上一些 flag 之类的。  \n比如，TBB 安装在 `/opt/tbb` 目录下，头文件在 `/opt/tbb/include` 里，那么这时 TBBConfig.cmake 里就会有 : `target_include_directories(TBB::tbb PUBLIC /opt/tbb/include)`  \n这样 main 在链接了 TBB::tbb 时也会被“传染”上 `/opt/tbb/include` 这个目录，无需手动添加。  \n再比如，TBB::tbb 链接了另一个库 Blosc::blosc，那么这个库也会自动连接到 main 上，无需调用者手动添加。\n  \n> 比如 spdlog 的 spdlog-config.cmake 就会定义 SPDLOG_NOT_HEADER_ONLY 这个宏为 PUBLIC 。从而实现直接 #include <spdlog/spdlog.h> 时候时纯头文件，而 find_package(spdlog REQUIRED) 时却变成预编译链接库的版本。( 其实不是 PUBLIC 而是 INTERFACE，因为伪对象没有实体 )\n  \n##### 和 `find_package(TBB CONFIG REQUIRED)` 有什么区别\n  \n其实更好的是通过 `find_package(TBB CONFIG REQUIRED)`，添加一个 CONFIG 选项。  \n这样他会优先查找 TBBConfig.cmake ( 系统自动的 ) 而不是 FindTBB.cmake ( 项目作者常把他塞在 cmake/ 目录里并添加到 CMAKE_MODULE_PATH )。这样能保证寻找包的这个 .cmake 脚本是和系统自带的 tbb 版本是适配的，而不是项目作者当年下载的那个版本的 .cmake 脚本。\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  add_executable(main main.cpp)\n  \n  find_package(TBB CONFIG REQUIRED)  \n  target_link_libraries(main PUBLIC TBB::tbb)  \n  ~~~\n  \n当然如果坚持要用 find_package(TBB REQUIRED) 也是可以的。  \n没有 CONFIG 选项：先找 FindTBB.cmake，再找 TBBConfig.cmake，找不到就报错。  \n有 CONFIG 选项：只会找 TBBConfig.cmake，找不到则报错。  \n此外有一些老年项目( 比如 OpenVDB ) 只提供 Find 而没有 Config 文件，这时候只能用 find_package(OpenVDB REQUIRED) 而不能带 CONFIG 选项。\n  \n#### /usr/lib/cmake/TBB/TBBConfig.cmake 长什么样？\n  \n不论 TBBConfig.cmake 还是 FindTBB.cmake，这个文件通常由库的作者提供，在 Linux 的包管理器安装 tbb 后也会自动安装这个文件。少部分对 CMake 不友好的第三方库，需要自己写 FindXXX.cmake 才能使用。\n  \n* TBBConfig.cmake  \n  ~~~cmake  \n  # Create imported target TBB::tbb  \n  add_library(TBB::tbb SHARED IMPORTED)\n  \n  set_target_properties(TBB::tbb PROPERTIES  \n  \tINTERFACE_COMPILE_DEFINITIONS \"\\$<\\$<CONFIG:DEBUG>:TBB_USE_DEBUG>\"  \n  \tINTERFACE_INCLUDE_DIRECTORIES \"${_IMPORT_PREFIX}/include\"  \n  )\n  \n  # Create imported target TBB::tbbmalloc  \n  add_library(TBB::tbbmalloc SHARED IMPORTED)\n  \n  set_target_proerties(TBB::tbbmalloc PROPERTIES  \n  \tINTERFACE_COMPILE_DEFINITIONS \"\\$<\\$<CONFIG:DEBUG>:TBB_USE_DEBUG>\"  \n  \tINTERFACE_INCLUDE_DIRECTORIES \"${_IMPORT_PREFIX}/include\"  \n  )\n  \n  # Create imported target TBB::tbbmalloc_proxy  \n  add_library(TBB::tbbmalloc_proxy SHARED IMPORTED)\n  \n  set_target_properties(TBB::tbbmalloc_proxy PROPERTIES  \n  \tINTERFACE_COMPILE_DEFINITIONS \"\\$<\\$<CONFIG:DEBUG>:TBB_USE_DEBUG>\"  \n  \tINTERFACE_INCLUDE_DIRECTORIES \"${_IMPORT_PREFIX}/include\"  \n  )  \n  ~~~\n  \n  \n#### find_package(Qt5 REQUIRED) 出错\n  \n~~~cmake\nfind_package(Qt5 REQUIRED)\ntarget_link_libraries(main PUBLIC Qt5::Widgets Qt5::Gui)\n~~~\n  \n* **ERROR**  \n  <img src=\"/imgs/CMake Note/Qt5Error.png\" alt=\"Qt5报错\">  \n  这里是说( 看最后一句 ) Qt5 包至少需要一个组件。  \n  Qt5 有很多组件，但是直接 `find_package(Qt5 REQUIRED)` 他不知道用户需要哪些组件。\n  \n##### 原因：Qt5 具有多个组件，你必须指定你需要哪些组件\n  \nfind_package 生成的伪对象 (imported target) 都按照 “包名::组件名” 的格式命名。  \n可以在 find_package 中通过 **COMPONENTS** 选项，后面跟随一个列表表示需要用的组件。\n  \n~~~cmake\nfind_package(Qt5 COMPONENTS Widgets Gui REQUIRED)\ntarget_link_libraries(main PUBLIC Qt5::Widgets Qt5::Gui)\n~~~\n  \n~~~cmake\nfind_package(TBB COMPONENTS tbb tbbmalloc tbbmalloc_proxy REQUIRED)\ntarget_link_libraries(main PUBLIC TBB::tbb TBB::tbbmalloc TBB::tbbmalloc_proxy)\n~~~\n  \n##### 常见错误：Windows 找不到 Qt5\n  \n因为 Windows 系统安装路径混乱没有固定的 /usr/lib 之类的默认路径能供CMake搜索所以报错了。  \n<img src=\"/imgs/CMake Note/Qt5CannotFound.png\" alt=\"Qt5找不到\">\n  \n* 假设 Qt5 安装在 C:\\Qt\\Qt5.14.2，去找这个目录  \n  C:\\Qt\\Qt5.14.2\\msvc2019_64\\lib\\cmake\\\n  \n* 会有一个 Qt5Config.cmake，现在有四种办法可以让CMake找到他\n  \n  * **第一种**：设置 CMAKE_MODULE_PATH 变量，添加一下包含 Qt5Config.cmake 这个文件的目录路径 C:\\Qt\\Qt5.14.2\\msvc2019_64\\lib\\cmake，当然这里也要把 `\\` 换成 `/`，因为 CMake 是倾向 Unix 的构建，*<del>这是派别和历史问题了</del>*。这种方法相当于在 CMake 搜索目录里加上这个路径，其他包在搜索遍历时也会遍历过这个路径，后面会有更好的办法。\n  \n    ~~~cmake  \n    set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} C:/Qt/Qt5.14.2/msvc2019_64/lib/cmake)\n    \n    find_package(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)  \n    target_link_libraries(main PUBLIC Qt5::Widgets Qt5::Gui)  \n    ~~~\n  \n  * **第二种(更好的办法)：设置<包名>_DIR 变量指向 <包名>Config.cmake 所在位置**  \n    设置 Qt5_DIR 这个变量为 C:\\Qt\\Qt5.14.2\\msvc2019_64\\lib\\cmake  \n    这样只有 Qt5 这个包会去这个目录里搜索 Qt5Config.cmake 更有针对性。\n  \n    ~~~cmake  \n    set(Qt5_Dir C:/Qt/Qt5.14.2/msvc2019_64/lib/cmake)\n    \n    find_package(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)  \n    target_link_libraries(main PUBLIC Qt5::Widgets Qt5::Gui)  \n    ~~~\n\n  \n  * 第三种(推荐)，直接在命令行通过 `-DQt5_DIR=\"xxx\"` 指定，这样不用修改 CMakeLists.txt  \n    `cmake -B build -DQt5_DIR=\"C:/Qt/Qt5.14.2/msvc2019_64/lib/cmake\"`  \n  * 第四种，还可以设置环境变量 Qt5_DIR 也是可以的，就是对 Windows 用户比较困难  \n    `export Qt5_DIR=\"/opt/Qt5.14.2/lib/cmake\"`\n  \n### 不指定 REQUIRED 找不到时不报错，只会设置 TBB_FOUND 为 FALSE\n  \n ~~~cmake  \n find_package(TBB)  \n if(TBB_FOUND)  \n \tmessage(STATUS \"TBB found at:${TBB_DIR}\")  \n \ttarget_link_libraries(main PUBLIC TBB::tbb)  \n \ttarget_compile_definitions(main PUBLIC WITH_TBB)  \n else()  \n \tmessage(WARNING \"TBB not found! using serial for\")  \n endif()  \n ~~~\n  \n前面很多例子都在 find_package() 加上 REQUIRED 选项。  \n如果我们不加 REQUIRED，在找不到对应 package 时不会报错。  \n这样的设计目的在于，当我们添加一些可选的依赖，如果没有也不会影响程序基本运行，我们找不到可选项，就可以向用户抛出一个警告。  \n找到了会把 TBB_FOUND 设为 TRUE，TBB_DIR 也会设置为 TBBConfig.cmake 所在目录。  \n找不到会把 TBB_FOUND 设为 FASLE，TBB_DIR 也会为空。  \n这里我们在找到 TBB 的 if 里定义一个 WITH_TBB 宏，稍后在 .cpp 里就可以根据这个判断。  \n如果找不到 TBB 可以 fallback 到保守的实现方式。  \n`-- TBB found at: /usr/lib64/cmake/TBB`\n  \n#### 在 C++ 中判断 WITH_TBB 宏，找不到 TBB 则退化到串行 for 循环\n  \n~~~c++\n#include <cstdio>\n#ifdef WITH_TBB\n#include <tbb/parallel_for.h>\n#endif\n\nint main()\n{\n#ifdef WITH_TBB\n\ttbb::parallel_for(0,4,[&](int i){\n#else\n        for(int i = 0; i < 4; i++){\n#endif\n\t\t\tprintf(\"hello, %d!\\n\",i);\n#ifdef WITH_TBB\n    });\n#else\n    }\n#endif\n}\n~~~\n  \n### 也可以使用 TARGET 判断是否存在 TBB::tbb 这个伪对象，实现 TBB_FOUND 的效果\n  \n~~~cmake\nfind_package(TBB)\nif(TARGET TBB::tbb)\n\tmessage(STATUS \"TBB found at:${TBB_DIR}\")\n\ttarget_link_libraries(main PUBLIC TBB::tbb)\n\ttarget_compile_definitions(main PUBLIC WITH_TBB)\nelse()\n\tmessage(WARNING \"TBB not found! using serial for\")\nendif()\n~~~\n  \n同时也可以在 if 进行复合语句判断  \n`NOT TARGET TBB::tbb AND TARGET Eigen3::eigen`  \n表示找得到 TBB 但是找不到 Eigen3。\n  \n## 第六章：输出与变量\n  \n### 在运行 cmake -B build 时，打印字符串用于调试程序 \n  \n~~~cmake\nmessage(\"Hello World\")\n~~~\n  \n>Hello world\n  \nmessage 会把字符串打在命令行。\n  \n#### message(STATUS \"...\")\n  \n~~~cmake\nmessage(STATUS \"Hello World\")\n~~~\n  \n>-- Hello world\n  \n不带 `STATUS` 选项，cmake 认为：“哦，你的需求很紧急，你只想调试程序。”，被认为是调试信息。  \n带上 `STATUS` 表示是状态信息，告诉用户做了这件事。\n  \n#### message(WARING \"...\") 表示警告信息\n  \n~~~cmake\nmessage(STATUS \"Hello world\")\nmessage(WARNING \"This is a warning sign\")\n~~~\n  \n>CMake Warning at CMakeLists.txt:2 (message):  \n>  This is a warning sign!\n  \n#### message(AUTHOR_WARNING \"...\") 表示仅仅是给项目作者看的警告\n  \n~~~cmake\nmessage(STATUS \"Hello world\")\nmessage(AUTHOR_WARNING \"Hollow Knight is the best!\")\n~~~\n  \n>-- Hello world  \n>CMake Warning (dev) at CMakeLists.txt:2 (message):  \n>  Hollow Knight is the best!  \n>This warning is for project developers. Use -Wno-dev suppress it.\n  \n**AUTHOR_WARNING 可以通过 -Wno-dev 关闭**\n  \n`cmake -B build -Wno-dev`\n  \n#### message(FATAL_ERROR \"...\") 表示是错误信息，会终止 CMake 的运行\n  \n~~~cmake\nmessage(STATUS \"Hello world\")\nmessage(FATAL_ERROR \"This is an error message!\")\nmessage(STATUS \"After Error\")\n~~~\n  \n>-- Hello world  \n>CMake Error at CMakeLists.txt:2 (message):  \n>  This is an error message!\n  \n因为程序被中断所以 Hello world 被打印，Error 有执行，但是 After Error 没有执行，因为在 Error message 处被中断运行了。\n  \n#### message(SEND_ERROR \"...\") 表示错误信息，但之后的语句仍继续执行\n  \n~~~cmake\nmessage(STATUS \"Hello world\")\nmessage(SEND_ERROR \"This is an error message!\")\nmessage(STATUS \"After Error\")\n~~~\n  \n>-- Hello world  \n>CMake Error at CMakeLists.txt:2 (message) :  \n>  This is an error message  \n>  \n>After Error\n  \n可以看到 After Error 正常运行。\n  \n### message 可以用于打印变量\n  \n~~~cmake\nset(myvar \"Hello world\")\nmessage(\"myvar is: ${myvar}\")\n~~~\n  \n>myvar is: Hello world  \n>-- Configuring done  \n>-- Generating done\n  \n#### 如果 set 没加引号会怎么样？\n  \n**会变成分号分隔的列表。**  \n这时候 set(myvar Hello world) 等价于 set(myvar \"Hello;world\")\n  \n~~~cmake\nset(myvar Hello world)\nmessage(\"myvar is: ${myvar}\")\n~~~\n  \n>myvar is: Hello;world  \n>-- Configuring done  \n>-- Generating done\n  \n#### 如果 message 没加引号会怎么样？\n  \n**会把列表里的字符串当作他的关键字**  \n结论：除非实在实在需要列表，不然建议始终在你不确定的地方加上引号，例如：  \nset(source \"main.cpp\" \"mylib.cpp\" \"C:/Program Files/a.cpp\")  \nmessage(\"${source}\")  \n这里的 `C:/Program Files/a.cpp` 有空格所以最好使用引号，这也是为什么CMake用 `;` 做分割，因为 ` ` 可能出现在路径中，而 `;` 不会出现在文件路径中。\n  \n~~~cmake\nset(myvar FATAL_ERROR hello)\nmessage(${myvar})\n# 这样${myvar} 会变成 FATAL_ERROR hello\n~~~\n  \n>CMake Error at CMakeLists.txt:2 (message) :  \n>  hello\n  \n## 第七章：变量与缓存(最大坑点)\n  \n### 重复执行 cmake -B build 会有什么区别\n  \n假如多次执行后几次执行会比第一次执行输出少很多。  \n这是因为 CMake 第一遍需要检测编译器和 C++ 特性等比较耗时，检测完后会把结果存储的**缓存**中，这样第二遍运行cmake -B build 时就可以直接使用缓存的值，就不需要在检测一遍了。\n  \n### 如何清理缓存？删 build 大法\n  \n虽然 CMake 缓存为了加快编译的出发点是好的，但是有问题。比如有时候外部的情况有所更新比如原来的编译器被卸载或者更改，这时候 CMake 缓存内却还存储的是旧的值，就会导致一些问题。  \n最简单的解决办法就是删除 build 文件夹，然后重新运行 cmake -B build。  \n缓存是很多 CMake 出错的根源，因此如果出现诡异的错误，可以先试着删除 build 重新构建看看。  \n删除了缓存就会重新跑一边检测，写新缓存。  \n所以有了经典的 CMake 笑话：\n  \n>99%的 cmake 错误都可以用删 build 解决  \n>删 build 大法好  \n>rm -rf build\n  \n### 清除缓存，其实只需删除 build/CMakeCache.txt 就可以了\n  \n删除 build 虽然简单粗暴彻底，但是这会导致编译产生的中间结果 (.o文件) 也都被删除了，重新编译需要花费很长时间。  \n如果只想清除缓存，不想从头重新编译，可以只删除 build/CMakeCache.txt 这个文件。  \n它存储了缓存的变量，删除它就可以让 CMake 强制重新检测一遍所有的库和编译器。  \n但是有些错误是中间文件的问题还是要删除 build  \n### find_package 就用到了缓存机制\n  \n变量缓存的意义在于能把 find_package 找到的库文件位置等信息，存储起来。  \n这下下次 find_package 时就会利用上缓存的变量，直接返回。  \n避免重复执行 cmake -B 时速度变慢的问题。\n  \n但是会有这样一个问题，假如第一次 build，没有 TBB 库  \n然后我们安装 TBB 后，再次进行build  \n这时候 CMake 读了缓存发现：“哦，我之前找过 TBB，没找到，那不用找了没有 TBB 库”  \n这时候 CMake 就不会去找了……  \n这时候就要 rm -rf build/CMakeCache.txt，删除缓存文件让 CMake 强行重新配置。\n  \n### 设置缓存变量\n  \n语法是：`set(变量名 \"变量值\" CACHE 变量类型 \"注释\")`\n  \n~~~cmake\nset(myvar \"hello\" CACHE STRING \"this is the docstring.\")\nmessage(\"myvar is: ${myvar}\")\n~~~\n  \n**缓存的 myvar 会出现在 build/CMakeCache.txt 里。**\n  \n### 常见问题：我修改了 CMakeLists.txt 里 set 的值，却没有更新。\n  \n为了更新缓存变量，经常有人偷懒直接修改 CMakeLists.txt 里的值，这是没用的。  \n因为 set(...CACHE..) 在缓存变量已经存在的时候，不会去更新缓存的值。  \nCMakeLists.txt 里 set 的值被认为是“默认值”，因此不会在第二次 set 的时候更新。  \n比如上面我们设置过 myvar 的内容是 hello，然后 build，现在改成 world，但是 CMakeCaChe.txt 内的 myvar 还会是 hello\n  \n~~~cmake\nset(myvar \"world\" CACHE STRING \"This is the docstring!\")\nmessage(\"myvar is: ${myvar}\")\n~~~\n  \n### 缓存变量如何更新？标准解法：通过命令行 -D参数\n  \n当然可以使用 ”删 build 大法“，但是有更好的。  \n更新缓存变量正确的方式，通过命令行参数：`cmake -B build -Dmyvar=world`\n  \n#### 命令行 -D 太硬核了，有没有图形化的缓存编译器？\n  \n* 在 Linux 中，可以运行 ccmake -B build 启动基于终端的可视化缓存编辑菜单。  \n* 在 Windows 中，可以 cmake-gui -B build 来启动图形界面编辑各个缓存选项。  \n* 当然，可以直接用编辑器打开 build/CMakeCaChe.txt 修改后保存。  \n  CMakeCaChe.txt 用文本文件存储的目的就是可供用户手动编辑，或者被第三方软件打开并解析的。\n  \n### 也可以通过指定 FORCE 来强制 set 更新缓存\n  \nset 可以在后面加一个 FORCE 选项，表示无论缓存存在与否，都强制更新缓存。  \n不过这样就会导致没办法用 -Dmyvar=othervalue 来更新缓存变量。\n  \n~~~cmake\nset(myvar \"world\" CACHE STRING \"This is the docstring\" FORCE)\nmessage(\"mtvar is: ${myvar}\")\n~~~\n  \n### 缓存变量除了 STRING 还有哪些类型？\n  \n* STRING 字符串，比如：\"hello\",\"world\"  \n* FILEPATH 文件路径，例如：\"C:/vcpkg/scripts/buildsystems/vcpkg.cmake\"  \n* PATH 目录路径，例如：\"C:/Qt/Qt5.14.2/msvc2019_64/cmake/\"  \n* BOOL 布尔值，只有两个取值：ON 或 OFF  \n  注意：TRUE 和 ON 等价，FALSE 和 OFF 等价；YES 和 ON 等价，NO 和 OFF 等价。\n  \n#### 添加一个 BOOL 类型变量，用于控制是否启用某些特性\n  \n~~~cmake\nadd_executable(main main.cpp)\n\nset(WITH_TBB ON CACHR BOOL \"set to ON to enable TBB, OFF to disable TBB.\")\n\nif(WITH_TBB)\n\ttarget_compile_definitions(main PUBLIC WITH_TBB)\n\tfind_package(TBB REQUIRED)\n\ttarget_link_libraries(main PUBLIC TBB::tbb)\nendif()\n~~~\n  \n这里就是用 CACHE变量 控制是否启用 TBB。\n  \n#### CMake 对 BOOL 类型缓存的 set 提供了简写：option\n  \n`option(变量名 \"描述\" 变量值)`  \n等价于  \n`set(变量名 CACHE BOOL 变量值 \"描述\")`\n  \n~~~cmake\nadd_executable(main main.cpp)\n\noption(WITH_TBB \"set to ON to enable TBB, OFF to disable TBB.\")\nif(WITH_TBB)\n\ttarget_compile_definitions(main PUBLIC WITH_TBB)\n\tfind_package(TBB REQUIRED)\n\ttarget_link_libraries(main PUBLIC TBB::tbb)\nendif()\n~~~\n  \noption 的本质还是 set CACHE  \n所以还会有和 set CACHE 一样的问题：option 设置成了 OFF，但是还是 ON。\n  \n#### 常见问题：在 CMakeLists.txt 里修改了 option 为 OFF，但是运行出来还是 ON\n  \n因为 option 本质就是 set CACHE，  \n虽然修改了，但是 CMakeCaChe.txt 内还是 ON\n  \n#### 解决办法还是 -D参数 来修改\n  \n-D变量名:BOOL=ON/OFF  \n`cmake -B build -DWITH_TBB:BOOL=OFF`\n  \n#### 或者改用 set 然后 Force\n  \n#### 绕靠缓存：使用普通变量，但仅当没有定义时设定为默认值\n  \n一般而言，CMake 自带的变量( 如 CMAKE_BUILD_TYPE )都这样设置。  \n**这样项目的使用者还是可以用 -D来指示参数，**只不过不会在 ccmake 里被显示。(ccmake是查询缓存的)\n  \n~~~cmake\nif(NOT DEFINED WITH_TBB)\n\tset(WITH_TBB ON)\nendif()\nmessage(\"WITH_TBB: ${WITH_TBB}\")\nif(WITH_TBB)\n\ttarget_compile_definition(main PUBLIC WITH_TBB)\n\tfind_package(TBB REQUIRED)\n\ttarget_link_libraries(main PUBLIC TBB::tbb)\nendif()\n~~~\n  \n## 第八章：跨平台和编译器\n  \n### 在CMake 中给 .cpp 定义一个宏\n  \n~~~cpp\n#include <cstdio>\n\nint main()\n{\n#ifdef MY_MACRO\n    printf(\"MY_MACRO defined! value: %d\\n\", MY_MACRO);\n#else\n    printf(\"MY_MACRO not defined!\\n\");\n#endif\n}\n~~~\n  \n~~~cmake\nadd_executable(main)\nfile(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)\ntarget_sources(main PUBLIC ${sources})\ntarget_compile_definitions(main PUBLIC MY_MACRO=233)\t# 相当于 gcc -DMY_MACRO=233\n~~~\n  \n> MY_MACRO defined! value: 233\n  \n### 根据不同的操作系统，把宏定义为不同的值\n  \n~~~c++\n#include <cstdio>\n\nint main()\n{\n#ifdef MY_NAME\n    printf(\"Hello, %s!\\n\", MY_NAME);\n#else\n    printf(\"I don`t know your name!\\n\");\n#endif\n}\n~~~\n  \n~~~cmake\nif(CMAKE_SYSTEM_NAME MATCHES \"Windows\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Bill Gates\")\nelseif(CMAKE_SYSTEM_NAME MATCHES \"Linux\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Linus Torvalds\")\nelseif(CMAKE_SYSTEM_NAME MATCHES \"Darwin\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Steve Jobs\")\nelseif()\n~~~\n  \n### CMake 提供了一些简写变量：WIN32, APPLE, UNIX, ANDROID, IOS等等\n  \n虽然是 WIN32 但是对 32位和 64位Windows一样适用  \nAPPLE 对所有苹果产品 MacOS/IOS 都为真  \nUNIX 对所有 Unix 类系统( FreeBSD, Linux, Android, MacOS, IOS ) 都为真\n  \n~~~cmake\nif(WIN32)\t# WIN32 这些是 bool 类型\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Bill Gates\")\nelseif(UNIX AND NOT APPLE)\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Linus Torvalds\")\nelseif(APPLE)\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Steve Jobs\")\nelseif()\n~~~\n  \n### 使用生成器表达式，简化指令\n  \n语法：`$<$<类型:值>:为真时表达式>`  \n比如`$<$<PLATFORM_ID:Windows>:MY_NAME=\"Bill Gates\">`  \n在 Windows 平台上还会变成 MY_NAME=\"Bill Gates\"  \n其他平台则为空字符。\n  \n~~~cmake\ntarget_compile_definitions(main PUBLIC\n\t$<$<PLATFROM_ID:Windows>:MY_NAME=\"Bill Gates\">\n\t$<$<PLATFROM_ID:Linux>:MY_NAME=\"Linus Torvalds\">\n\t$<$<PLATFROM_ID:Darwin>:MY_NAME=\"Steve Jobs\">\n)\n~~~\n  \n### 生成器表达式：如需多个平台可以用逗号分隔\n  \n~~~cmake\ntarget_compile_definitions(main PUBLIC\n\t$<$<PLATFORM_ID:Windows>:MY_NAME=\"DOS-like\">\n\t$<$<PLATFROM_ID:Linux,Darwin,FreeBSD>:MY_NAME=\"Unix-like\">\n)\n~~~\n  \n相关参考：[CMake : PLATFROM_ID](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#genex:PLATFROM_ID)\n  \n### 判断当前是哪一款 C++ 编译器\n  \n~~~cmake\nif(CMAKE_CXX_COMPILER_ID MATCHES \"GNU\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"gcc\")\nelseif(CMAKE_CXX_COMPILER_ID MATCHES \"NVIDIA\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"nvcc\")\nelseif(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n\ttarget_compile_difinitions(mian PUBLIC MY_NAME=\"clang\")\nelseif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"msvc\")\nendif()\n~~~\n  \n### 也同样可以使用生成器表达式\n  \n~~~cmake\ntarget_compile_definitions(main PUBLIC\n\t$<$<CXX_COMPILER_ID:GNU,Clang>:MY_NAME=\"Open-source\">\n\t$<$<CXX_COMPILER_ID:MSVC,NVIDIA>:MY_NAME=\"Commercial\">\n)\n~~~\n  \n### 生成器表达式可以做复杂的逻辑判断\n  \n~~~cmake\ntarget_compile_definitions(main PUBLIC\n\t$<$<AND:$<CXX_COMPILER_ID:GNU,Clang>,$<PLATFROM_ID:Linux,FreeBSD>>:MY_NAME=\"Open-source\">\n)\n~~~\n  \n### CMake 还提供了一些简写变量：MSVC, CMAKE_COMPILER_IS_GNUCC\n  \n~~~cmake\nif(MSVC)\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"MSVC\")\nelseif(CMAKE_COMPILER_IS_GNUCC)\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"GCC\")\nelse()\n\ttarget_compile_definitions(main PUBLIC MY_NAME=\"Other compiler\")\nendif()\n~~~\n  \n### CMAKE_CXX_COMPILER_ID 直接作为字符串变量\n  \n~~~cmake\ntarget_compile_definitions(main PUBLIC MY_NAME=\"The ${CMAKE_CXX_COMPILER_ID} Compiler\")\n~~~\n  \n### 从命令行参数指定编译器\n  \n`cmake -B build -DCMAKE_CXX_COMPILER=\"/usr/bin/clang++\"`  \n当然这个得第一次就定义，如果第二次使用这个命令需要 删build 清除缓存。\n  \n### 也可以通过环境变量 CXX 指定\n  \n`CXX='which clang' cmake -B build`\n  \n### CMAKE_GENERATOR 也可以了解一下\n  \n~~~cmake\nmessage(\"Generator:${CMAKE_GENERATOR}\")\nmessage(\"C++ compiler: ${CMAKE_CXX_COMPILER}\")\nmessage(\"C compiler: ${CMAKE_C_COMPILER}\")\n~~~\n  \n## 第九章：分支和判断\n  \n### BOOL 类型的值\n  \n* 通常来讲只有 ON/OFF 两个取值  \n  但是由于历史问题，TRUE/FALSE 和 YES/NO 也可以表示 BOOL 类型  \n* 但是推荐只使用 ON/OFF 避免混淆\n  \n### if 的特点：不需要加 ${}, 会自动尝试作为变量名求值\n  \n由于历史问题，if 的括号中有着特殊的语法，如果是一个字符串，比如 MYVAR，则他会先看是否有 ${MYVAR} 这个变量，如果有则被替换为变量的值来进行接下来的比较，否则保持原来的字符串不变。  \n~~~cmake\nset(MYVAR Hello)\nif(MYVAR MATCHES Hello)\n\tmessage(\"MYVAR is Hello\")\nelse()\n\tmessage(\"MYVAR is not hello\")\nendif()\n~~~\n  \n### 如果加上 ${} 也没区别\n  \n`if(${MYVAR} MATCHES \"Hello\")` 会展开成 `if(Hello MACHES \"Hello\")`  \n因为没有 Hello 变量所以被视为字符串正常进行匹配。\n  \n### 万一定义了 Hello 变量那就寄了\n  \n~~~cmake\nset(MYVAR Hello)\nset(Hello world)\nif(${MYVAR} MATCHES \"Hello\")\n\tmessage(\"MYVAR is Hello!\")\nelse()\n\tmessage(\"MYVAR is not Hello!\")\nendif()\t\n~~~\n  \n`if(${MYVAR} MATCHES \"Hello\")` 变成 `if(Hello MATCHES \"Hello\")`  \nif 认为用户要使用 Hello 变量，然后就出错了。  \n这里不要自作聪明加 ${} 就好了。\n  \n### 解决：用引号包裹，防止被当作变量名\n  \n~~~cmake\nset(MYVAR Hello)\nset(Hello world)\nif(\"${MYVAR}\" MATCHES \"Hello\")\n\tmessage(\"MYVAR is Hello!\")\nelse()\n\tmessage(\"MYVAR is not Hello!\")\nendif()\t\n~~~\n  \n但是你不觉得麻烦吗？直接变量名就好了。  \n**另外：CMake 仅仅是指令( set,message 这些 )不分大小写，但变量名什么的是分大小写的！**\n  \n## 第十章：变量和作用域\n  \n### 变量的传递规则：父传子\n  \n* 父模块内容会传递给子模块\n  \n* CMakeLists.txt\n  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)\n  \n  set(MYVAR ON)  \n  add_executable(main main.cpp)  \n  ~~~\n  \n* m/CMakeLists.txt  \n  ~~~cmake  \n  message(\"MYVAR is ${MYVAR}\")  \n  ~~~\n  \n* Output  \n  >MYVAR is ON\n  \n### 变量传递规则：子不传父\n  \n* 如果父模块本来就定义同名变量，则离开子模块后仍保持父模块原来设置的值。\n  \n* CMakeLists.txt  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)\n  \n  set(MYVAR OFF)  \n  add_subdirectory(mylib)  \n  message(\"MYVAR:${MYVAR}\")  \n  ~~~\n  \n* m/CMakeLists.txt\n  \n  ~~~cmake  \n  set(MYVAR ON)  \n  ~~~\n  \n* Output\n  \n  >MYVAR:OFF\n  \n### 若子模块想向父模块传递变量该怎么办？\n  \n* 可以使用 set 的 PARENT_SCOPE 选项把一个变量传递到上一层作用域\n  \n* CMakeLists.txt\n  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)\n  \n  set(MYVAR OFF)  \n  add_subdirectory(mylib)  \n  message(\"MYVAR:${MYVAR}\")  \n  ~~~\n  \n* m/CMakeLists.txt\n  \n  ~~~cmake  \n  set(MYVAR ON PARENT_SCOPE)  \n  ~~~\n  \n* Output\n  \n  >MYVAR:ON\n  \n* 如果父模块没有定义 MYVAR，也可以使用缓存变量向外传递( 不建议, 这样很不安全 )，但是因为缓存变量是全局的，这样不仅父模块可见，父模块的父模块也可见。\n  \n  * CMakeLists.txt\n  \n    ~~~cmake  \n    cmake_minimum_required(VERSION 3.15)\n    \n    add_subdirectory(mylib)  \n    message(\"MYVAR:${MYVAR}\")  \n    ~~~\n  \n  * m/CMakeLists.txt\n  \n    ~~~cmake  \n    set(MYVAR ON CACHE BOOL \"\" FORCE)  \n    ~~~\n  \n  * Output\n  \n    >MYVAR:ON\n  \n### 除了父模块还有哪些是带有独立作用域的\n  \n* include 的 XXX.cmake **没有**独立作用域  \n* add_subdirectory 的 CMakeLists.txt 有独立作用域  \n* macro **没有**独立作用域，插入执行，变量会暴露出来  \n* function **有**独立作用域，变量不会暴露出来  \n* 因此 PARENT_SCORE 也可以用于 function 的返回值\n  \n### 环境变量的访问方式：$ENV{xx}\n  \n* 用 ${xx} 访问的是局部变量，局部变量服从刚刚说的父子模块传递规则。\n  \n* 而还有一种特殊的方式可以访问系统的环境变量( enviroment variable ) : $ENV{xx}\n  \n* 比如 $ENV{PATH} 获取的就是 PATH 这个环境变量的值  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)  \n  project(helloCMake)\n  \n  message(\"PATH:$ENV{PATH}\")  \n  ~~~\n  \n### 缓存变量的访问方式：$CACHE{xx}\n  \n* 还可以用 $CACHE{xx} 访问缓存变量  \n  缓存变量和环境变量都是全局的，没有作用域一说\n  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)  \n  project(helloCMake)\n  \n  message(\"CMAKE_BUILD_TYPE:$CACHE{CMAKE_BUILD_TYPE}\")  \n  ~~~\n  \n### ${xx} 找不到局部变量时，会自动去找缓存变量\n  \n* 当 ${xx} 在局部变量找不到时，回去查询名为 xx 缓存变量\n  \n* 所以这里虽然没有定义 CMAKE_BUILD_TYPE，但是 ${} 在缓存变量中找到了  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)  \n  projecr(helloCMake)\n  \n  message(\"CMAKE_BUILD_TYPE:${CMAKE_BUILD_TYPE}\")\n  \n  add_executable(main main.cpp)  \n  ~~~\n  \n### if(DEFINED XX) 判断变量是否存在\n  \nif(DEFINED MYVAR) 可以判断是否定义了 MYVAR 变量，判断的是**局部变量**和**缓存变量**  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\nprojecr(helloCMake)\n\nif(DEFINED MYVAR)\n\tmessage(\"MYVAR:${MYVAR}\")\nelse()\n\tmessage(\"MYVAR not defined\")\nendif()\n~~~\n  \n需要注意的是即便变量是空字符串也是被认为存在的，因为 DEFINED 判断的是*是否被定义*。\n  \n### if(xx) 就可以判断是否存在且不为空\n  \n可以直接用 if(xx) 来判断空字符串，因为空字符串等于 OFF  \n~~~cmake\ncmake_minimum_required(VERSION 3.15)\nprojecr(helloCMake)\n\nset(MYVAR \"\")\nif(MYVAR)\n\tmessage(\"MYVAR is:${MYVAR}\")\nelse()\n\tmessage(\"MYVAR is empty or not defined\")\nendif()\n~~~\n  \n### if(DEFINED ENV{xx}) 判断环境变量是否存在\n  \n* 因为 $ENV{xx} 代表环境变量，因此在 set 和 if 中也可以用 ENV{xx} 来表示环境变量  \n  因为 set 的第一参数和 if 的参数都是不加 $ 的，  \n  所以要设置 ${x} 就变成了 set(x ...);  \n  设置 $ENV{x} 就变成了 set( ENV{x} ...)  \n  同理还可以用 if(DEFINED CACHE{x} ) 判断是否存在 缓存变量x  \n  但是 set( CACHE{x} ...) 不行，别搞错了。\n  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)  \n  project(helloCMake)\n  \n  set(ENV{MYVAR} \"hello\")  \n  if(DEFINED ENV{MYVAR})  \n  \tmessage(\"MYVAR:$ENV{MYVAR}\")  \n  else()  \n  \tmessage(\"MYVAR is not defined!\")  \n  endif()  \n  ~~~\n  \n### 第十一章：小建议\n  \n### CCache：编译加速缓存\n  \n* 用法：把 gcc -c main.cpp -o main 换成 ccache gcc -c main.cpp -o main 即可  \n  在 CMake 中，可这样来启用 ccache ( 就是给每个编译和链接命令前面加上 ccache )\n  \n  ~~~cmake  \n  cmake_minimum_required(VERSION 3.15)  \n  project(helloCMake)\n  \n  find_program(CCACHE_PROGRAM ccache)  \n  if(CCACHE_PROGRAM)  \n  \tmessage(STATUS \"Found CCache:${CCACHE_PROGRAM}\")  \n  \tset_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_PROGRAM})  \n  \tset_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ${CCACHE_PROGRAM})  \n  endif()  \n  ~~~\n  \n* CCache 官网：https://ccache.dev/ ( 不过好像不支持 MSVC )\n  \n### 添加一个 run 伪目标，用于启动主程序( 可执行文件 )\n  \n* 创建一个 run 伪目标，其执行 main 的可执行文件  \n  这里用了生成器表达式 `$<TARGET_FILE:main>` 会自动让 run 依赖 main  \n  如果自动依赖失败，可以手动加上 add_dependencies(run main) 也是可以的。\n  \n* 这样就可以在命令行运行 cmake --build build --target run 来启动 main.exe 运行了。而不必根据不同的平台，手动写出 build/main 或者 build\\main.exe  \n  ~~~cmake  \n  add_executable(main main.cpp)\n  \n  add_custom_target(run COMMAND $<TARGET_FILR:main>)  \n  ~~~\n  \n### 再加一个 configure 伪目标，用于可视化地修改缓存变量\n  \n* 这样就可以 cmake  --build build --target configure 来启动 ccmake 修改缓存了  \n  Linux 上相当于 ccmake -B build，Windows 则是 cmake-gui -B build\n  \n  ~~~cmake  \n  add_custom_target(run COMMAND $<TARGET_FILE:main>)  \n  if(CMAKE_EDIT_COMMAND)  \n  \tadd_custom_target(configure COMMAND ${CMAKE_EDIT_COMMAND} -B ${CMAKE_BINARY_DIR})  \n  endif()  \n  ~~~\n\n  \n  \n## [文件目录组织规范](https://www.bilibili.com/video/BV1V84y117YU)\n  \n基于CMake的项目组织。\n  \n### 推荐的目录组织\n  \n* project_name/include/project_name/module_name.h  \n* project_name/src/module_name.cpp\n  \n将头文件放在include/project_name目录下是防止**不同子项目**或**项目**与**系统头文件**相冲突。\n  \n**在CMakeLists.txt中**使用\n  \n`target_include_directories(project_name PUBLIC include)`\n  \n指定项目名project_name, PUBLIC导入include文件\n  \n**源文件中**\n  \n* #include<project_name/module_name>  \n* project_name::func();\n  \n**头文件中(project_name/include/project_name/module_name.h)**\n  \n~~~c++\n#pragma once\nnamespace project_name{\n    void func();\n}\n~~~\n  \n**实现文件(projecr_name/src/module_name.cpp)**\n  \n~~~c++\n#include <project_name/module.h>\nnamespace project_name{\n    void func()\n    {\n        int a;\n\t}\n}\n~~~\n  \n#### 例子\n  \n* biology  \n  * CMakeLists.txt  \n  * include  \n    * biology  \n      * Animal.h  \n  * src  \n    * Animal.cpp  \n* CMakeList.txt  \n* pybmain  \n  * CMakeLists.txt  \n  * include  \n    * pybmain  \n      * myutils.h  \n  * src  \n    * main.cpp\n  \n有点抽象……\n  \n<img src=\"D:\\Book\\C++\\MyC++Note\\CMake.png\" alt=\"CMake\" style=\"zoom:67%;\" />\n  \n### 划分子项目\n  \n一个大型的项目不可能是仅仅一个项目，往往是要分成多个子项目。\n  \n通常分为库文件，可执行文件两个部分，**库文件**主要负责逻辑运算、数据处理诸如此类的**代码逻辑**；**可执行文件**主要是和**用户的交互逻辑**。\n  \n### 根项目的 CMakeLists.txt 配置\n  \n* 在根项目的 CMakeLists.txt 中，设置了该项目默认的构建模式，设置了统一的 C++ 版本等各种选项。然后通过 `project` 命令初始化了根项目。  \n* 随后通过 `add_subdirectory` 把子项目添加进来( 顺序无关紧要 )，这会调用子项目的 CMakeLists.txt 。  \n  比如调用 biology/CMakeLists.txt 和 pybmain/CMakeLists.txt\n  \n~~~cmake\ncmake_minimum_required(VERSION 3.18)\n\nif (NOT CMAKE_BUILD_TYPE)\n\tset(CMAKE_BUILD_TYPE Release)\nendif()\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n\nproject(CppCMakeDemo LANGUAGES CXX)\n\nadd_subdirectory(pybmain)\nadd_subdirectory(biology)\n~~~\n  \n# 我遇到的实际问题\n  \n## 将资源拷贝到Build目录，供可执行文件读取\n  \n~~~cmake\nadd_custom_command(\n\tTARGET main POST_BUILD\n\tCOMMAND ${CMAKE_COMMAND} -E copy_directory\n\t\t\t${CMAKE_CURRENT_SOURCE_DIR}/obj\n\t\t\t${CMAKE_CURRENT_BINARY_DIR}/obj\n)\n~~~\n  \n[CMake官方：add_custom_command](https://cmake.org/cmake/help/latest/command/add_custom_command.html?highlight=add_custom_command)  \n[Post copy files to currently building target directory.](https://discourse.cmake.org/t/post-copy-files-to-currently-building-target-directory/6027)在这个问题中：“For example, if I’m building demo1 I want the output dir to be demo1s binary dir, if I’m building demo2, demo2’s binary dir etc.”有点意思但是我没想到解决思路用`${PROJECT_SOURCE_DIR}`和`${PROJECT_BINARY_DIR}`不行吗？  ","slug":"CMake Note","published":1,"updated":"2024-01-14T08:13:08.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti1000bbkbw2xfh7vlp","content":"<p>对 CMake\r\n粗浅的学习，之前看一个up的讲的一般，后来看了小彭老师，的确不错，因为官方文档看起来有点吃力，所以就……<br />\r\n学习过程中把知识点做了一点笔记方便后续复习</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"cmake\">CMake</h1>\r\n<p>本文档为学习笔记，该部分内容来源<a\r\nhref=\"https://www.bilibili.com/video/BV1vR4y1u77h/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0\">b站Up刘贝斯的CMake教学</a>。</p>\r\n<h2 id=\"what-is-cmake\">What is CMake?</h2>\r\n<p>CMake 是一种高级编译配置工具。</p>\r\n<p>当多人使用一种或不同种语言、编译器开发一个项目时，最终需要输出一个<strong>可执行文件</strong>或者<strong>共享库</strong>(dll,\r\nso等等)，此时——CMake就可以帮助到我们，不必用G++或GCC逐个编译我们所写过的代码。<br />\r\n所有操作都是通过编译CMakeLists.txt完成的。<br />\r\n使用CMake来处理大型的C/C++/Java等项目。</p>\r\n<h2 id=\"cmake-安装\">CMake 安装</h2>\r\n<ul>\r\n<li>Linux大多都有安装。<br />\r\n</li>\r\n<li>Windows, 下载网站(https://cmake.org/download/)</li>\r\n</ul>\r\n<h2 id=\"cmake-hello-world\">CMake: Hello World</h2>\r\n<p>1.首先写一个C/C++的hello world</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>2.编写<code>CmakeLists.txt</code></p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">PROJECT</span> (HELLOW)<br><br><span class=\"hljs-keyword\">SET</span>(SRC_LIST main.cpp)<br><br><span class=\"hljs-keyword\">MESSAGE</span>(STATUS <span class=\"hljs-string\">&quot;This is BINARY dir &quot;</span> <span class=\"hljs-variable\">$&#123;HELLO_BINAR_DIR&#125;</span>)<br><br><span class=\"hljs-keyword\">MESSAGE</span>(STATUS <span class=\"hljs-string\">&quot;This is SOURCE dir &quot;</span> <span class=\"hljs-variable\">$&#123;HELLO_SOURCE_DIR&#125;</span>)<br><br><span class=\"hljs-keyword\">ADD_EXECUTABLE</span>&#123;hello $(SRC_LIST)&#125;<br></code></pre></td></tr></table></figure>\r\n<p>3.使用CMake，生成<code>makefile</code>文件</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">cmake .  <br></code></pre></td></tr></table></figure>\r\n<h3 id=\"cmake-hello-world语法介绍\">CMake: Hello World语法介绍</h3>\r\n<h4 id=\"project关键字-简书cmake命令之project\"><code>PROJECT</code>关键字\r\n—— <a\r\nhref=\"https://www.jianshu.com/p/cdd6e56c2422\">简书CMake命令之project</a></h4>\r\n<p>可以用来<strong>指定工程的名字和支持的语言</strong>，默认支持所有语言。<br />\r\nPROJECT (HELLO) 指定了工程的名字——HELLO，并且支持所有语言。</p>\r\n<h1 id=\"cmake教程\"><a\r\nhref=\"https://www.bilibili.com/video/BV16P4y1g7MH\"><strong>CMake教程</strong></a></h1>\r\n<h2 id=\"第一章-添加源文件\">第一章 添加源文件</h2>\r\n<ul>\r\n<li>第一种，添加名为 <em>main</em> 的 <em>executable</em> ，源文件为\r\n<em>main.cpp</em> 。</li>\r\n</ul>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>第二种，先创建 <strong>目标( executable\r\n)</strong>，稍后再添加源文件。</li>\r\n</ul>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC main.cpp)<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"若有多个源文件呢\">若有多个源文件呢？</h3>\r\n<p>逐个添加即可</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC main.cpp other.cpp)<br></code></pre></td></tr></table></figure>\r\n<p>或者使用<strong>变量</strong>来存储</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">set</span>(sources main.cpp other.cpp)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<p>建议把头文件也加上，这样在VS中可以出现在 \"Header Flies\" 一栏</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">set</span>(sources main.cpp other.cpp other.h)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<p>我们还可以使用 <strong>GLOB</strong>\r\n自动查找当前目录下指定拓展名的文件，实现批量添加源文件</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">file</span>(GLOB sources *.cpp *.h)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<p>但是使用 <strong>GLOB</strong>\r\n需要注意，如果我们增添新的源文件时，CMake可能不会更新，所以要启用\r\n<strong>CONFIGURE_DEPENDS</strong> 选项，当添加新文件时，<strong>在\r\nBuild 时进行检测</strong>，自动更新变量</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"源码在子文件夹中\">源码在子文件夹中？</h3>\r\n<h4 id=\"例子\">例子：</h4>\r\n<ul>\r\n<li>mylib\r\n<ul>\r\n<li>other.cpp<br />\r\n</li>\r\n<li>other.h<br />\r\n</li>\r\n</ul></li>\r\n<li>CMakeLists.txt<br />\r\n</li>\r\n<li>main.cpp</li>\r\n</ul>\r\n<p>将<strong>路径名、后缀名全部</strong>写出来</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h mylib/*.cpp mylib/*.h)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<p>然鹅，dark不必，我们可以使用 <strong>aux_source_directory</strong> ,\r\n自动搜集需要的文件后缀名<br />\r\n本例中<code>aux_source_directory(. sources)</code>和<code>aux_source_directory(mylib sources)</code>\r\n表示<strong>当前目录</strong>和 <strong>mylib 目录</strong>\r\n全部加入项目中。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">aux_source_directory</span>(. sources)<br><span class=\"hljs-keyword\">aux_source_directory</span>(mylib sources)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<p>更进一步：<strong>GLOB_RECURES</strong>\r\n能够自动包含所有子文件夹下的文件<br />\r\n但是注意，<strong>GLOB_RECURES</strong> 会把 <strong>build\r\n目录</strong>下的临时 .cpp 文件( 这些临时文件是 CMake 为了测试编译器\r\n)也加进来。<br />\r\n解决办法：一种，可以把源码统一放到 src 目录下。二种，要求使用者不要把\r\nbuild 放到和源码同一个目录里。这两种之间前者好一点。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">file</span>(GLOB_RECURES sources CONFIGURE_DEPENDS *.cpp *.h)<br>target_source(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"第二章-项目配置变量build_type\">第二章\r\n项目配置变量——BUILD_TYPE</h2>\r\n<h3\r\nid=\"cmake_build_type-构建的类型调试模式-or-发布模式\">CMAKE_BUILD_TYPE\r\n构建的类型，调试模式 or 发布模式</h3>\r\n<ul>\r\n<li>CMAKE_BUILD_TYPE 是 CMake 中一个特殊的变量，\r\n用于控制构建类型，他的值可以是：\r\n<ul>\r\n<li>Debug 调试模式，完全不进行优化，生成调试信息，方便调试程序<br />\r\n</li>\r\n<li>Release 发布模式，优化程度最高，性能最佳，但是编译比 Debug 慢<br />\r\n</li>\r\n<li>MinsizeRel 最小体积发布，生成的文件比 Release\r\n更小，不完全优化，减少二进制体积。<br />\r\n</li>\r\n<li>RelWithDebInfo 带调试信息发布，生成的文件比 Release\r\n更大，因为带有调试的符号信息。<br />\r\n</li>\r\n</ul></li>\r\n<li>默认情况下，CMAKE_BUILD_TYPE 为空字符，这时相当于 Debug。</li>\r\n</ul>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">cmake_minimun_required(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellowcmake LANGUAGES CXX)<br><br><span class=\"hljs-keyword\">set</span>(CMAKE_BUILD_TYPE Release)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure>\r\n<p>各种构建模式在编译器选项上的区别</p>\r\n<ul>\r\n<li>在 Release\r\n模式下，追求的是程序最佳的性能表现，在此情况下编译器会对程序做最大的代码优化以达到最快的运行速度。另一方面，由于代码优化后不与源代码一致，此模式下一般会丢失大量的调试信息。</li>\r\n</ul>\r\n<p>在编译器上各种构建类型的体现：</p>\r\n<ul>\r\n<li>Debug : '-O0 -g'<br />\r\n</li>\r\n<li>Release : '-O3 -DNDEBUG'<br />\r\n</li>\r\n<li>MinSizeRel : '-Os -DNDEBUG'<br />\r\n</li>\r\n<li>RelWithDebInfo : '-O2 -g -DNDEBUG'</li>\r\n</ul>\r\n<p>此外，定义 NDEBUG 宏会使 assert 被去除掉。</p>\r\n<p>因为默认情况下是 Debug 导致生成程序的效率很低。<br />\r\n小技巧：设定一个变量的默认值</p>\r\n<p>如何让 CMAKE_BUILD_TYPE 在用户没有指定的情况时为\r\nRelease，指定的时候保持用户的指定的值不变？<br />\r\n即 CMake 默认情况下 CMAKE_BUILD_TYPE 是一个空字符串。<br />\r\n因此可以通过\r\n<code>if( NOT CMAKE_BUILD_TYPE )</code>判断是否为空，空则自动设置为\r\nRelease 模式。<br />\r\n大多数 CMakeLists.txt\r\n开头都会有这样三行，目的是让默认的构建类型为发布模式 (高度优化)\r\n而不是默认的调试模式 (不会优化) 。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>( <span class=\"hljs-keyword\">NOT</span> CMAKE_BUILD_TYPE )<br>\t<span class=\"hljs-keyword\">set</span>(CMAKE_BUILD_TYPE Release)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"project\">Project</h3>\r\n<p>project : 初始化项目信息，并把当前 CMakeLists.txt\r\n所在位置作为根目录</p>\r\n<p>这里初始化名为 hellocmake 的项目；为什么一定需要项目名？<br />\r\n因为对于 MSVC，他会在 build 里生成 hellocmake.sln 作为 IDE\r\n眼中的项目。<br />\r\nCMAKE_CURRENT_SOURCE_DIR 表示<strong>当前源码目录</strong>的位置，例如\r\n~/hellocmake<br />\r\nCMAKE_CURRENT_BINARY_DIR 表示<strong>当前输出目录</strong>的位置，例如\r\n~/hellocmake/build</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">cmake_minumum_required(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellocmake)<br><br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_NAME: $&#123;PROJECT_NAME&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_SOURCE_DIR: $&#123;PROECJR_SOURCE_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_BINARY_DIR: $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;CMAKE_CURRENT_SOURCE_DIR: $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;CMAKE_CURRENT_BINARY_DIR: $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure>\r\n<h4\r\nid=\"和子模块的关系project_x_dir-和-cmake_current_x_dir\">和子模块的关系：PROJECT_X_DIR\r\n和 CMAKE_CURRENT_x_DIR</h4>\r\n<p>PROJECT_SOURCE_DIR 表示最近一次调用 project 的 CMakeLists.txt\r\n所在的源码目录。<br />\r\nCMAKE_CURRENT_SOURCE_DIR 表示当前 CMakeLists.txt 所在的源码目录。<br />\r\nCMAKE_SOURCE_DIR 表示最为外层 CMakeLists.txt 的源码根目录。<br />\r\n利用 PROJECT_SOURCE_DIR 可以实现从子模块直接获取项目最外层的路径。<br />\r\n<strong>不建议使用 CMAKE_SOURCE_DIR ,\r\n那样会让你的项目无法被人作为子模块使用。</strong></p>\r\n<blockquote>\r\n<p>mylib got PORJECT_SOURCE_DIR: /home/bate/Codes/course/11/template</p>\r\n<p>mylib got CMAKE_CURRENT_SOURCE_DIR:\r\n/home/bate/Codes/course/11/template/mylib</p>\r\n</blockquote>\r\n<h4 id=\"其他相关变量\">其他相关变量</h4>\r\n<ul>\r\n<li>PROJECT_SOURCE_DIR : 当前项目源码路径( 存放 main.cpp 的地方)<br />\r\n</li>\r\n<li>PROJECT_BINARY_DIR : 当前项目输出路径 ( 存放 main.exe 的地方 )<br />\r\n</li>\r\n<li>CMAKE_SOURCE_DIR : 根项目源码路径 ( 存放 main.cpp 的地方 )<br />\r\n</li>\r\n<li>CMAKE_BINARY_DIR : 根项目输出路径 ( 存放 main.cpp 的地方 )<br />\r\n</li>\r\n<li>PROJECT_IS_TOP_LEVEL : BOOL 类型，表示当前项目是否是 ( 最顶层的 )\r\n根项目<br />\r\n</li>\r\n<li>PROJECT_NAME : 当前项目名<br />\r\n</li>\r\n<li>CMAKE_PROJECT_NAME : 根项目的项目名<br />\r\n</li>\r\n<li>详见 : <a\r\nhref=\"https://cmake.org/cmake/help/latest/command/project.html\">CMake之Project</a></li>\r\n</ul>\r\n<h4\r\nid=\"子模块也可使用-project-命令将当前目录作为一个独立的子项目\">子模块也可使用\r\nproject 命令，将当前目录作为一个独立的子项目</h4>\r\n<p>这样 PROJECT_SOURCE_DIR 就会是子模块的源码目录而不是外层了。<br />\r\n这时候 CMake\r\n会认为这个子模块是一个独立的项目，会额外做一些初始化。<br />\r\n他的构建目录 PROJECR_BINARY_DIR 也会变成 build/<源码相对路径><br />\r\n这样在 MSVC 上也会看见 build/mylib.vcxproj 的生成</p>\r\n<blockquote>\r\n<p>PORJECT_NAME : hellowcmake</p>\r\n<p>PROJECT_SOURCE_DIR : /home/bate/Codes/course/11/template</p>\r\n<p>PROJECT_BINARY_DIR : /home/bate/Codes/course/11/template/build</p>\r\n<p>CMAKE_CURRENT_SOURCE_DIR : /home/bate/Codes/course/11/template</p>\r\n<p>CMAKE_CURRENT_BINARY_DIR :\r\n/home/bate/Codes/course/11/template/build</p>\r\n<p>mylib got PROJECT_NAME : mylib</p>\r\n<p>mylib got CMAKE_SOURCE_DIR : /home/bate/Codes/course/11/template</p>\r\n<p>mylib got CMAKE_BINARY_DIR :\r\n/home/bate/Codes/course/11/template/build</p>\r\n<p>mylib got PROJECT_SOURCE_DIR :\r\n/home/bate/Codes/course/11/template/mylib</p>\r\n<p>mylib got PROJECT_BINARY_DIR :\r\n/home/bate/Codes/course/11/build/mylib</p>\r\n<p>mylib got CMAKE_CURRENT_SOURCE_DIR :\r\n/home/bate/Codes/course/11/template/mylib</p>\r\n<p>mylib got CMAKE_CURRENT_BINARY_DIR :\r\n/home/bate/Codes/course/11/template/build/mylib</p>\r\n</blockquote>\r\n<h4 id=\"project-的初始化-languages-字段\">project 的初始化 : LANGUAGES\r\n字段</h4>\r\n<ul>\r\n<li>project( 项目名 LANGUAGES 使用的语言列表...)\r\n指定了该项目使用了那种编程语言<br />\r\n目前支持的语言：\r\n<ul>\r\n<li>C : C语言<br />\r\n</li>\r\n<li>CXX : C++<br />\r\n</li>\r\n<li>ASM : 汇编<br />\r\n</li>\r\n<li>Fortran : 老年人的编程语言(雾)，IBM<br />\r\n</li>\r\n<li>CUDA : 英伟达的黑科技 CUDA ( 需要 CMake 3.8 版本 )<br />\r\n</li>\r\n<li>OBJC : 苹果的 Objective-C ( 需要 CMake 3.16 版本 )<br />\r\n</li>\r\n<li>OBJCXX : 苹果的 Objective-C++ ( 需要 CMake 3.16 版本 )<br />\r\n</li>\r\n<li>ISPC : 一种英特尔的自动 SIMD 编程语言 ( 需要 CMake 3.18 版本 )<br />\r\n</li>\r\n</ul></li>\r\n<li>如果不指定 LANGUAGES, 默认为 C 和 CXX。</li>\r\n</ul>\r\n<h5\r\nid=\"常见问题languages-中没有启用-c-语言但却用到了-c-语言\">常见问题：LANGUAGES\r\n中没有启用 C 语言，但却用到了 C 语言</h5>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellocmake LANGUAGES CXX)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.c)<br></code></pre></td></tr></table></figure>\r\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello world from Cmake!\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>这样不行滴哥们，会报错，因为你在 CMakeLists.txt 的设置中没有启用 C\r\n语言。<br />\r\n解决办法：</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSiON <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellocmake LANGUAGES C CXX)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.c)<br></code></pre></td></tr></table></figure>\r\n<p>这次启用了 C 和 C++ 就不会报错力。</p>\r\n<h5\r\nid=\"也可以先设置-languages-none-之后调用-enable_languagecxx\">也可以先设置\r\nLANGUAGES NONE, 之后调用 enable_language(CXX)</h5>\r\n<p>这样可以把 enable_language 放到 if\r\n语句中，从而只有某些选项开启才启用某语言类似的操作。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellocmake LANGUAGES NONE)<br><span class=\"hljs-keyword\">enable_language</span>(CXX)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"设置-c-标准cmake_cxx_standard-变量\">设置 C++\r\n标准：CMAKE_CXX_STANDARD 变量</h4>\r\n<ul>\r\n<li>CMAKE_CXX_STANDARD 是一个整数，表示要用的 C++ 标准。<br />\r\n比如需要 C++17 即设为 17。<br />\r\n</li>\r\n<li>CMAKE_CXX_STANDARD_REQUIRED 是 BOOL 型，可以为 ON / OFF , 默认为\r\nOFF。<br />\r\n表示是否一定要支持指定的 C++ 标准，如果为 OFF 则CMake 检测到编译器不支持\r\nC++17 时不报错，而是将设置调整为 C++14 让开发人员使用；为 ON\r\n时，不支持会报错，具有更好的安全性。<br />\r\n</li>\r\n<li>CMAKE_CXX_EXTENSIONS 是 BOOL 变量，默认为 ON。为 ON 表示启用 GCC\r\n特有的一些拓展功能；OFF 则关闭 GCC 的拓展功能，只使用标准的 C++。<br />\r\n要兼容其他编译器( 如 MSVC )的项目都会将其设为 OFF，以防使用了 GCC\r\n特有的特性。<br />\r\n</li>\r\n<li>注意，最好在 project 命令前设置 CMAKE_CXX_STANDARD\r\n一系列变量，这样一来 CMAKE 可以在 project\r\n函数内对编译器进行一些检测，查看是否能支持对应版本C++的特性。</li>\r\n</ul>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">17</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_EXTENSIONS <span class=\"hljs-keyword\">ON</span>)<br><br><span class=\"hljs-keyword\">project</span>(hellocmake LANGUAGES CXX)<br></code></pre></td></tr></table></figure>\r\n<h5 id=\"常见误区-小彭老师我手动加--stdc17-行不得行\">常见误区 :\r\n小彭老师，我手动加 -std=c++17 行不得行</h5>\r\n<ul>\r\n<li>不要直接修改 CMAKE_CXX_FLAGS 来添加 -std=c++17<br />\r\n使用 CMake 封装好的 CMAKE_CXX_STANDARD<br />\r\n前者为什么不好，GCC 用户一旦手动指定 -std=c++17, 就是使用了 GCC\r\n的特性，而 MSVC 的用户就无法使用了。<br />\r\n而且 CMake 已经自动根据 CMAKE_CXX_STANDARD 的默认值 11 添加了\r\n-std=c++11，之后你再手动添加 -std=c++17 选项就发生了冲突。<br />\r\n所以一定要使用 CMake 已经封装好的 CMAKE_CXX_STANDARD !</li>\r\n</ul>\r\n<h3 id=\"projec-的初始化version-字段\">projec 的初始化：VERSION 字段</h3>\r\n<ul>\r\n<li>project(项目名 VERSION x.y.z) 可以将当前项目的版本号设定为\r\nx.y.z<br />\r\n之后可以使用 PROJECT_VERSION 获取当前项目的版本号<br />\r\n</li>\r\n<li>PROJECT_VERSION_MAJOR 获取 x ( 主版本号 )<br />\r\nPROJECT_VERSION_MINOR 获取 y ( 次版本号 )<br />\r\nPROJECT_VERSION_PATCH 获取 z ( 补丁版本号 )</li>\r\n</ul>\r\n<h4\r\nid=\"项目名的另一个作用-会设置另外-_source_dir-等变量\">项目名的另一个作用\r\n: 会设置另外 <项目名>_SOURCE_DIR 等变量</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellocmake VERSION <span class=\"hljs-number\">2.7</span>.<span class=\"hljs-number\">1</span>)<br><br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_NAME: $&#123;PROJECT_NAME&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_VERSION: $&#123;PROJECT_VERSION&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_SOURCE_DIR: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_BINARY_DIR: $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;hellocmake_VERSION: $&#123;hellocmake_VERSION&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;hellocmake_SOURCE_DIR: $&#123;hellocmake_SOURCE_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;hellocmake_BINARY_DIR: $&#123;hellocmake_BINARY_DIR&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>PROJECT_NAME: hellocmake<br />\r\nPROJECT_VERSION: 2.7.1<br />\r\nPROJECT_SOURCE_DIR: /home/bate/Codes/course/11/templa<br />\r\nPROJECT_BINARY_DIR: /tmp/build/home/bate/Codes/course/11/templa<br />\r\nhellocmake_VERSION: 2.7.1<br />\r\nhellocmake_SOURCE_DIR: /home/bate/Codes/course/11/templa<br />\r\nhellocmake_BINARY_DIR: /tmp/build/home/bate/Codes/course/11/templa</p>\r\n</blockquote>\r\n<p>这个功能可以让我们在当前项目去查询别的项目的版本号比如在 hellocmake\r\n查询 helloworld 的版本号或者其他信息。</p>\r\n<h4 id=\"小技巧-cmake-的-表达式可以嵌套\">小技巧 : CMake 的 ${}\r\n表达式可以嵌套</h4>\r\n<p>因为 ${PROJECT_NAME} 的值是 hellocmake<br />\r\n所以 <span class=\"math inline\">\\({\\)</span>{PROJECT_NAME}_VERSION}\r\n相当于 ${hellocmake_VERSION} 即 2.7.1<br />\r\n<a href=\"https://blog.csdn.net/fuyajun01/article/details/8891749\">CMake\r\n其他关键字</a></p>\r\n<h4 id=\"一个标准的-cmakelists.txt-模板\">一个标准的 CMakeLists.txt\r\n模板</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">17</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span>)<br><br><span class=\"hljs-keyword\">project</span>(zeno LANGUAGES C CXX)<br><br><span class=\"hljs-keyword\">if</span>(PROJECT_BINARY_DIR <span class=\"hljs-keyword\">STREQUAL</span> PROJECT_SOURCE_DIR)<br>\t<span class=\"hljs-keyword\">message</span>(WARING <span class=\"hljs-string\">&quot;The binary directory of CMake cannot be the same as source directory!&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br><br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">NOT</span> CMAKE_BUILD_TYPE)<br>\t<span class=\"hljs-keyword\">set</span>(CMAKE_BUILD_TYPE Release)<br><span class=\"hljs-keyword\">endif</span>()<br><br><span class=\"hljs-keyword\">if</span>(WIN32)<br>\t<span class=\"hljs-keyword\">add_definitions</span>(-DNOMINMAX -D_USE_MATH_DEFINES)<br><span class=\"hljs-keyword\">endif</span>()<br><br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">NOT</span> MSVC)<br>\t<span class=\"hljs-keyword\">find_program</span>(CCACHE_PROGRAM ccache)<br>\t<span class=\"hljs-keyword\">if</span>(CCACHE_PROGRAM)<br>\t\t<span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Found CCache: $&#123;CCACHE_PROGRAM&#125;&quot;</span>)<br>\t\t<span class=\"hljs-keyword\">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_COMPILE <span class=\"hljs-variable\">$&#123;CCACHE_PROGRAM&#125;</span>)<br>\t\t<span class=\"hljs-keyword\">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_LINK <span class=\"hljs-variable\">$&#123;CCACHE_PROGRAM&#125;</span>)<br>\t<span class=\"hljs-keyword\">endif</span>()<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"第三章链接库文件\">第三章：链接库文件</h2>\r\n<h3 id=\"main.cpp-调用-mylib.cpp-里的-say_hello-函数\">main.cpp 调用\r\nmylib.cpp 里的 say_hello 函数</h3>\r\n<ul>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp mylib.cpp)  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>main.cpp</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;mylib.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>\t<span class=\"hljs-built_in\">say_hello</span>();  <br>&#125;  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>mylib.cpp<br />\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;mylib.h&quot;</span>  </span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">say_hello</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello, mylib!\\n&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li>\r\n</ul>\r\n<h4 id=\"改进mylib-作为静态库\">改进：mylib 作为静态库</h4>\r\n<blockquote>\r\n<p><a\r\nhref=\"https://www.jianshu.com/p/090e1c0310ab\">《静态库和动态库》</a> ,\r\n<a\r\nhref=\"https://blog.csdn.net/weixin_39766005/article/details/122368414\">《CMake\r\n| 编译静态库、动态库和对象库》</a><br />\r\n静态库会在<em>链接时</em>完整的复制到每一个可执行文件，被多次使用时就会造成多分冗余。<br />\r\n动态库在<em>链接时</em>不复制，程序运行时由系统动态加载到内存中，供程序调用，系统仅需加载一次，多个程序公用，节省内存。</p>\r\n</blockquote>\r\n<ul>\r\n<li><p>CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib STATIC mylib.cpp)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h4 id=\"改进mylib-作为一个动态库\">改进：mylib 作为一个动态库</h4>\r\n<ul>\r\n<li>CMakeLists.txt ( 动态库在Windows上有坑 )<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h4 id=\"改进mylib-作为一个对象库\">改进：mylib 作为一个对象库</h4>\r\n<p>对象库类似于静态库，但不生成 .a 文件，只由 CMake\r\n记住该库生成了那些对象文件<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">add_libraty(mylib OBJECT mylib.cpp)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure></p>\r\n<p>对象库是 CMake\r\n自创的，绕开了编译器和操作系统的各种繁琐规则，保证了跨平台统一性。<br />\r\n在自己的项目中，推荐全部使用对象库( OBJECT ) 替代静态库 ( STATIC )\r\n避免跨平台的麻烦。<br />\r\n对象库仅仅作为组织代码的方式，而实际生成的可执行文件只有一个，减轻了部署的困难。</p>\r\n<h4\r\nid=\"静态库的麻烦gcc-编译器会自作聪明将自动剔除没有引用符号的对象\">静态库的麻烦：GCC\r\n编译器会自作聪明，将自动剔除没有引用符号的对象</h4>\r\n<ul>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib STATIC mylib.cpp)  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>mylib.cpp<br />\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span>  </span><br><span class=\"hljs-comment\">// 静态初始化  </span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> unused = <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;My initialized\\n&quot;</span>);\t<span class=\"hljs-comment\">// 会在主函数前被执行  </span><br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>main.cpp<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Main function\\n&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>Output<br />\r\n&gt;main function</p></li>\r\n</ul>\r\n<p>这里就是 GCC 看到没有引用人 mylib ，就会删掉 mylib.o\r\n但是恰恰遇到了静待初始化，GCC 就做错了。</p>\r\n<h4\r\nid=\"对象库就可以绕开编译器的不统一保证不会自动剔除没有用到的对象文件\">对象库就可以绕开编译器的不统一：保证不会自动剔除没有用到的对象文件</h4>\r\n<ul>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib OBJECT mylib.cpp)  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>mylib.cpp</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> unused = <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Mylib Function\\n&quot;</span>);  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>main.cpp<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Main Function\\n&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>Output<br />\r\n&gt;Mylib Function<br />\r\n&gt;Main Function</p></li>\r\n</ul>\r\n<h4 id=\"add_library-无参数时是静态库还是动态库\">add_library\r\n无参数时，是静态库还是动态库</h4>\r\n<p>会根据 BUILD_SHARED_LIBS 这个变量的值决定是动态库还是静态库。<br />\r\nON 则相当于 SHARED, OFF 则相当于 STATIC<br />\r\n如果未指定 BUILD_SHARED_LIBS 变量，则默认为 STATIC。<br />\r\n因此，如果发现一个项目内的 add_library\r\n都是无参的，意味着我们可以使用：<br />\r\n<code>cmake -B build -DBUILD_SHARD_LIBS:BOOL=ON</code><br />\r\n来让他全部生成为动态库，这里涉及到<em>命令行传递变量的规则。</em></p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(BUILD_SHARED_LIBS <span class=\"hljs-keyword\">ON</span>)<br><br><span class=\"hljs-keyword\">add_library</span>(mylib mylib.cpp)<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"小技巧设定一个变量的默认值\">小技巧：设定一个变量的默认值</h4>\r\n<p>要让 BUILD_SHARED_LIBS 默认为 ON，可以用之前类似的思路<br />\r\n如果该变量没有定义，则设为 ON，否则保持用户指定的值不变<br />\r\n这样用户没有指定 BUILD_SHARED_LIBS 时，会默认变成ON。<br />\r\n只有用户指定 BUILD_SHARED_LIBS 为 OFF 即\r\n<code>-DBUILD_SHARED_LIBS:BOOL:OFF</code><br />\r\n才会生成静态库，否则默认生成动态库。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">DEFINED</span> BUILD_SHARED_LIBS)<br>\t<span class=\"hljs-keyword\">set</span>(BUILD_SHARED_LIBS <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h4\r\nid=\"常见坑点动态库无法链接静态库\">常见坑点：动态库无法链接静态库</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(otherlib STATIC otherlib.cpp)<br><br><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure>\r\n<p><code>target_link_libraries(mylib PUBLIC otherlib)</code>试图将静态库<code>otherlib</code>链接到<code>mylib</code>中，发生错误。<em>静态库<code>otherlib</code>误以为用户将其连接到一个可执行文件上</em>，但用户却连接到动态库上。动态库在内存中的地址会变化的，在编译时会指定一个<code>fPIC</code>选项，但是静态库没有<code>fPIC</code>选项，静态库的地址并不想变化，而动态库本身却想改变地址，二者会发生冲突。</p>\r\n<h5 id=\"解决办法\">解决办法：</h5>\r\n<p>1、将<code>otherlib</code>变为对象库</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(otherlib OBJECT otherlib.cpp)<br><br><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br>target_link_libraties(main PUBLIC mylib)<br></code></pre></td></tr></table></figure>\r\n<p>2、让静态库编译也生成位置无关的代码( PIC )，这样才能装在动态库中</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(CMAKE_POSITION_INDEPENDENT_CODE <span class=\"hljs-keyword\">ON</span>)<br><br><span class=\"hljs-keyword\">add_library</span>(otherlib STATIC otherlib.cpp)<br><br><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure>\r\n<p>但是这样处理会导致本来不需要为静态 PIC 的静态库也变成 PIC\r\n了，<strong>所以我们可以只针对一个库，只对他启用位置无关的代码( PIC\r\n)</strong><br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(otherlib STATIC otherib.cpp)<br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> otherlib PROPERTY POSITION_INDEPENDENT_CODE <span class=\"hljs-keyword\">ON</span>)<br><br><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br>target_link_libraried(main PUBLIC mylib)<br></code></pre></td></tr></table></figure></p>\r\n<p><strong>注意，add_library()\r\n是要指定头文件的，这里偷懒没加，指定头文件后其就会出现在IDE中。</strong></p>\r\n<h2 id=\"第四章-对象的属性\">第四章 : 对象的属性</h2>\r\n<p>前面提到的 <code>POSITION_INDEPENDENT_CODE</code>\r\n就是一个属性。<br />\r\n### 除了 <code>POSITION_INDEPENDENT_CODE</code> 还有哪些属性呢？</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY CXX_STANDARD <span class=\"hljs-number\">17</span>)\t<span class=\"hljs-comment\"># 采用 C++17 标准编译( 默认为11 )</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span>)\t<span class=\"hljs-comment\"># 如果编译器不支持 C++17，则直接报错( 默认为 OFF )</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY WIN32_EXECUTABLE <span class=\"hljs-keyword\">ON</span>)\t<span class=\"hljs-comment\"># 在 Windows 系统中运行时不启动控制台窗口，只有 GUI 界面 (默认 OFF)</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY LINK_WHAT_YOU_USE <span class=\"hljs-keyword\">ON</span>)\t<span class=\"hljs-comment\"># 告诉编译器不要自动剔除没有引用符号的链接库(默认 OFF)</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY LIBRARY_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)\t<span class=\"hljs-comment\"># 设置动态链接库的输出路径(默认 $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY ARCHIVE_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)\t<span class=\"hljs-comment\"># 设置静态链接库的输出路径(默认 $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY RUNTIME_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)\t<span class=\"hljs-comment\"># 设置可执行文件的输出路径(默认 $&#123;CMAKE_BINARY_DIR&#125;)</span><br></code></pre></td></tr></table></figure>\r\n<p>这样一个一个 <code>set_property</code>\r\n好麻烦啊！要是有更简单的写法就好了，于是……</p>\r\n<h3 id=\"另一个方法-set_target_properties-批量设置多个属性\">另一个方法 :\r\n<code>set_target_properties</code> 批量设置多个属性</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">set_target_properties</span>(main PROPERTIES<br>\tCXX_STANDARD <span class=\"hljs-number\">17</span><br>\tCXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span><br>\tWIN32_EXECUTABLE <span class=\"hljs-keyword\">ON</span><br>\tLINK_WHAT_YOU_USE <span class=\"hljs-keyword\">ON</span><br>\tLIBRARY_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib<br>\tARCHIVE_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib<br>\tRUNTIME_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin<br>)<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"另一种方法通过全局的变量让之后创建的所有对象都享有同样的属性\">另一种方法：通过全局的变量，让之后创建的所有对象都享有同样的属性</h3>\r\n<p>相当于改变了各属性的默认初始值，要注意<em>此时</em>\r\n<code>set(CMAKE_xxx)</code> <em>必须在</em> <code>add_executable</code>\r\n<em>之前才有效</em>。<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">17</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_WIN32_EXECUTABLE <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_LINK_WHAT_YOU_USE <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<br><span class=\"hljs-keyword\">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<br><span class=\"hljs-keyword\">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<br><br>add_executbale(main main.cpp) <span class=\"hljs-comment\"># 这里需要放在后面</span><br></code></pre></td></tr></table></figure></p>\r\n<h3 id=\"百度常见的错误\">百度常见的错误！！！</h3>\r\n<p>对于 <code>CXX_STANDARD</code> 这种 CMake\r\n本身提供了变量进行配置设置的，不要自己去设置 -std=c++17 选项，会和 CMake\r\n自己设置好的产生冲突，导致出错！<br />\r\n请始终使用 <code>CXX_STANDARD</code> 或者全局变量\r\n<code>CMAKE_CXX_STANDARD</code> 来设置 -std=c++17 这个 flag，CMake\r\n会在配置阶段进行编译器检测是否支持 C++17。<br />\r\nCUDA 的 -arch=sm_75 也是同样的道理，请使用\r\n<code>CUDA_ARCHITECTURES</code> 属性。<br />\r\n再者说 -std=c++17 只是 GCC 编译器的选项，也不能进行跨平台适用于 MSVC\r\n编译器啊！！！</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY CXX_STANDARD <span class=\"hljs-number\">17</span>)\t<span class=\"hljs-comment\"># 正确</span><br><span class=\"hljs-keyword\">target_compile_options</span>(main PUBLIC <span class=\"hljs-string\">&quot;-std=c++17&quot;</span>)\t<span class=\"hljs-comment\"># 错误！！！！</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY CUDA_ARCHITECTURES <span class=\"hljs-number\">75</span>)\t<span class=\"hljs-comment\"># 正确</span><br><span class=\"hljs-keyword\">target_compile_options</span>(main PUBLIC <span class=\"hljs-string\">&quot;-arch=sm_75&quot;</span>)\t<span class=\"hljs-comment\"># 错误！！！</span><br></code></pre></td></tr></table></figure>\r\n<h3 id=\"假如在-windows-使用动态链接库需要额外操作\">假如在 Windows\r\n使用动态链接库，需要额外操作</h3>\r\n<p><code>m/mylib.cpp</code></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><span class=\"hljs-comment\">// 需要手动加入这几句，在实现处加入dllexport</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _MSC_VER</span><br>__declspec(dllexport)<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">say_hello</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello, world!\\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p><code>m/mylib.h</code></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span><br><span class=\"hljs-comment\">// 在声明处，加入import</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _MSC_VER</span><br>__declspec(dllimport)<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">say_hello</span><span class=\"hljs-params\">()</span></span>;<br></code></pre></td></tr></table></figure>\r\n<p>根目录下的 <code>CMakeLists.txt</code><br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">add_subdirectory</span>(mylib)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure></p>\r\n<p>子目录<code>m</code>下的<code>CMakeLists.txt</code>,\r\n<code>m/CMakeLists.txt</code><br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp mylib.h)<br></code></pre></td></tr></table></figure></p>\r\n<h4\r\nid=\"常见问题链接了自己的-dll但是运行时会找不到\">常见问题：链接了自己的\r\ndll，但是运行时会找不到</h4>\r\n<ul>\r\n<li>这是因为 dll 和 exe 不在用一个目录，而愚蠢的 Windows\r\n只会在<strong>当前 exe 所在目录查找</strong>，<strong>然后查找\r\n<em>PATH环境变量</em></strong>，找不到就报错。而 dll 在其他目录，因此\r\nWindows 找不到。\r\n<ul>\r\n<li><strong>解决办法1</strong>：把 dll 所在位置加到\r\n<em>PATH环境变量</em> 里，一劳永逸。<br />\r\n</li>\r\n<li><strong>结局办法2</strong>：把这个 dll，以及这个 dll 依赖的其他所有\r\ndll，全部拷贝到和 exe 文件同一目录下。</li>\r\n</ul></li>\r\n</ul>\r\n<h4\r\nid=\"手动拷贝-dll-好麻烦cmake-能不能救一下把-dll-自动生成在-exe-同一目录下\">手动拷贝\r\ndll 好麻烦，CMake 能不能救一下！把 dll 自动生成在 exe 同一目录下</h4>\r\n<ul>\r\n<li>说到底还是因为 CMake 把定义在顶层模块里的 main 放在\r\n<code>build/main.exe</code><br />\r\n而 mylib 因为是定义在 mylib 这个子模块里的，因此被放到了\r\n<code>build/mylib/mylib.dll</code></li>\r\n</ul>\r\n<h5\r\nid=\"解决1设置-mylib-对象的-xx_output_deirectory-系列属性\">解决1：设置\r\nmylib 对象的 xx_OUTPUT_DEIRECTORY 系列属性</h5>\r\n<ul>\r\n<li><p>所以，可以设置 mylib 的这些属性，让 mylib.dll 文件输出到\r\nPROJECT_BINARY_DIR，也就是项目根目录( main 所在的位置 )，这样 main.exe\r\n在运行时就能找到 mylib.dll</p></li>\r\n<li><p>为了侍奉 Windows，要设置全部的 6个属性！很烦！<br />\r\n<code>m/CMakeLists.txt</code></p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp mylib.h)<br><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br></code></pre></td></tr></table></figure>\r\n<p>这样就会输出到项目根目录 build 目录下</p></li>\r\n</ul>\r\n<h5 id=\"而在-linux-系统下就显得简便了\">而在 Linux\r\n系统下就显得简便了</h5>\r\n<ul>\r\n<li>Linux 系统支持 RPATH，CMake 会让生成出来可执行文件的 RPATH\r\n指向他链接了的 .so 文件所在目录，运行时会优先从 RPATH\r\n里找链接库，所以即使不在同目录也能找到。<br />\r\n所以<strong>第三种解决办法</strong>，卸载 Windows 安装 Linux。<br />\r\n</li>\r\n<li>需要手动修改或者查看一个 ELF 文件的 RPATH，可以用 chrpath 或者\r\npathchelf 命令。</li>\r\n</ul>\r\n<h2 id=\"第五章连接第三方库\">第五章：连接第三方库</h2>\r\n<h3 id=\"例子需要使用-tbb-库\">例子：需要使用 tbb 库</h3>\r\n<ul>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC tbb)\t<span class=\"hljs-comment\"># Linux 上直接链接 tbb 是可以的，但是 Windows 可能不行。  </span><br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>main.cpp<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;tbb/parallel_for.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;  <br>\ttbb::<span class=\"hljs-built_in\">parallel_for</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">4</span>,[&amp;](<span class=\"hljs-type\">int</span> i)&#123;  <br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello, %d!\\n&quot;</span>, i);  <br>    &#125;);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>OutPut<br />\r\n&gt;Hello, 0!<br />\r\n&gt;Hello, 1!<br />\r\n&gt;Hello, 2!<br />\r\n&gt;Hello, 3!</p></li>\r\n</ul>\r\n<h4 id=\"直接链接-tbb-的缺点\">直接链接 tbb 的缺点</h4>\r\n<p>Linux 可以直接链接，是因为其有默认的库目录 <code>usr/lib</code>\r\n，但是 Windows 没有一个固定的库安装位置。Linux 因为\r\n<code>usr/lib/</code>, Linux 可以找到\r\n<code>usr/lib/libtbb.so</code><br />\r\n如果这样直接指定 tbb，CMake 会让连接器在系统的库目录里查找 tbb，他会找到\r\n<code>usr/lib/libtbb.so</code>\r\n这个系统自带的，但是对于没有一个固定库安装位置的 Windows\r\n系统并不适用。<br />\r\n此外，他还要求 tbb 的头文件就在 <code>usr/include</code>\r\n这个系统默认的头文件目录，<br />\r\n这样才能 <code>#include &lt;tbb/parallel_for.h</code> 不报错，如果 tbb\r\n的头文件在其他地方<br />\r\n就需要再加一个 <code>target_include_directories</code>\r\n设置额外的头文件查找目录。</p>\r\n<ul>\r\n<li>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC tbb)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h4 id=\"windows-可以直接写出全部的绝对路径十分的硬核\">Windows\r\n可以直接写出全部的绝对路径，十分的硬核</h4>\r\n<p>也可以直接写出全部的路径，这样就能让没有默认系统路径的 Windows\r\n系统找到安装在不知何处的\r\ntbb，不过这样就不能跨平台了，如果其他人安装在不同位置就会发生错误。<br />\r\n<strong>顺便一提，CMake 的路径分隔符始终是<code>/</code>。即使在 Windows\r\n上，也要把所有的 <code>\\</code> 改成\r\n<code>/</code></strong>，这是为了跨平台考量。请放心，CMake 会自动在调用\r\nMSVC时转换成 <code>\\</code> ，可以放心的用 <code>$&#123;x&#125;/bin</code>\r\n来实现和 Python 的 <a\r\nhref=\"https://blog.csdn.net/swan777/article/details/89040802\"><code>os.path.join(x, 'bin')</code></a>\r\n一样的效果。</p>\r\n<ul>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC C:/User/archibate/installed/tbb/tbb.dll)  <br></code></pre></td></tr></table></figure></p>\r\n<blockquote>\r\n<p>大多数操作系统都是 Unix-like，只有 Windows 搞特殊。<br />\r\n<code>cd /d C:\\\\Program\\ Files\\\\(x86\\)\\\\Micsoft\\ Visual\\ Studio\\\\2019\\\\</code><br />\r\n在路径中动不动就放一堆转移符、空格、特殊符号<br />\r\n高情商：Windows 是最适合练习 C 语言转移符使用水平的平台！</p>\r\n</blockquote></li>\r\n</ul>\r\n<h4 id=\"终于find_package\">终于！<code>find_package</code></h4>\r\n<p>更通用的方式：find_package<br />\r\n更好的办法就是使用 CMake 的 <code>find_package</code> 命令。<br />\r\n<code>find_package(TBB REQUIRED)</code> 会查找\r\n<code>/usr/lib/cmake/TBB/TBBConfig.cmake</code>\r\n这个配置文件，根据里面的配置信息创建 <code>TBB::tbb</code> 这个伪对象(\r\n实际它指向真正的 tbb 库文件路径 <code>usr/lib/libtbb.so</code>\r\n)，之后通过 <code>target_link_libraries</code> 链接\r\n<code>TBB::tbb</code> 就可以正常工作。</p>\r\n<ul>\r\n<li>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">add_executbale(main main.cpp)<br><br><span class=\"hljs-keyword\">find_package</span>(TBB REQUIRED)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)\t<span class=\"hljs-comment\"># TBB 包下的 tbb 库  </span><br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h5 id=\"tbbtbb-的秘密自带了一些-public-属性\"><code>TBB::tbb</code>\r\n的秘密：自带了一些 PUBLIC 属性</h5>\r\n<p><code>TBB::tbb</code> 是一个伪对象( imported )，他除了会指向\r\n<code>/usr/lib/libtbb.so</code>，TBBConfig.cmake 还会给 TBB::tbb\r\n添加一些 PUBLIC 属性，用于让链接了他的对象带上一些 flag 之类的。<br />\r\n比如，TBB 安装在 <code>/opt/tbb</code> 目录下，头文件在\r\n<code>/opt/tbb/include</code> 里，那么这时 TBBConfig.cmake 里就会有 :\r\n<code>target_include_directories(TBB::tbb PUBLIC /opt/tbb/include)</code><br />\r\n这样 main 在链接了 TBB::tbb 时也会被“传染”上\r\n<code>/opt/tbb/include</code> 这个目录，无需手动添加。<br />\r\n再比如，TBB::tbb 链接了另一个库 Blosc::blosc，那么这个库也会自动连接到\r\nmain 上，无需调用者手动添加。</p>\r\n<blockquote>\r\n<p>比如 spdlog 的 spdlog-config.cmake 就会定义 SPDLOG_NOT_HEADER_ONLY\r\n这个宏为 PUBLIC 。从而实现直接 #include &lt;spdlog/spdlog.h&gt;\r\n时候时纯头文件，而 find_package(spdlog REQUIRED)\r\n时却变成预编译链接库的版本。( 其实不是 PUBLIC 而是\r\nINTERFACE，因为伪对象没有实体 )</p>\r\n</blockquote>\r\n<h5 id=\"和-find_packagetbb-config-required-有什么区别\">和\r\n<code>find_package(TBB CONFIG REQUIRED)</code> 有什么区别</h5>\r\n<p>其实更好的是通过\r\n<code>find_package(TBB CONFIG REQUIRED)</code>，添加一个 CONFIG\r\n选项。<br />\r\n这样他会优先查找 TBBConfig.cmake ( 系统自动的 ) 而不是 FindTBB.cmake (\r\n项目作者常把他塞在 cmake/ 目录里并添加到 CMAKE_MODULE_PATH\r\n)。这样能保证寻找包的这个 .cmake 脚本是和系统自带的 tbb\r\n版本是适配的，而不是项目作者当年下载的那个版本的 .cmake 脚本。</p>\r\n<ul>\r\n<li>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">find_package</span>(TBB CONFIG REQUIRED)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<p>当然如果坚持要用 find_package(TBB REQUIRED) 也是可以的。<br />\r\n没有 CONFIG 选项：先找 FindTBB.cmake，再找\r\nTBBConfig.cmake，找不到就报错。<br />\r\n有 CONFIG 选项：只会找 TBBConfig.cmake，找不到则报错。<br />\r\n此外有一些老年项目( 比如 OpenVDB ) 只提供 Find 而没有 Config\r\n文件，这时候只能用 find_package(OpenVDB REQUIRED) 而不能带 CONFIG\r\n选项。</p>\r\n<h4\r\nid=\"usrlibcmaketbbtbbconfig.cmake-长什么样\">/usr/lib/cmake/TBB/TBBConfig.cmake\r\n长什么样？</h4>\r\n<p>不论 TBBConfig.cmake 还是\r\nFindTBB.cmake，这个文件通常由库的作者提供，在 Linux 的包管理器安装 tbb\r\n后也会自动安装这个文件。少部分对 CMake 不友好的第三方库，需要自己写\r\nFindXXX.cmake 才能使用。</p>\r\n<ul>\r\n<li>TBBConfig.cmake<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-comment\"># Create imported target TBB::tbb  </span><br><span class=\"hljs-keyword\">add_library</span>(TBB::tbb SHARED IMPORTED)<br><br><span class=\"hljs-keyword\">set_target_properties</span>(TBB::tbb PROPERTIES  <br>\tINTERFACE_COMPILE_DEFINITIONS <span class=\"hljs-string\">&quot;\\$&lt;\\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span>  <br>\tINTERFACE_INCLUDE_DIRECTORIES <span class=\"hljs-string\">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span>  <br>)<br><br><span class=\"hljs-comment\"># Create imported target TBB::tbbmalloc  </span><br><span class=\"hljs-keyword\">add_library</span>(TBB::tbbmalloc SHARED IMPORTED)<br><br>set_target_proerties(TBB::tbbmalloc PROPERTIES  <br>\tINTERFACE_COMPILE_DEFINITIONS <span class=\"hljs-string\">&quot;\\$&lt;\\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span>  <br>\tINTERFACE_INCLUDE_DIRECTORIES <span class=\"hljs-string\">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span>  <br>)<br><br><span class=\"hljs-comment\"># Create imported target TBB::tbbmalloc_proxy  </span><br><span class=\"hljs-keyword\">add_library</span>(TBB::tbbmalloc_proxy SHARED IMPORTED)<br><br><span class=\"hljs-keyword\">set_target_properties</span>(TBB::tbbmalloc_proxy PROPERTIES  <br>\tINTERFACE_COMPILE_DEFINITIONS <span class=\"hljs-string\">&quot;\\$&lt;\\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span>  <br>\tINTERFACE_INCLUDE_DIRECTORIES <span class=\"hljs-string\">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span>  <br>)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h4 id=\"find_packageqt5-required-出错\">find_package(Qt5 REQUIRED)\r\n出错</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(Qt5 REQUIRED)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><strong>ERROR</strong><br />\r\n<img src=\"/imgs/CMake Note/Qt5Error.png\" alt=\"Qt5报错\"><br />\r\n这里是说( 看最后一句 ) Qt5 包至少需要一个组件。<br />\r\nQt5 有很多组件，但是直接 <code>find_package(Qt5 REQUIRED)</code>\r\n他不知道用户需要哪些组件。</li>\r\n</ul>\r\n<h5 id=\"原因qt5-具有多个组件你必须指定你需要哪些组件\">原因：Qt5\r\n具有多个组件，你必须指定你需要哪些组件</h5>\r\n<p>find_package 生成的伪对象 (imported target) 都按照 “包名::组件名”\r\n的格式命名。<br />\r\n可以在 find_package 中通过 <strong>COMPONENTS</strong>\r\n选项，后面跟随一个列表表示需要用的组件。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(Qt5 COMPONENTS Widgets Gui REQUIRED)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)<br></code></pre></td></tr></table></figure>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(TBB COMPONENTS tbb tbbmalloc tbbmalloc_proxy REQUIRED)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb TBB::tbbmalloc TBB::tbbmalloc_proxy)<br></code></pre></td></tr></table></figure>\r\n<h5 id=\"常见错误windows-找不到-qt5\">常见错误：Windows 找不到 Qt5</h5>\r\n<p>因为 Windows 系统安装路径混乱没有固定的 /usr/lib\r\n之类的默认路径能供CMake搜索所以报错了。<br />\r\n<img src=\"/imgs/CMake Note/Qt5CannotFound.png\" alt=\"Qt5找不到\"></p>\r\n<ul>\r\n<li><p>假设 Qt5 安装在 C:.2，去找这个目录<br />\r\nC:.2_64<br />\r\n</p></li>\r\n<li><p>会有一个 Qt5Config.cmake，现在有四种办法可以让CMake找到他</p>\r\n<ul>\r\n<li><p><strong>第一种</strong>：设置 CMAKE_MODULE_PATH\r\n变量，添加一下包含 Qt5Config.cmake 这个文件的目录路径\r\nC:.2_64，当然这里也要把 <code>\\</code> 换成 <code>/</code>，因为 CMake\r\n是倾向 Unix\r\n的构建，<em><del>这是派别和历史问题了</del></em>。这种方法相当于在 CMake\r\n搜索目录里加上这个路径，其他包在搜索遍历时也会遍历过这个路径，后面会有更好的办法。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(CMAKE_MODULE_PATH <span class=\"hljs-variable\">$&#123;CMAKE_MODULE_PATH&#125;</span> C:/Qt/Qt5.<span class=\"hljs-number\">14.2</span>/msvc2019_64/lib/cmake)<br><br><span class=\"hljs-keyword\">find_package</span>(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>**第二种(更好的办法)：设置<包名>_DIR 变量指向 <包名>Config.cmake\r\n所在位置**<br />\r\n设置 Qt5_DIR 这个变量为 C:.2_64 这样只有 Qt5 这个包会去这个目录里搜索\r\nQt5Config.cmake 更有针对性。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(Qt5_Dir C:/Qt/Qt5.<span class=\"hljs-number\">14.2</span>/msvc2019_64/lib/cmake)<br><br><span class=\"hljs-keyword\">find_package</span>(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>第三种(推荐)，直接在命令行通过 <code>-DQt5_DIR=\"xxx\"</code>\r\n指定，这样不用修改 CMakeLists.txt<br />\r\n<code>cmake -B build -DQt5_DIR=\"C:/Qt/Qt5.14.2/msvc2019_64/lib/cmake\"</code><br />\r\n</p></li>\r\n<li><p>第四种，还可以设置环境变量 Qt5_DIR 也是可以的，就是对 Windows\r\n用户比较困难<br />\r\n<code>export Qt5_DIR=\"/opt/Qt5.14.2/lib/cmake\"</code></p></li>\r\n</ul></li>\r\n</ul>\r\n<h3\r\nid=\"不指定-required-找不到时不报错只会设置-tbb_found-为-false\">不指定\r\nREQUIRED 找不到时不报错，只会设置 TBB_FOUND 为 FALSE</h3>\r\n<p><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(TBB)  <br><span class=\"hljs-keyword\">if</span>(TBB_FOUND)  <br>\t<span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;TBB found at:$&#123;TBB_DIR&#125;&quot;</span>)  <br>\t<span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)  <br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC WITH_TBB)  <br><span class=\"hljs-keyword\">else</span>()  <br>\t<span class=\"hljs-keyword\">message</span>(WARNING <span class=\"hljs-string\">&quot;TBB not found! using serial for&quot;</span>)  <br><span class=\"hljs-keyword\">endif</span>()  <br></code></pre></td></tr></table></figure></p>\r\n<p>前面很多例子都在 find_package() 加上 REQUIRED 选项。<br />\r\n如果我们不加 REQUIRED，在找不到对应 package 时不会报错。<br />\r\n这样的设计目的在于，当我们添加一些可选的依赖，如果没有也不会影响程序基本运行，我们找不到可选项，就可以向用户抛出一个警告。<br />\r\n找到了会把 TBB_FOUND 设为 TRUE，TBB_DIR 也会设置为 TBBConfig.cmake\r\n所在目录。<br />\r\n找不到会把 TBB_FOUND 设为 FASLE，TBB_DIR 也会为空。<br />\r\n这里我们在找到 TBB 的 if 里定义一个 WITH_TBB 宏，稍后在 .cpp\r\n里就可以根据这个判断。<br />\r\n如果找不到 TBB 可以 fallback 到保守的实现方式。<br />\r\n<code>-- TBB found at: /usr/lib64/cmake/TBB</code></p>\r\n<h4 id=\"在-c-中判断-with_tbb-宏找不到-tbb-则退化到串行-for-循环\">在 C++\r\n中判断 WITH_TBB 宏，找不到 TBB 则退化到串行 for 循环</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WITH_TBB</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;tbb/parallel_for.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WITH_TBB</span><br>\ttbb::<span class=\"hljs-built_in\">parallel_for</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">4</span>,[&amp;](<span class=\"hljs-type\">int</span> i)&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++)&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello, %d!\\n&quot;</span>,i);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WITH_TBB</span><br>    &#125;);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>    &#125;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"也可以使用-target-判断是否存在-tbbtbb-这个伪对象实现-tbb_found-的效果\">也可以使用\r\nTARGET 判断是否存在 TBB::tbb 这个伪对象，实现 TBB_FOUND 的效果</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(TBB)<br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">TARGET</span> TBB::tbb)<br>\t<span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;TBB found at:$&#123;TBB_DIR&#125;&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC WITH_TBB)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(WARNING <span class=\"hljs-string\">&quot;TBB not found! using serial for&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<p>同时也可以在 if 进行复合语句判断<br />\r\n<code>NOT TARGET TBB::tbb AND TARGET Eigen3::eigen</code><br />\r\n表示找得到 TBB 但是找不到 Eigen3。</p>\r\n<h2 id=\"第六章输出与变量\">第六章：输出与变量</h2>\r\n<h3 id=\"在运行-cmake--b-build-时打印字符串用于调试程序\">在运行 cmake -B\r\nbuild 时，打印字符串用于调试程序</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;Hello World&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Hello world</p>\r\n</blockquote>\r\n<p>message 会把字符串打在命令行。</p>\r\n<h4 id=\"messagestatus-...\">message(STATUS \"...\")</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Hello World&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>-- Hello world</p>\r\n</blockquote>\r\n<p>不带 <code>STATUS</code> 选项，cmake\r\n认为：“哦，你的需求很紧急，你只想调试程序。”，被认为是调试信息。<br />\r\n带上 <code>STATUS</code> 表示是状态信息，告诉用户做了这件事。</p>\r\n<h4 id=\"messagewaring-...-表示警告信息\">message(WARING \"...\")\r\n表示警告信息</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Hello world&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(WARNING <span class=\"hljs-string\">&quot;This is a warning sign&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>CMake Warning at CMakeLists.txt:2 (message):<br />\r\nThis is a warning sign!</p>\r\n</blockquote>\r\n<h4\r\nid=\"messageauthor_warning-...-表示仅仅是给项目作者看的警告\">message(AUTHOR_WARNING\r\n\"...\") 表示仅仅是给项目作者看的警告</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Hello world&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(AUTHOR_WARNING <span class=\"hljs-string\">&quot;Hollow Knight is the best!&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>-- Hello world<br />\r\nCMake Warning (dev) at CMakeLists.txt:2 (message):<br />\r\nHollow Knight is the best!<br />\r\nThis warning is for project developers. Use -Wno-dev suppress it.</p>\r\n</blockquote>\r\n<p><strong>AUTHOR_WARNING 可以通过 -Wno-dev 关闭</strong></p>\r\n<p><code>cmake -B build -Wno-dev</code></p>\r\n<h4\r\nid=\"messagefatal_error-...-表示是错误信息会终止-cmake-的运行\">message(FATAL_ERROR\r\n\"...\") 表示是错误信息，会终止 CMake 的运行</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Hello world&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(FATAL_ERROR <span class=\"hljs-string\">&quot;This is an error message!&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;After Error&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>-- Hello world<br />\r\nCMake Error at CMakeLists.txt:2 (message):<br />\r\nThis is an error message!</p>\r\n</blockquote>\r\n<p>因为程序被中断所以 Hello world 被打印，Error 有执行，但是 After Error\r\n没有执行，因为在 Error message 处被中断运行了。</p>\r\n<h4\r\nid=\"messagesend_error-...-表示错误信息但之后的语句仍继续执行\">message(SEND_ERROR\r\n\"...\") 表示错误信息，但之后的语句仍继续执行</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Hello world&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(SEND_ERROR <span class=\"hljs-string\">&quot;This is an error message!&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;After Error&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>-- Hello world<br />\r\nCMake Error at CMakeLists.txt:2 (message) :<br />\r\nThis is an error message</p>\r\n<p>After Error</p>\r\n</blockquote>\r\n<p>可以看到 After Error 正常运行。</p>\r\n<h3 id=\"message-可以用于打印变量\">message 可以用于打印变量</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar <span class=\"hljs-string\">&quot;Hello world&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>myvar is: Hello world<br />\r\n-- Configuring done<br />\r\n-- Generating done</p>\r\n</blockquote>\r\n<h4 id=\"如果-set-没加引号会怎么样\">如果 set 没加引号会怎么样？</h4>\r\n<p><strong>会变成分号分隔的列表。</strong><br />\r\n这时候 set(myvar Hello world) 等价于 set(myvar \"Hello;world\")</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar Hello world)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>myvar is: Hello;world<br />\r\n-- Configuring done<br />\r\n-- Generating done</p>\r\n</blockquote>\r\n<h4 id=\"如果-message-没加引号会怎么样\">如果 message\r\n没加引号会怎么样？</h4>\r\n<p><strong>会把列表里的字符串当作他的关键字</strong><br />\r\n结论：除非实在实在需要列表，不然建议始终在你不确定的地方加上引号，例如：<br />\r\nset(source \"main.cpp\" \"mylib.cpp\" \"C:/Program Files/a.cpp\")<br />\r\nmessage(\"${source}\")<br />\r\n这里的 <code>C:/Program Files/a.cpp</code>\r\n有空格所以最好使用引号，这也是为什么CMake用 <code>;</code> 做分割，因为\r\n<code></code> 可能出现在路径中，而 <code>;</code>\r\n不会出现在文件路径中。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar FATAL_ERROR hello)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;myvar&#125;</span>)<br><span class=\"hljs-comment\"># 这样$&#123;myvar&#125; 会变成 FATAL_ERROR hello</span><br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>CMake Error at CMakeLists.txt:2 (message) :<br />\r\nhello</p>\r\n</blockquote>\r\n<h2 id=\"第七章变量与缓存最大坑点\">第七章：变量与缓存(最大坑点)</h2>\r\n<h3 id=\"重复执行-cmake--b-build-会有什么区别\">重复执行 cmake -B build\r\n会有什么区别</h3>\r\n<p>假如多次执行后几次执行会比第一次执行输出少很多。<br />\r\n这是因为 CMake 第一遍需要检测编译器和 C++\r\n特性等比较耗时，检测完后会把结果存储的<strong>缓存</strong>中，这样第二遍运行cmake\r\n-B build 时就可以直接使用缓存的值，就不需要在检测一遍了。</p>\r\n<h3 id=\"如何清理缓存删-build-大法\">如何清理缓存？删 build 大法</h3>\r\n<p>虽然 CMake\r\n缓存为了加快编译的出发点是好的，但是有问题。比如有时候外部的情况有所更新比如原来的编译器被卸载或者更改，这时候\r\nCMake 缓存内却还存储的是旧的值，就会导致一些问题。<br />\r\n最简单的解决办法就是删除 build 文件夹，然后重新运行 cmake -B\r\nbuild。<br />\r\n缓存是很多 CMake 出错的根源，因此如果出现诡异的错误，可以先试着删除\r\nbuild 重新构建看看。<br />\r\n删除了缓存就会重新跑一边检测，写新缓存。<br />\r\n所以有了经典的 CMake 笑话：</p>\r\n<blockquote>\r\n<p>99%的 cmake 错误都可以用删 build 解决<br />\r\n删 build 大法好<br />\r\nrm -rf build</p>\r\n</blockquote>\r\n<h3\r\nid=\"清除缓存其实只需删除-buildcmakecache.txt-就可以了\">清除缓存，其实只需删除\r\nbuild/CMakeCache.txt 就可以了</h3>\r\n<p>删除 build 虽然简单粗暴彻底，但是这会导致编译产生的中间结果 (.o文件)\r\n也都被删除了，重新编译需要花费很长时间。<br />\r\n如果只想清除缓存，不想从头重新编译，可以只删除 build/CMakeCache.txt\r\n这个文件。<br />\r\n它存储了缓存的变量，删除它就可以让 CMake\r\n强制重新检测一遍所有的库和编译器。<br />\r\n但是有些错误是中间文件的问题还是要删除 build<br />\r\n### find_package 就用到了缓存机制</p>\r\n<p>变量缓存的意义在于能把 find_package\r\n找到的库文件位置等信息，存储起来。<br />\r\n这下下次 find_package 时就会利用上缓存的变量，直接返回。<br />\r\n避免重复执行 cmake -B 时速度变慢的问题。</p>\r\n<p>但是会有这样一个问题，假如第一次 build，没有 TBB 库<br />\r\n然后我们安装 TBB 后，再次进行build<br />\r\n这时候 CMake 读了缓存发现：“哦，我之前找过 TBB，没找到，那不用找了没有\r\nTBB 库”<br />\r\n这时候 CMake 就不会去找了……<br />\r\n这时候就要 rm -rf build/CMakeCache.txt，删除缓存文件让 CMake\r\n强行重新配置。</p>\r\n<h3 id=\"设置缓存变量\">设置缓存变量</h3>\r\n<p>语法是：<code>set(变量名 \"变量值\" CACHE 变量类型 \"注释\")</code></p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar <span class=\"hljs-string\">&quot;hello&quot;</span> CACHE <span class=\"hljs-keyword\">STRING</span> <span class=\"hljs-string\">&quot;this is the docstring.&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<p><strong>缓存的 myvar 会出现在 build/CMakeCache.txt 里。</strong></p>\r\n<h3\r\nid=\"常见问题我修改了-cmakelists.txt-里-set-的值却没有更新\">常见问题：我修改了\r\nCMakeLists.txt 里 set 的值，却没有更新。</h3>\r\n<p>为了更新缓存变量，经常有人偷懒直接修改 CMakeLists.txt\r\n里的值，这是没用的。<br />\r\n因为 set(...CACHE..)\r\n在缓存变量已经存在的时候，不会去更新缓存的值。<br />\r\nCMakeLists.txt 里 set 的值被认为是“默认值”，因此不会在第二次 set\r\n的时候更新。<br />\r\n比如上面我们设置过 myvar 的内容是 hello，然后 build，现在改成\r\nworld，但是 CMakeCaChe.txt 内的 myvar 还会是 hello</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar <span class=\"hljs-string\">&quot;world&quot;</span> CACHE <span class=\"hljs-keyword\">STRING</span> <span class=\"hljs-string\">&quot;This is the docstring!&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"缓存变量如何更新标准解法通过命令行--d参数\">缓存变量如何更新？标准解法：通过命令行\r\n-D参数</h3>\r\n<p>当然可以使用 ”删 build 大法“，但是有更好的。<br />\r\n更新缓存变量正确的方式，通过命令行参数：<code>cmake -B build -Dmyvar=world</code></p>\r\n<h4 id=\"命令行--d-太硬核了有没有图形化的缓存编译器\">命令行 -D\r\n太硬核了，有没有图形化的缓存编译器？</h4>\r\n<ul>\r\n<li>在 Linux 中，可以运行 ccmake -B build\r\n启动基于终端的可视化缓存编辑菜单。<br />\r\n</li>\r\n<li>在 Windows 中，可以 cmake-gui -B build\r\n来启动图形界面编辑各个缓存选项。<br />\r\n</li>\r\n<li>当然，可以直接用编辑器打开 build/CMakeCaChe.txt 修改后保存。<br />\r\nCMakeCaChe.txt\r\n用文本文件存储的目的就是可供用户手动编辑，或者被第三方软件打开并解析的。</li>\r\n</ul>\r\n<h3 id=\"也可以通过指定-force-来强制-set-更新缓存\">也可以通过指定 FORCE\r\n来强制 set 更新缓存</h3>\r\n<p>set 可以在后面加一个 FORCE\r\n选项，表示无论缓存存在与否，都强制更新缓存。<br />\r\n不过这样就会导致没办法用 -Dmyvar=othervalue 来更新缓存变量。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar <span class=\"hljs-string\">&quot;world&quot;</span> CACHE <span class=\"hljs-keyword\">STRING</span> <span class=\"hljs-string\">&quot;This is the docstring&quot;</span> FORCE)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;mtvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"缓存变量除了-string-还有哪些类型\">缓存变量除了 STRING\r\n还有哪些类型？</h3>\r\n<ul>\r\n<li>STRING 字符串，比如：\"hello\",\"world\"<br />\r\n</li>\r\n<li>FILEPATH\r\n文件路径，例如：\"C:/vcpkg/scripts/buildsystems/vcpkg.cmake\"<br />\r\n</li>\r\n<li>PATH 目录路径，例如：\"C:/Qt/Qt5.14.2/msvc2019_64/cmake/\"<br />\r\n</li>\r\n<li>BOOL 布尔值，只有两个取值：ON 或 OFF<br />\r\n注意：TRUE 和 ON 等价，FALSE 和 OFF 等价；YES 和 ON 等价，NO 和 OFF\r\n等价。</li>\r\n</ul>\r\n<h4 id=\"添加一个-bool-类型变量用于控制是否启用某些特性\">添加一个 BOOL\r\n类型变量，用于控制是否启用某些特性</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">set</span>(WITH_TBB <span class=\"hljs-keyword\">ON</span> CACHR BOOL <span class=\"hljs-string\">&quot;set to ON to enable TBB, OFF to disable TBB.&quot;</span>)<br><br><span class=\"hljs-keyword\">if</span>(WITH_TBB)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC WITH_TBB)<br>\t<span class=\"hljs-keyword\">find_package</span>(TBB REQUIRED)<br>\t<span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<p>这里就是用 CACHE变量 控制是否启用 TBB。</p>\r\n<h4 id=\"cmake-对-bool-类型缓存的-set-提供了简写option\">CMake 对 BOOL\r\n类型缓存的 set 提供了简写：option</h4>\r\n<p><code>option(变量名 \"描述\" 变量值)</code><br />\r\n等价于<br />\r\n<code>set(变量名 CACHE BOOL 变量值 \"描述\")</code></p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">option</span>(WITH_TBB <span class=\"hljs-string\">&quot;set to ON to enable TBB, OFF to disable TBB.&quot;</span>)<br><span class=\"hljs-keyword\">if</span>(WITH_TBB)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC WITH_TBB)<br>\t<span class=\"hljs-keyword\">find_package</span>(TBB REQUIRED)<br>\t<span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<p>option 的本质还是 set CACHE<br />\r\n所以还会有和 set CACHE 一样的问题：option 设置成了 OFF，但是还是\r\nON。</p>\r\n<h4\r\nid=\"常见问题在-cmakelists.txt-里修改了-option-为-off但是运行出来还是-on\">常见问题：在\r\nCMakeLists.txt 里修改了 option 为 OFF，但是运行出来还是 ON</h4>\r\n<p>因为 option 本质就是 set CACHE，<br />\r\n虽然修改了，但是 CMakeCaChe.txt 内还是 ON</p>\r\n<h4 id=\"解决办法还是--d参数-来修改\">解决办法还是 -D参数 来修改</h4>\r\n<p>-D变量名:BOOL=ON/OFF<br />\r\n<code>cmake -B build -DWITH_TBB:BOOL=OFF</code></p>\r\n<h4 id=\"或者改用-set-然后-force\">或者改用 set 然后 Force</h4>\r\n<h4\r\nid=\"绕靠缓存使用普通变量但仅当没有定义时设定为默认值\">绕靠缓存：使用普通变量，但仅当没有定义时设定为默认值</h4>\r\n<p>一般而言，CMake 自带的变量( 如 CMAKE_BUILD_TYPE )都这样设置。<br />\r\n<strong>这样项目的使用者还是可以用 -D来指示参数，</strong>只不过不会在\r\nccmake 里被显示。(ccmake是查询缓存的)</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">DEFINED</span> WITH_TBB)<br>\t<span class=\"hljs-keyword\">set</span>(WITH_TBB <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">endif</span>()<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;WITH_TBB: $&#123;WITH_TBB&#125;&quot;</span>)<br><span class=\"hljs-keyword\">if</span>(WITH_TBB)<br>\ttarget_compile_definition(main PUBLIC WITH_TBB)<br>\t<span class=\"hljs-keyword\">find_package</span>(TBB REQUIRED)<br>\t<span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"第八章跨平台和编译器\">第八章：跨平台和编译器</h2>\r\n<h3 id=\"在cmake-中给-.cpp-定义一个宏\">在CMake 中给 .cpp 定义一个宏</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> MY_MACRO</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;MY_MACRO defined! value: %d\\n&quot;</span>, MY_MACRO);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;MY_MACRO not defined!\\n&quot;</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_MACRO=<span class=\"hljs-number\">233</span>)\t<span class=\"hljs-comment\"># 相当于 gcc -DMY_MACRO=233</span><br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>MY_MACRO defined! value: 233</p>\r\n</blockquote>\r\n<h3\r\nid=\"根据不同的操作系统把宏定义为不同的值\">根据不同的操作系统，把宏定义为不同的值</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> MY_NAME</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello, %s!\\n&quot;</span>, MY_NAME);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;I don`t know your name!\\n&quot;</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(CMAKE_SYSTEM_NAME <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Windows&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Bill Gates&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_SYSTEM_NAME <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Linux&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Linus Torvalds&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_SYSTEM_NAME <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Darwin&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Steve Jobs&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>()<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"cmake-提供了一些简写变量win32-apple-unix-android-ios等等\">CMake\r\n提供了一些简写变量：WIN32, APPLE, UNIX, ANDROID, IOS等等</h3>\r\n<p>虽然是 WIN32 但是对 32位和 64位Windows一样适用<br />\r\nAPPLE 对所有苹果产品 MacOS/IOS 都为真<br />\r\nUNIX 对所有 Unix 类系统( FreeBSD, Linux, Android, MacOS, IOS )\r\n都为真</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(WIN32)\t<span class=\"hljs-comment\"># WIN32 这些是 bool 类型</span><br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Bill Gates&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(UNIX <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">NOT</span> APPLE)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Linus Torvalds&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(APPLE)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Steve Jobs&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>()<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"使用生成器表达式简化指令\">使用生成器表达式，简化指令</h3>\r\n<p>语法：<code>$&lt;$&lt;类型:值&gt;:为真时表达式&gt;</code><br />\r\n比如<code>$&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME=\"Bill Gates\"&gt;</code><br />\r\n在 Windows 平台上还会变成 MY_NAME=\"Bill Gates\"<br />\r\n其他平台则为空字符。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC<br>\t$&lt;$&lt;PLATFROM_ID:Windows&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Bill Gates&quot;</span>&gt;<br>\t$&lt;$&lt;PLATFROM_ID:Linux&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Linus Torvalds&quot;</span>&gt;<br>\t$&lt;$&lt;PLATFROM_ID:Darwin&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Steve Jobs&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"生成器表达式如需多个平台可以用逗号分隔\">生成器表达式：如需多个平台可以用逗号分隔</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC<br>\t$&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME=<span class=\"hljs-string\">&quot;DOS-like&quot;</span>&gt;<br>\t$&lt;$&lt;PLATFROM_ID:Linux,Darwin,FreeBSD&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Unix-like&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure>\r\n<p>相关参考：<a\r\nhref=\"https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#genex:PLATFROM_ID\">CMake\r\n: PLATFROM_ID</a></p>\r\n<h3 id=\"判断当前是哪一款-c-编译器\">判断当前是哪一款 C++ 编译器</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(CMAKE_CXX_COMPILER_ID <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;GNU&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;gcc&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_CXX_COMPILER_ID <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;NVIDIA&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;nvcc&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_CXX_COMPILER_ID <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Clang&quot;</span>)<br>\ttarget_compile_difinitions(mian PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;clang&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_CXX_COMPILER_ID <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;MSVC&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;msvc&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"也同样可以使用生成器表达式\">也同样可以使用生成器表达式</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC<br>\t$&lt;$&lt;CXX_COMPILER_ID:GNU,Clang&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Open-source&quot;</span>&gt;<br>\t$&lt;$&lt;CXX_COMPILER_ID:MSVC,NVIDIA&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Commercial&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"生成器表达式可以做复杂的逻辑判断\">生成器表达式可以做复杂的逻辑判断</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC<br>\t$&lt;$&lt;<span class=\"hljs-keyword\">AND</span>:$&lt;CXX_COMPILER_ID:GNU,Clang&gt;,$&lt;PLATFROM_ID:Linux,FreeBSD&gt;&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Open-source&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"cmake-还提供了一些简写变量msvc-cmake_compiler_is_gnucc\">CMake\r\n还提供了一些简写变量：MSVC, CMAKE_COMPILER_IS_GNUCC</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(MSVC)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;MSVC&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_COMPILER_IS_GNUCC)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;GCC&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Other compiler&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"cmake_cxx_compiler_id-直接作为字符串变量\">CMAKE_CXX_COMPILER_ID\r\n直接作为字符串变量</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;The $&#123;CMAKE_CXX_COMPILER_ID&#125; Compiler&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"从命令行参数指定编译器\">从命令行参数指定编译器</h3>\r\n<p><code>cmake -B build -DCMAKE_CXX_COMPILER=\"/usr/bin/clang++\"</code><br />\r\n当然这个得第一次就定义，如果第二次使用这个命令需要 删build\r\n清除缓存。</p>\r\n<h3 id=\"也可以通过环境变量-cxx-指定\">也可以通过环境变量 CXX 指定</h3>\r\n<p><code>CXX='which clang' cmake -B build</code></p>\r\n<h3 id=\"cmake_generator-也可以了解一下\">CMAKE_GENERATOR\r\n也可以了解一下</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;Generator:$&#123;CMAKE_GENERATOR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;C++ compiler: $&#123;CMAKE_CXX_COMPILER&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;C compiler: $&#123;CMAKE_C_COMPILER&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"第九章分支和判断\">第九章：分支和判断</h2>\r\n<h3 id=\"bool-类型的值\">BOOL 类型的值</h3>\r\n<ul>\r\n<li>通常来讲只有 ON/OFF 两个取值<br />\r\n但是由于历史问题，TRUE/FALSE 和 YES/NO 也可以表示 BOOL 类型<br />\r\n</li>\r\n<li>但是推荐只使用 ON/OFF 避免混淆</li>\r\n</ul>\r\n<h3 id=\"if-的特点不需要加-会自动尝试作为变量名求值\">if 的特点：不需要加\r\n${}, 会自动尝试作为变量名求值</h3>\r\n<p>由于历史问题，if 的括号中有着特殊的语法，如果是一个字符串，比如\r\nMYVAR，则他会先看是否有 ${MYVAR}\r\n这个变量，如果有则被替换为变量的值来进行接下来的比较，否则保持原来的字符串不变。<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR Hello)<br><span class=\"hljs-keyword\">if</span>(MYVAR <span class=\"hljs-keyword\">MATCHES</span> Hello)<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is Hello&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is not hello&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure></p>\r\n<h3 id=\"如果加上-也没区别\">如果加上 ${} 也没区别</h3>\r\n<p><code>if($&#123;MYVAR&#125; MATCHES \"Hello\")</code> 会展开成\r\n<code>if(Hello MACHES \"Hello\")</code><br />\r\n因为没有 Hello 变量所以被视为字符串正常进行匹配。</p>\r\n<h3 id=\"万一定义了-hello-变量那就寄了\">万一定义了 Hello\r\n变量那就寄了</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR Hello)<br><span class=\"hljs-keyword\">set</span>(Hello world)<br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-variable\">$&#123;MYVAR&#125;</span> <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>)<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is Hello!&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is not Hello!&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()\t<br></code></pre></td></tr></table></figure>\r\n<p><code>if($&#123;MYVAR&#125; MATCHES \"Hello\")</code> 变成\r\n<code>if(Hello MATCHES \"Hello\")</code><br />\r\nif 认为用户要使用 Hello 变量，然后就出错了。<br />\r\n这里不要自作聪明加 ${} 就好了。</p>\r\n<h3\r\nid=\"解决用引号包裹防止被当作变量名\">解决：用引号包裹，防止被当作变量名</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR Hello)<br><span class=\"hljs-keyword\">set</span>(Hello world)<br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">&quot;$&#123;MYVAR&#125;&quot;</span> <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>)<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is Hello!&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is not Hello!&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()\t<br></code></pre></td></tr></table></figure>\r\n<p>但是你不觉得麻烦吗？直接变量名就好了。<br />\r\n<strong>另外：CMake 仅仅是指令( set,message 这些\r\n)不分大小写，但变量名什么的是分大小写的！</strong></p>\r\n<h2 id=\"第十章变量和作用域\">第十章：变量和作用域</h2>\r\n<h3 id=\"变量的传递规则父传子\">变量的传递规则：父传子</h3>\r\n<ul>\r\n<li><p>父模块内容会传递给子模块</p></li>\r\n<li><p>CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">ON</span>)  <br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>m/CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is $&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>Output<br />\r\n&gt;MYVAR is ON</p></li>\r\n</ul>\r\n<h3 id=\"变量传递规则子不传父\">变量传递规则：子不传父</h3>\r\n<ul>\r\n<li><p>如果父模块本来就定义同名变量，则离开子模块后仍保持父模块原来设置的值。</p></li>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">OFF</span>)  <br><span class=\"hljs-keyword\">add_subdirectory</span>(mylib)  <br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>m/CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">ON</span>)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>Output</p>\r\n<blockquote>\r\n<p>MYVAR:OFF</p>\r\n</blockquote></li>\r\n</ul>\r\n<h3\r\nid=\"若子模块想向父模块传递变量该怎么办\">若子模块想向父模块传递变量该怎么办？</h3>\r\n<ul>\r\n<li><p>可以使用 set 的 PARENT_SCOPE\r\n选项把一个变量传递到上一层作用域</p></li>\r\n<li><p>CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">OFF</span>)  <br><span class=\"hljs-keyword\">add_subdirectory</span>(mylib)  <br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>m/CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">ON</span> PARENT_SCOPE)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>Output</p>\r\n<blockquote>\r\n<p>MYVAR:ON</p>\r\n</blockquote></li>\r\n<li><p>如果父模块没有定义 MYVAR，也可以使用缓存变量向外传递( 不建议,\r\n这样很不安全\r\n)，但是因为缓存变量是全局的，这样不仅父模块可见，父模块的父模块也可见。</p>\r\n<ul>\r\n<li><p>CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">add_subdirectory</span>(mylib)  <br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>m/CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">ON</span> CACHE BOOL <span class=\"hljs-string\">&quot;&quot;</span> FORCE)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>Output</p>\r\n<blockquote>\r\n<p>MYVAR:ON</p>\r\n</blockquote></li>\r\n</ul></li>\r\n</ul>\r\n<h3\r\nid=\"除了父模块还有哪些是带有独立作用域的\">除了父模块还有哪些是带有独立作用域的</h3>\r\n<ul>\r\n<li>include 的 XXX.cmake <strong>没有</strong>独立作用域<br />\r\n</li>\r\n<li>add_subdirectory 的 CMakeLists.txt 有独立作用域<br />\r\n</li>\r\n<li>macro\r\n<strong>没有</strong>独立作用域，插入执行，变量会暴露出来<br />\r\n</li>\r\n<li>function <strong>有</strong>独立作用域，变量不会暴露出来<br />\r\n</li>\r\n<li>因此 PARENT_SCORE 也可以用于 function 的返回值</li>\r\n</ul>\r\n<h3 id=\"环境变量的访问方式envxx\">环境变量的访问方式：$ENV{xx}</h3>\r\n<ul>\r\n<li><p>用 ${xx}\r\n访问的是局部变量，局部变量服从刚刚说的父子模块传递规则。</p></li>\r\n<li><p>而还有一种特殊的方式可以访问系统的环境变量( enviroment variable )\r\n: $ENV{xx}</p></li>\r\n<li><p>比如 $ENV{PATH} 获取的就是 PATH 这个环境变量的值<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)  <br><span class=\"hljs-keyword\">project</span>(helloCMake)<br><br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PATH:$ENV&#123;PATH&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></p></li>\r\n</ul>\r\n<h3 id=\"缓存变量的访问方式cachexx\">缓存变量的访问方式：$CACHE{xx}</h3>\r\n<ul>\r\n<li><p>还可以用 $CACHE{xx} 访问缓存变量<br />\r\n缓存变量和环境变量都是全局的，没有作用域一说</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)  <br><span class=\"hljs-keyword\">project</span>(helloCMake)<br><br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;CMAKE_BUILD_TYPE:$CACHE&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3 id=\"xx-找不到局部变量时会自动去找缓存变量\">${xx}\r\n找不到局部变量时，会自动去找缓存变量</h3>\r\n<ul>\r\n<li><p>当 ${xx} 在局部变量找不到时，回去查询名为 xx 缓存变量</p></li>\r\n<li><p>所以这里虽然没有定义 CMAKE_BUILD_TYPE，但是 ${}\r\n在缓存变量中找到了<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)  <br>projecr(helloCMake)<br><br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;CMAKE_BUILD_TYPE:$&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)  <br></code></pre></td></tr></table></figure></p></li>\r\n</ul>\r\n<h3 id=\"ifdefined-xx-判断变量是否存在\">if(DEFINED XX)\r\n判断变量是否存在</h3>\r\n<p>if(DEFINED MYVAR) 可以判断是否定义了 MYVAR\r\n变量，判断的是<strong>局部变量</strong>和<strong>缓存变量</strong><br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br>projecr(helloCMake)<br><br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">DEFINED</span> MYVAR)<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR not defined&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure></p>\r\n<p>需要注意的是即便变量是空字符串也是被认为存在的，因为 DEFINED\r\n判断的是<em>是否被定义</em>。</p>\r\n<h3 id=\"ifxx-就可以判断是否存在且不为空\">if(xx)\r\n就可以判断是否存在且不为空</h3>\r\n<p>可以直接用 if(xx) 来判断空字符串，因为空字符串等于 OFF<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br>projecr(helloCMake)<br><br><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-string\">&quot;&quot;</span>)<br><span class=\"hljs-keyword\">if</span>(MYVAR)<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is:$&#123;MYVAR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is empty or not defined&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure></p>\r\n<h3 id=\"ifdefined-envxx-判断环境变量是否存在\">if(DEFINED ENV{xx})\r\n判断环境变量是否存在</h3>\r\n<ul>\r\n<li><p>因为 $ENV{xx} 代表环境变量，因此在 set 和 if 中也可以用 ENV{xx}\r\n来表示环境变量<br />\r\n因为 set 的第一参数和 if 的参数都是不加 $ 的，<br />\r\n所以要设置 ${x} 就变成了 set(x ...);<br />\r\n设置 $ENV{x} 就变成了 set( ENV{x} ...)<br />\r\n同理还可以用 if(DEFINED CACHE{x} ) 判断是否存在 缓存变量x<br />\r\n但是 set( CACHE{x} ...) 不行，别搞错了。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)  <br><span class=\"hljs-keyword\">project</span>(helloCMake)<br><br><span class=\"hljs-keyword\">set</span>(ENV&#123;MYVAR&#125; <span class=\"hljs-string\">&quot;hello&quot;</span>)  <br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">DEFINED</span> ENV&#123;MYVAR&#125;)  <br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR:$ENV&#123;MYVAR&#125;&quot;</span>)  <br><span class=\"hljs-keyword\">else</span>()  <br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is not defined!&quot;</span>)  <br><span class=\"hljs-keyword\">endif</span>()  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3 id=\"第十一章小建议\">第十一章：小建议</h3>\r\n<h3 id=\"ccache编译加速缓存\">CCache：编译加速缓存</h3>\r\n<ul>\r\n<li><p>用法：把 gcc -c main.cpp -o main 换成 ccache gcc -c main.cpp -o\r\nmain 即可<br />\r\n在 CMake 中，可这样来启用 ccache ( 就是给每个编译和链接命令前面加上\r\nccache )</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)  <br><span class=\"hljs-keyword\">project</span>(helloCMake)<br><br><span class=\"hljs-keyword\">find_program</span>(CCACHE_PROGRAM ccache)  <br><span class=\"hljs-keyword\">if</span>(CCACHE_PROGRAM)  <br>\t<span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Found CCache:$&#123;CCACHE_PROGRAM&#125;&quot;</span>)  <br>\t<span class=\"hljs-keyword\">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_COMPILE <span class=\"hljs-variable\">$&#123;CCACHE_PROGRAM&#125;</span>)  <br>\t<span class=\"hljs-keyword\">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_LINK <span class=\"hljs-variable\">$&#123;CCACHE_PROGRAM&#125;</span>)  <br><span class=\"hljs-keyword\">endif</span>()  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>CCache 官网：https://ccache.dev/ ( 不过好像不支持 MSVC )</p></li>\r\n</ul>\r\n<h3 id=\"添加一个-run-伪目标用于启动主程序-可执行文件\">添加一个 run\r\n伪目标，用于启动主程序( 可执行文件 )</h3>\r\n<ul>\r\n<li><p>创建一个 run 伪目标，其执行 main 的可执行文件<br />\r\n这里用了生成器表达式 <code>$&lt;TARGET_FILE:main&gt;</code> 会自动让 run\r\n依赖 main<br />\r\n如果自动依赖失败，可以手动加上 add_dependencies(run main)\r\n也是可以的。</p></li>\r\n<li><p>这样就可以在命令行运行 cmake --build build --target run 来启动\r\nmain.exe 运行了。而不必根据不同的平台，手动写出 build/main 或者\r\nbuild.exe<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">add_custom_target</span>(run <span class=\"hljs-keyword\">COMMAND</span> $&lt;TARGET_FILR:main&gt;)  <br></code></pre></td></tr></table></figure></p></li>\r\n</ul>\r\n<h3 id=\"再加一个-configure-伪目标用于可视化地修改缓存变量\">再加一个\r\nconfigure 伪目标，用于可视化地修改缓存变量</h3>\r\n<ul>\r\n<li><p>这样就可以 cmake --build build --target configure 来启动 ccmake\r\n修改缓存了<br />\r\nLinux 上相当于 ccmake -B build，Windows 则是 cmake-gui -B build</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_custom_target</span>(run <span class=\"hljs-keyword\">COMMAND</span> $&lt;TARGET_FILE:main&gt;)  <br><span class=\"hljs-keyword\">if</span>(CMAKE_EDIT_COMMAND)  <br>\t<span class=\"hljs-keyword\">add_custom_target</span>(configure <span class=\"hljs-keyword\">COMMAND</span> <span class=\"hljs-variable\">$&#123;CMAKE_EDIT_COMMAND&#125;</span> -B <span class=\"hljs-variable\">$&#123;CMAKE_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">endif</span>()  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"文件目录组织规范\"><a\r\nhref=\"https://www.bilibili.com/video/BV1V84y117YU\">文件目录组织规范</a></h2>\r\n<p>基于CMake的项目组织。</p>\r\n<h3 id=\"推荐的目录组织\">推荐的目录组织</h3>\r\n<ul>\r\n<li>project_name/include/project_name/module_name.h<br />\r\n</li>\r\n<li>project_name/src/module_name.cpp</li>\r\n</ul>\r\n<p>将头文件放在include/project_name目录下是防止<strong>不同子项目</strong>或<strong>项目</strong>与<strong>系统头文件</strong>相冲突。</p>\r\n<p><strong>在CMakeLists.txt中</strong>使用</p>\r\n<p><code>target_include_directories(project_name PUBLIC include)</code></p>\r\n<p>指定项目名project_name, PUBLIC导入include文件</p>\r\n<p><strong>源文件中</strong></p>\r\n<ul>\r\n<li>#include<project_name/module_name><br />\r\n</li>\r\n<li>project_name::func();</li>\r\n</ul>\r\n<p><strong>头文件中(project_name/include/project_name/module_name.h)</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span><br><span class=\"hljs-keyword\">namespace</span> project_name&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p><strong>实现文件(projecr_name/src/module_name.cpp)</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;project_name/module.h&gt;</span></span><br><span class=\"hljs-keyword\">namespace</span> project_name&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-type\">int</span> a;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"例子-1\">例子</h4>\r\n<ul>\r\n<li>biology\r\n<ul>\r\n<li>CMakeLists.txt<br />\r\n</li>\r\n<li>include\r\n<ul>\r\n<li>biology\r\n<ul>\r\n<li>Animal.h<br />\r\n</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>src\r\n<ul>\r\n<li>Animal.cpp<br />\r\n</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>CMakeList.txt<br />\r\n</li>\r\n<li>pybmain\r\n<ul>\r\n<li>CMakeLists.txt<br />\r\n</li>\r\n<li>include\r\n<ul>\r\n<li>pybmain\r\n<ul>\r\n<li>myutils.h<br />\r\n</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>src\r\n<ul>\r\n<li>main.cpp</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<p>有点抽象……</p>\r\n<p><img src=\"D:\\Book\\C++\\MyC++Note\\CMake.png\" alt=\"CMake\" style=\"zoom:67%;\" /></p>\r\n<h3 id=\"划分子项目\">划分子项目</h3>\r\n<p>一个大型的项目不可能是仅仅一个项目，往往是要分成多个子项目。</p>\r\n<p>通常分为库文件，可执行文件两个部分，<strong>库文件</strong>主要负责逻辑运算、数据处理诸如此类的<strong>代码逻辑</strong>；<strong>可执行文件</strong>主要是和<strong>用户的交互逻辑</strong>。</p>\r\n<h3 id=\"根项目的-cmakelists.txt-配置\">根项目的 CMakeLists.txt 配置</h3>\r\n<ul>\r\n<li>在根项目的 CMakeLists.txt\r\n中，设置了该项目默认的构建模式，设置了统一的 C++\r\n版本等各种选项。然后通过 <code>project</code> 命令初始化了根项目。<br />\r\n</li>\r\n<li>随后通过 <code>add_subdirectory</code> 把子项目添加进来(\r\n顺序无关紧要 )，这会调用子项目的 CMakeLists.txt 。<br />\r\n比如调用 biology/CMakeLists.txt 和 pybmain/CMakeLists.txt</li>\r\n</ul>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.18</span>)<br><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">NOT</span> CMAKE_BUILD_TYPE)<br>\t<span class=\"hljs-keyword\">set</span>(CMAKE_BUILD_TYPE Release)<br><span class=\"hljs-keyword\">endif</span>()<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">20</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_EXTENSIONS <span class=\"hljs-keyword\">OFF</span>)<br><br><span class=\"hljs-keyword\">project</span>(CppCMakeDemo LANGUAGES CXX)<br><br><span class=\"hljs-keyword\">add_subdirectory</span>(pybmain)<br><span class=\"hljs-keyword\">add_subdirectory</span>(biology)<br></code></pre></td></tr></table></figure>\r\n<h1 id=\"我遇到的实际问题\">我遇到的实际问题</h1>\r\n<h2\r\nid=\"将资源拷贝到build目录供可执行文件读取\">将资源拷贝到Build目录，供可执行文件读取</h2>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_custom_command</span>(<br>\t<span class=\"hljs-keyword\">TARGET</span> main POST_BUILD<br>\t<span class=\"hljs-keyword\">COMMAND</span> <span class=\"hljs-variable\">$&#123;CMAKE_COMMAND&#125;</span> -E copy_directory<br>\t\t\t<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/obj<br>\t\t\t<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/obj<br>)<br></code></pre></td></tr></table></figure>\r\n<p><a\r\nhref=\"https://cmake.org/cmake/help/latest/command/add_custom_command.html?highlight=add_custom_command\">CMake官方：add_custom_command</a><br />\r\n<a\r\nhref=\"https://discourse.cmake.org/t/post-copy-files-to-currently-building-target-directory/6027\">Post\r\ncopy files to currently building target directory.</a>在这个问题中：“For\r\nexample, if I’m building demo1 I want the output dir to be demo1s binary\r\ndir, if I’m building demo2, demo2’s binary dir\r\netc.”有点意思但是我没想到解决思路用<code>$&#123;PROJECT_SOURCE_DIR&#125;</code>和<code>$&#123;PROJECT_BINARY_DIR&#125;</code>不行吗？</p>\r\n","site":{"data":{}},"excerpt":"<p>对 CMake\r\n粗浅的学习，之前看一个up的讲的一般，后来看了小彭老师，的确不错，因为官方文档看起来有点吃力，所以就……<br />\r\n学习过程中把知识点做了一点笔记方便后续复习</p>","more":"<h1 id=\"cmake\">CMake</h1>\r\n<p>本文档为学习笔记，该部分内容来源<a\r\nhref=\"https://www.bilibili.com/video/BV1vR4y1u77h/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0\">b站Up刘贝斯的CMake教学</a>。</p>\r\n<h2 id=\"what-is-cmake\">What is CMake?</h2>\r\n<p>CMake 是一种高级编译配置工具。</p>\r\n<p>当多人使用一种或不同种语言、编译器开发一个项目时，最终需要输出一个<strong>可执行文件</strong>或者<strong>共享库</strong>(dll,\r\nso等等)，此时——CMake就可以帮助到我们，不必用G++或GCC逐个编译我们所写过的代码。<br />\r\n所有操作都是通过编译CMakeLists.txt完成的。<br />\r\n使用CMake来处理大型的C/C++/Java等项目。</p>\r\n<h2 id=\"cmake-安装\">CMake 安装</h2>\r\n<ul>\r\n<li>Linux大多都有安装。<br />\r\n</li>\r\n<li>Windows, 下载网站(https://cmake.org/download/)</li>\r\n</ul>\r\n<h2 id=\"cmake-hello-world\">CMake: Hello World</h2>\r\n<p>1.首先写一个C/C++的hello world</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>2.编写<code>CmakeLists.txt</code></p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">PROJECT</span> (HELLOW)<br><br><span class=\"hljs-keyword\">SET</span>(SRC_LIST main.cpp)<br><br><span class=\"hljs-keyword\">MESSAGE</span>(STATUS <span class=\"hljs-string\">&quot;This is BINARY dir &quot;</span> <span class=\"hljs-variable\">$&#123;HELLO_BINAR_DIR&#125;</span>)<br><br><span class=\"hljs-keyword\">MESSAGE</span>(STATUS <span class=\"hljs-string\">&quot;This is SOURCE dir &quot;</span> <span class=\"hljs-variable\">$&#123;HELLO_SOURCE_DIR&#125;</span>)<br><br><span class=\"hljs-keyword\">ADD_EXECUTABLE</span>&#123;hello $(SRC_LIST)&#125;<br></code></pre></td></tr></table></figure>\r\n<p>3.使用CMake，生成<code>makefile</code>文件</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">cmake .  <br></code></pre></td></tr></table></figure>\r\n<h3 id=\"cmake-hello-world语法介绍\">CMake: Hello World语法介绍</h3>\r\n<h4 id=\"project关键字-简书cmake命令之project\"><code>PROJECT</code>关键字\r\n—— <a\r\nhref=\"https://www.jianshu.com/p/cdd6e56c2422\">简书CMake命令之project</a></h4>\r\n<p>可以用来<strong>指定工程的名字和支持的语言</strong>，默认支持所有语言。<br />\r\nPROJECT (HELLO) 指定了工程的名字——HELLO，并且支持所有语言。</p>\r\n<h1 id=\"cmake教程\"><a\r\nhref=\"https://www.bilibili.com/video/BV16P4y1g7MH\"><strong>CMake教程</strong></a></h1>\r\n<h2 id=\"第一章-添加源文件\">第一章 添加源文件</h2>\r\n<ul>\r\n<li>第一种，添加名为 <em>main</em> 的 <em>executable</em> ，源文件为\r\n<em>main.cpp</em> 。</li>\r\n</ul>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>第二种，先创建 <strong>目标( executable\r\n)</strong>，稍后再添加源文件。</li>\r\n</ul>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC main.cpp)<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"若有多个源文件呢\">若有多个源文件呢？</h3>\r\n<p>逐个添加即可</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC main.cpp other.cpp)<br></code></pre></td></tr></table></figure>\r\n<p>或者使用<strong>变量</strong>来存储</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">set</span>(sources main.cpp other.cpp)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<p>建议把头文件也加上，这样在VS中可以出现在 \"Header Flies\" 一栏</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">set</span>(sources main.cpp other.cpp other.h)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<p>我们还可以使用 <strong>GLOB</strong>\r\n自动查找当前目录下指定拓展名的文件，实现批量添加源文件</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">file</span>(GLOB sources *.cpp *.h)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<p>但是使用 <strong>GLOB</strong>\r\n需要注意，如果我们增添新的源文件时，CMake可能不会更新，所以要启用\r\n<strong>CONFIGURE_DEPENDS</strong> 选项，当添加新文件时，<strong>在\r\nBuild 时进行检测</strong>，自动更新变量</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"源码在子文件夹中\">源码在子文件夹中？</h3>\r\n<h4 id=\"例子\">例子：</h4>\r\n<ul>\r\n<li>mylib\r\n<ul>\r\n<li>other.cpp<br />\r\n</li>\r\n<li>other.h<br />\r\n</li>\r\n</ul></li>\r\n<li>CMakeLists.txt<br />\r\n</li>\r\n<li>main.cpp</li>\r\n</ul>\r\n<p>将<strong>路径名、后缀名全部</strong>写出来</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h mylib/*.cpp mylib/*.h)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<p>然鹅，dark不必，我们可以使用 <strong>aux_source_directory</strong> ,\r\n自动搜集需要的文件后缀名<br />\r\n本例中<code>aux_source_directory(. sources)</code>和<code>aux_source_directory(mylib sources)</code>\r\n表示<strong>当前目录</strong>和 <strong>mylib 目录</strong>\r\n全部加入项目中。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">aux_source_directory</span>(. sources)<br><span class=\"hljs-keyword\">aux_source_directory</span>(mylib sources)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<p>更进一步：<strong>GLOB_RECURES</strong>\r\n能够自动包含所有子文件夹下的文件<br />\r\n但是注意，<strong>GLOB_RECURES</strong> 会把 <strong>build\r\n目录</strong>下的临时 .cpp 文件( 这些临时文件是 CMake 为了测试编译器\r\n)也加进来。<br />\r\n解决办法：一种，可以把源码统一放到 src 目录下。二种，要求使用者不要把\r\nbuild 放到和源码同一个目录里。这两种之间前者好一点。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">file</span>(GLOB_RECURES sources CONFIGURE_DEPENDS *.cpp *.h)<br>target_source(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"第二章-项目配置变量build_type\">第二章\r\n项目配置变量——BUILD_TYPE</h2>\r\n<h3\r\nid=\"cmake_build_type-构建的类型调试模式-or-发布模式\">CMAKE_BUILD_TYPE\r\n构建的类型，调试模式 or 发布模式</h3>\r\n<ul>\r\n<li>CMAKE_BUILD_TYPE 是 CMake 中一个特殊的变量，\r\n用于控制构建类型，他的值可以是：\r\n<ul>\r\n<li>Debug 调试模式，完全不进行优化，生成调试信息，方便调试程序<br />\r\n</li>\r\n<li>Release 发布模式，优化程度最高，性能最佳，但是编译比 Debug 慢<br />\r\n</li>\r\n<li>MinsizeRel 最小体积发布，生成的文件比 Release\r\n更小，不完全优化，减少二进制体积。<br />\r\n</li>\r\n<li>RelWithDebInfo 带调试信息发布，生成的文件比 Release\r\n更大，因为带有调试的符号信息。<br />\r\n</li>\r\n</ul></li>\r\n<li>默认情况下，CMAKE_BUILD_TYPE 为空字符，这时相当于 Debug。</li>\r\n</ul>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">cmake_minimun_required(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellowcmake LANGUAGES CXX)<br><br><span class=\"hljs-keyword\">set</span>(CMAKE_BUILD_TYPE Release)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure>\r\n<p>各种构建模式在编译器选项上的区别</p>\r\n<ul>\r\n<li>在 Release\r\n模式下，追求的是程序最佳的性能表现，在此情况下编译器会对程序做最大的代码优化以达到最快的运行速度。另一方面，由于代码优化后不与源代码一致，此模式下一般会丢失大量的调试信息。</li>\r\n</ul>\r\n<p>在编译器上各种构建类型的体现：</p>\r\n<ul>\r\n<li>Debug : '-O0 -g'<br />\r\n</li>\r\n<li>Release : '-O3 -DNDEBUG'<br />\r\n</li>\r\n<li>MinSizeRel : '-Os -DNDEBUG'<br />\r\n</li>\r\n<li>RelWithDebInfo : '-O2 -g -DNDEBUG'</li>\r\n</ul>\r\n<p>此外，定义 NDEBUG 宏会使 assert 被去除掉。</p>\r\n<p>因为默认情况下是 Debug 导致生成程序的效率很低。<br />\r\n小技巧：设定一个变量的默认值</p>\r\n<p>如何让 CMAKE_BUILD_TYPE 在用户没有指定的情况时为\r\nRelease，指定的时候保持用户的指定的值不变？<br />\r\n即 CMake 默认情况下 CMAKE_BUILD_TYPE 是一个空字符串。<br />\r\n因此可以通过\r\n<code>if( NOT CMAKE_BUILD_TYPE )</code>判断是否为空，空则自动设置为\r\nRelease 模式。<br />\r\n大多数 CMakeLists.txt\r\n开头都会有这样三行，目的是让默认的构建类型为发布模式 (高度优化)\r\n而不是默认的调试模式 (不会优化) 。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>( <span class=\"hljs-keyword\">NOT</span> CMAKE_BUILD_TYPE )<br>\t<span class=\"hljs-keyword\">set</span>(CMAKE_BUILD_TYPE Release)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"project\">Project</h3>\r\n<p>project : 初始化项目信息，并把当前 CMakeLists.txt\r\n所在位置作为根目录</p>\r\n<p>这里初始化名为 hellocmake 的项目；为什么一定需要项目名？<br />\r\n因为对于 MSVC，他会在 build 里生成 hellocmake.sln 作为 IDE\r\n眼中的项目。<br />\r\nCMAKE_CURRENT_SOURCE_DIR 表示<strong>当前源码目录</strong>的位置，例如\r\n~/hellocmake<br />\r\nCMAKE_CURRENT_BINARY_DIR 表示<strong>当前输出目录</strong>的位置，例如\r\n~/hellocmake/build</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">cmake_minumum_required(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellocmake)<br><br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_NAME: $&#123;PROJECT_NAME&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_SOURCE_DIR: $&#123;PROECJR_SOURCE_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_BINARY_DIR: $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;CMAKE_CURRENT_SOURCE_DIR: $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;CMAKE_CURRENT_BINARY_DIR: $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure>\r\n<h4\r\nid=\"和子模块的关系project_x_dir-和-cmake_current_x_dir\">和子模块的关系：PROJECT_X_DIR\r\n和 CMAKE_CURRENT_x_DIR</h4>\r\n<p>PROJECT_SOURCE_DIR 表示最近一次调用 project 的 CMakeLists.txt\r\n所在的源码目录。<br />\r\nCMAKE_CURRENT_SOURCE_DIR 表示当前 CMakeLists.txt 所在的源码目录。<br />\r\nCMAKE_SOURCE_DIR 表示最为外层 CMakeLists.txt 的源码根目录。<br />\r\n利用 PROJECT_SOURCE_DIR 可以实现从子模块直接获取项目最外层的路径。<br />\r\n<strong>不建议使用 CMAKE_SOURCE_DIR ,\r\n那样会让你的项目无法被人作为子模块使用。</strong></p>\r\n<blockquote>\r\n<p>mylib got PORJECT_SOURCE_DIR: /home/bate/Codes/course/11/template</p>\r\n<p>mylib got CMAKE_CURRENT_SOURCE_DIR:\r\n/home/bate/Codes/course/11/template/mylib</p>\r\n</blockquote>\r\n<h4 id=\"其他相关变量\">其他相关变量</h4>\r\n<ul>\r\n<li>PROJECT_SOURCE_DIR : 当前项目源码路径( 存放 main.cpp 的地方)<br />\r\n</li>\r\n<li>PROJECT_BINARY_DIR : 当前项目输出路径 ( 存放 main.exe 的地方 )<br />\r\n</li>\r\n<li>CMAKE_SOURCE_DIR : 根项目源码路径 ( 存放 main.cpp 的地方 )<br />\r\n</li>\r\n<li>CMAKE_BINARY_DIR : 根项目输出路径 ( 存放 main.cpp 的地方 )<br />\r\n</li>\r\n<li>PROJECT_IS_TOP_LEVEL : BOOL 类型，表示当前项目是否是 ( 最顶层的 )\r\n根项目<br />\r\n</li>\r\n<li>PROJECT_NAME : 当前项目名<br />\r\n</li>\r\n<li>CMAKE_PROJECT_NAME : 根项目的项目名<br />\r\n</li>\r\n<li>详见 : <a\r\nhref=\"https://cmake.org/cmake/help/latest/command/project.html\">CMake之Project</a></li>\r\n</ul>\r\n<h4\r\nid=\"子模块也可使用-project-命令将当前目录作为一个独立的子项目\">子模块也可使用\r\nproject 命令，将当前目录作为一个独立的子项目</h4>\r\n<p>这样 PROJECT_SOURCE_DIR 就会是子模块的源码目录而不是外层了。<br />\r\n这时候 CMake\r\n会认为这个子模块是一个独立的项目，会额外做一些初始化。<br />\r\n他的构建目录 PROJECR_BINARY_DIR 也会变成 build/<源码相对路径><br />\r\n这样在 MSVC 上也会看见 build/mylib.vcxproj 的生成</p>\r\n<blockquote>\r\n<p>PORJECT_NAME : hellowcmake</p>\r\n<p>PROJECT_SOURCE_DIR : /home/bate/Codes/course/11/template</p>\r\n<p>PROJECT_BINARY_DIR : /home/bate/Codes/course/11/template/build</p>\r\n<p>CMAKE_CURRENT_SOURCE_DIR : /home/bate/Codes/course/11/template</p>\r\n<p>CMAKE_CURRENT_BINARY_DIR :\r\n/home/bate/Codes/course/11/template/build</p>\r\n<p>mylib got PROJECT_NAME : mylib</p>\r\n<p>mylib got CMAKE_SOURCE_DIR : /home/bate/Codes/course/11/template</p>\r\n<p>mylib got CMAKE_BINARY_DIR :\r\n/home/bate/Codes/course/11/template/build</p>\r\n<p>mylib got PROJECT_SOURCE_DIR :\r\n/home/bate/Codes/course/11/template/mylib</p>\r\n<p>mylib got PROJECT_BINARY_DIR :\r\n/home/bate/Codes/course/11/build/mylib</p>\r\n<p>mylib got CMAKE_CURRENT_SOURCE_DIR :\r\n/home/bate/Codes/course/11/template/mylib</p>\r\n<p>mylib got CMAKE_CURRENT_BINARY_DIR :\r\n/home/bate/Codes/course/11/template/build/mylib</p>\r\n</blockquote>\r\n<h4 id=\"project-的初始化-languages-字段\">project 的初始化 : LANGUAGES\r\n字段</h4>\r\n<ul>\r\n<li>project( 项目名 LANGUAGES 使用的语言列表...)\r\n指定了该项目使用了那种编程语言<br />\r\n目前支持的语言：\r\n<ul>\r\n<li>C : C语言<br />\r\n</li>\r\n<li>CXX : C++<br />\r\n</li>\r\n<li>ASM : 汇编<br />\r\n</li>\r\n<li>Fortran : 老年人的编程语言(雾)，IBM<br />\r\n</li>\r\n<li>CUDA : 英伟达的黑科技 CUDA ( 需要 CMake 3.8 版本 )<br />\r\n</li>\r\n<li>OBJC : 苹果的 Objective-C ( 需要 CMake 3.16 版本 )<br />\r\n</li>\r\n<li>OBJCXX : 苹果的 Objective-C++ ( 需要 CMake 3.16 版本 )<br />\r\n</li>\r\n<li>ISPC : 一种英特尔的自动 SIMD 编程语言 ( 需要 CMake 3.18 版本 )<br />\r\n</li>\r\n</ul></li>\r\n<li>如果不指定 LANGUAGES, 默认为 C 和 CXX。</li>\r\n</ul>\r\n<h5\r\nid=\"常见问题languages-中没有启用-c-语言但却用到了-c-语言\">常见问题：LANGUAGES\r\n中没有启用 C 语言，但却用到了 C 语言</h5>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellocmake LANGUAGES CXX)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.c)<br></code></pre></td></tr></table></figure>\r\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello world from Cmake!\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>这样不行滴哥们，会报错，因为你在 CMakeLists.txt 的设置中没有启用 C\r\n语言。<br />\r\n解决办法：</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSiON <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellocmake LANGUAGES C CXX)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.c)<br></code></pre></td></tr></table></figure>\r\n<p>这次启用了 C 和 C++ 就不会报错力。</p>\r\n<h5\r\nid=\"也可以先设置-languages-none-之后调用-enable_languagecxx\">也可以先设置\r\nLANGUAGES NONE, 之后调用 enable_language(CXX)</h5>\r\n<p>这样可以把 enable_language 放到 if\r\n语句中，从而只有某些选项开启才启用某语言类似的操作。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellocmake LANGUAGES NONE)<br><span class=\"hljs-keyword\">enable_language</span>(CXX)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"设置-c-标准cmake_cxx_standard-变量\">设置 C++\r\n标准：CMAKE_CXX_STANDARD 变量</h4>\r\n<ul>\r\n<li>CMAKE_CXX_STANDARD 是一个整数，表示要用的 C++ 标准。<br />\r\n比如需要 C++17 即设为 17。<br />\r\n</li>\r\n<li>CMAKE_CXX_STANDARD_REQUIRED 是 BOOL 型，可以为 ON / OFF , 默认为\r\nOFF。<br />\r\n表示是否一定要支持指定的 C++ 标准，如果为 OFF 则CMake 检测到编译器不支持\r\nC++17 时不报错，而是将设置调整为 C++14 让开发人员使用；为 ON\r\n时，不支持会报错，具有更好的安全性。<br />\r\n</li>\r\n<li>CMAKE_CXX_EXTENSIONS 是 BOOL 变量，默认为 ON。为 ON 表示启用 GCC\r\n特有的一些拓展功能；OFF 则关闭 GCC 的拓展功能，只使用标准的 C++。<br />\r\n要兼容其他编译器( 如 MSVC )的项目都会将其设为 OFF，以防使用了 GCC\r\n特有的特性。<br />\r\n</li>\r\n<li>注意，最好在 project 命令前设置 CMAKE_CXX_STANDARD\r\n一系列变量，这样一来 CMAKE 可以在 project\r\n函数内对编译器进行一些检测，查看是否能支持对应版本C++的特性。</li>\r\n</ul>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">17</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_EXTENSIONS <span class=\"hljs-keyword\">ON</span>)<br><br><span class=\"hljs-keyword\">project</span>(hellocmake LANGUAGES CXX)<br></code></pre></td></tr></table></figure>\r\n<h5 id=\"常见误区-小彭老师我手动加--stdc17-行不得行\">常见误区 :\r\n小彭老师，我手动加 -std=c++17 行不得行</h5>\r\n<ul>\r\n<li>不要直接修改 CMAKE_CXX_FLAGS 来添加 -std=c++17<br />\r\n使用 CMake 封装好的 CMAKE_CXX_STANDARD<br />\r\n前者为什么不好，GCC 用户一旦手动指定 -std=c++17, 就是使用了 GCC\r\n的特性，而 MSVC 的用户就无法使用了。<br />\r\n而且 CMake 已经自动根据 CMAKE_CXX_STANDARD 的默认值 11 添加了\r\n-std=c++11，之后你再手动添加 -std=c++17 选项就发生了冲突。<br />\r\n所以一定要使用 CMake 已经封装好的 CMAKE_CXX_STANDARD !</li>\r\n</ul>\r\n<h3 id=\"projec-的初始化version-字段\">projec 的初始化：VERSION 字段</h3>\r\n<ul>\r\n<li>project(项目名 VERSION x.y.z) 可以将当前项目的版本号设定为\r\nx.y.z<br />\r\n之后可以使用 PROJECT_VERSION 获取当前项目的版本号<br />\r\n</li>\r\n<li>PROJECT_VERSION_MAJOR 获取 x ( 主版本号 )<br />\r\nPROJECT_VERSION_MINOR 获取 y ( 次版本号 )<br />\r\nPROJECT_VERSION_PATCH 获取 z ( 补丁版本号 )</li>\r\n</ul>\r\n<h4\r\nid=\"项目名的另一个作用-会设置另外-_source_dir-等变量\">项目名的另一个作用\r\n: 会设置另外 <项目名>_SOURCE_DIR 等变量</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(hellocmake VERSION <span class=\"hljs-number\">2.7</span>.<span class=\"hljs-number\">1</span>)<br><br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_NAME: $&#123;PROJECT_NAME&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_VERSION: $&#123;PROJECT_VERSION&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_SOURCE_DIR: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PROJECT_BINARY_DIR: $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;hellocmake_VERSION: $&#123;hellocmake_VERSION&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;hellocmake_SOURCE_DIR: $&#123;hellocmake_SOURCE_DIR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;hellocmake_BINARY_DIR: $&#123;hellocmake_BINARY_DIR&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>PROJECT_NAME: hellocmake<br />\r\nPROJECT_VERSION: 2.7.1<br />\r\nPROJECT_SOURCE_DIR: /home/bate/Codes/course/11/templa<br />\r\nPROJECT_BINARY_DIR: /tmp/build/home/bate/Codes/course/11/templa<br />\r\nhellocmake_VERSION: 2.7.1<br />\r\nhellocmake_SOURCE_DIR: /home/bate/Codes/course/11/templa<br />\r\nhellocmake_BINARY_DIR: /tmp/build/home/bate/Codes/course/11/templa</p>\r\n</blockquote>\r\n<p>这个功能可以让我们在当前项目去查询别的项目的版本号比如在 hellocmake\r\n查询 helloworld 的版本号或者其他信息。</p>\r\n<h4 id=\"小技巧-cmake-的-表达式可以嵌套\">小技巧 : CMake 的 ${}\r\n表达式可以嵌套</h4>\r\n<p>因为 ${PROJECT_NAME} 的值是 hellocmake<br />\r\n所以 <span class=\"math inline\">\\({\\)</span>{PROJECT_NAME}_VERSION}\r\n相当于 ${hellocmake_VERSION} 即 2.7.1<br />\r\n<a href=\"https://blog.csdn.net/fuyajun01/article/details/8891749\">CMake\r\n其他关键字</a></p>\r\n<h4 id=\"一个标准的-cmakelists.txt-模板\">一个标准的 CMakeLists.txt\r\n模板</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">17</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span>)<br><br><span class=\"hljs-keyword\">project</span>(zeno LANGUAGES C CXX)<br><br><span class=\"hljs-keyword\">if</span>(PROJECT_BINARY_DIR <span class=\"hljs-keyword\">STREQUAL</span> PROJECT_SOURCE_DIR)<br>\t<span class=\"hljs-keyword\">message</span>(WARING <span class=\"hljs-string\">&quot;The binary directory of CMake cannot be the same as source directory!&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br><br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">NOT</span> CMAKE_BUILD_TYPE)<br>\t<span class=\"hljs-keyword\">set</span>(CMAKE_BUILD_TYPE Release)<br><span class=\"hljs-keyword\">endif</span>()<br><br><span class=\"hljs-keyword\">if</span>(WIN32)<br>\t<span class=\"hljs-keyword\">add_definitions</span>(-DNOMINMAX -D_USE_MATH_DEFINES)<br><span class=\"hljs-keyword\">endif</span>()<br><br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">NOT</span> MSVC)<br>\t<span class=\"hljs-keyword\">find_program</span>(CCACHE_PROGRAM ccache)<br>\t<span class=\"hljs-keyword\">if</span>(CCACHE_PROGRAM)<br>\t\t<span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Found CCache: $&#123;CCACHE_PROGRAM&#125;&quot;</span>)<br>\t\t<span class=\"hljs-keyword\">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_COMPILE <span class=\"hljs-variable\">$&#123;CCACHE_PROGRAM&#125;</span>)<br>\t\t<span class=\"hljs-keyword\">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_LINK <span class=\"hljs-variable\">$&#123;CCACHE_PROGRAM&#125;</span>)<br>\t<span class=\"hljs-keyword\">endif</span>()<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"第三章链接库文件\">第三章：链接库文件</h2>\r\n<h3 id=\"main.cpp-调用-mylib.cpp-里的-say_hello-函数\">main.cpp 调用\r\nmylib.cpp 里的 say_hello 函数</h3>\r\n<ul>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp mylib.cpp)  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>main.cpp</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;mylib.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>\t<span class=\"hljs-built_in\">say_hello</span>();  <br>&#125;  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>mylib.cpp<br />\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;mylib.h&quot;</span>  </span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">say_hello</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello, mylib!\\n&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li>\r\n</ul>\r\n<h4 id=\"改进mylib-作为静态库\">改进：mylib 作为静态库</h4>\r\n<blockquote>\r\n<p><a\r\nhref=\"https://www.jianshu.com/p/090e1c0310ab\">《静态库和动态库》</a> ,\r\n<a\r\nhref=\"https://blog.csdn.net/weixin_39766005/article/details/122368414\">《CMake\r\n| 编译静态库、动态库和对象库》</a><br />\r\n静态库会在<em>链接时</em>完整的复制到每一个可执行文件，被多次使用时就会造成多分冗余。<br />\r\n动态库在<em>链接时</em>不复制，程序运行时由系统动态加载到内存中，供程序调用，系统仅需加载一次，多个程序公用，节省内存。</p>\r\n</blockquote>\r\n<ul>\r\n<li><p>CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib STATIC mylib.cpp)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h4 id=\"改进mylib-作为一个动态库\">改进：mylib 作为一个动态库</h4>\r\n<ul>\r\n<li>CMakeLists.txt ( 动态库在Windows上有坑 )<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h4 id=\"改进mylib-作为一个对象库\">改进：mylib 作为一个对象库</h4>\r\n<p>对象库类似于静态库，但不生成 .a 文件，只由 CMake\r\n记住该库生成了那些对象文件<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">add_libraty(mylib OBJECT mylib.cpp)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure></p>\r\n<p>对象库是 CMake\r\n自创的，绕开了编译器和操作系统的各种繁琐规则，保证了跨平台统一性。<br />\r\n在自己的项目中，推荐全部使用对象库( OBJECT ) 替代静态库 ( STATIC )\r\n避免跨平台的麻烦。<br />\r\n对象库仅仅作为组织代码的方式，而实际生成的可执行文件只有一个，减轻了部署的困难。</p>\r\n<h4\r\nid=\"静态库的麻烦gcc-编译器会自作聪明将自动剔除没有引用符号的对象\">静态库的麻烦：GCC\r\n编译器会自作聪明，将自动剔除没有引用符号的对象</h4>\r\n<ul>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib STATIC mylib.cpp)  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>mylib.cpp<br />\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span>  </span><br><span class=\"hljs-comment\">// 静态初始化  </span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> unused = <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;My initialized\\n&quot;</span>);\t<span class=\"hljs-comment\">// 会在主函数前被执行  </span><br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>main.cpp<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Main function\\n&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>Output<br />\r\n&gt;main function</p></li>\r\n</ul>\r\n<p>这里就是 GCC 看到没有引用人 mylib ，就会删掉 mylib.o\r\n但是恰恰遇到了静待初始化，GCC 就做错了。</p>\r\n<h4\r\nid=\"对象库就可以绕开编译器的不统一保证不会自动剔除没有用到的对象文件\">对象库就可以绕开编译器的不统一：保证不会自动剔除没有用到的对象文件</h4>\r\n<ul>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib OBJECT mylib.cpp)  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>mylib.cpp</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> unused = <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Mylib Function\\n&quot;</span>);  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>main.cpp<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Main Function\\n&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>Output<br />\r\n&gt;Mylib Function<br />\r\n&gt;Main Function</p></li>\r\n</ul>\r\n<h4 id=\"add_library-无参数时是静态库还是动态库\">add_library\r\n无参数时，是静态库还是动态库</h4>\r\n<p>会根据 BUILD_SHARED_LIBS 这个变量的值决定是动态库还是静态库。<br />\r\nON 则相当于 SHARED, OFF 则相当于 STATIC<br />\r\n如果未指定 BUILD_SHARED_LIBS 变量，则默认为 STATIC。<br />\r\n因此，如果发现一个项目内的 add_library\r\n都是无参的，意味着我们可以使用：<br />\r\n<code>cmake -B build -DBUILD_SHARD_LIBS:BOOL=ON</code><br />\r\n来让他全部生成为动态库，这里涉及到<em>命令行传递变量的规则。</em></p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(BUILD_SHARED_LIBS <span class=\"hljs-keyword\">ON</span>)<br><br><span class=\"hljs-keyword\">add_library</span>(mylib mylib.cpp)<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"小技巧设定一个变量的默认值\">小技巧：设定一个变量的默认值</h4>\r\n<p>要让 BUILD_SHARED_LIBS 默认为 ON，可以用之前类似的思路<br />\r\n如果该变量没有定义，则设为 ON，否则保持用户指定的值不变<br />\r\n这样用户没有指定 BUILD_SHARED_LIBS 时，会默认变成ON。<br />\r\n只有用户指定 BUILD_SHARED_LIBS 为 OFF 即\r\n<code>-DBUILD_SHARED_LIBS:BOOL:OFF</code><br />\r\n才会生成静态库，否则默认生成动态库。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">DEFINED</span> BUILD_SHARED_LIBS)<br>\t<span class=\"hljs-keyword\">set</span>(BUILD_SHARED_LIBS <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h4\r\nid=\"常见坑点动态库无法链接静态库\">常见坑点：动态库无法链接静态库</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(otherlib STATIC otherlib.cpp)<br><br><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure>\r\n<p><code>target_link_libraries(mylib PUBLIC otherlib)</code>试图将静态库<code>otherlib</code>链接到<code>mylib</code>中，发生错误。<em>静态库<code>otherlib</code>误以为用户将其连接到一个可执行文件上</em>，但用户却连接到动态库上。动态库在内存中的地址会变化的，在编译时会指定一个<code>fPIC</code>选项，但是静态库没有<code>fPIC</code>选项，静态库的地址并不想变化，而动态库本身却想改变地址，二者会发生冲突。</p>\r\n<h5 id=\"解决办法\">解决办法：</h5>\r\n<p>1、将<code>otherlib</code>变为对象库</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(otherlib OBJECT otherlib.cpp)<br><br><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br>target_link_libraties(main PUBLIC mylib)<br></code></pre></td></tr></table></figure>\r\n<p>2、让静态库编译也生成位置无关的代码( PIC )，这样才能装在动态库中</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(CMAKE_POSITION_INDEPENDENT_CODE <span class=\"hljs-keyword\">ON</span>)<br><br><span class=\"hljs-keyword\">add_library</span>(otherlib STATIC otherlib.cpp)<br><br><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure>\r\n<p>但是这样处理会导致本来不需要为静态 PIC 的静态库也变成 PIC\r\n了，<strong>所以我们可以只针对一个库，只对他启用位置无关的代码( PIC\r\n)</strong><br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(otherlib STATIC otherib.cpp)<br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> otherlib PROPERTY POSITION_INDEPENDENT_CODE <span class=\"hljs-keyword\">ON</span>)<br><br><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(mylib PUBLIC otherlib)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br>target_link_libraried(main PUBLIC mylib)<br></code></pre></td></tr></table></figure></p>\r\n<p><strong>注意，add_library()\r\n是要指定头文件的，这里偷懒没加，指定头文件后其就会出现在IDE中。</strong></p>\r\n<h2 id=\"第四章-对象的属性\">第四章 : 对象的属性</h2>\r\n<p>前面提到的 <code>POSITION_INDEPENDENT_CODE</code>\r\n就是一个属性。<br />\r\n### 除了 <code>POSITION_INDEPENDENT_CODE</code> 还有哪些属性呢？</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY CXX_STANDARD <span class=\"hljs-number\">17</span>)\t<span class=\"hljs-comment\"># 采用 C++17 标准编译( 默认为11 )</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span>)\t<span class=\"hljs-comment\"># 如果编译器不支持 C++17，则直接报错( 默认为 OFF )</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY WIN32_EXECUTABLE <span class=\"hljs-keyword\">ON</span>)\t<span class=\"hljs-comment\"># 在 Windows 系统中运行时不启动控制台窗口，只有 GUI 界面 (默认 OFF)</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY LINK_WHAT_YOU_USE <span class=\"hljs-keyword\">ON</span>)\t<span class=\"hljs-comment\"># 告诉编译器不要自动剔除没有引用符号的链接库(默认 OFF)</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY LIBRARY_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)\t<span class=\"hljs-comment\"># 设置动态链接库的输出路径(默认 $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY ARCHIVE_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)\t<span class=\"hljs-comment\"># 设置静态链接库的输出路径(默认 $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY RUNTIME_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)\t<span class=\"hljs-comment\"># 设置可执行文件的输出路径(默认 $&#123;CMAKE_BINARY_DIR&#125;)</span><br></code></pre></td></tr></table></figure>\r\n<p>这样一个一个 <code>set_property</code>\r\n好麻烦啊！要是有更简单的写法就好了，于是……</p>\r\n<h3 id=\"另一个方法-set_target_properties-批量设置多个属性\">另一个方法 :\r\n<code>set_target_properties</code> 批量设置多个属性</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">set_target_properties</span>(main PROPERTIES<br>\tCXX_STANDARD <span class=\"hljs-number\">17</span><br>\tCXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span><br>\tWIN32_EXECUTABLE <span class=\"hljs-keyword\">ON</span><br>\tLINK_WHAT_YOU_USE <span class=\"hljs-keyword\">ON</span><br>\tLIBRARY_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib<br>\tARCHIVE_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib<br>\tRUNTIME_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin<br>)<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"另一种方法通过全局的变量让之后创建的所有对象都享有同样的属性\">另一种方法：通过全局的变量，让之后创建的所有对象都享有同样的属性</h3>\r\n<p>相当于改变了各属性的默认初始值，要注意<em>此时</em>\r\n<code>set(CMAKE_xxx)</code> <em>必须在</em> <code>add_executable</code>\r\n<em>之前才有效</em>。<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">17</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_WIN32_EXECUTABLE <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_LINK_WHAT_YOU_USE <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<br><span class=\"hljs-keyword\">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)<br><span class=\"hljs-keyword\">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<br><br>add_executbale(main main.cpp) <span class=\"hljs-comment\"># 这里需要放在后面</span><br></code></pre></td></tr></table></figure></p>\r\n<h3 id=\"百度常见的错误\">百度常见的错误！！！</h3>\r\n<p>对于 <code>CXX_STANDARD</code> 这种 CMake\r\n本身提供了变量进行配置设置的，不要自己去设置 -std=c++17 选项，会和 CMake\r\n自己设置好的产生冲突，导致出错！<br />\r\n请始终使用 <code>CXX_STANDARD</code> 或者全局变量\r\n<code>CMAKE_CXX_STANDARD</code> 来设置 -std=c++17 这个 flag，CMake\r\n会在配置阶段进行编译器检测是否支持 C++17。<br />\r\nCUDA 的 -arch=sm_75 也是同样的道理，请使用\r\n<code>CUDA_ARCHITECTURES</code> 属性。<br />\r\n再者说 -std=c++17 只是 GCC 编译器的选项，也不能进行跨平台适用于 MSVC\r\n编译器啊！！！</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY CXX_STANDARD <span class=\"hljs-number\">17</span>)\t<span class=\"hljs-comment\"># 正确</span><br><span class=\"hljs-keyword\">target_compile_options</span>(main PUBLIC <span class=\"hljs-string\">&quot;-std=c++17&quot;</span>)\t<span class=\"hljs-comment\"># 错误！！！！</span><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> main PROPERTY CUDA_ARCHITECTURES <span class=\"hljs-number\">75</span>)\t<span class=\"hljs-comment\"># 正确</span><br><span class=\"hljs-keyword\">target_compile_options</span>(main PUBLIC <span class=\"hljs-string\">&quot;-arch=sm_75&quot;</span>)\t<span class=\"hljs-comment\"># 错误！！！</span><br></code></pre></td></tr></table></figure>\r\n<h3 id=\"假如在-windows-使用动态链接库需要额外操作\">假如在 Windows\r\n使用动态链接库，需要额外操作</h3>\r\n<p><code>m/mylib.cpp</code></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><span class=\"hljs-comment\">// 需要手动加入这几句，在实现处加入dllexport</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _MSC_VER</span><br>__declspec(dllexport)<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">say_hello</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello, world!\\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p><code>m/mylib.h</code></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span><br><span class=\"hljs-comment\">// 在声明处，加入import</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _MSC_VER</span><br>__declspec(dllimport)<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">say_hello</span><span class=\"hljs-params\">()</span></span>;<br></code></pre></td></tr></table></figure>\r\n<p>根目录下的 <code>CMakeLists.txt</code><br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">add_subdirectory</span>(mylib)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC mylib)<br></code></pre></td></tr></table></figure></p>\r\n<p>子目录<code>m</code>下的<code>CMakeLists.txt</code>,\r\n<code>m/CMakeLists.txt</code><br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp mylib.h)<br></code></pre></td></tr></table></figure></p>\r\n<h4\r\nid=\"常见问题链接了自己的-dll但是运行时会找不到\">常见问题：链接了自己的\r\ndll，但是运行时会找不到</h4>\r\n<ul>\r\n<li>这是因为 dll 和 exe 不在用一个目录，而愚蠢的 Windows\r\n只会在<strong>当前 exe 所在目录查找</strong>，<strong>然后查找\r\n<em>PATH环境变量</em></strong>，找不到就报错。而 dll 在其他目录，因此\r\nWindows 找不到。\r\n<ul>\r\n<li><strong>解决办法1</strong>：把 dll 所在位置加到\r\n<em>PATH环境变量</em> 里，一劳永逸。<br />\r\n</li>\r\n<li><strong>结局办法2</strong>：把这个 dll，以及这个 dll 依赖的其他所有\r\ndll，全部拷贝到和 exe 文件同一目录下。</li>\r\n</ul></li>\r\n</ul>\r\n<h4\r\nid=\"手动拷贝-dll-好麻烦cmake-能不能救一下把-dll-自动生成在-exe-同一目录下\">手动拷贝\r\ndll 好麻烦，CMake 能不能救一下！把 dll 自动生成在 exe 同一目录下</h4>\r\n<ul>\r\n<li>说到底还是因为 CMake 把定义在顶层模块里的 main 放在\r\n<code>build/main.exe</code><br />\r\n而 mylib 因为是定义在 mylib 这个子模块里的，因此被放到了\r\n<code>build/mylib/mylib.dll</code></li>\r\n</ul>\r\n<h5\r\nid=\"解决1设置-mylib-对象的-xx_output_deirectory-系列属性\">解决1：设置\r\nmylib 对象的 xx_OUTPUT_DEIRECTORY 系列属性</h5>\r\n<ul>\r\n<li><p>所以，可以设置 mylib 的这些属性，让 mylib.dll 文件输出到\r\nPROJECT_BINARY_DIR，也就是项目根目录( main 所在的位置 )，这样 main.exe\r\n在运行时就能找到 mylib.dll</p></li>\r\n<li><p>为了侍奉 Windows，要设置全部的 6个属性！很烦！<br />\r\n<code>m/CMakeLists.txt</code></p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_library</span>(mylib SHARED mylib.cpp mylib.h)<br><br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">set_property</span>(<span class=\"hljs-keyword\">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class=\"hljs-variable\">$&#123;PROJECT_BINARY_DIR&#125;</span>)  <br></code></pre></td></tr></table></figure>\r\n<p>这样就会输出到项目根目录 build 目录下</p></li>\r\n</ul>\r\n<h5 id=\"而在-linux-系统下就显得简便了\">而在 Linux\r\n系统下就显得简便了</h5>\r\n<ul>\r\n<li>Linux 系统支持 RPATH，CMake 会让生成出来可执行文件的 RPATH\r\n指向他链接了的 .so 文件所在目录，运行时会优先从 RPATH\r\n里找链接库，所以即使不在同目录也能找到。<br />\r\n所以<strong>第三种解决办法</strong>，卸载 Windows 安装 Linux。<br />\r\n</li>\r\n<li>需要手动修改或者查看一个 ELF 文件的 RPATH，可以用 chrpath 或者\r\npathchelf 命令。</li>\r\n</ul>\r\n<h2 id=\"第五章连接第三方库\">第五章：连接第三方库</h2>\r\n<h3 id=\"例子需要使用-tbb-库\">例子：需要使用 tbb 库</h3>\r\n<ul>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC tbb)\t<span class=\"hljs-comment\"># Linux 上直接链接 tbb 是可以的，但是 Windows 可能不行。  </span><br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>main.cpp<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;tbb/parallel_for.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;  <br>\ttbb::<span class=\"hljs-built_in\">parallel_for</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">4</span>,[&amp;](<span class=\"hljs-type\">int</span> i)&#123;  <br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello, %d!\\n&quot;</span>, i);  <br>    &#125;);  <br>&#125;  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>OutPut<br />\r\n&gt;Hello, 0!<br />\r\n&gt;Hello, 1!<br />\r\n&gt;Hello, 2!<br />\r\n&gt;Hello, 3!</p></li>\r\n</ul>\r\n<h4 id=\"直接链接-tbb-的缺点\">直接链接 tbb 的缺点</h4>\r\n<p>Linux 可以直接链接，是因为其有默认的库目录 <code>usr/lib</code>\r\n，但是 Windows 没有一个固定的库安装位置。Linux 因为\r\n<code>usr/lib/</code>, Linux 可以找到\r\n<code>usr/lib/libtbb.so</code><br />\r\n如果这样直接指定 tbb，CMake 会让连接器在系统的库目录里查找 tbb，他会找到\r\n<code>usr/lib/libtbb.so</code>\r\n这个系统自带的，但是对于没有一个固定库安装位置的 Windows\r\n系统并不适用。<br />\r\n此外，他还要求 tbb 的头文件就在 <code>usr/include</code>\r\n这个系统默认的头文件目录，<br />\r\n这样才能 <code>#include &lt;tbb/parallel_for.h</code> 不报错，如果 tbb\r\n的头文件在其他地方<br />\r\n就需要再加一个 <code>target_include_directories</code>\r\n设置额外的头文件查找目录。</p>\r\n<ul>\r\n<li>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC tbb)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h4 id=\"windows-可以直接写出全部的绝对路径十分的硬核\">Windows\r\n可以直接写出全部的绝对路径，十分的硬核</h4>\r\n<p>也可以直接写出全部的路径，这样就能让没有默认系统路径的 Windows\r\n系统找到安装在不知何处的\r\ntbb，不过这样就不能跨平台了，如果其他人安装在不同位置就会发生错误。<br />\r\n<strong>顺便一提，CMake 的路径分隔符始终是<code>/</code>。即使在 Windows\r\n上，也要把所有的 <code>\\</code> 改成\r\n<code>/</code></strong>，这是为了跨平台考量。请放心，CMake 会自动在调用\r\nMSVC时转换成 <code>\\</code> ，可以放心的用 <code>$&#123;x&#125;/bin</code>\r\n来实现和 Python 的 <a\r\nhref=\"https://blog.csdn.net/swan777/article/details/89040802\"><code>os.path.join(x, 'bin')</code></a>\r\n一样的效果。</p>\r\n<ul>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC C:/User/archibate/installed/tbb/tbb.dll)  <br></code></pre></td></tr></table></figure></p>\r\n<blockquote>\r\n<p>大多数操作系统都是 Unix-like，只有 Windows 搞特殊。<br />\r\n<code>cd /d C:\\\\Program\\ Files\\\\(x86\\)\\\\Micsoft\\ Visual\\ Studio\\\\2019\\\\</code><br />\r\n在路径中动不动就放一堆转移符、空格、特殊符号<br />\r\n高情商：Windows 是最适合练习 C 语言转移符使用水平的平台！</p>\r\n</blockquote></li>\r\n</ul>\r\n<h4 id=\"终于find_package\">终于！<code>find_package</code></h4>\r\n<p>更通用的方式：find_package<br />\r\n更好的办法就是使用 CMake 的 <code>find_package</code> 命令。<br />\r\n<code>find_package(TBB REQUIRED)</code> 会查找\r\n<code>/usr/lib/cmake/TBB/TBBConfig.cmake</code>\r\n这个配置文件，根据里面的配置信息创建 <code>TBB::tbb</code> 这个伪对象(\r\n实际它指向真正的 tbb 库文件路径 <code>usr/lib/libtbb.so</code>\r\n)，之后通过 <code>target_link_libraries</code> 链接\r\n<code>TBB::tbb</code> 就可以正常工作。</p>\r\n<ul>\r\n<li>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">add_executbale(main main.cpp)<br><br><span class=\"hljs-keyword\">find_package</span>(TBB REQUIRED)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)\t<span class=\"hljs-comment\"># TBB 包下的 tbb 库  </span><br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h5 id=\"tbbtbb-的秘密自带了一些-public-属性\"><code>TBB::tbb</code>\r\n的秘密：自带了一些 PUBLIC 属性</h5>\r\n<p><code>TBB::tbb</code> 是一个伪对象( imported )，他除了会指向\r\n<code>/usr/lib/libtbb.so</code>，TBBConfig.cmake 还会给 TBB::tbb\r\n添加一些 PUBLIC 属性，用于让链接了他的对象带上一些 flag 之类的。<br />\r\n比如，TBB 安装在 <code>/opt/tbb</code> 目录下，头文件在\r\n<code>/opt/tbb/include</code> 里，那么这时 TBBConfig.cmake 里就会有 :\r\n<code>target_include_directories(TBB::tbb PUBLIC /opt/tbb/include)</code><br />\r\n这样 main 在链接了 TBB::tbb 时也会被“传染”上\r\n<code>/opt/tbb/include</code> 这个目录，无需手动添加。<br />\r\n再比如，TBB::tbb 链接了另一个库 Blosc::blosc，那么这个库也会自动连接到\r\nmain 上，无需调用者手动添加。</p>\r\n<blockquote>\r\n<p>比如 spdlog 的 spdlog-config.cmake 就会定义 SPDLOG_NOT_HEADER_ONLY\r\n这个宏为 PUBLIC 。从而实现直接 #include &lt;spdlog/spdlog.h&gt;\r\n时候时纯头文件，而 find_package(spdlog REQUIRED)\r\n时却变成预编译链接库的版本。( 其实不是 PUBLIC 而是\r\nINTERFACE，因为伪对象没有实体 )</p>\r\n</blockquote>\r\n<h5 id=\"和-find_packagetbb-config-required-有什么区别\">和\r\n<code>find_package(TBB CONFIG REQUIRED)</code> 有什么区别</h5>\r\n<p>其实更好的是通过\r\n<code>find_package(TBB CONFIG REQUIRED)</code>，添加一个 CONFIG\r\n选项。<br />\r\n这样他会优先查找 TBBConfig.cmake ( 系统自动的 ) 而不是 FindTBB.cmake (\r\n项目作者常把他塞在 cmake/ 目录里并添加到 CMAKE_MODULE_PATH\r\n)。这样能保证寻找包的这个 .cmake 脚本是和系统自带的 tbb\r\n版本是适配的，而不是项目作者当年下载的那个版本的 .cmake 脚本。</p>\r\n<ul>\r\n<li>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">find_package</span>(TBB CONFIG REQUIRED)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<p>当然如果坚持要用 find_package(TBB REQUIRED) 也是可以的。<br />\r\n没有 CONFIG 选项：先找 FindTBB.cmake，再找\r\nTBBConfig.cmake，找不到就报错。<br />\r\n有 CONFIG 选项：只会找 TBBConfig.cmake，找不到则报错。<br />\r\n此外有一些老年项目( 比如 OpenVDB ) 只提供 Find 而没有 Config\r\n文件，这时候只能用 find_package(OpenVDB REQUIRED) 而不能带 CONFIG\r\n选项。</p>\r\n<h4\r\nid=\"usrlibcmaketbbtbbconfig.cmake-长什么样\">/usr/lib/cmake/TBB/TBBConfig.cmake\r\n长什么样？</h4>\r\n<p>不论 TBBConfig.cmake 还是\r\nFindTBB.cmake，这个文件通常由库的作者提供，在 Linux 的包管理器安装 tbb\r\n后也会自动安装这个文件。少部分对 CMake 不友好的第三方库，需要自己写\r\nFindXXX.cmake 才能使用。</p>\r\n<ul>\r\n<li>TBBConfig.cmake<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-comment\"># Create imported target TBB::tbb  </span><br><span class=\"hljs-keyword\">add_library</span>(TBB::tbb SHARED IMPORTED)<br><br><span class=\"hljs-keyword\">set_target_properties</span>(TBB::tbb PROPERTIES  <br>\tINTERFACE_COMPILE_DEFINITIONS <span class=\"hljs-string\">&quot;\\$&lt;\\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span>  <br>\tINTERFACE_INCLUDE_DIRECTORIES <span class=\"hljs-string\">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span>  <br>)<br><br><span class=\"hljs-comment\"># Create imported target TBB::tbbmalloc  </span><br><span class=\"hljs-keyword\">add_library</span>(TBB::tbbmalloc SHARED IMPORTED)<br><br>set_target_proerties(TBB::tbbmalloc PROPERTIES  <br>\tINTERFACE_COMPILE_DEFINITIONS <span class=\"hljs-string\">&quot;\\$&lt;\\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span>  <br>\tINTERFACE_INCLUDE_DIRECTORIES <span class=\"hljs-string\">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span>  <br>)<br><br><span class=\"hljs-comment\"># Create imported target TBB::tbbmalloc_proxy  </span><br><span class=\"hljs-keyword\">add_library</span>(TBB::tbbmalloc_proxy SHARED IMPORTED)<br><br><span class=\"hljs-keyword\">set_target_properties</span>(TBB::tbbmalloc_proxy PROPERTIES  <br>\tINTERFACE_COMPILE_DEFINITIONS <span class=\"hljs-string\">&quot;\\$&lt;\\$&lt;CONFIG:DEBUG&gt;:TBB_USE_DEBUG&gt;&quot;</span>  <br>\tINTERFACE_INCLUDE_DIRECTORIES <span class=\"hljs-string\">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span>  <br>)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h4 id=\"find_packageqt5-required-出错\">find_package(Qt5 REQUIRED)\r\n出错</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(Qt5 REQUIRED)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li><strong>ERROR</strong><br />\r\n<img src=\"/imgs/CMake Note/Qt5Error.png\" alt=\"Qt5报错\"><br />\r\n这里是说( 看最后一句 ) Qt5 包至少需要一个组件。<br />\r\nQt5 有很多组件，但是直接 <code>find_package(Qt5 REQUIRED)</code>\r\n他不知道用户需要哪些组件。</li>\r\n</ul>\r\n<h5 id=\"原因qt5-具有多个组件你必须指定你需要哪些组件\">原因：Qt5\r\n具有多个组件，你必须指定你需要哪些组件</h5>\r\n<p>find_package 生成的伪对象 (imported target) 都按照 “包名::组件名”\r\n的格式命名。<br />\r\n可以在 find_package 中通过 <strong>COMPONENTS</strong>\r\n选项，后面跟随一个列表表示需要用的组件。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(Qt5 COMPONENTS Widgets Gui REQUIRED)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)<br></code></pre></td></tr></table></figure>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(TBB COMPONENTS tbb tbbmalloc tbbmalloc_proxy REQUIRED)<br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb TBB::tbbmalloc TBB::tbbmalloc_proxy)<br></code></pre></td></tr></table></figure>\r\n<h5 id=\"常见错误windows-找不到-qt5\">常见错误：Windows 找不到 Qt5</h5>\r\n<p>因为 Windows 系统安装路径混乱没有固定的 /usr/lib\r\n之类的默认路径能供CMake搜索所以报错了。<br />\r\n<img src=\"/imgs/CMake Note/Qt5CannotFound.png\" alt=\"Qt5找不到\"></p>\r\n<ul>\r\n<li><p>假设 Qt5 安装在 C:.2，去找这个目录<br />\r\nC:.2_64<br />\r\n</p></li>\r\n<li><p>会有一个 Qt5Config.cmake，现在有四种办法可以让CMake找到他</p>\r\n<ul>\r\n<li><p><strong>第一种</strong>：设置 CMAKE_MODULE_PATH\r\n变量，添加一下包含 Qt5Config.cmake 这个文件的目录路径\r\nC:.2_64，当然这里也要把 <code>\\</code> 换成 <code>/</code>，因为 CMake\r\n是倾向 Unix\r\n的构建，<em><del>这是派别和历史问题了</del></em>。这种方法相当于在 CMake\r\n搜索目录里加上这个路径，其他包在搜索遍历时也会遍历过这个路径，后面会有更好的办法。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(CMAKE_MODULE_PATH <span class=\"hljs-variable\">$&#123;CMAKE_MODULE_PATH&#125;</span> C:/Qt/Qt5.<span class=\"hljs-number\">14.2</span>/msvc2019_64/lib/cmake)<br><br><span class=\"hljs-keyword\">find_package</span>(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>**第二种(更好的办法)：设置<包名>_DIR 变量指向 <包名>Config.cmake\r\n所在位置**<br />\r\n设置 Qt5_DIR 这个变量为 C:.2_64 这样只有 Qt5 这个包会去这个目录里搜索\r\nQt5Config.cmake 更有针对性。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(Qt5_Dir C:/Qt/Qt5.<span class=\"hljs-number\">14.2</span>/msvc2019_64/lib/cmake)<br><br><span class=\"hljs-keyword\">find_package</span>(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)  <br><span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>第三种(推荐)，直接在命令行通过 <code>-DQt5_DIR=\"xxx\"</code>\r\n指定，这样不用修改 CMakeLists.txt<br />\r\n<code>cmake -B build -DQt5_DIR=\"C:/Qt/Qt5.14.2/msvc2019_64/lib/cmake\"</code><br />\r\n</p></li>\r\n<li><p>第四种，还可以设置环境变量 Qt5_DIR 也是可以的，就是对 Windows\r\n用户比较困难<br />\r\n<code>export Qt5_DIR=\"/opt/Qt5.14.2/lib/cmake\"</code></p></li>\r\n</ul></li>\r\n</ul>\r\n<h3\r\nid=\"不指定-required-找不到时不报错只会设置-tbb_found-为-false\">不指定\r\nREQUIRED 找不到时不报错，只会设置 TBB_FOUND 为 FALSE</h3>\r\n<p><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(TBB)  <br><span class=\"hljs-keyword\">if</span>(TBB_FOUND)  <br>\t<span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;TBB found at:$&#123;TBB_DIR&#125;&quot;</span>)  <br>\t<span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)  <br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC WITH_TBB)  <br><span class=\"hljs-keyword\">else</span>()  <br>\t<span class=\"hljs-keyword\">message</span>(WARNING <span class=\"hljs-string\">&quot;TBB not found! using serial for&quot;</span>)  <br><span class=\"hljs-keyword\">endif</span>()  <br></code></pre></td></tr></table></figure></p>\r\n<p>前面很多例子都在 find_package() 加上 REQUIRED 选项。<br />\r\n如果我们不加 REQUIRED，在找不到对应 package 时不会报错。<br />\r\n这样的设计目的在于，当我们添加一些可选的依赖，如果没有也不会影响程序基本运行，我们找不到可选项，就可以向用户抛出一个警告。<br />\r\n找到了会把 TBB_FOUND 设为 TRUE，TBB_DIR 也会设置为 TBBConfig.cmake\r\n所在目录。<br />\r\n找不到会把 TBB_FOUND 设为 FASLE，TBB_DIR 也会为空。<br />\r\n这里我们在找到 TBB 的 if 里定义一个 WITH_TBB 宏，稍后在 .cpp\r\n里就可以根据这个判断。<br />\r\n如果找不到 TBB 可以 fallback 到保守的实现方式。<br />\r\n<code>-- TBB found at: /usr/lib64/cmake/TBB</code></p>\r\n<h4 id=\"在-c-中判断-with_tbb-宏找不到-tbb-则退化到串行-for-循环\">在 C++\r\n中判断 WITH_TBB 宏，找不到 TBB 则退化到串行 for 循环</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WITH_TBB</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;tbb/parallel_for.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WITH_TBB</span><br>\ttbb::<span class=\"hljs-built_in\">parallel_for</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">4</span>,[&amp;](<span class=\"hljs-type\">int</span> i)&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++)&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello, %d!\\n&quot;</span>,i);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WITH_TBB</span><br>    &#125;);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>    &#125;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"也可以使用-target-判断是否存在-tbbtbb-这个伪对象实现-tbb_found-的效果\">也可以使用\r\nTARGET 判断是否存在 TBB::tbb 这个伪对象，实现 TBB_FOUND 的效果</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(TBB)<br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">TARGET</span> TBB::tbb)<br>\t<span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;TBB found at:$&#123;TBB_DIR&#125;&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC WITH_TBB)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(WARNING <span class=\"hljs-string\">&quot;TBB not found! using serial for&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<p>同时也可以在 if 进行复合语句判断<br />\r\n<code>NOT TARGET TBB::tbb AND TARGET Eigen3::eigen</code><br />\r\n表示找得到 TBB 但是找不到 Eigen3。</p>\r\n<h2 id=\"第六章输出与变量\">第六章：输出与变量</h2>\r\n<h3 id=\"在运行-cmake--b-build-时打印字符串用于调试程序\">在运行 cmake -B\r\nbuild 时，打印字符串用于调试程序</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;Hello World&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>Hello world</p>\r\n</blockquote>\r\n<p>message 会把字符串打在命令行。</p>\r\n<h4 id=\"messagestatus-...\">message(STATUS \"...\")</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Hello World&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>-- Hello world</p>\r\n</blockquote>\r\n<p>不带 <code>STATUS</code> 选项，cmake\r\n认为：“哦，你的需求很紧急，你只想调试程序。”，被认为是调试信息。<br />\r\n带上 <code>STATUS</code> 表示是状态信息，告诉用户做了这件事。</p>\r\n<h4 id=\"messagewaring-...-表示警告信息\">message(WARING \"...\")\r\n表示警告信息</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Hello world&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(WARNING <span class=\"hljs-string\">&quot;This is a warning sign&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>CMake Warning at CMakeLists.txt:2 (message):<br />\r\nThis is a warning sign!</p>\r\n</blockquote>\r\n<h4\r\nid=\"messageauthor_warning-...-表示仅仅是给项目作者看的警告\">message(AUTHOR_WARNING\r\n\"...\") 表示仅仅是给项目作者看的警告</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Hello world&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(AUTHOR_WARNING <span class=\"hljs-string\">&quot;Hollow Knight is the best!&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>-- Hello world<br />\r\nCMake Warning (dev) at CMakeLists.txt:2 (message):<br />\r\nHollow Knight is the best!<br />\r\nThis warning is for project developers. Use -Wno-dev suppress it.</p>\r\n</blockquote>\r\n<p><strong>AUTHOR_WARNING 可以通过 -Wno-dev 关闭</strong></p>\r\n<p><code>cmake -B build -Wno-dev</code></p>\r\n<h4\r\nid=\"messagefatal_error-...-表示是错误信息会终止-cmake-的运行\">message(FATAL_ERROR\r\n\"...\") 表示是错误信息，会终止 CMake 的运行</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Hello world&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(FATAL_ERROR <span class=\"hljs-string\">&quot;This is an error message!&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;After Error&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>-- Hello world<br />\r\nCMake Error at CMakeLists.txt:2 (message):<br />\r\nThis is an error message!</p>\r\n</blockquote>\r\n<p>因为程序被中断所以 Hello world 被打印，Error 有执行，但是 After Error\r\n没有执行，因为在 Error message 处被中断运行了。</p>\r\n<h4\r\nid=\"messagesend_error-...-表示错误信息但之后的语句仍继续执行\">message(SEND_ERROR\r\n\"...\") 表示错误信息，但之后的语句仍继续执行</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Hello world&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(SEND_ERROR <span class=\"hljs-string\">&quot;This is an error message!&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;After Error&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>-- Hello world<br />\r\nCMake Error at CMakeLists.txt:2 (message) :<br />\r\nThis is an error message</p>\r\n<p>After Error</p>\r\n</blockquote>\r\n<p>可以看到 After Error 正常运行。</p>\r\n<h3 id=\"message-可以用于打印变量\">message 可以用于打印变量</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar <span class=\"hljs-string\">&quot;Hello world&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>myvar is: Hello world<br />\r\n-- Configuring done<br />\r\n-- Generating done</p>\r\n</blockquote>\r\n<h4 id=\"如果-set-没加引号会怎么样\">如果 set 没加引号会怎么样？</h4>\r\n<p><strong>会变成分号分隔的列表。</strong><br />\r\n这时候 set(myvar Hello world) 等价于 set(myvar \"Hello;world\")</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar Hello world)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>myvar is: Hello;world<br />\r\n-- Configuring done<br />\r\n-- Generating done</p>\r\n</blockquote>\r\n<h4 id=\"如果-message-没加引号会怎么样\">如果 message\r\n没加引号会怎么样？</h4>\r\n<p><strong>会把列表里的字符串当作他的关键字</strong><br />\r\n结论：除非实在实在需要列表，不然建议始终在你不确定的地方加上引号，例如：<br />\r\nset(source \"main.cpp\" \"mylib.cpp\" \"C:/Program Files/a.cpp\")<br />\r\nmessage(\"${source}\")<br />\r\n这里的 <code>C:/Program Files/a.cpp</code>\r\n有空格所以最好使用引号，这也是为什么CMake用 <code>;</code> 做分割，因为\r\n<code></code> 可能出现在路径中，而 <code>;</code>\r\n不会出现在文件路径中。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar FATAL_ERROR hello)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-variable\">$&#123;myvar&#125;</span>)<br><span class=\"hljs-comment\"># 这样$&#123;myvar&#125; 会变成 FATAL_ERROR hello</span><br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>CMake Error at CMakeLists.txt:2 (message) :<br />\r\nhello</p>\r\n</blockquote>\r\n<h2 id=\"第七章变量与缓存最大坑点\">第七章：变量与缓存(最大坑点)</h2>\r\n<h3 id=\"重复执行-cmake--b-build-会有什么区别\">重复执行 cmake -B build\r\n会有什么区别</h3>\r\n<p>假如多次执行后几次执行会比第一次执行输出少很多。<br />\r\n这是因为 CMake 第一遍需要检测编译器和 C++\r\n特性等比较耗时，检测完后会把结果存储的<strong>缓存</strong>中，这样第二遍运行cmake\r\n-B build 时就可以直接使用缓存的值，就不需要在检测一遍了。</p>\r\n<h3 id=\"如何清理缓存删-build-大法\">如何清理缓存？删 build 大法</h3>\r\n<p>虽然 CMake\r\n缓存为了加快编译的出发点是好的，但是有问题。比如有时候外部的情况有所更新比如原来的编译器被卸载或者更改，这时候\r\nCMake 缓存内却还存储的是旧的值，就会导致一些问题。<br />\r\n最简单的解决办法就是删除 build 文件夹，然后重新运行 cmake -B\r\nbuild。<br />\r\n缓存是很多 CMake 出错的根源，因此如果出现诡异的错误，可以先试着删除\r\nbuild 重新构建看看。<br />\r\n删除了缓存就会重新跑一边检测，写新缓存。<br />\r\n所以有了经典的 CMake 笑话：</p>\r\n<blockquote>\r\n<p>99%的 cmake 错误都可以用删 build 解决<br />\r\n删 build 大法好<br />\r\nrm -rf build</p>\r\n</blockquote>\r\n<h3\r\nid=\"清除缓存其实只需删除-buildcmakecache.txt-就可以了\">清除缓存，其实只需删除\r\nbuild/CMakeCache.txt 就可以了</h3>\r\n<p>删除 build 虽然简单粗暴彻底，但是这会导致编译产生的中间结果 (.o文件)\r\n也都被删除了，重新编译需要花费很长时间。<br />\r\n如果只想清除缓存，不想从头重新编译，可以只删除 build/CMakeCache.txt\r\n这个文件。<br />\r\n它存储了缓存的变量，删除它就可以让 CMake\r\n强制重新检测一遍所有的库和编译器。<br />\r\n但是有些错误是中间文件的问题还是要删除 build<br />\r\n### find_package 就用到了缓存机制</p>\r\n<p>变量缓存的意义在于能把 find_package\r\n找到的库文件位置等信息，存储起来。<br />\r\n这下下次 find_package 时就会利用上缓存的变量，直接返回。<br />\r\n避免重复执行 cmake -B 时速度变慢的问题。</p>\r\n<p>但是会有这样一个问题，假如第一次 build，没有 TBB 库<br />\r\n然后我们安装 TBB 后，再次进行build<br />\r\n这时候 CMake 读了缓存发现：“哦，我之前找过 TBB，没找到，那不用找了没有\r\nTBB 库”<br />\r\n这时候 CMake 就不会去找了……<br />\r\n这时候就要 rm -rf build/CMakeCache.txt，删除缓存文件让 CMake\r\n强行重新配置。</p>\r\n<h3 id=\"设置缓存变量\">设置缓存变量</h3>\r\n<p>语法是：<code>set(变量名 \"变量值\" CACHE 变量类型 \"注释\")</code></p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar <span class=\"hljs-string\">&quot;hello&quot;</span> CACHE <span class=\"hljs-keyword\">STRING</span> <span class=\"hljs-string\">&quot;this is the docstring.&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<p><strong>缓存的 myvar 会出现在 build/CMakeCache.txt 里。</strong></p>\r\n<h3\r\nid=\"常见问题我修改了-cmakelists.txt-里-set-的值却没有更新\">常见问题：我修改了\r\nCMakeLists.txt 里 set 的值，却没有更新。</h3>\r\n<p>为了更新缓存变量，经常有人偷懒直接修改 CMakeLists.txt\r\n里的值，这是没用的。<br />\r\n因为 set(...CACHE..)\r\n在缓存变量已经存在的时候，不会去更新缓存的值。<br />\r\nCMakeLists.txt 里 set 的值被认为是“默认值”，因此不会在第二次 set\r\n的时候更新。<br />\r\n比如上面我们设置过 myvar 的内容是 hello，然后 build，现在改成\r\nworld，但是 CMakeCaChe.txt 内的 myvar 还会是 hello</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar <span class=\"hljs-string\">&quot;world&quot;</span> CACHE <span class=\"hljs-keyword\">STRING</span> <span class=\"hljs-string\">&quot;This is the docstring!&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"缓存变量如何更新标准解法通过命令行--d参数\">缓存变量如何更新？标准解法：通过命令行\r\n-D参数</h3>\r\n<p>当然可以使用 ”删 build 大法“，但是有更好的。<br />\r\n更新缓存变量正确的方式，通过命令行参数：<code>cmake -B build -Dmyvar=world</code></p>\r\n<h4 id=\"命令行--d-太硬核了有没有图形化的缓存编译器\">命令行 -D\r\n太硬核了，有没有图形化的缓存编译器？</h4>\r\n<ul>\r\n<li>在 Linux 中，可以运行 ccmake -B build\r\n启动基于终端的可视化缓存编辑菜单。<br />\r\n</li>\r\n<li>在 Windows 中，可以 cmake-gui -B build\r\n来启动图形界面编辑各个缓存选项。<br />\r\n</li>\r\n<li>当然，可以直接用编辑器打开 build/CMakeCaChe.txt 修改后保存。<br />\r\nCMakeCaChe.txt\r\n用文本文件存储的目的就是可供用户手动编辑，或者被第三方软件打开并解析的。</li>\r\n</ul>\r\n<h3 id=\"也可以通过指定-force-来强制-set-更新缓存\">也可以通过指定 FORCE\r\n来强制 set 更新缓存</h3>\r\n<p>set 可以在后面加一个 FORCE\r\n选项，表示无论缓存存在与否，都强制更新缓存。<br />\r\n不过这样就会导致没办法用 -Dmyvar=othervalue 来更新缓存变量。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(myvar <span class=\"hljs-string\">&quot;world&quot;</span> CACHE <span class=\"hljs-keyword\">STRING</span> <span class=\"hljs-string\">&quot;This is the docstring&quot;</span> FORCE)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;mtvar is: $&#123;myvar&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"缓存变量除了-string-还有哪些类型\">缓存变量除了 STRING\r\n还有哪些类型？</h3>\r\n<ul>\r\n<li>STRING 字符串，比如：\"hello\",\"world\"<br />\r\n</li>\r\n<li>FILEPATH\r\n文件路径，例如：\"C:/vcpkg/scripts/buildsystems/vcpkg.cmake\"<br />\r\n</li>\r\n<li>PATH 目录路径，例如：\"C:/Qt/Qt5.14.2/msvc2019_64/cmake/\"<br />\r\n</li>\r\n<li>BOOL 布尔值，只有两个取值：ON 或 OFF<br />\r\n注意：TRUE 和 ON 等价，FALSE 和 OFF 等价；YES 和 ON 等价，NO 和 OFF\r\n等价。</li>\r\n</ul>\r\n<h4 id=\"添加一个-bool-类型变量用于控制是否启用某些特性\">添加一个 BOOL\r\n类型变量，用于控制是否启用某些特性</h4>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">set</span>(WITH_TBB <span class=\"hljs-keyword\">ON</span> CACHR BOOL <span class=\"hljs-string\">&quot;set to ON to enable TBB, OFF to disable TBB.&quot;</span>)<br><br><span class=\"hljs-keyword\">if</span>(WITH_TBB)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC WITH_TBB)<br>\t<span class=\"hljs-keyword\">find_package</span>(TBB REQUIRED)<br>\t<span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<p>这里就是用 CACHE变量 控制是否启用 TBB。</p>\r\n<h4 id=\"cmake-对-bool-类型缓存的-set-提供了简写option\">CMake 对 BOOL\r\n类型缓存的 set 提供了简写：option</h4>\r\n<p><code>option(变量名 \"描述\" 变量值)</code><br />\r\n等价于<br />\r\n<code>set(变量名 CACHE BOOL 变量值 \"描述\")</code></p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">option</span>(WITH_TBB <span class=\"hljs-string\">&quot;set to ON to enable TBB, OFF to disable TBB.&quot;</span>)<br><span class=\"hljs-keyword\">if</span>(WITH_TBB)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC WITH_TBB)<br>\t<span class=\"hljs-keyword\">find_package</span>(TBB REQUIRED)<br>\t<span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<p>option 的本质还是 set CACHE<br />\r\n所以还会有和 set CACHE 一样的问题：option 设置成了 OFF，但是还是\r\nON。</p>\r\n<h4\r\nid=\"常见问题在-cmakelists.txt-里修改了-option-为-off但是运行出来还是-on\">常见问题：在\r\nCMakeLists.txt 里修改了 option 为 OFF，但是运行出来还是 ON</h4>\r\n<p>因为 option 本质就是 set CACHE，<br />\r\n虽然修改了，但是 CMakeCaChe.txt 内还是 ON</p>\r\n<h4 id=\"解决办法还是--d参数-来修改\">解决办法还是 -D参数 来修改</h4>\r\n<p>-D变量名:BOOL=ON/OFF<br />\r\n<code>cmake -B build -DWITH_TBB:BOOL=OFF</code></p>\r\n<h4 id=\"或者改用-set-然后-force\">或者改用 set 然后 Force</h4>\r\n<h4\r\nid=\"绕靠缓存使用普通变量但仅当没有定义时设定为默认值\">绕靠缓存：使用普通变量，但仅当没有定义时设定为默认值</h4>\r\n<p>一般而言，CMake 自带的变量( 如 CMAKE_BUILD_TYPE )都这样设置。<br />\r\n<strong>这样项目的使用者还是可以用 -D来指示参数，</strong>只不过不会在\r\nccmake 里被显示。(ccmake是查询缓存的)</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">DEFINED</span> WITH_TBB)<br>\t<span class=\"hljs-keyword\">set</span>(WITH_TBB <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">endif</span>()<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;WITH_TBB: $&#123;WITH_TBB&#125;&quot;</span>)<br><span class=\"hljs-keyword\">if</span>(WITH_TBB)<br>\ttarget_compile_definition(main PUBLIC WITH_TBB)<br>\t<span class=\"hljs-keyword\">find_package</span>(TBB REQUIRED)<br>\t<span class=\"hljs-keyword\">target_link_libraries</span>(main PUBLIC TBB::tbb)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"第八章跨平台和编译器\">第八章：跨平台和编译器</h2>\r\n<h3 id=\"在cmake-中给-.cpp-定义一个宏\">在CMake 中给 .cpp 定义一个宏</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> MY_MACRO</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;MY_MACRO defined! value: %d\\n&quot;</span>, MY_MACRO);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;MY_MACRO not defined!\\n&quot;</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main)<br><span class=\"hljs-keyword\">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)<br><span class=\"hljs-keyword\">target_sources</span>(main PUBLIC <span class=\"hljs-variable\">$&#123;sources&#125;</span>)<br><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_MACRO=<span class=\"hljs-number\">233</span>)\t<span class=\"hljs-comment\"># 相当于 gcc -DMY_MACRO=233</span><br></code></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>MY_MACRO defined! value: 233</p>\r\n</blockquote>\r\n<h3\r\nid=\"根据不同的操作系统把宏定义为不同的值\">根据不同的操作系统，把宏定义为不同的值</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> MY_NAME</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Hello, %s!\\n&quot;</span>, MY_NAME);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;I don`t know your name!\\n&quot;</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(CMAKE_SYSTEM_NAME <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Windows&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Bill Gates&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_SYSTEM_NAME <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Linux&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Linus Torvalds&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_SYSTEM_NAME <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Darwin&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Steve Jobs&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>()<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"cmake-提供了一些简写变量win32-apple-unix-android-ios等等\">CMake\r\n提供了一些简写变量：WIN32, APPLE, UNIX, ANDROID, IOS等等</h3>\r\n<p>虽然是 WIN32 但是对 32位和 64位Windows一样适用<br />\r\nAPPLE 对所有苹果产品 MacOS/IOS 都为真<br />\r\nUNIX 对所有 Unix 类系统( FreeBSD, Linux, Android, MacOS, IOS )\r\n都为真</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(WIN32)\t<span class=\"hljs-comment\"># WIN32 这些是 bool 类型</span><br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Bill Gates&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(UNIX <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">NOT</span> APPLE)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Linus Torvalds&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(APPLE)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Steve Jobs&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>()<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"使用生成器表达式简化指令\">使用生成器表达式，简化指令</h3>\r\n<p>语法：<code>$&lt;$&lt;类型:值&gt;:为真时表达式&gt;</code><br />\r\n比如<code>$&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME=\"Bill Gates\"&gt;</code><br />\r\n在 Windows 平台上还会变成 MY_NAME=\"Bill Gates\"<br />\r\n其他平台则为空字符。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC<br>\t$&lt;$&lt;PLATFROM_ID:Windows&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Bill Gates&quot;</span>&gt;<br>\t$&lt;$&lt;PLATFROM_ID:Linux&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Linus Torvalds&quot;</span>&gt;<br>\t$&lt;$&lt;PLATFROM_ID:Darwin&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Steve Jobs&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"生成器表达式如需多个平台可以用逗号分隔\">生成器表达式：如需多个平台可以用逗号分隔</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC<br>\t$&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME=<span class=\"hljs-string\">&quot;DOS-like&quot;</span>&gt;<br>\t$&lt;$&lt;PLATFROM_ID:Linux,Darwin,FreeBSD&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Unix-like&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure>\r\n<p>相关参考：<a\r\nhref=\"https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#genex:PLATFROM_ID\">CMake\r\n: PLATFROM_ID</a></p>\r\n<h3 id=\"判断当前是哪一款-c-编译器\">判断当前是哪一款 C++ 编译器</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(CMAKE_CXX_COMPILER_ID <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;GNU&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;gcc&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_CXX_COMPILER_ID <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;NVIDIA&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;nvcc&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_CXX_COMPILER_ID <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Clang&quot;</span>)<br>\ttarget_compile_difinitions(mian PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;clang&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_CXX_COMPILER_ID <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;MSVC&quot;</span>)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;msvc&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"也同样可以使用生成器表达式\">也同样可以使用生成器表达式</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC<br>\t$&lt;$&lt;CXX_COMPILER_ID:GNU,Clang&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Open-source&quot;</span>&gt;<br>\t$&lt;$&lt;CXX_COMPILER_ID:MSVC,NVIDIA&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Commercial&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"生成器表达式可以做复杂的逻辑判断\">生成器表达式可以做复杂的逻辑判断</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC<br>\t$&lt;$&lt;<span class=\"hljs-keyword\">AND</span>:$&lt;CXX_COMPILER_ID:GNU,Clang&gt;,$&lt;PLATFROM_ID:Linux,FreeBSD&gt;&gt;:MY_NAME=<span class=\"hljs-string\">&quot;Open-source&quot;</span>&gt;<br>)<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"cmake-还提供了一些简写变量msvc-cmake_compiler_is_gnucc\">CMake\r\n还提供了一些简写变量：MSVC, CMAKE_COMPILER_IS_GNUCC</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">if</span>(MSVC)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;MSVC&quot;</span>)<br><span class=\"hljs-keyword\">elseif</span>(CMAKE_COMPILER_IS_GNUCC)<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;GCC&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;Other compiler&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"cmake_cxx_compiler_id-直接作为字符串变量\">CMAKE_CXX_COMPILER_ID\r\n直接作为字符串变量</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class=\"hljs-string\">&quot;The $&#123;CMAKE_CXX_COMPILER_ID&#125; Compiler&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"从命令行参数指定编译器\">从命令行参数指定编译器</h3>\r\n<p><code>cmake -B build -DCMAKE_CXX_COMPILER=\"/usr/bin/clang++\"</code><br />\r\n当然这个得第一次就定义，如果第二次使用这个命令需要 删build\r\n清除缓存。</p>\r\n<h3 id=\"也可以通过环境变量-cxx-指定\">也可以通过环境变量 CXX 指定</h3>\r\n<p><code>CXX='which clang' cmake -B build</code></p>\r\n<h3 id=\"cmake_generator-也可以了解一下\">CMAKE_GENERATOR\r\n也可以了解一下</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;Generator:$&#123;CMAKE_GENERATOR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;C++ compiler: $&#123;CMAKE_CXX_COMPILER&#125;&quot;</span>)<br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;C compiler: $&#123;CMAKE_C_COMPILER&#125;&quot;</span>)<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"第九章分支和判断\">第九章：分支和判断</h2>\r\n<h3 id=\"bool-类型的值\">BOOL 类型的值</h3>\r\n<ul>\r\n<li>通常来讲只有 ON/OFF 两个取值<br />\r\n但是由于历史问题，TRUE/FALSE 和 YES/NO 也可以表示 BOOL 类型<br />\r\n</li>\r\n<li>但是推荐只使用 ON/OFF 避免混淆</li>\r\n</ul>\r\n<h3 id=\"if-的特点不需要加-会自动尝试作为变量名求值\">if 的特点：不需要加\r\n${}, 会自动尝试作为变量名求值</h3>\r\n<p>由于历史问题，if 的括号中有着特殊的语法，如果是一个字符串，比如\r\nMYVAR，则他会先看是否有 ${MYVAR}\r\n这个变量，如果有则被替换为变量的值来进行接下来的比较，否则保持原来的字符串不变。<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR Hello)<br><span class=\"hljs-keyword\">if</span>(MYVAR <span class=\"hljs-keyword\">MATCHES</span> Hello)<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is Hello&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is not hello&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure></p>\r\n<h3 id=\"如果加上-也没区别\">如果加上 ${} 也没区别</h3>\r\n<p><code>if($&#123;MYVAR&#125; MATCHES \"Hello\")</code> 会展开成\r\n<code>if(Hello MACHES \"Hello\")</code><br />\r\n因为没有 Hello 变量所以被视为字符串正常进行匹配。</p>\r\n<h3 id=\"万一定义了-hello-变量那就寄了\">万一定义了 Hello\r\n变量那就寄了</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR Hello)<br><span class=\"hljs-keyword\">set</span>(Hello world)<br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-variable\">$&#123;MYVAR&#125;</span> <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>)<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is Hello!&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is not Hello!&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()\t<br></code></pre></td></tr></table></figure>\r\n<p><code>if($&#123;MYVAR&#125; MATCHES \"Hello\")</code> 变成\r\n<code>if(Hello MATCHES \"Hello\")</code><br />\r\nif 认为用户要使用 Hello 变量，然后就出错了。<br />\r\n这里不要自作聪明加 ${} 就好了。</p>\r\n<h3\r\nid=\"解决用引号包裹防止被当作变量名\">解决：用引号包裹，防止被当作变量名</h3>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR Hello)<br><span class=\"hljs-keyword\">set</span>(Hello world)<br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">&quot;$&#123;MYVAR&#125;&quot;</span> <span class=\"hljs-keyword\">MATCHES</span> <span class=\"hljs-string\">&quot;Hello&quot;</span>)<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is Hello!&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is not Hello!&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()\t<br></code></pre></td></tr></table></figure>\r\n<p>但是你不觉得麻烦吗？直接变量名就好了。<br />\r\n<strong>另外：CMake 仅仅是指令( set,message 这些\r\n)不分大小写，但变量名什么的是分大小写的！</strong></p>\r\n<h2 id=\"第十章变量和作用域\">第十章：变量和作用域</h2>\r\n<h3 id=\"变量的传递规则父传子\">变量的传递规则：父传子</h3>\r\n<ul>\r\n<li><p>父模块内容会传递给子模块</p></li>\r\n<li><p>CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">ON</span>)  <br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>m/CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is $&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>Output<br />\r\n&gt;MYVAR is ON</p></li>\r\n</ul>\r\n<h3 id=\"变量传递规则子不传父\">变量传递规则：子不传父</h3>\r\n<ul>\r\n<li><p>如果父模块本来就定义同名变量，则离开子模块后仍保持父模块原来设置的值。</p></li>\r\n<li><p>CMakeLists.txt<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">OFF</span>)  <br><span class=\"hljs-keyword\">add_subdirectory</span>(mylib)  <br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>m/CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">ON</span>)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>Output</p>\r\n<blockquote>\r\n<p>MYVAR:OFF</p>\r\n</blockquote></li>\r\n</ul>\r\n<h3\r\nid=\"若子模块想向父模块传递变量该怎么办\">若子模块想向父模块传递变量该怎么办？</h3>\r\n<ul>\r\n<li><p>可以使用 set 的 PARENT_SCOPE\r\n选项把一个变量传递到上一层作用域</p></li>\r\n<li><p>CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">OFF</span>)  <br><span class=\"hljs-keyword\">add_subdirectory</span>(mylib)  <br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>m/CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">ON</span> PARENT_SCOPE)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>Output</p>\r\n<blockquote>\r\n<p>MYVAR:ON</p>\r\n</blockquote></li>\r\n<li><p>如果父模块没有定义 MYVAR，也可以使用缓存变量向外传递( 不建议,\r\n这样很不安全\r\n)，但是因为缓存变量是全局的，这样不仅父模块可见，父模块的父模块也可见。</p>\r\n<ul>\r\n<li><p>CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><br><span class=\"hljs-keyword\">add_subdirectory</span>(mylib)  <br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>m/CMakeLists.txt</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-keyword\">ON</span> CACHE BOOL <span class=\"hljs-string\">&quot;&quot;</span> FORCE)  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>Output</p>\r\n<blockquote>\r\n<p>MYVAR:ON</p>\r\n</blockquote></li>\r\n</ul></li>\r\n</ul>\r\n<h3\r\nid=\"除了父模块还有哪些是带有独立作用域的\">除了父模块还有哪些是带有独立作用域的</h3>\r\n<ul>\r\n<li>include 的 XXX.cmake <strong>没有</strong>独立作用域<br />\r\n</li>\r\n<li>add_subdirectory 的 CMakeLists.txt 有独立作用域<br />\r\n</li>\r\n<li>macro\r\n<strong>没有</strong>独立作用域，插入执行，变量会暴露出来<br />\r\n</li>\r\n<li>function <strong>有</strong>独立作用域，变量不会暴露出来<br />\r\n</li>\r\n<li>因此 PARENT_SCORE 也可以用于 function 的返回值</li>\r\n</ul>\r\n<h3 id=\"环境变量的访问方式envxx\">环境变量的访问方式：$ENV{xx}</h3>\r\n<ul>\r\n<li><p>用 ${xx}\r\n访问的是局部变量，局部变量服从刚刚说的父子模块传递规则。</p></li>\r\n<li><p>而还有一种特殊的方式可以访问系统的环境变量( enviroment variable )\r\n: $ENV{xx}</p></li>\r\n<li><p>比如 $ENV{PATH} 获取的就是 PATH 这个环境变量的值<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)  <br><span class=\"hljs-keyword\">project</span>(helloCMake)<br><br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;PATH:$ENV&#123;PATH&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></p></li>\r\n</ul>\r\n<h3 id=\"缓存变量的访问方式cachexx\">缓存变量的访问方式：$CACHE{xx}</h3>\r\n<ul>\r\n<li><p>还可以用 $CACHE{xx} 访问缓存变量<br />\r\n缓存变量和环境变量都是全局的，没有作用域一说</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)  <br><span class=\"hljs-keyword\">project</span>(helloCMake)<br><br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;CMAKE_BUILD_TYPE:$CACHE&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3 id=\"xx-找不到局部变量时会自动去找缓存变量\">${xx}\r\n找不到局部变量时，会自动去找缓存变量</h3>\r\n<ul>\r\n<li><p>当 ${xx} 在局部变量找不到时，回去查询名为 xx 缓存变量</p></li>\r\n<li><p>所以这里虽然没有定义 CMAKE_BUILD_TYPE，但是 ${}\r\n在缓存变量中找到了<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)  <br>projecr(helloCMake)<br><br><span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;CMAKE_BUILD_TYPE:$&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)<br><br><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)  <br></code></pre></td></tr></table></figure></p></li>\r\n</ul>\r\n<h3 id=\"ifdefined-xx-判断变量是否存在\">if(DEFINED XX)\r\n判断变量是否存在</h3>\r\n<p>if(DEFINED MYVAR) 可以判断是否定义了 MYVAR\r\n变量，判断的是<strong>局部变量</strong>和<strong>缓存变量</strong><br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br>projecr(helloCMake)<br><br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">DEFINED</span> MYVAR)<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR:$&#123;MYVAR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR not defined&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure></p>\r\n<p>需要注意的是即便变量是空字符串也是被认为存在的，因为 DEFINED\r\n判断的是<em>是否被定义</em>。</p>\r\n<h3 id=\"ifxx-就可以判断是否存在且不为空\">if(xx)\r\n就可以判断是否存在且不为空</h3>\r\n<p>可以直接用 if(xx) 来判断空字符串，因为空字符串等于 OFF<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br>projecr(helloCMake)<br><br><span class=\"hljs-keyword\">set</span>(MYVAR <span class=\"hljs-string\">&quot;&quot;</span>)<br><span class=\"hljs-keyword\">if</span>(MYVAR)<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is:$&#123;MYVAR&#125;&quot;</span>)<br><span class=\"hljs-keyword\">else</span>()<br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is empty or not defined&quot;</span>)<br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure></p>\r\n<h3 id=\"ifdefined-envxx-判断环境变量是否存在\">if(DEFINED ENV{xx})\r\n判断环境变量是否存在</h3>\r\n<ul>\r\n<li><p>因为 $ENV{xx} 代表环境变量，因此在 set 和 if 中也可以用 ENV{xx}\r\n来表示环境变量<br />\r\n因为 set 的第一参数和 if 的参数都是不加 $ 的，<br />\r\n所以要设置 ${x} 就变成了 set(x ...);<br />\r\n设置 $ENV{x} 就变成了 set( ENV{x} ...)<br />\r\n同理还可以用 if(DEFINED CACHE{x} ) 判断是否存在 缓存变量x<br />\r\n但是 set( CACHE{x} ...) 不行，别搞错了。</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)  <br><span class=\"hljs-keyword\">project</span>(helloCMake)<br><br><span class=\"hljs-keyword\">set</span>(ENV&#123;MYVAR&#125; <span class=\"hljs-string\">&quot;hello&quot;</span>)  <br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">DEFINED</span> ENV&#123;MYVAR&#125;)  <br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR:$ENV&#123;MYVAR&#125;&quot;</span>)  <br><span class=\"hljs-keyword\">else</span>()  <br>\t<span class=\"hljs-keyword\">message</span>(<span class=\"hljs-string\">&quot;MYVAR is not defined!&quot;</span>)  <br><span class=\"hljs-keyword\">endif</span>()  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3 id=\"第十一章小建议\">第十一章：小建议</h3>\r\n<h3 id=\"ccache编译加速缓存\">CCache：编译加速缓存</h3>\r\n<ul>\r\n<li><p>用法：把 gcc -c main.cpp -o main 换成 ccache gcc -c main.cpp -o\r\nmain 即可<br />\r\n在 CMake 中，可这样来启用 ccache ( 就是给每个编译和链接命令前面加上\r\nccache )</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)  <br><span class=\"hljs-keyword\">project</span>(helloCMake)<br><br><span class=\"hljs-keyword\">find_program</span>(CCACHE_PROGRAM ccache)  <br><span class=\"hljs-keyword\">if</span>(CCACHE_PROGRAM)  <br>\t<span class=\"hljs-keyword\">message</span>(STATUS <span class=\"hljs-string\">&quot;Found CCache:$&#123;CCACHE_PROGRAM&#125;&quot;</span>)  <br>\t<span class=\"hljs-keyword\">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_COMPILE <span class=\"hljs-variable\">$&#123;CCACHE_PROGRAM&#125;</span>)  <br>\t<span class=\"hljs-keyword\">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_LINK <span class=\"hljs-variable\">$&#123;CCACHE_PROGRAM&#125;</span>)  <br><span class=\"hljs-keyword\">endif</span>()  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>CCache 官网：https://ccache.dev/ ( 不过好像不支持 MSVC )</p></li>\r\n</ul>\r\n<h3 id=\"添加一个-run-伪目标用于启动主程序-可执行文件\">添加一个 run\r\n伪目标，用于启动主程序( 可执行文件 )</h3>\r\n<ul>\r\n<li><p>创建一个 run 伪目标，其执行 main 的可执行文件<br />\r\n这里用了生成器表达式 <code>$&lt;TARGET_FILE:main&gt;</code> 会自动让 run\r\n依赖 main<br />\r\n如果自动依赖失败，可以手动加上 add_dependencies(run main)\r\n也是可以的。</p></li>\r\n<li><p>这样就可以在命令行运行 cmake --build build --target run 来启动\r\nmain.exe 运行了。而不必根据不同的平台，手动写出 build/main 或者\r\nbuild.exe<br />\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_executable</span>(main main.cpp)<br><br><span class=\"hljs-keyword\">add_custom_target</span>(run <span class=\"hljs-keyword\">COMMAND</span> $&lt;TARGET_FILR:main&gt;)  <br></code></pre></td></tr></table></figure></p></li>\r\n</ul>\r\n<h3 id=\"再加一个-configure-伪目标用于可视化地修改缓存变量\">再加一个\r\nconfigure 伪目标，用于可视化地修改缓存变量</h3>\r\n<ul>\r\n<li><p>这样就可以 cmake --build build --target configure 来启动 ccmake\r\n修改缓存了<br />\r\nLinux 上相当于 ccmake -B build，Windows 则是 cmake-gui -B build</p>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_custom_target</span>(run <span class=\"hljs-keyword\">COMMAND</span> $&lt;TARGET_FILE:main&gt;)  <br><span class=\"hljs-keyword\">if</span>(CMAKE_EDIT_COMMAND)  <br>\t<span class=\"hljs-keyword\">add_custom_target</span>(configure <span class=\"hljs-keyword\">COMMAND</span> <span class=\"hljs-variable\">$&#123;CMAKE_EDIT_COMMAND&#125;</span> -B <span class=\"hljs-variable\">$&#123;CMAKE_BINARY_DIR&#125;</span>)  <br><span class=\"hljs-keyword\">endif</span>()  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"文件目录组织规范\"><a\r\nhref=\"https://www.bilibili.com/video/BV1V84y117YU\">文件目录组织规范</a></h2>\r\n<p>基于CMake的项目组织。</p>\r\n<h3 id=\"推荐的目录组织\">推荐的目录组织</h3>\r\n<ul>\r\n<li>project_name/include/project_name/module_name.h<br />\r\n</li>\r\n<li>project_name/src/module_name.cpp</li>\r\n</ul>\r\n<p>将头文件放在include/project_name目录下是防止<strong>不同子项目</strong>或<strong>项目</strong>与<strong>系统头文件</strong>相冲突。</p>\r\n<p><strong>在CMakeLists.txt中</strong>使用</p>\r\n<p><code>target_include_directories(project_name PUBLIC include)</code></p>\r\n<p>指定项目名project_name, PUBLIC导入include文件</p>\r\n<p><strong>源文件中</strong></p>\r\n<ul>\r\n<li>#include<project_name/module_name><br />\r\n</li>\r\n<li>project_name::func();</li>\r\n</ul>\r\n<p><strong>头文件中(project_name/include/project_name/module_name.h)</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span><br><span class=\"hljs-keyword\">namespace</span> project_name&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p><strong>实现文件(projecr_name/src/module_name.cpp)</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;project_name/module.h&gt;</span></span><br><span class=\"hljs-keyword\">namespace</span> project_name&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-type\">int</span> a;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"例子-1\">例子</h4>\r\n<ul>\r\n<li>biology\r\n<ul>\r\n<li>CMakeLists.txt<br />\r\n</li>\r\n<li>include\r\n<ul>\r\n<li>biology\r\n<ul>\r\n<li>Animal.h<br />\r\n</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>src\r\n<ul>\r\n<li>Animal.cpp<br />\r\n</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>CMakeList.txt<br />\r\n</li>\r\n<li>pybmain\r\n<ul>\r\n<li>CMakeLists.txt<br />\r\n</li>\r\n<li>include\r\n<ul>\r\n<li>pybmain\r\n<ul>\r\n<li>myutils.h<br />\r\n</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>src\r\n<ul>\r\n<li>main.cpp</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<p>有点抽象……</p>\r\n<p><img src=\"D:\\Book\\C++\\MyC++Note\\CMake.png\" alt=\"CMake\" style=\"zoom:67%;\" /></p>\r\n<h3 id=\"划分子项目\">划分子项目</h3>\r\n<p>一个大型的项目不可能是仅仅一个项目，往往是要分成多个子项目。</p>\r\n<p>通常分为库文件，可执行文件两个部分，<strong>库文件</strong>主要负责逻辑运算、数据处理诸如此类的<strong>代码逻辑</strong>；<strong>可执行文件</strong>主要是和<strong>用户的交互逻辑</strong>。</p>\r\n<h3 id=\"根项目的-cmakelists.txt-配置\">根项目的 CMakeLists.txt 配置</h3>\r\n<ul>\r\n<li>在根项目的 CMakeLists.txt\r\n中，设置了该项目默认的构建模式，设置了统一的 C++\r\n版本等各种选项。然后通过 <code>project</code> 命令初始化了根项目。<br />\r\n</li>\r\n<li>随后通过 <code>add_subdirectory</code> 把子项目添加进来(\r\n顺序无关紧要 )，这会调用子项目的 CMakeLists.txt 。<br />\r\n比如调用 biology/CMakeLists.txt 和 pybmain/CMakeLists.txt</li>\r\n</ul>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.18</span>)<br><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">NOT</span> CMAKE_BUILD_TYPE)<br>\t<span class=\"hljs-keyword\">set</span>(CMAKE_BUILD_TYPE Release)<br><span class=\"hljs-keyword\">endif</span>()<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">20</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">ON</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_EXTENSIONS <span class=\"hljs-keyword\">OFF</span>)<br><br><span class=\"hljs-keyword\">project</span>(CppCMakeDemo LANGUAGES CXX)<br><br><span class=\"hljs-keyword\">add_subdirectory</span>(pybmain)<br><span class=\"hljs-keyword\">add_subdirectory</span>(biology)<br></code></pre></td></tr></table></figure>\r\n<h1 id=\"我遇到的实际问题\">我遇到的实际问题</h1>\r\n<h2\r\nid=\"将资源拷贝到build目录供可执行文件读取\">将资源拷贝到Build目录，供可执行文件读取</h2>\r\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_custom_command</span>(<br>\t<span class=\"hljs-keyword\">TARGET</span> main POST_BUILD<br>\t<span class=\"hljs-keyword\">COMMAND</span> <span class=\"hljs-variable\">$&#123;CMAKE_COMMAND&#125;</span> -E copy_directory<br>\t\t\t<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/obj<br>\t\t\t<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/obj<br>)<br></code></pre></td></tr></table></figure>\r\n<p><a\r\nhref=\"https://cmake.org/cmake/help/latest/command/add_custom_command.html?highlight=add_custom_command\">CMake官方：add_custom_command</a><br />\r\n<a\r\nhref=\"https://discourse.cmake.org/t/post-copy-files-to-currently-building-target-directory/6027\">Post\r\ncopy files to currently building target directory.</a>在这个问题中：“For\r\nexample, if I’m building demo1 I want the output dir to be demo1s binary\r\ndir, if I’m building demo2, demo2’s binary dir\r\netc.”有点意思但是我没想到解决思路用<code>$&#123;PROJECT_SOURCE_DIR&#125;</code>和<code>$&#123;PROJECT_BINARY_DIR&#125;</code>不行吗？</p>"},{"typora-root-url":"./..","title":"PBR备忘笔记","date":"2022-06-17T12:05:13.000Z","_content":"  \n记录一些有关`PBR`的知识，以免自己忘记了。网页居然不支持LATEX。  \n回头再看自己这篇文章写的稀烂，入门学习PBR还是看[LearnOpenGL]([LearnOpenGL - Theory](https://learnopengl.com/PBR/Theory))吧  \n  \n<!--more-->  \n  \n# 几个问题\n  \n什么是`PBR`呢？  \n即`Physicallly-Based-Rendering`，中文可以叫做基于物理的渲染。是一种渲染技术。  \n  \n为什么要有PBR呢？  \n随着游戏行业的发展玩家对于画面的要求也是越来越严格，对于真实性和细节有更进一步的要求。  \n而PBR能做到的就是表现十分**写实的材质**，而且还可以制造出**风格化**迥异的资源。  \n  \n# PBR\n  \n## 初步了解\n  \n### 什么叫基于物理\n  \n物理的渲染包含了三个条件：  \n  \n* 基于物理的材质  \n  \n* 基于物理的灯光  \n  \n* 基于物理适配的摄像机  \n  \n### 基于物理的材质\n  \n这种材质归根结底是对于现实世界的一种模拟。  \n  \n#### 物理材质的三个条件\n  \n* 必须遵循能量守恒，比如传播过程的光能+光转换为其他形式的能量不会超过光发出是的能量。  \n  \n* 基于微表面模型  \n  \n* 基于物理的`BRDF`  \n  \n##### 微平面理论\n  \n为了模拟现实世界的物体表面，我们认为物体表面都是由很小、随机朝向的镜面平面(发生镜面反射的小平面)。  \n光滑表面的小镜面分布更加规则。  \n而粗糙表面的小镜面十分混沌。  \n  \n##### 能量守恒\n  \n高中物理(  \n对于粗糙平面更多的光被转换为其他能量，反射强度低。  \n光滑平面，由于折射、散射更少，镜面反射会更强。  \n  \n###### 反射率方程\n  \n我们在模拟过程中，往往用反射率方程描述能量守恒  \n$$\n\\begin{aligned}\n\tL_0=Le+\\\\\n\t\\int_{\\Omega}f_r\\hspace{20px}\n\\end{aligned}\n$$\n  \n<div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math1.png\" alt=\"math1\"></div>  \n  \n而重点就在于反射比例，它规定了光在物体表面如何反射。  \n  \n**BRDF 双向反射分布函数**  \n  \n粗糙来讲BRDF就是描述光在物体表面如何反射。  \n*双向*：是说相机方向和光源方向调换后，他们的反射规律是一致的，即一束光打到表面分配到各个方向这个过程是可逆的，可以变成“分配出去的那些光”再汇聚成原来打进来的光，有点类似光路可逆。  \n  \n当光打到物体表面，会发生散射和高光反射。散射是向各个角度射出强度相近的光，高光反射就是我们常常在物体表面看到光斑。  \n  \n而与BRDF对应的还有BTDF，BTDF是双向透射分布函数，从名字就可以大概知道这个函数描述的是物体投射后在表面向各方向如何发射光线。  \n  \n<div style=\"margin:auto;width:30%\"><img src=\"/imgs/PBR/BSDF.png\" alt=\"BSDF示意\"></div>  \n  \nBRDF+BTDF就是BSDF，双向散射分布函数，感性来讲有了BSDF我们就知道，当一束光打到一块玻璃砖上表面时，上表面光如何发射(BRDF)，下表面如何透射(BTDF)。  \n  \n一般的BRDF：$f_{r}(p,w_{i},w_{o})$或者$f_{r}(w_{i},w_{r})$  \n即通过入射光反向和反射光方向，计算得到反射比例。  \n  \n**BRDF计算**  \n  \n我们可以把BRDF分为两个部分进行计算，即**漫反射**和**高光反射**。  \n  \n* 漫反射：可以采用经典的Lambert模型，这只是一种经验模型  \n  我们根据光与平面法线的夹角计算光强，夹角越大光强越小，可以参照太阳对于地球夏冬温度的影响。  \n  \n  <div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math2.png\" alt=\"math2\"></div>  \n  \n* 高光反射：  \n  \n  * Phong模型，根据反射方向和视角方向衡量高光的强弱。  \n  \n  * Blinn-Phong：根据半角向量和法线方向，半角向量即视角方向和入射方向的“角分线”，该向量越接近法线说明反射路径越接近“`入射反向`->`|法线`->`视角方向`”，反射就越强。  \n    半角向量的引入极大的节约了计算过程，由于Phong模型需要计算反射反向所以比较于Blinn-Phong效率低。而Blinn-Phong已经有很好的效果了。  \n  \n<div style=\"margin:auto;width:100%\"><img src=\"/imgs/PBR/phong.png\" alt=\"PhongAndBlinnPhong\"></div>  \n  \n* 基于物理的高光：  \n  \n  <div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math3.png\" alt=\"math3\"></div>  \n  \n###### 法线分布函数(NDF)  \n  \n<div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math4.png\" alt=\"math4\"></div>  \n  \n**与Blinn-Phong模型区别**：二者虽然都是法线对于光的影响，但是Blinn-Phong终究是经验模型，NDF更贴切实际，尤其是在末端部分，GGX-NDF末端过度平滑更加具有真实感更贴近物理，而Blinn-Phong相比较为生硬。  \n  \n###### 几何遮蔽\n  \n我们先前讨论的微平面理论，把每个小平面单独计算互不干扰，但是在实际中面与面的遮挡关系是存在的，比如人的内眼角和鼻子交汇处(这里也常常运用AO贴图，这个例子不太恰当但是主要是说明这种遮挡现象)，真实物体的表面凹凸不平，微平面间势必存在相互遮挡的关系。  \n  \n<div style=\"margin:auto;width:80%\"><img src=\"/imgs/PBR/jihe.png\" alt=\"几何遮蔽\"></div>  \n  \n左侧为几何遮蔽示意，右侧为几何阴影示意。  \n对于几何遮蔽我们通常运用统计学(概率论)的有关知识近似计算相互遮蔽，因为我们很难一个一个去算微平面间的遮挡。  \n  \n<div style=\"margin:auto;width:80%\"><img src=\"/imgs/PBR/几何遮蔽.png\" alt=\"几何遮蔽公式\"></div>\n  \n<div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math5.png\" alt=\"math5\"></div>\n  \n###### 菲涅尔方程\n  \n被反射的光线对比光线被折射部分所占的比率，描述了反射相对于折射的强度。比如我们垂直观察水面很容易看到水底，而我们远离水面水平观察时往往只能看到水面波光粼粼的样子这就是菲涅尔反射，ta描述了反射相对于折射的强度。  \n还有一个典型的物理例子就是在夏天时路远处的柏油会发生镜面反射。  \n  \n<div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math7.png\" alt=\"math7\"></div>\n  \n## Last\n  \n<div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math6.png\" alt=\"math6\"></div>\n  \n材质的效果关键就是FDG，但是BRDF不止于FDG，而PBR也不止于BRDF。  ","source":"_posts/PBR.md","raw":"---\ntypora-root-url: ./..\ntitle: PBR备忘笔记\ndate: 2022-06-17 20:05:13\ntags: \n\n---\n  \n记录一些有关`PBR`的知识，以免自己忘记了。网页居然不支持LATEX。  \n回头再看自己这篇文章写的稀烂，入门学习PBR还是看[LearnOpenGL]([LearnOpenGL - Theory](https://learnopengl.com/PBR/Theory))吧  \n  \n<!--more-->  \n  \n# 几个问题\n  \n什么是`PBR`呢？  \n即`Physicallly-Based-Rendering`，中文可以叫做基于物理的渲染。是一种渲染技术。  \n  \n为什么要有PBR呢？  \n随着游戏行业的发展玩家对于画面的要求也是越来越严格，对于真实性和细节有更进一步的要求。  \n而PBR能做到的就是表现十分**写实的材质**，而且还可以制造出**风格化**迥异的资源。  \n  \n# PBR\n  \n## 初步了解\n  \n### 什么叫基于物理\n  \n物理的渲染包含了三个条件：  \n  \n* 基于物理的材质  \n  \n* 基于物理的灯光  \n  \n* 基于物理适配的摄像机  \n  \n### 基于物理的材质\n  \n这种材质归根结底是对于现实世界的一种模拟。  \n  \n#### 物理材质的三个条件\n  \n* 必须遵循能量守恒，比如传播过程的光能+光转换为其他形式的能量不会超过光发出是的能量。  \n  \n* 基于微表面模型  \n  \n* 基于物理的`BRDF`  \n  \n##### 微平面理论\n  \n为了模拟现实世界的物体表面，我们认为物体表面都是由很小、随机朝向的镜面平面(发生镜面反射的小平面)。  \n光滑表面的小镜面分布更加规则。  \n而粗糙表面的小镜面十分混沌。  \n  \n##### 能量守恒\n  \n高中物理(  \n对于粗糙平面更多的光被转换为其他能量，反射强度低。  \n光滑平面，由于折射、散射更少，镜面反射会更强。  \n  \n###### 反射率方程\n  \n我们在模拟过程中，往往用反射率方程描述能量守恒  \n$$\n\\begin{aligned}\n\tL_0=Le+\\\\\n\t\\int_{\\Omega}f_r\\hspace{20px}\n\\end{aligned}\n$$\n  \n<div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math1.png\" alt=\"math1\"></div>  \n  \n而重点就在于反射比例，它规定了光在物体表面如何反射。  \n  \n**BRDF 双向反射分布函数**  \n  \n粗糙来讲BRDF就是描述光在物体表面如何反射。  \n*双向*：是说相机方向和光源方向调换后，他们的反射规律是一致的，即一束光打到表面分配到各个方向这个过程是可逆的，可以变成“分配出去的那些光”再汇聚成原来打进来的光，有点类似光路可逆。  \n  \n当光打到物体表面，会发生散射和高光反射。散射是向各个角度射出强度相近的光，高光反射就是我们常常在物体表面看到光斑。  \n  \n而与BRDF对应的还有BTDF，BTDF是双向透射分布函数，从名字就可以大概知道这个函数描述的是物体投射后在表面向各方向如何发射光线。  \n  \n<div style=\"margin:auto;width:30%\"><img src=\"/imgs/PBR/BSDF.png\" alt=\"BSDF示意\"></div>  \n  \nBRDF+BTDF就是BSDF，双向散射分布函数，感性来讲有了BSDF我们就知道，当一束光打到一块玻璃砖上表面时，上表面光如何发射(BRDF)，下表面如何透射(BTDF)。  \n  \n一般的BRDF：$f_{r}(p,w_{i},w_{o})$或者$f_{r}(w_{i},w_{r})$  \n即通过入射光反向和反射光方向，计算得到反射比例。  \n  \n**BRDF计算**  \n  \n我们可以把BRDF分为两个部分进行计算，即**漫反射**和**高光反射**。  \n  \n* 漫反射：可以采用经典的Lambert模型，这只是一种经验模型  \n  我们根据光与平面法线的夹角计算光强，夹角越大光强越小，可以参照太阳对于地球夏冬温度的影响。  \n  \n  <div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math2.png\" alt=\"math2\"></div>  \n  \n* 高光反射：  \n  \n  * Phong模型，根据反射方向和视角方向衡量高光的强弱。  \n  \n  * Blinn-Phong：根据半角向量和法线方向，半角向量即视角方向和入射方向的“角分线”，该向量越接近法线说明反射路径越接近“`入射反向`->`|法线`->`视角方向`”，反射就越强。  \n    半角向量的引入极大的节约了计算过程，由于Phong模型需要计算反射反向所以比较于Blinn-Phong效率低。而Blinn-Phong已经有很好的效果了。  \n  \n<div style=\"margin:auto;width:100%\"><img src=\"/imgs/PBR/phong.png\" alt=\"PhongAndBlinnPhong\"></div>  \n  \n* 基于物理的高光：  \n  \n  <div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math3.png\" alt=\"math3\"></div>  \n  \n###### 法线分布函数(NDF)  \n  \n<div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math4.png\" alt=\"math4\"></div>  \n  \n**与Blinn-Phong模型区别**：二者虽然都是法线对于光的影响，但是Blinn-Phong终究是经验模型，NDF更贴切实际，尤其是在末端部分，GGX-NDF末端过度平滑更加具有真实感更贴近物理，而Blinn-Phong相比较为生硬。  \n  \n###### 几何遮蔽\n  \n我们先前讨论的微平面理论，把每个小平面单独计算互不干扰，但是在实际中面与面的遮挡关系是存在的，比如人的内眼角和鼻子交汇处(这里也常常运用AO贴图，这个例子不太恰当但是主要是说明这种遮挡现象)，真实物体的表面凹凸不平，微平面间势必存在相互遮挡的关系。  \n  \n<div style=\"margin:auto;width:80%\"><img src=\"/imgs/PBR/jihe.png\" alt=\"几何遮蔽\"></div>  \n  \n左侧为几何遮蔽示意，右侧为几何阴影示意。  \n对于几何遮蔽我们通常运用统计学(概率论)的有关知识近似计算相互遮蔽，因为我们很难一个一个去算微平面间的遮挡。  \n  \n<div style=\"margin:auto;width:80%\"><img src=\"/imgs/PBR/几何遮蔽.png\" alt=\"几何遮蔽公式\"></div>\n  \n<div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math5.png\" alt=\"math5\"></div>\n  \n###### 菲涅尔方程\n  \n被反射的光线对比光线被折射部分所占的比率，描述了反射相对于折射的强度。比如我们垂直观察水面很容易看到水底，而我们远离水面水平观察时往往只能看到水面波光粼粼的样子这就是菲涅尔反射，ta描述了反射相对于折射的强度。  \n还有一个典型的物理例子就是在夏天时路远处的柏油会发生镜面反射。  \n  \n<div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math7.png\" alt=\"math7\"></div>\n  \n## Last\n  \n<div style=\"margin:left;width:100%\"><img src=\"/imgs/PBR/math6.png\" alt=\"math6\"></div>\n  \n材质的效果关键就是FDG，但是BRDF不止于FDG，而PBR也不止于BRDF。  ","slug":"PBR","published":1,"updated":"2024-01-14T08:13:08.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti2000dbkbwdhlb8og1","content":"<p>记录一些有关<code>PBR</code>的知识，以免自己忘记了。网页居然不支持LATEX。<br />\r\n回头再看自己这篇文章写的稀烂，入门学习PBR还是看<a\r\nhref=\"%5BLearnOpenGL%20-%20Theory%5D(https://learnopengl.com/PBR/Theory)\">LearnOpenGL</a>吧</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"几个问题\">几个问题</h1>\r\n<p>什么是<code>PBR</code>呢？<br />\r\n即<code>Physicallly-Based-Rendering</code>，中文可以叫做基于物理的渲染。是一种渲染技术。</p>\r\n<p>为什么要有PBR呢？<br />\r\n随着游戏行业的发展玩家对于画面的要求也是越来越严格，对于真实性和细节有更进一步的要求。<br />\r\n而PBR能做到的就是表现十分<strong>写实的材质</strong>，而且还可以制造出<strong>风格化</strong>迥异的资源。</p>\r\n<h1 id=\"pbr\">PBR</h1>\r\n<h2 id=\"初步了解\">初步了解</h2>\r\n<h3 id=\"什么叫基于物理\">什么叫基于物理</h3>\r\n<p>物理的渲染包含了三个条件：</p>\r\n<ul>\r\n<li><p>基于物理的材质</p></li>\r\n<li><p>基于物理的灯光</p></li>\r\n<li><p>基于物理适配的摄像机</p></li>\r\n</ul>\r\n<h3 id=\"基于物理的材质\">基于物理的材质</h3>\r\n<p>这种材质归根结底是对于现实世界的一种模拟。</p>\r\n<h4 id=\"物理材质的三个条件\">物理材质的三个条件</h4>\r\n<ul>\r\n<li><p>必须遵循能量守恒，比如传播过程的光能+光转换为其他形式的能量不会超过光发出是的能量。</p></li>\r\n<li><p>基于微表面模型</p></li>\r\n<li><p>基于物理的<code>BRDF</code></p></li>\r\n</ul>\r\n<h5 id=\"微平面理论\">微平面理论</h5>\r\n<p>为了模拟现实世界的物体表面，我们认为物体表面都是由很小、随机朝向的镜面平面(发生镜面反射的小平面)。<br />\r\n光滑表面的小镜面分布更加规则。<br />\r\n而粗糙表面的小镜面十分混沌。</p>\r\n<h5 id=\"能量守恒\">能量守恒</h5>\r\n<p>高中物理(<br />\r\n对于粗糙平面更多的光被转换为其他能量，反射强度低。<br />\r\n光滑平面，由于折射、散射更少，镜面反射会更强。</p>\r\n<h6 id=\"反射率方程\">反射率方程</h6>\r\n<p>我们在模拟过程中，往往用反射率方程描述能量守恒<br />\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    L_0=Le+\\\\\r\n    \\int_{\\Omega}f_r\\hspace{20px}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math1.png\" alt=\"math1\">\r\n</div>\r\n<p>而重点就在于反射比例，它规定了光在物体表面如何反射。</p>\r\n<p><strong>BRDF 双向反射分布函数</strong></p>\r\n<p>粗糙来讲BRDF就是描述光在物体表面如何反射。<br />\r\n<em>双向</em>：是说相机方向和光源方向调换后，他们的反射规律是一致的，即一束光打到表面分配到各个方向这个过程是可逆的，可以变成“分配出去的那些光”再汇聚成原来打进来的光，有点类似光路可逆。</p>\r\n<p>当光打到物体表面，会发生散射和高光反射。散射是向各个角度射出强度相近的光，高光反射就是我们常常在物体表面看到光斑。</p>\r\n<p>而与BRDF对应的还有BTDF，BTDF是双向透射分布函数，从名字就可以大概知道这个函数描述的是物体投射后在表面向各方向如何发射光线。</p>\r\n<div style=\"margin:auto;width:30%\">\r\n<img src=\"/imgs/PBR/BSDF.png\" alt=\"BSDF示意\">\r\n</div>\r\n<p>BRDF+BTDF就是BSDF，双向散射分布函数，感性来讲有了BSDF我们就知道，当一束光打到一块玻璃砖上表面时，上表面光如何发射(BRDF)，下表面如何透射(BTDF)。</p>\r\n<p>一般的BRDF：<span\r\nclass=\"math inline\">\\(f_{r}(p,w_{i},w_{o})\\)</span>或者<span\r\nclass=\"math inline\">\\(f_{r}(w_{i},w_{r})\\)</span><br />\r\n即通过入射光反向和反射光方向，计算得到反射比例。</p>\r\n<p><strong>BRDF计算</strong></p>\r\n<p>我们可以把BRDF分为两个部分进行计算，即<strong>漫反射</strong>和<strong>高光反射</strong>。</p>\r\n<ul>\r\n<li><p>漫反射：可以采用经典的Lambert模型，这只是一种经验模型<br />\r\n我们根据光与平面法线的夹角计算光强，夹角越大光强越小，可以参照太阳对于地球夏冬温度的影响。</p>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math2.png\" alt=\"math2\">\r\n</div></li>\r\n<li><p>高光反射：</p>\r\n<ul>\r\n<li><p>Phong模型，根据反射方向和视角方向衡量高光的强弱。</p></li>\r\n<li><p>Blinn-Phong：根据半角向量和法线方向，半角向量即视角方向和入射方向的“角分线”，该向量越接近法线说明反射路径越接近“<code>入射反向</code>-&gt;<code>|法线</code>-&gt;<code>视角方向</code>”，反射就越强。<br />\r\n半角向量的引入极大的节约了计算过程，由于Phong模型需要计算反射反向所以比较于Blinn-Phong效率低。而Blinn-Phong已经有很好的效果了。</p></li>\r\n</ul></li>\r\n</ul>\r\n<div style=\"margin:auto;width:100%\">\r\n<img src=\"/imgs/PBR/phong.png\" alt=\"PhongAndBlinnPhong\">\r\n</div>\r\n<ul>\r\n<li><p>基于物理的高光：</p>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math3.png\" alt=\"math3\">\r\n</div></li>\r\n</ul>\r\n<h6 id=\"法线分布函数ndf\">法线分布函数(NDF)</h6>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math4.png\" alt=\"math4\">\r\n</div>\r\n<p><strong>与Blinn-Phong模型区别</strong>：二者虽然都是法线对于光的影响，但是Blinn-Phong终究是经验模型，NDF更贴切实际，尤其是在末端部分，GGX-NDF末端过度平滑更加具有真实感更贴近物理，而Blinn-Phong相比较为生硬。</p>\r\n<h6 id=\"几何遮蔽\">几何遮蔽</h6>\r\n<p>我们先前讨论的微平面理论，把每个小平面单独计算互不干扰，但是在实际中面与面的遮挡关系是存在的，比如人的内眼角和鼻子交汇处(这里也常常运用AO贴图，这个例子不太恰当但是主要是说明这种遮挡现象)，真实物体的表面凹凸不平，微平面间势必存在相互遮挡的关系。</p>\r\n<div style=\"margin:auto;width:80%\">\r\n<img src=\"/imgs/PBR/jihe.png\" alt=\"几何遮蔽\">\r\n</div>\r\n<p>左侧为几何遮蔽示意，右侧为几何阴影示意。<br />\r\n对于几何遮蔽我们通常运用统计学(概率论)的有关知识近似计算相互遮蔽，因为我们很难一个一个去算微平面间的遮挡。</p>\r\n<div style=\"margin:auto;width:80%\">\r\n<img src=\"/imgs/PBR/几何遮蔽.png\" alt=\"几何遮蔽公式\">\r\n</div>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math5.png\" alt=\"math5\">\r\n</div>\r\n<h6 id=\"菲涅尔方程\">菲涅尔方程</h6>\r\n<p>被反射的光线对比光线被折射部分所占的比率，描述了反射相对于折射的强度。比如我们垂直观察水面很容易看到水底，而我们远离水面水平观察时往往只能看到水面波光粼粼的样子这就是菲涅尔反射，ta描述了反射相对于折射的强度。<br />\r\n还有一个典型的物理例子就是在夏天时路远处的柏油会发生镜面反射。</p>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math7.png\" alt=\"math7\">\r\n</div>\r\n<h2 id=\"last\">Last</h2>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math6.png\" alt=\"math6\">\r\n</div>\r\n<p>材质的效果关键就是FDG，但是BRDF不止于FDG，而PBR也不止于BRDF。</p>\r\n","site":{"data":{}},"excerpt":"<p>记录一些有关<code>PBR</code>的知识，以免自己忘记了。网页居然不支持LATEX。<br />\r\n回头再看自己这篇文章写的稀烂，入门学习PBR还是看<a\r\nhref=\"%5BLearnOpenGL%20-%20Theory%5D(https://learnopengl.com/PBR/Theory)\">LearnOpenGL</a>吧</p>","more":"<h1 id=\"几个问题\">几个问题</h1>\r\n<p>什么是<code>PBR</code>呢？<br />\r\n即<code>Physicallly-Based-Rendering</code>，中文可以叫做基于物理的渲染。是一种渲染技术。</p>\r\n<p>为什么要有PBR呢？<br />\r\n随着游戏行业的发展玩家对于画面的要求也是越来越严格，对于真实性和细节有更进一步的要求。<br />\r\n而PBR能做到的就是表现十分<strong>写实的材质</strong>，而且还可以制造出<strong>风格化</strong>迥异的资源。</p>\r\n<h1 id=\"pbr\">PBR</h1>\r\n<h2 id=\"初步了解\">初步了解</h2>\r\n<h3 id=\"什么叫基于物理\">什么叫基于物理</h3>\r\n<p>物理的渲染包含了三个条件：</p>\r\n<ul>\r\n<li><p>基于物理的材质</p></li>\r\n<li><p>基于物理的灯光</p></li>\r\n<li><p>基于物理适配的摄像机</p></li>\r\n</ul>\r\n<h3 id=\"基于物理的材质\">基于物理的材质</h3>\r\n<p>这种材质归根结底是对于现实世界的一种模拟。</p>\r\n<h4 id=\"物理材质的三个条件\">物理材质的三个条件</h4>\r\n<ul>\r\n<li><p>必须遵循能量守恒，比如传播过程的光能+光转换为其他形式的能量不会超过光发出是的能量。</p></li>\r\n<li><p>基于微表面模型</p></li>\r\n<li><p>基于物理的<code>BRDF</code></p></li>\r\n</ul>\r\n<h5 id=\"微平面理论\">微平面理论</h5>\r\n<p>为了模拟现实世界的物体表面，我们认为物体表面都是由很小、随机朝向的镜面平面(发生镜面反射的小平面)。<br />\r\n光滑表面的小镜面分布更加规则。<br />\r\n而粗糙表面的小镜面十分混沌。</p>\r\n<h5 id=\"能量守恒\">能量守恒</h5>\r\n<p>高中物理(<br />\r\n对于粗糙平面更多的光被转换为其他能量，反射强度低。<br />\r\n光滑平面，由于折射、散射更少，镜面反射会更强。</p>\r\n<h6 id=\"反射率方程\">反射率方程</h6>\r\n<p>我们在模拟过程中，往往用反射率方程描述能量守恒<br />\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    L_0=Le+\\\\\r\n    \\int_{\\Omega}f_r\\hspace{20px}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math1.png\" alt=\"math1\">\r\n</div>\r\n<p>而重点就在于反射比例，它规定了光在物体表面如何反射。</p>\r\n<p><strong>BRDF 双向反射分布函数</strong></p>\r\n<p>粗糙来讲BRDF就是描述光在物体表面如何反射。<br />\r\n<em>双向</em>：是说相机方向和光源方向调换后，他们的反射规律是一致的，即一束光打到表面分配到各个方向这个过程是可逆的，可以变成“分配出去的那些光”再汇聚成原来打进来的光，有点类似光路可逆。</p>\r\n<p>当光打到物体表面，会发生散射和高光反射。散射是向各个角度射出强度相近的光，高光反射就是我们常常在物体表面看到光斑。</p>\r\n<p>而与BRDF对应的还有BTDF，BTDF是双向透射分布函数，从名字就可以大概知道这个函数描述的是物体投射后在表面向各方向如何发射光线。</p>\r\n<div style=\"margin:auto;width:30%\">\r\n<img src=\"/imgs/PBR/BSDF.png\" alt=\"BSDF示意\">\r\n</div>\r\n<p>BRDF+BTDF就是BSDF，双向散射分布函数，感性来讲有了BSDF我们就知道，当一束光打到一块玻璃砖上表面时，上表面光如何发射(BRDF)，下表面如何透射(BTDF)。</p>\r\n<p>一般的BRDF：<span\r\nclass=\"math inline\">\\(f_{r}(p,w_{i},w_{o})\\)</span>或者<span\r\nclass=\"math inline\">\\(f_{r}(w_{i},w_{r})\\)</span><br />\r\n即通过入射光反向和反射光方向，计算得到反射比例。</p>\r\n<p><strong>BRDF计算</strong></p>\r\n<p>我们可以把BRDF分为两个部分进行计算，即<strong>漫反射</strong>和<strong>高光反射</strong>。</p>\r\n<ul>\r\n<li><p>漫反射：可以采用经典的Lambert模型，这只是一种经验模型<br />\r\n我们根据光与平面法线的夹角计算光强，夹角越大光强越小，可以参照太阳对于地球夏冬温度的影响。</p>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math2.png\" alt=\"math2\">\r\n</div></li>\r\n<li><p>高光反射：</p>\r\n<ul>\r\n<li><p>Phong模型，根据反射方向和视角方向衡量高光的强弱。</p></li>\r\n<li><p>Blinn-Phong：根据半角向量和法线方向，半角向量即视角方向和入射方向的“角分线”，该向量越接近法线说明反射路径越接近“<code>入射反向</code>-&gt;<code>|法线</code>-&gt;<code>视角方向</code>”，反射就越强。<br />\r\n半角向量的引入极大的节约了计算过程，由于Phong模型需要计算反射反向所以比较于Blinn-Phong效率低。而Blinn-Phong已经有很好的效果了。</p></li>\r\n</ul></li>\r\n</ul>\r\n<div style=\"margin:auto;width:100%\">\r\n<img src=\"/imgs/PBR/phong.png\" alt=\"PhongAndBlinnPhong\">\r\n</div>\r\n<ul>\r\n<li><p>基于物理的高光：</p>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math3.png\" alt=\"math3\">\r\n</div></li>\r\n</ul>\r\n<h6 id=\"法线分布函数ndf\">法线分布函数(NDF)</h6>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math4.png\" alt=\"math4\">\r\n</div>\r\n<p><strong>与Blinn-Phong模型区别</strong>：二者虽然都是法线对于光的影响，但是Blinn-Phong终究是经验模型，NDF更贴切实际，尤其是在末端部分，GGX-NDF末端过度平滑更加具有真实感更贴近物理，而Blinn-Phong相比较为生硬。</p>\r\n<h6 id=\"几何遮蔽\">几何遮蔽</h6>\r\n<p>我们先前讨论的微平面理论，把每个小平面单独计算互不干扰，但是在实际中面与面的遮挡关系是存在的，比如人的内眼角和鼻子交汇处(这里也常常运用AO贴图，这个例子不太恰当但是主要是说明这种遮挡现象)，真实物体的表面凹凸不平，微平面间势必存在相互遮挡的关系。</p>\r\n<div style=\"margin:auto;width:80%\">\r\n<img src=\"/imgs/PBR/jihe.png\" alt=\"几何遮蔽\">\r\n</div>\r\n<p>左侧为几何遮蔽示意，右侧为几何阴影示意。<br />\r\n对于几何遮蔽我们通常运用统计学(概率论)的有关知识近似计算相互遮蔽，因为我们很难一个一个去算微平面间的遮挡。</p>\r\n<div style=\"margin:auto;width:80%\">\r\n<img src=\"/imgs/PBR/几何遮蔽.png\" alt=\"几何遮蔽公式\">\r\n</div>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math5.png\" alt=\"math5\">\r\n</div>\r\n<h6 id=\"菲涅尔方程\">菲涅尔方程</h6>\r\n<p>被反射的光线对比光线被折射部分所占的比率，描述了反射相对于折射的强度。比如我们垂直观察水面很容易看到水底，而我们远离水面水平观察时往往只能看到水面波光粼粼的样子这就是菲涅尔反射，ta描述了反射相对于折射的强度。<br />\r\n还有一个典型的物理例子就是在夏天时路远处的柏油会发生镜面反射。</p>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math7.png\" alt=\"math7\">\r\n</div>\r\n<h2 id=\"last\">Last</h2>\r\n<div style=\"margin:left;width:100%\">\r\n<img src=\"/imgs/PBR/math6.png\" alt=\"math6\">\r\n</div>\r\n<p>材质的效果关键就是FDG，但是BRDF不止于FDG，而PBR也不止于BRDF。</p>"},{"title":"思绪之海桶狭间(","date":"2022-04-08T14:25:16.000Z","_content":"  \n## 隔离期间\n  \n隔离期间搞一个自己的blog。  \n原名`New Start`，  \n记录一些自己的感悟。\n  \n<!--more-->\n  \n## 闲言碎语\n  \n1、刘明翼和周帆要考研了，杨崇兴过两天就要去实习了，只剩下我在所剩无几的大学时光等待着琐碎破败的人生到来，这个时候我才知道我曾做的一切是多么想暂缓逝而不返的时光，然而残酷的现实是——一切都是徒劳，生活没有什么预兆、也没有什么标识，一切就这么发生了，没有惊天动地的变故，没有振奋人心的庆典，一切都是那么平常，而这平常就是生活最大的残酷。\n  \n一切都随着流水走向着尽头，走向着开始，而我注定和从前一样缅怀在自己卑谬的过去中，难看地呻吟。\n  \n2、年龄越来越大，越能明白有个能畅所欲言的对象是多么可贵，如果这个对象能回应、甚至帮助你那就更为可贵了。有些话有些事只能自己挨着。真羡慕那些什么都能说，肆无忌惮的人，好轻松。不知什么时候开始，彷佛依赖上了内心流血的状态，就像用舌头舔刀刃上的血，明明血不会止住，反而迷恋上血的味道。\n  \n没什么办法，那些面对巨大挫折却仍能坚持下来，没有丧失心智的人原来是这么的强大。\n  \n> 世界上只有一种真正的英雄主义，那就是在认识生活的真相后依然热爱生活。\n  \n3、全部是真实的，却是虚假的。\n  \n用虚伪的去描绘最为真实的。我们的现实我们的感受，是虚伪的还是真实的呢？\n  \n是他人的传递，还是萌生于我们的内在呢？我不知道，不管是自己还是他人，不同的真实也许是相同的虚幻，不同的虚幻也可能是相同的真实。我又在什么时候迷失了自己的灵魂呢……\n  \n> 全都是真实的 却是虚假的  \n>   \n> 用虚伪去描绘真实的  \n>   \n> 用真实去欺骗虚假的  \n>   \n> 我们的空洞眼神里  \n>   \n> 诡异着 映射着 敏感着  \n>   \n> 奇幻色彩的爆炸波\n  \n4、明知是熊熊的烈火、不知前路如何，却仍能为了改变现状，为了更好的未来毅然献身，这样的理想主义者值得我们永远歌颂，如此高贵的品格才是人类最为珍贵的。也许有人歌颂英雄只是为了能让自己当个懦夫，但是我相信对英雄的呼唤和歌颂能唤醒这个世界隐藏的光明。\n  \n5、昨天洗澡的时候突然发现自己为什么有屯物癖。小时候家里条件不是很好，每次自己有了新东西都会很开心，可是时间久了东西就会坏掉，我失去我的这些最珍贵的东西时我十分伤心，所以再后来就喜欢“备份”，同样的东西要有很多才会安心，总是怕他们离我而去，慢慢的慢慢的就成了无意识的举动，堆着堆着就成了习惯。也许我不是屯物癖吧，我只是害怕失去的感觉，堆积备份追寻自己的安心。\n  \n6、我从不幻想着自己是特殊的、特别的，我只觉得自己是异常的，另类的。\n  \n7、我不再年轻了，我开始听伍佰，开始知道人生总是充满着不完美，人生就是一个慢慢填满遗憾的过程，我不是在说自己变得成熟，只是觉得有了什么从前从未有过的感受，我不知道这种感受叫做什么，他们都说这叫长大，可是长大真的是这样吗？别人也会和我一样忧愁、抑郁吗？问题会有答案，但那也只是在教材上，生活中大多时候问题是没有答案的。我不知道，我不知道，我不知道。\n  \n8、这个世界这么大，大到没有我的容身之处，而这个世界又是这么的小，小到我都不知道游乐场在哪？也许这个世界就是这样，像快乐套餐里没有快乐一样，荒诞合理。\n  \n9、\n  \n> 前方啊没有方向，身上啊没有了衣裳  \n>   \n> 鲜血啊渗出了翅膀，我的眼泪湿透了胸膛  \n>   \n> 飞翔着强忍着伤，逃离了猎人的枪  \n>   \n> 我的双脚没有了知觉，我的心情下冰冷的雪  \n>   \n> 亲爱的母亲挚爱的朋友，我会坚定好好的活  \n>   \n> 沉默的大地沉默的天空，红色的血继续的流  \n>   \n> 纵然带着永远的伤口，至少我还拥有自由  \n>   \n> 飞翔吧飞在天空，用力吹吧无情的风  \n>   \n> 我不会害怕也无须懦弱，流浪的路我自己走  \n>   \n> 那是种骄傲阳光的洒脱，白云从我脚下掠过  \n>   \n> 干枯的身影憔悴的面容，挥着翅膀不再回头  \n>   \n> 纵然带着永远的伤口，至少我还拥有自由  \n>   \n> 纵然带着永远的伤口，至少我还拥有自由  \n>   \n> 至少我还拥有自由，至少我还拥有自由  \n>   \n> 呜——  \n>   \n> ——《白鸽》伍佰\n  \n10、当她看见我没有所谓“餐票”便要阻止我就餐时，我仿佛看到了那个使用粮票、饭票的时代，那时候我们还是可以胜利的，贪婪的投机者和黑心的资本家还没有破坏我们的宝贵成功，我们走在一条崎岖但蓬勃的道路上。\n  \n可是我面前的这一景象和那时已经截然不同了，她口中的那张纸不过同“优惠券”，“代金券”这些促销手段一样，是那些吸血鬼的把戏，一个劣质的谎言罢了，只不过是为了中饱私囊掏空他人腰包所想出来的卑劣的技俩罢了。\n  \n11、你这么费力有什么用，到时候人家不过是领着ta去道个歉认个错，这事情也就罢了。上面松松口，走动走动，也就过去了，上面都松了手，你在底下还能一直死咬着不成？  \n我今天还就和你把话说透了，我倒是要教教你这法是什么法！法就是皇帝的法，就是皇家的法，任你个小芝麻再怎么搅和也休想把这官场给搅得天朗水清。咬到了最后你也只得落一句：“算了，草草结案吧！”\n  \n12、某些所谓顶流，不过是套了个炫丽的虚假的外壳罢了，拿着剥削来的资源卖弄起来，竟也装做出砥柱的样子，不禁令人作呕。就像是马戏团的小丑换了一套滑稽的万圣节戏服罢了，里面装的都是铜臭糜烂。\n  \n13、为什么一定要有什么思想、什么主旨呢？只是看着难道就不可以吗？  \n就只是看着就不能感受到作者传递出来的感情、思想、观念了吗？我一直认为人心是十分奇妙的东西，是强大的东西，我觉得就像这样看着他的感受也能传递给我，在潜移默化地影响我。只是单纯地看着就不可以的话，是我们太小瞧了这副作品，还是太小瞧了人心。\n  \n14、我一直觉得土地很神奇，春种秋收。播下种子挥洒汗水，在种地种菜的过程中憧憬着未来，憧憬着美好的明天，用自己的劳动换取美好的生活，切身感受自然的奇迹，在这个过程中自我彷佛得到了救赎。  \n人终归是自然的一份子，在这个种菜劳作的过程中，也许也是我们追根溯源，回归自然的一个过程。作为自然的一员，这种回归的过程带给我们慰藉和安逸，让我得到身心的放松，道教认为小孩子生下来是最完美的，先天之气完足，没有尘世的侵扰，我认为某种程度也是一种我们人类最贴近自然的状态，神完气足和自然融为一体，和自然同在，感受美妙的世界，体悟生命的奇迹，让我们能够放下世俗的争扰，去追寻自己真正的内心。  \n*对了，黄瓜和苦瓜别种在一起，会串花粉，黄瓜会变苦的。*\n  \n15、我很喜欢给事物带来终结，或者说是去感悟事情的结束，因为我从小时候见到的一切，他们的结尾总是那么令人铭记于心、痛彻心扉，这样看来，结束彷佛是一件美好的事，可是真的是这样吗？是结束太过痛彻心扉，刻在了心上，造成了一种感情的涟漪让我感动，还是结束真的是一件很美好，值得铭记的事情？也许这两种都是一样的吧。  \n思来想去我只能说我不知道，彷佛生活不知从什么时候开始就变得很复杂，什么东西我都搞不太懂，也许复杂的不只是生活，或者说复杂的根本不是生活，复杂的是我。也许生活本来是很简单的，只是我太复杂了，所以把生活搞得也复杂了。诶，又或者说，生活很复杂，然后我被生活搞得很复杂……你看很复杂吧，我完全搞不懂。我不知道诶。\n  \n> 所有年轻人，年轻人，年轻人，问题出现我再告诉大家！\n  \n16、明知是假的却只能依赖，因为不这么做便活不下去。  \n或许人类注定是悲哀的生物，但是悲哀的命运也不妨碍我们去追寻美，去创造美。  \n即便是悲惨的命运也能创造出无比美丽的生物。\n  \n17、言语稚嫩，文笔不成熟又怎样呢？心中这份感情可是货真价实的，不把这么美妙宝贵的情感写下来的话，不是可惜了吗？是自己的可惜，也是全人类的可惜哦~  \n用自己的语言，文字记录自己的情感，没什么好难为情的，这是一件无比浪漫，足够引以为傲的事情。因为稚嫩的记述本身就是动人的。\n  \n18、\n  \n> 逃げちゃ駄目だ，逃げちゃ駄目だ，逃げちゃ駄目だ。\n  \n19、<ruby>燃烧了…<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">燃えたよ…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>直至雪白……<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">まっ白に…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>已经燃烧殆尽了…<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">燃えつきた…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>只剩下雪白的灰……<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">まっ白な灰に……</span></rt></ruby>\n  \n> <ruby>燃烧了…<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">燃えたよ…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>直至雪白……<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">まっ白に…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>已经燃烧殆尽了…<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">燃えつきた…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>只剩下雪白的灰……<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">まっ白な灰に……</span></rt></ruby>\n  \n20、挽救烂尾的方式之一：播放结尾的时候配上最悲情、悲壮的音乐，不时穿插之前的回忆，人物不要发出声音，声音只放bgm就行，~~最后来个意识流从天空俯瞰，所有人围着主角，然后突然黑掉屏幕，赫然打上几个大字：“全剧终”~~。\n  \n21、最宝贵的情感只属于自己，若是有人能感怀一二对于自身来说便是极大的幸福了，很少有人去体悟别人的感情，自己的感情终究是属于自己的，他人不会关心，纵是共情，也是他人的悸动。\n  \n22、不深入涡流直面深渊，便没有评价的资本。\n  \n> 没有调查就没有发言权\n  \n23、没有能力的勇敢就是鲁莽，自己没有能力就什么都保护不了。\n  \n24、后来我才知道你也和我听一样的歌，我们也都一样，曾一样愤懑，曾一样踌躇，我不知道是什么样的原因，不知道是默契还是缘分，还是同样的时代背景，家庭环境？不，你应该过得比我好，一定要比我优渥。我很想浪漫的说，你我的相同是命运的馈赠，是千古最长情的缘分，可是也许这份共同是这个时代带给我们每个人的。  \n珈乐和焰火青年。\n  \n25、我突然明白了，我的心上已经有了口子，虽然会愈合，但是随着悸动，它的伤口会崩开、流出血来，想要止住血只能拿新的伤痛插在上面，可是这么一插血是止住了，也造就了新的创口。\n  \n26、其实张之铭每次晾内裤都会踩着杨崇兴的凳子，放心是脱了鞋的，这样的小恶作剧对于张之铭来说也算是一种乐趣，可是杨崇兴去实习了，张之铭再也没踩过那张凳子，也许是因为那个人走了就不再回来，也可能是因为那个人把在寝室剪头用来围脖子的破布放在了凳子上，张之铭怕脚沾上头发茬子。\n  \n27、网络浪潮有最迅猛的两个时候，一个是ta诞生的时候，另一个就是ta死的时候。\n  \n28、当我们欣赏过去的经典追忆过去时，是不是在追寻着眼中那个人的步履。聆听过去，也是追寻过去，体悟过去。\n  \n29、其实无私的爱是无比宝贵的，是可遇而不可求的，可是因为我们大多数人出生便得到了父母无私的、厚重的、广阔的爱，导致我们以为这种爱是常见的，乃至更有甚者认为是没有价值的。  \n等我长大与人接触后，才发现没有人爱我自己，曾经“最廉价”的爱居然是那么昂贵的。对周遭急切的期待，往往迎来的都是冰冷的“款待”。爱是一种可贵的能力，是一种宝贵的体验，无论是给予爱还是获得爱，我们所需要的第一件事就是爱自己。  \n希望所有人都能自爱自重，希望所有人都能收获爱，也希望所有人也有余力去爱。\n  \n30、\n  \n> 天下风云出我辈，一入江湖岁月催。  \n> 皇图霸业谈笑中，不胜人生一场醉。  \n>   \n> 提剑跨骑挥鬼雨，白骨如山鸟惊飞。  \n>   \n> 尘世如潮人如水，只叹江湖几人回。  \n>   \n> 英雄路远掌声近，莫问苍生问星辰。  \n>   \n> 天路有涯风有信，大海无量不见人。\n  \n> 本来无一物 何处惹尘埃\n  \n31、语言真是有意思，如果你直接说\"不明白\"，\"看不懂\"，\"不知道\"，人们可能不以为意，但是如果你说\"真有深度\"，不仅能欺骗自己，还能蛊惑他人，何乐而不为。  \n可是这种行事我终是觉得厌恶，而自己却不知意地做了，故而我也常常厌恶我自己。  \n这追慕虚荣的卑劣，就刻在了我们每个人的身子里，我厌恶我自己。\n  \n32、现在我才明白了，原来他是对的，真实竟然如此不堪，满是令人作呕，卑劣才是通性，高尚终是凤毛麟角。\n  \n> 因为我们不知道，所以错过了晚霞、潮汐和海浪。\n  \n> 你的实力是货真价实的，我南部赝作可以保证，这次绝不是虚张声势。\n  \n33、朋友的猫，吃了被老鼠药毒的老鼠中毒了，打了两针，现在情况也不到怎么样，那时只看见它趴伏在水泥地上，耷拉着头，也不理人，身上的毛脏脏的、有几根毛毛涔涔地立出来，它小巧的脚背上沾粘着灰色的土，水泥地有些年头了，上面裂开了几道七扭八歪的缝，缝里藏着红色的砖。不知道，明天还能不能再见到这只猫。  \n也许被耗子药毒死的猫并不少见，这也不是第一只、也许也不会是最后一只，但可能是朋友的最后一只。就同那些那些被冲垮的村落一样，也不是第一个也可能不是最后一个，但却是我们的最后一个。  \n*面对现代城市化的冲击，传统的小农经济不断遭受着挤压，那些用尽被碾压着的最后一丝气息给我留下美好回忆的乡村时光，已经是很久之前的记忆了，我不知道该说什么来表达这种感情，也不知道能做什么挽回点东西来宽慰自己，我只能像朋友那样打了两针，和猫一起坐在老旧的水泥地上，让阳光不舍地洒下一点夕阳，剩下的便只有孤独的陪伴。*  \n~~*这段话就是我给自己打的针，我就是那只猫。描写水泥地也是描写猫，不过我真的很担心朋友的猫怎么样了，希望猫没事🙏。表达对猫的缅怀，和城农冲突的无奈，对美好生活的思念，对农田生活的向往。*~~\n  \n34、这个世界真神奇，一方面游戏行业寒冬、版号缩水，另一方面国内经济情况低迷、人们消费意愿降低，国内厂商纷纷开源节流，而人才市场的竞争反而愈演愈烈，世界真魔幻啊，今年失业的恐怕是我。\n  \n35、时代的沙砾那么大，他却想爱每一个人。为什么我想做游戏，因为在我最难过的时候，是空洞骑士带给我了唯一的快乐，我不是想煽情的说，是他给了我活下去的勇气巴拉巴拉的，事实上我也没有勇敢的活下去，也没有变成优秀的大人，我还是和以前一样失去很多，依旧悲伤，但是它带给我的那些快乐是那么的深刻，再后来我玩旷野之息时，我再次体会到了这样的美好，在一个新的世界了，奇妙、自由没有烦恼，只有快乐。世界那么大，我却想爱每一个人，因为当初的我没有人爱。  \n之前爽鸭看到米的惊呼，我不以为意只觉得好笑，如今我望向米，发出“我超，米！”的惊叹，更甚于爽鸭。只觉得人生的悲哀罢了。\n  \n36、朋友的猫还活着，毛还是一样脏兮兮的，躺在混乱的电子设备堆里，嘴巴对着麦克风，朋友一直有一个歌手的梦，猫猫还活着我不知道为什么我会很开心，明明我的梦是那么遥远。\n  \n37、人生就是一个不断发现自己，认识自己，超脱自己，和解自己的过程，希望大家都能找到实现自我价值的方式和平台，满足自己的内心需求，活出只属于自己的人生，哪怕它没有那么缤纷多彩。\n  \n38、人生难免有遗憾，但是不要……不要……不要太多吧。  \n不是你的问题，是时间。时间就像深海，我们每个人都只能在中慢慢浮沉，无能为力。  \n时间是没有办法停止的，我们只能往下走了。  \n感情是人类最大的累赘，肉体是飞升的负担。  \n但真挚的情感总是可贵，令人动容。感情无法被人为模拟复现，真挚而可贵，也许正是这奇妙的心拥有超脱一切的力量。\n  \n39、我再也不看v了，原来我一直追寻虚假的过程只不过是寻找自己的投影，我在虚拟的身上几近疯狂地寻找真实的证明哪怕没有表表征，我的内心却是这样追寻的，我在人造的虚拟背后看到一丝真实的投影便自我感动地落泪，原来我是这般的不堪，我再也不看v了，我，再也不看v了。\n  \n40、如果不能在璀璨的烈焰中死去，便在无波的颓唐中磨平了一生。\n  \n41、如何创造一个悲剧——在路边抓来一个路人。\n  \n42、忽然发现自己什么都不会，成为了社会废人。\n  \n43、如果一个人不能得到生的光辉，便会理所应当地追求死的慷慨。\n  \n44、每当我体会到生的美妙，都会下意识的痛彻死的悲痛，因为我知道那些美妙终是虚幻的、终是离我遥远的是我无法触及的。\n  \n45、愈是压抑沉闷的今照，才能愈发凸显阴云散去、万里晴空的激动；在无数苦闷坚守的日夜后，迎来的朝阳更加痛彻心扉。  \n人被生活的枷锁所桎梏，在挫败与困顿中抗争，于失意绝望后而觉醒，坚韧的人性之光方显弥足珍贵。  \n“与天斗，其乐无穷。”\n  \n46、原以为最辉煌的日子是未来，没想到竟是毫无建树的过去，宛如雨后的积水只能映出一点赛博的霓虹，根本无法与日月争辉。又是入夜只留我暗自唔泣，待到朝阳氲氤被叶尖的露珠顶替。\n  \n47、我不是三峡好人，也游不到海水变蓝，我只是小武在站台上用一个桶所装载的忧愁。\n  \n48、22/10/13，在如此严峻的秋招环境中，有的人收获米哈游和网易雷火的offer，而有的人还在失业，我却一心只想摆烂当个废物，事实上我也完成了我成了一个只会摆烂自怨自艾的废物。  \n49、22/10/14，库洛测试题做的一塌糊涂，根本比不过别人，所以我选择摆烂了，技不如人，菜的自己想哭了，突然发现以前别人开的玩笑可能是真的，自己真的一点技术含量都没有。  \n50、22/10/16 18:21 如果能够死得壮烈我一定不会犹豫因为生命已经让我没有了欢愉，但我却不敢结束一切，因为我懦弱到了只想死去。  \n我不知道自己什么时候死了，我也不知道自己活了多久，只能记得如弥留之际看到他人的痛彻自己竟也受了感动，连一个死人都扮演不好，也许最终归宿也找寻不到了吧。  \n51、22/10/16 18:38 如果我死了请不要为我悲伤，用礼炮为我欢呼；如果我死了请不要怀念我，我的一生毫无建树；如果我死了请不要为我歌唱，因为我是生活的败者；如果我死了请不要为我激动，因为我是空中虚无；如果我死了请把我忘记，因为我已经离去。  \n52、22/10/16 18:38 我一直都是生活的失败者，做着不切实际的美梦立下旖旎的目标麻痹自己，现在秋天过半，寒冬踏着欢歌来到，朝露褪去夕阳沉沦，夜带着星光皎洁，我的梦也该醒了，早已枯死的花是时候凋落。  \n53、22/10/16 18:42 我还记得欢乐的感觉，沐浴在阳光里的温暖，但我未来马上就会将他们遗忘，曾经我体悟到的欢乐以后再也没有了，想到这在看见那阳光动人的笑脸，我的十指就刺痛了起来，原来快乐也会给人悲伤。  \n54、把狂妄无知当作清醒，把诡辩欺诈当作真理，拉帮结派狐假虎威狗仗人势，有什么可夸耀的，简直令人恶心至极。  \n55、如果不能在平静的海面上，补到伏在水底的鱼，便会寄予希望于疯狂的海啸，哪怕这灾难将会把自己席卷，破灭而来的希望也比枯死的等待更靓丽的多。\n  \n56、后来张之铭留在了平昌，他和以前一样早上会去书店门前的大树下看落叶，只是从此以后与他为伴的唯有晨朝的寒气，他就这样在那里等着，在秋季的冷风中。  \n57、我曾经的朋友已经许久未见，今日方得知原来她早就去了美国，群里的大佬知识技术也十分雄厚都有了不错的工作，有的人去了米哈游，有的人去了鹰角，看到他们我无比的羡慕，那是我曾憧憬的生活。但我的水平与他们差得太远，只知道自己差的多了，不会的多了……不知道心里这种感受是什么，也许是落寞吧。  \n58、每个人都喜欢酷姐姐，就像每个人都喜欢死亡。  \n59、如果爱就不要接近选择离开，爱和生活虽然都很难，但生活不是爱，爱也不是生活。  \n60、好冷啊，原来已经是冬天了吗？  \n我原以为我可以熬过这个冬天，但是素色的和服我终究没有收到，我想我应该不会活到夏季了。  \n61、安逸只能带来晨昏的死寂，而唯有痛彻方能焕发振奋的创作。  \n62、成长就是学会遗憾。\n  \n63、深情的缠绵尤为沉痛，人生的豁达也同样可贵，有的人死去却被人们怀念在心中，人生的感动永远留在民族的心中，作为我们共同的回忆。  \n64、世人多叹英雄迟暮，丈夫壮志难酬。惜少年踌躇，豪杰壮志，最后时过境迁物是人非，天下不定，生而不能如愿，如何不叹？  \n“死后葬于城北！”  \n“朕不能为弟报仇，虽有万里江山，何足为贵？”  \n“悠悠苍天何薄于我！”\n  \n65、发现自己找工作就像段誉和王语嫣聊天，王语嫣只想表哥，段誉却痴痴地想着王语嫣，面试官想要顶级人才，我却妄想一个工作机会，“我这辈子要是能一直哄着你开心就知足了”，我要是有一份工作就知足了。\"我不喜欢和轻浮的人交朋友\"，你好像不太适合这个岗位。  \n66、鸠摩智这个角色真是颇有佛缘，身为大轮明王通晓佛法道理，又有一身的武学修为，受人\"指点\"千里迢迢来到大理，段誉授其逆练心法，不曾想竟能成功练成少泽剑。  \n67、想不出活下去的理由，眼前所见都是赶快死去的事实。人生的旅途还未开始便受了一身的病，理想尚未起步，行业的寒冬就已经到来，千疮百孔的心智，学艺不精技不如人，残存的人生仿佛一眼就望到了头，我失去了活下去的理由，只能想到死的绝望，因为我是最软弱无能的妖怪。  \n68、GenShin上ys没什么好评价的，都说烂了，鸡场加堵场。从米看前有画月发家史，再有前车之鉴绷绷绷，从羊看前有尼、谷、丁，尼古丁，还有人搞什么“两岸猿声啼不住，轻舟已过万重山”，只有你是高贵的，狭隘的闵翠主义，”不识庐山真面目，只猿身在此山中“。  \n69、tnnd，都tm的怪段正淳！cao！  \n70、他人入我门，善果非常，我门破戒悔，罪无可恕。  \n71、打扰一个人的美梦残忍，还是让他沉沦其中残忍，我分不清。  \n72、每次看到那么奢华富贵的生活，我都在怀疑我是在革命前还是革命后，有时候再看几期牛事，我便更分不清了。  \n73、怎么样才能活下去啊。  \n74、我的人生这么funny，我是不是应该去做喜剧演员。  \n75、*西湖好，西湖好，九州百姓乐眉梢。群妖伏，魔首逃，九州春风万处飘，壮志凌云鲲鹏鸟，鲲鹏鸟。万圣好，万圣好，万圣明鉴平病灶。除岁炮，春来到，呕心沥血谱功劳。万圣锦旗昭，神州土木牢，土木牢。*  \n76、死亡对我来讲也许真的是甜蜜的，但却会有人因为这份甜蜜而伤心，所以我也失去了品尝这甜蜜的勇气。  \n77、回头看了看自己之前写的所谓感悟，原来我也思考过，也有那么一点有趣，我究竟是如何变成现在这个样子的啊。人都盲目地走在自以为正确的道路上越走越远，越走越远，直到找不到自己。  \n78、事到如今才明白我真正擅长的事啊，我既不聪明也不灵活，我所擅长的只有**逃避**罢了，一味的逃啊，逃啊，从现实逃向虚拟，又从虚拟逃向二者的夹缝之中，我就想躲在阴暗夹层的老鼠，只能窥视微弱的光，没有出去战斗的勇气，因为逃避是我最擅长的。  \n79、你为什么监视我？还是我们本来就都一样，在坠向地面的短暂一生中不甘着，渴望超脱。\n  \n80、事实比故事更荒诞，因为不仅真实还伤人，就在你我每一个人的身边。\n  \n> 前段时间在公园跑完步，看见有一个妈妈带着她的女儿在卖一些便宜的东西，我在她摊子上买了一个钥匙坠，她的女儿大约6-7岁左右，穿着粉红色的棉服，挺可爱的也不怕人。我随后坐在了旁边休息顺便刷抖音，小姑娘看见了就站我后面一起看，我也没在意。抖音视频有一条狗吃各种比较贵的食物。休息一会我准备回家，我听见小妹妹问她妈妈:妈妈，我想当一只狗狗。她妈问:为什么啊，琴琴(是这个读音，不确定字）小姑娘说:当狗狗可以每天吃肉啊，还有零食吃，我看大哥哥手机上的狗狗是这样的，我也想当那样的狗狗。她妈没有接话，只是伸出手扶正了小女孩的蝴蝶结。\n  \nb站狗吃奢华大餐：BV15E411P7Pz  \n我能理解宠物主人有给宠物吃各种各样东西的权力，但是我不甘和愤怒的是这背后更深层次的悲哀，在这荒诞视频的背后是阶级矛盾，是资产阶级对无产阶级的压迫，他们用无产者的辛苦劳动去喂养低贱的畜生，而我们的人民，我们的劳苦大众每天过着艰难的生活，甚至不如那吸血鬼所圈养的一条狗！牢记阶级苦！当阿廖莎再吃二遍苦受二茬罪时，他们会在父亲的大树下想起他曾经的教诲，那是无产者定会胜利，因为不胜利就会像今天一样迈向死亡，而死亡不属于无产者。\n  \n81、我感性时常落泪，有人也说我软弱或许吧，但是我的内心却实打实的痛到流出鲜红的泪。  \n82、你是要成为只会哀叹的懦夫，还是向生活奋起反击的勇者？  \n不畏艰险、不怕牺牲，敢于奉献的探索者精神和只会隅泣的逃兵哪个更值得歌颂。  \n我知道你饱受委屈和折磨，怕血肉模糊的心智再受折磨，可是逃避不能解决问题，愈合的肱骨才会更硬，羊啃食过的青草才会分蘖。  \n83、母弱出商贾，父强做侍郎，族望留原籍，家贫走他乡。    ——施耐庵  \n84、原来荒诞的才是现实，文学作品只是借用。  \n85、我不会拥有 [Happy End] 了，我的路途结束了，[Bad End] 就是我的 [Last End]，也是我的 [True End]。这个世界太糟糕了，我恨透他了，但是我最恨的是我自己，因为我只有 [Bad End]。  \n86、如果没有人关心我，我说出去的话又有谁懂呢？既然我说出去的话没有人懂，又怎么会有人关心我。  \n87、“虚伪”登堂入室，”真诚“嗤笑失意，这个世界已经不适合我了。  \n88、\"丐帮有多少弟子不是我说了算，是您说了算。如果您真的英明神武，又有谁愿意当乞丐。\"  \n89、我想回到过去，因为我能看见那些曾给我带来快乐的东西，曾让我温暖的东西，而未来却是黑漆漆的看不见的冰冷，至于现在……我在想过去。  \n90、\n  \n> 我明明没有喝酒，眼睛里却流出了酒。一想到大叔在某个地方从眼睛里流出酒来，酒就从我的眼睛里流个不停。  \n>   \n> 他明明没有喝酒，酒却从眼里流了出来。  \n>   \n> 嗯，我一直都知道的，MADAO早就开花了。  \n>   \n> MADAO是抛弃了一切英雄色彩的武士，却在每次人生的关键选择上，做出了最英雄主义的抉择  \n> MADAO其实早就已经开花了\n  \n91、我们每个人都是一座孤岛，只是恰巧在同一片海，被阳光映上彼此的影子。  \n92、我是一棵树，一棵树先生一样的树，所以我的根要向下，到那广袤深沉的泥土里去，作他们的一员。  \n93、中国太大了，大到里面装了好几个世界。  \n——神功盖世的吕大侠，源自b站视频[《被挂上热搜的“第一次吃华莱士”，背后藏着最残酷的底层之痛》](https://www.bilibili.com/video/BV1cM411w7D9)评论  \n94、他们是聪明人装糊涂，你以为他不知道？他只不知道咱们过得苦！他只知道怎么去骗我们，却装作不会骗我们的糊涂样子，根本不关心人民的死活。  \n95、  \n每年都有好建议，每年都没见落实，只有一天天变瘦的荷包，和一天天饿瘪的肚子，一天天萎靡的精神  \n一天天疲倦的身体，铸成城市梦幻的霓虹，用我们炽热的青春和血液，灌溉黑色的混凝土，发出耀眼的光  \n又到了夜晚，我很是不安，曾有这样无数的夜，我难以入睡，我一无所长却疲惫不堪，每时每刻都深陷不安。  \n96、看来是找不到工作了，不是被嫌弃菜，就是嫌弃没实习，要么就嫌弃没经验，还没开始就走到头了，人生已经肉眼可见的结束了。  \n97、23届的我最合适的结局竟是横死街头，在时间的长河中没人会在意我，前面有21，22的，后面有24的，只死我一个23的弱爆菜鸡，对这个世界也没有什么影响，时间根本不会在乎，没人关心我这具死在路边的尸体。  \n98、只是我一个人的寒冬罢了，我在广袤的狭小天地之间，踏着笨拙的舞步，雪花一片片排在我的身上，在温暖的春天里把我埋在最美丽的寒冬里，我能感受到他们携带着我的温暖向安逸的天堂飞去，我就在这只属于我一个人的寒冬中笨拙的挣扎，这是世界留给我最后的温柔。  \n99、我知道为什么我一直在寻找自己的影子了，我在同情自己投影的时候，是在可怜自己，我所有的悲痛欢喜愤懑都是为自己，我才发现原来自己是这样一个自私的人。  \n100、有时候真想毁灭啊，因为我所拥有的便是这一点仅存的名叫生命的能量，利用这微弱的力量绽放出不起眼的火花可能是我最大的成就了，但是我却缺少爆炸的勇气，因为我只是个胆小鬼罢了。  \n101、我目前最大的成就就是有关爱我的父母，我最大的罪恶就是没有回报他们。  \n102、不会解决问题只会喊人填表，要是填表就能实现共产主义，那东北大学在新时代就又一次成为革命领袖了，傻屄。  \n从根本上就不关心学生，只想着把自己那点破数据做得好看些，不能切实地帮助学生解决就业问题，那就恳请您别来浪费我的时间，肏你妈的，臭傻屄。  \n不仅浪费普通学生时间，还特么浪费学生干部的时间，臭傻屄。  \n只针对傻屄措施，不针对人，只针对形式主义，只针对情报特科，本人傻屄大龄愤青，脾气暴躁，思想极端。  \n103、“我只能看到一片黑暗，还有老大姐的背景。”杀哥这样说道，背景中是他常用的那首音乐，以往一样哀伤的旋律，竟格外的有诗意，杀哥躺下睡了，明天他还要去那片黑暗里探索生活，而我也一样只不过我看着这黑暗有些许难眠。  \n104、才发现自己C++不会，计组没学，计网没学，操作系统没学，图形学也不会。  \n我大学的四年究竟干了什么，为什么我什么都不会啊。  \n自己学了四年计算机什么都不会。  \n105、我还记得那天是小雨的天气，外面的乌云浮在天上，遮掩着太阳，他很轻松地说道：“我悟了，元凯，我得道了。”，说完他就转身走了，我只看见雨淅淅沥沥地落在他的肩上，后来我也离了道观，就再也没见过他，我至今也不知道他悟到了什么。  \n106、现在是2023/3/11原来罪恶王冠都已经是12年前的作品了，现在的二次元和那时的二次元已经有了天差地别的变化，我还是觉得那时候好，那时候的二次元给人一种独立、探索、思考的感觉、很有生命力比较干净，那时候总是有天马行空的幻想虽然很幼稚但是令人沉醉，如今大部分给我的感觉只是沉浸在娱乐里，我不能说哪种的好坏，因为我是带着滤镜去看过去，只能说我怀念那个时代，那个每部作品都个性分明、独有新意百花齐放的年代，如今的圈子虽然大了，但是我却再也找不到当年的味道了，也很少看新番了，偶尔想翻出过去的番剧看一看，也许我们这些老二次元都已经被生活压弯了腰，面对曾经的热爱已经没有多少力气去燃烧自己的生命，只能看着过去的背影映在夕阳橙红色的阳光里给自己一点安慰。  \n二次元变了，它变得不再是那个二次元了，二次元变了，它变得还是那个二次元。  \n二次元变了，他变得不再是那个二次元了，二次元变了，他变得还是那个二次元。  \n107、我看见棒棒拉了满满一摞的货，比快递三轮车的小仓库都大上一圈，但是他还是跨过公路，向左拉去了，他脸上没有什么情绪，只是一个普通的辛苦工人，日复一日的努力让他对生活的热情和未来的向往都消耗的差不多了，而迎着他开过去一辆不知道什么牌子的豪车。  \n108、为什么别人那么牛而我这么菜，nmd，地球怎么不爆炸。  \n109、“听丁大哥说啊，离咱们这一百多里地就是共产党，这个党啊，是我们工人自己的党，领袖是毛主席，领着好几百万大兵啊，叫解放军，只要他们到咱们这来啊，咱们的苦日子就熬到头了。”  \n一百多里地好远啊，一百多年好近啊，丁大哥，我上了当，我走错了。  \n110、npy问你什么时候跟她回家见家长，你不敢搭话，她说今天的鸡蛋又涨了，你摸了摸兜里的20块钱，皱巴巴的，全是汗渍，你鼓起勇气“我这还有20”，她却说“你拿着吧，吃点好的，在外面干活不容易。”  \n你吃完了饭感觉很难受，晚上你做了梦，梦里你有车有房，让辛苦了一辈子的父母过上了好日子。  \n111、等鸡长大，就变成了俄，等饿长大了就变成了洋，羊长大了就变成了new，牛鬼蛇神长大了啊，就……只有天知道了。  \n112、我是一块残留热血的肉贴在这钢铁、混凝土的树林，用热血和生命去浇筑，待到冷却、待到麻木，在树林中做最后的飞翔，却因桎梏太久只能坠落。他是一块残留热血的肉……  \n113、我要用的文字做一把利刃，像这个冷酷无情的世界奋力反击！哪怕我摔得粉碎，动作可笑滑稽，我也无所畏惧，因为即便我一败涂地，至少我拼劲全力愤怒过、燃烧过、绽放过，纵使这一切没那么绚烂美丽，但这也是我对这个无情宇宙的最大反叛。  \n[失业死宅日记](https://www.bilibili.com/video/BV1HN411F7KV)，[n站原本视频](https://acg.tv/sm11365022)  \n世界是以混沌残忍著称的混蛋，他用利刃把所有的敏感温柔全部搅碎，残酷麻木附着在刃上随着他的死亡之舞做着旋转，所有人在这疯狂的舞步中要么麻木、要么沉沦、要么受伤，然而即便随着他起舞最后也会和遍体鳞伤。他就像一只贪婪的野兽，舔舐鲜血痛苦为乐，也有天才的幸运儿站在中心绚丽的起舞，但那不是我，我只是一个被搅碎的、被蹂躏的发出悲鸣的懦弱的人。  \n每一个对抗生活的人都是勇敢的战士，即便普通却不意味着他们平凡，平凡是扎向他们的武器，在这场和自我、和世界的无尽对抗之中，踏上战场已经是一种荣耀。  \n114、明明判决的是违法者被绳之以法，可最后回头看来，却是一桩桩由人性深处的幽暗引起的惨案和悲剧。  \n115、以前我不知道为什么有人会觉得动漫角色是活的，我虽然很喜欢动漫，但是我应该只是觉得故事有趣，角色丰满，画面美丽等等，我应该是知道那些只是假的，是文学创作，直到今天听到ai阿尔托莉雅翻唱的富士山下，我真的获得了来自动漫角色安慰，我突然觉得她真的活过来了，就在我身边。  \n116、“别以为父母和钱和年轻和房间和T恤和我和你和银魂动画永远都有”\t——空知英秋  \n117、  \n“tmd“  \n”好像把人全杀光了啊“  \n”但我没本事只能杀我自己啊“  \n”我好像真的不正常了“  \n”是因为周一吗？“  \n”要是能永远都是万圣节就好了，这样大家都会以为我在Cosplay了“  \n118、像你们这种人中龙凤，英才豪杰自然是体会不到我等平平之辈的痛苦的。  \n119、我病了，我患了一种怪病，在这个冰冷的混凝土的世界里，在这个现实和虚幻边界愈渐模糊的时代，我渴望温暖，怀念过去，时光在一声声的排风中逃走了，我的思绪不知在哪里，我病了，我患上了一种奇怪的病。  \n120、我只是一个普通的人，一个再普通不过的普通人，我和你一样过着普通的生活，或者你比我艰难得多，或优渥得多，但我是像千千万万个这样的我一样平凡而普通的人，我只想用我自己的汗水让父母过上好的生活，我只想实现那仅存的支撑我活下去的所谓人生理想，我和千千万万的我一样是一个普通的人。  \n121、我这几天要动用我全部的思绪把他们都写下来，因为我马上就会离开这个世界，这是我能留给这个世界最后的东西，也是我能留下的唯一的痕迹了，但是在这个信息如海般的世界，我的文字只是空中微末的尘埃，后来的人啊不要像我一样，要努力地学习，要勇敢地去生活，去解放我们哪些还在遭受苦难和压迫、剥削的兄弟姐妹，不过这一天我终是看不见了，我要把我的肉体埋葬在一片鸟语花香的地方，这是我能想到的唯一的美好，我要把我悲哀的思绪带离这人世，若这世界上有我这样的悲哀那就只让他在我一个人身上发生就够了，我悲哀的灵魂我低劣的思想把我的人生带入了一场不能回头的悲剧，熟悉的陌生人啊不要重蹈我故事的覆辙，把我作为你的反面教材勇敢的前进下去吧。  \n122、刚才突发奇想的最喜欢的音乐制作人应该是[梶浦由记](https://zh.moegirl.org.cn/%E6%A2%B6%E6%B5%A6%E7%94%B1%E8%AE%B0)老师，啊，每次听到《晓之车》总是很感动，内心深处的某些东西被触动着，这样的歌实在是太优美了，有着很强的力量能够直击听众的内心，仿佛是只有在天上才能听到的，用中国话来说就是，“此曲只应天上有，人间能得几回闻”，这句话出自唐朝诗人杜甫的古诗作品《赠花卿》，那也是一首很美的诗。  \n123、没有神仙救世主，同志们我们只能靠自己！  \n124、重读《范进中举》有感，范进回到家只有挨饿多日、瘦骨嶙峋的母亲，母亲让他变卖了家里仅存的下蛋的母鸡，范进走上集市去买鸡，却被这社会又毒打了一顿，他倚在墙边，拖着满是伤痕的身体困倦了，恍惚中他看见有人对他说他中了举人，在这场举人梦里他发了疯，周围的人也发了疯，我也发了疯。  \n125、当阿廖莎在生产队的枯树下，吃二茬苦遭二茬罪时，会拾起他的思想，我们会找到一口井，他们当时就是在那样一口井边出发的，这口井会在各个地方涌现，这场征途我们只能靠自己，而且过程必然是残酷的，是要流血的，注定是不温和的，纵观过去温和的结果往往是招来团队的毁灭。我们是不怕斗争的，是不怕死亡的，我们是一定要胜利的。  \n126、别人一张嘴就是ssp，年薪百万，轻松的工作，优秀的同事，优渥的工作环境，充满前景的发展空间，而我只是想找一份游戏行业的工作养活自己，减轻父母的负担，我错在哪里，我不知道。  \n127、《西游记后传》还是不错的，《西游记》讲了一直发生的事而且很隐晦，其文学价值无需多言，而后传虽然通俗一些，但是讲的现在的过去发生的事，那时候的事都不提也看不清，但是他却讲了这么一个事，看起来很有意思，当然导演本人肯定没有这个想法我只是自己看着自己瞎想好玩。  \n128、鲁迅真的好厉害，他活在那么久之前，却清清楚楚地看清了我的样子，把我的现况，作为往事一篇篇写下。  \n129、人们不关心我，他们只在乎自己，他们凑过来不过是因为我的悲鸣比较可笑，他们只想听一声沉重的闷响然后在发表一些感动自我的深思，这之后人们就再也想不起来了，仿佛这一声闷响从未发生过，他们又等下一声闷响去了，却不知下一声闷响可能就是自己。  \n130、我像一首不符合时代旋律的歌，在时代的合奏中我的旋律格外刺耳，充斥着违和感和不协调。我融不进这美丽的时代，我在他们的映衬下是一首悲伤的歌。  \n131、怀着满腔热血想进入游戏行业，还没跨出半步就被这寒冬冻死，我像一块受了潮的木头，内外都感到刺骨，只希望我在最后能发出一点微弱的热量给这口炉子增添一点温度，此后便没有了我这块薪柴。  \n132、短评浅析[小岗同学葬礼](https://www.bilibili.com/video/BV1Vm4y167AC/)人未死去给自己办了一场告别仪式，我觉得还是挺有艺术气息的，人的内心深处都有着死亡的冲动，他用一种积极快乐的方式去向过去、向自我发起一场单方面的告别，因为这场和过去自己的告别是无疾而终的，从事实而言是无法达到的，从心理上讲是一种自我的分割。他用这样一种方式对自己发起反叛，对社会的固有认知发起一场属于自己的浪漫冲锋，他用众目睽睽向世界宣布过去死亡的宣言，然后让自己能够向着未来发起一场新的冲锋。  \n133、我恨人类，所以我挥刀向自己砍去。  \n134、理想主义者是这个世界最浪漫的人，但世界并不浪漫，所以理想和现实碰撞出的火花才格外绚烂。  \n135、有的人是真的逆天，就像我朋友说的“铁拳没砸到自己头上觉得自己挺能耐”，能说出比“何不食肉糜”还逆天的话，古人诚不欺我也。自己站在风口上便以为自己是时代的弄潮儿了，可惜这种人目光短浅又毫无同理之心，命比时代的浪还要短，只能看见自己顺着波涛拍动两下翅膀，看不见此波退去，下一波浪潮来临时的悲哀内有千百个自己的悲惨死相，还在这摇唇鼓舌，真是可笑，不骂他个八辈祖宗都是给他的面子了。  \n136、理想主义者是这个世界最浪漫的人，但世界并不浪漫，所以理想和现实碰撞出的火花才格外绚烂。  \n137、已经等不及想看后人如何评价我们了，自轰轰烈烈的公运失败后，这些叛徒朝着准备主意方向走去，却为了得到人民群众的信任不敢去承认，搞几波枪打出头鸟，后来再也没人敢在公共场合讨论，在网上日常说话发表评论都有敏感词看着，和过去的文字狱别无二致，阶级固化日益严峻，阶级矛盾愈演愈烈，过去地主小姐之流又出现在了这片土地上，革命先辈的血当真被这些投机倒把倒行逆施的叛徒们搞得白流了。  \n照这样看我想歌名的时间就快来了，不知是百年还是多久，这漫长的等待在史书上可能只有短短几页，但是一个人可能耗尽一生可能都望不到曙光，希望以后我们能实现真正的共产主义。  \n史记三页纸为轻，人生百世命何沉。  \n138、如果生活需要喜剧演员那我一定是一位出色的影帝，但是生活是一场闹剧，而我却偏偏里面演了一出喜剧，所以显得格外的悲剧，但是喜剧终是要人笑得，所以最后大家都露出了开心的笑容，只有我留下了悔恨的泪水。  \n139、“我只是想毁灭掉，这个，腐朽的世界”  \n既然超脱自我是如此的困难，那么追求毁灭和堕落，我想也是理所当然，情有可原的。  \n得不到的就期盼着它毁灭，还要在走向死寂的昏暗路口乞怜他人的宽慰，我不值得任何人为我哀叹，我不配任何人为我歌唱，我不配为任何人所留恋。  \n后来的人啊，如果你在人生的路牌上看见我的这番话，就不要像我一样沉沦，去冲破这命运的诅咒，去打破这可悲的诅咒，去勇往直前的做吧，去不断进取、不断学习吧，去放开手勇敢地爱吧，去活出精彩的、只属于你自己的样子吧。  \n后来的人啊，不要成为前面的人。  \n后来的人啊，祝你拥有幸福美满的一生。  \n140、后来我才知道，同理心是一种可贵的品质，这种品质不是每个人都有，甚至有的畜生遗忘了它。  \n141、网络真神奇啊，每个人都在上面聊着自己，对他人漠不关心，看似彼此能聊以安慰，仔细一看人家只不过在宽慰自己。  \n142、我一直都沉浸在难过的情绪中，以至不能自拔，我想痛苦也是一种毒药，而我就是他的吸食者。  \n143、我本质是一个糟糕透顶的人，我只是把我理想的样子伪装出来罢了，我一直都是祥林嫂，只不过在我死前呻吟一两声罢了，鲁迅在数十年前就写尽了我的荒唐。  \n144、因为我毫无建树，有没有特点，而且性格屌差，长得也丑，上有年迈的父母，我不能创造美好的生活报答他们的养育之恩，对于社会也没有帮助。  \n145、其实很多时候你们看那些我说出的哗众取宠之语，很多都是我肺腑之言，但是在这个荒谬的时代就成了令人哂笑的笑料，太多力，一时反而说不上来，就像面具戴在脸上时间久了就不自知了，就像悲伤沉浸其中时间久了就以痛苦为常态了。  \n146、生活是一个温柔并残酷的对手，他温柔的地方在于用名为平常的毒药渐渐损食人的心智磨灭热情和冲动，待回过神来已经在平凡中不能自拔；他残酷的地方在于这一过程没有表征，当看见别人鱼跃龙门时心中不少悸动，但是在两三下的挣扎后又再次沉浸在这沉沦的毒坛中。  \n若是你凭借超凡的毅力和坚韧战胜了自我，他还有压箱底的把式，用最残酷的方式终结你的抗争，可能是身体的也可能是精神的，正因为这对手如此的可怕，我们才会敬佩歌颂哪些坚韧不拔的英雄。  \n147、在心理学上有一种概念叫“缺失取向”，就是说一个人越是缺少什么越是表现什么。一个人越是极端地去表现积极乐观，他的内心就越是脆弱不堪，在他几近疯狂地、甚至令人感到违和不适的快乐面具下，可能隐藏着的是一颗遍体鳞伤的心，就像一张拉满弦的弓，一旦松手便是崩坏般的毁灭。  \n这种积极是悲哀的，只是在欺骗自我罢了，在生活中我曾见过这样的人，他是自知的，但是他无法放下，因为他弓弦的另一端是沉重的6便士，我什么都做不了，我听见他的笑声一下下刺痛我的鼓膜，看到他扭曲疯狂的笑容一幕幕映入我的眼帘，令我身心都感到些许的不适，我并不反感、或者说我没有资格反感，我只是感觉悲伤罢了。  \n148、我经常回忆过去因为他离我遥远、朦胧我能随意的想像令他完美，我不敢去想将来因为那是未知，我用尽一切方法逃离当下以远离未来，但无论我逃去何方他总能追上，在我于当下困顿时，我又想起过去，在过去中我从当下迈向未来。  \n149、骑士在扮演小丑，小丑在扮演骑士，这是个荒谬的时代，人们戴着不属于自己的假面，展露容颜者被称为异类，粉末假饰者收获赞美，人们被虚幻迷盖，对真实漠不关心，肉林的霓虹掩饰了沉重的担子，眼帘中都是狂欢迷醉，而死亡毁灭接踵而至。  \n150、和生活的这场战斗没有胜利可言，一旦开始便没有归途，最后的结果莫不是和解便是毁灭。  \n151、我想我是一个自私的人，每当我有所思考都是从自我的角度出发，很少想到他人，而想要说些什么欲从他人角度进行阐述，又有些不好意思，不知从何处下手。这应该是一个坏习惯我应该改一改，但是我又不知道怎么开始，很多事情我都是这样的，想要有所改变却迟迟迈不出手脚。  \n152、之前一直不理解《太吾绘卷》里的武学逆练是什么，因为在过去的教育过程中都是专心但粗糙地学习书本上、学校教授的知识不太理解，后来看见一个视频标题叫[[《官僚主义如何逆练群众理论》]](https://www.bilibili.com/video/BV1TX4y1z7D5)，再想想现实中藿香正气的例子便有些明白了，懂了理论但是为了自己的利益和欲望反其道而行之达到自己的预期，背离了知识的思想初衷，现在想想真是唏嘘。  \n153、我终是没发出光的，在这个炫丽的时代，寒冷的雨夜浇灭了我稚嫩的荧光，绮丽的世界不再希望炬火，因为和未来感的世界相衬起来是那么格格不入，在华丽的舞台背后，我在垃圾桶里等待死亡。  \n154、“莫说你一个宋慈就是十个八个也休想把这浑浊的世道变得天朗水清”，随着一把大火所有的罪证都化作灰烬，这些个衣冠禽兽都作了清白之身，刁光斗死在法不责众的乱拳之下，这场游戏，宋慈输了，刁光斗也输了，获得胜利的也只有王权一人，这场游戏从一开始就注定是王权之下的一桩悲剧罢了，所谓的你争我斗平反冤案，也只不是在王权的平台上的一幕而已。  \n155、人们总是在幻想中寻找认同，希望自己拥有打败一切的力量，希望自己能面对挫折坚毅不拔，从能打爆一切的勇者、拥有无数朋友的冒险家，面对残酷生活依旧坚韧的主人公，人们总是把自己的希望向外投影并追寻，但是摄像机是永远追不上投影屏的，想要成为幻想中的存在要自己行动。  \n156、我很害怕“结束”，仿佛只要没有“结束”一切都还来得及一切就都还有机会，我就还能在做些什么，但是“结束”是无可避免的无论如何逃避都要迎接“结束”。  \n157、今天是2023/05/11，晚上11点就是是《塞尔达：王国之泪》发售日了，在这个平凡的日子，世界上最伟大的游戏续作发售了，在这个伟大的发售日一切都那么平常，一切都仿佛没有发生，母亲还是在做饭，父亲还是辛苦的工作，我还是一如既往的失业，我还是没有解决生活的难题。虚拟世界的伟大波澜击不起我平凡生活的一丝浪花，人们用虚拟世界的梦幻来装饰糊涂的现实，世界上最荒诞的现实主义就在我身上发生。  \n158、突然想聊聊王家卫的抽帧，这种抽帧的手法营造了一种不真实感，这种不真实感就如同做梦，用这种去真作幻的手法去给观众想像感悟的空间，人在回忆时想像力是最强的因为不真切却又想极力看清所以就用想像弥补了空白，而王家卫的抽帧留给观众的是留白的画面，引起观众潜意识的想像补充，所以给人一种朦胧和梦幻的感觉。  \n159、我见过一家工厂，那里的材料要交钱才能变成罐头，这材料也是要分三六九等的，有的走了高级通道便通到什么堂皇的所在，不过我看应是颠倒过来的，叫荒唐才对。这样的流水线效率可高的呢，若是哪个落了队脱了群断是要不得的，他们说这是现代化，我是不懂的。  \n这样造出的罐头终是卖不出的，因为味道是差远了的，倒是那些堂皇的罐头是炙手可热的玩意。  \n160、那时候还有每天都会弹出来的腾讯新闻，可是这粗糙又美好的一切都成为了只能追忆的过去，眼前只有疲于奔命的现实和逐渐被压垮的身心，如果可以我希望在这场名为现实的噩梦中，回到过去。  \n161、无产者的哀伤竟被小资产阶级篡夺，作为生活的调剂和故作高深的资本，他妈的，你配吗？恶心。  \n162、人生的顿悟和无知竟是极为的相似，在无知时对自我没有喜欢讨厌不知其为何物，在学习中发现自己的闪光点心存喜爱不足心存悔过，这一过程知晓喜恶，在最后顿悟时接纳自己的一切有回到无厌喜的状态，虽然相似，但是也许应该有不同吧，我在漫长的学习过程中回滚到了无知的深渊，那顿悟的一朝我想我终是达到不了了。  \n163、  \n如果今天是你最后一次看见我，  \n你会对我说什么，  \n我想你什么都不会说，还会觉得我莫名其妙，  \n所以这结束还是由我来说更合适，  \n“再见，我将要去往新的明天。”\n  \n164、现在是2023/05/22晚22:02我的精神越发的不振了，我的精神几近癫狂，我想我很快就会病倒了，或者结束这一切了，我将死亡。\n  \n165、我是在做梦吗？我想这应该是一场噩梦吧，毕竟整个世界都没有人理睬我，难道我在梦里都不受人待见吗。在梦里也会肚子饿吗？在梦里也不能受到别人的眷顾吗？在梦里也不能受到他人的青睐吗？  \n那梦和现实有什么区别吗？那我还是在梦里死去吧，这样比较浪漫。  \n在自己的梦中死去算是自杀吗？在这个和现实一样悲哀的梦中死去。\n  \n166、“只要你还没意识到自己并非无所不能，那你就还是雏鸟。”\n  \n167、别着急，没什么，弗拉基米尔·伊里奇，他只是而昏过去了，等他醒来世界将再次插满红旗。\n  \n168、明年也许会有，也许不会，但是明年我的青春一定没有了。在每日的时光流逝中，随他而去的还有我曾以为无穷的可能性，我的一切生机活力都在慢慢消失，有人说这是长大的代价，但我只感到了死寂的悲凉。明天的太阳会再次升起，但明天我的生命也许不再蓬勃。\n  \n169、\"我的瓦西亚死了，\"妇人安静地说，悲哀的眼泪又沿着她憔悴的脸颊流下来，\"自然我的日子也完了，我活活的给人把心挖了去。然而汤是不应该糟蹋的，里面放得有盐呢。  \n---屠格涅夫<白菜汤>","source":"_posts/New-Start.md","raw":"---\ntitle: 思绪之海桶狭间(\ndate: 2022-04-08 22:25:16\ntags:\n---\n  \n## 隔离期间\n  \n隔离期间搞一个自己的blog。  \n原名`New Start`，  \n记录一些自己的感悟。\n  \n<!--more-->\n  \n## 闲言碎语\n  \n1、刘明翼和周帆要考研了，杨崇兴过两天就要去实习了，只剩下我在所剩无几的大学时光等待着琐碎破败的人生到来，这个时候我才知道我曾做的一切是多么想暂缓逝而不返的时光，然而残酷的现实是——一切都是徒劳，生活没有什么预兆、也没有什么标识，一切就这么发生了，没有惊天动地的变故，没有振奋人心的庆典，一切都是那么平常，而这平常就是生活最大的残酷。\n  \n一切都随着流水走向着尽头，走向着开始，而我注定和从前一样缅怀在自己卑谬的过去中，难看地呻吟。\n  \n2、年龄越来越大，越能明白有个能畅所欲言的对象是多么可贵，如果这个对象能回应、甚至帮助你那就更为可贵了。有些话有些事只能自己挨着。真羡慕那些什么都能说，肆无忌惮的人，好轻松。不知什么时候开始，彷佛依赖上了内心流血的状态，就像用舌头舔刀刃上的血，明明血不会止住，反而迷恋上血的味道。\n  \n没什么办法，那些面对巨大挫折却仍能坚持下来，没有丧失心智的人原来是这么的强大。\n  \n> 世界上只有一种真正的英雄主义，那就是在认识生活的真相后依然热爱生活。\n  \n3、全部是真实的，却是虚假的。\n  \n用虚伪的去描绘最为真实的。我们的现实我们的感受，是虚伪的还是真实的呢？\n  \n是他人的传递，还是萌生于我们的内在呢？我不知道，不管是自己还是他人，不同的真实也许是相同的虚幻，不同的虚幻也可能是相同的真实。我又在什么时候迷失了自己的灵魂呢……\n  \n> 全都是真实的 却是虚假的  \n>   \n> 用虚伪去描绘真实的  \n>   \n> 用真实去欺骗虚假的  \n>   \n> 我们的空洞眼神里  \n>   \n> 诡异着 映射着 敏感着  \n>   \n> 奇幻色彩的爆炸波\n  \n4、明知是熊熊的烈火、不知前路如何，却仍能为了改变现状，为了更好的未来毅然献身，这样的理想主义者值得我们永远歌颂，如此高贵的品格才是人类最为珍贵的。也许有人歌颂英雄只是为了能让自己当个懦夫，但是我相信对英雄的呼唤和歌颂能唤醒这个世界隐藏的光明。\n  \n5、昨天洗澡的时候突然发现自己为什么有屯物癖。小时候家里条件不是很好，每次自己有了新东西都会很开心，可是时间久了东西就会坏掉，我失去我的这些最珍贵的东西时我十分伤心，所以再后来就喜欢“备份”，同样的东西要有很多才会安心，总是怕他们离我而去，慢慢的慢慢的就成了无意识的举动，堆着堆着就成了习惯。也许我不是屯物癖吧，我只是害怕失去的感觉，堆积备份追寻自己的安心。\n  \n6、我从不幻想着自己是特殊的、特别的，我只觉得自己是异常的，另类的。\n  \n7、我不再年轻了，我开始听伍佰，开始知道人生总是充满着不完美，人生就是一个慢慢填满遗憾的过程，我不是在说自己变得成熟，只是觉得有了什么从前从未有过的感受，我不知道这种感受叫做什么，他们都说这叫长大，可是长大真的是这样吗？别人也会和我一样忧愁、抑郁吗？问题会有答案，但那也只是在教材上，生活中大多时候问题是没有答案的。我不知道，我不知道，我不知道。\n  \n8、这个世界这么大，大到没有我的容身之处，而这个世界又是这么的小，小到我都不知道游乐场在哪？也许这个世界就是这样，像快乐套餐里没有快乐一样，荒诞合理。\n  \n9、\n  \n> 前方啊没有方向，身上啊没有了衣裳  \n>   \n> 鲜血啊渗出了翅膀，我的眼泪湿透了胸膛  \n>   \n> 飞翔着强忍着伤，逃离了猎人的枪  \n>   \n> 我的双脚没有了知觉，我的心情下冰冷的雪  \n>   \n> 亲爱的母亲挚爱的朋友，我会坚定好好的活  \n>   \n> 沉默的大地沉默的天空，红色的血继续的流  \n>   \n> 纵然带着永远的伤口，至少我还拥有自由  \n>   \n> 飞翔吧飞在天空，用力吹吧无情的风  \n>   \n> 我不会害怕也无须懦弱，流浪的路我自己走  \n>   \n> 那是种骄傲阳光的洒脱，白云从我脚下掠过  \n>   \n> 干枯的身影憔悴的面容，挥着翅膀不再回头  \n>   \n> 纵然带着永远的伤口，至少我还拥有自由  \n>   \n> 纵然带着永远的伤口，至少我还拥有自由  \n>   \n> 至少我还拥有自由，至少我还拥有自由  \n>   \n> 呜——  \n>   \n> ——《白鸽》伍佰\n  \n10、当她看见我没有所谓“餐票”便要阻止我就餐时，我仿佛看到了那个使用粮票、饭票的时代，那时候我们还是可以胜利的，贪婪的投机者和黑心的资本家还没有破坏我们的宝贵成功，我们走在一条崎岖但蓬勃的道路上。\n  \n可是我面前的这一景象和那时已经截然不同了，她口中的那张纸不过同“优惠券”，“代金券”这些促销手段一样，是那些吸血鬼的把戏，一个劣质的谎言罢了，只不过是为了中饱私囊掏空他人腰包所想出来的卑劣的技俩罢了。\n  \n11、你这么费力有什么用，到时候人家不过是领着ta去道个歉认个错，这事情也就罢了。上面松松口，走动走动，也就过去了，上面都松了手，你在底下还能一直死咬着不成？  \n我今天还就和你把话说透了，我倒是要教教你这法是什么法！法就是皇帝的法，就是皇家的法，任你个小芝麻再怎么搅和也休想把这官场给搅得天朗水清。咬到了最后你也只得落一句：“算了，草草结案吧！”\n  \n12、某些所谓顶流，不过是套了个炫丽的虚假的外壳罢了，拿着剥削来的资源卖弄起来，竟也装做出砥柱的样子，不禁令人作呕。就像是马戏团的小丑换了一套滑稽的万圣节戏服罢了，里面装的都是铜臭糜烂。\n  \n13、为什么一定要有什么思想、什么主旨呢？只是看着难道就不可以吗？  \n就只是看着就不能感受到作者传递出来的感情、思想、观念了吗？我一直认为人心是十分奇妙的东西，是强大的东西，我觉得就像这样看着他的感受也能传递给我，在潜移默化地影响我。只是单纯地看着就不可以的话，是我们太小瞧了这副作品，还是太小瞧了人心。\n  \n14、我一直觉得土地很神奇，春种秋收。播下种子挥洒汗水，在种地种菜的过程中憧憬着未来，憧憬着美好的明天，用自己的劳动换取美好的生活，切身感受自然的奇迹，在这个过程中自我彷佛得到了救赎。  \n人终归是自然的一份子，在这个种菜劳作的过程中，也许也是我们追根溯源，回归自然的一个过程。作为自然的一员，这种回归的过程带给我们慰藉和安逸，让我得到身心的放松，道教认为小孩子生下来是最完美的，先天之气完足，没有尘世的侵扰，我认为某种程度也是一种我们人类最贴近自然的状态，神完气足和自然融为一体，和自然同在，感受美妙的世界，体悟生命的奇迹，让我们能够放下世俗的争扰，去追寻自己真正的内心。  \n*对了，黄瓜和苦瓜别种在一起，会串花粉，黄瓜会变苦的。*\n  \n15、我很喜欢给事物带来终结，或者说是去感悟事情的结束，因为我从小时候见到的一切，他们的结尾总是那么令人铭记于心、痛彻心扉，这样看来，结束彷佛是一件美好的事，可是真的是这样吗？是结束太过痛彻心扉，刻在了心上，造成了一种感情的涟漪让我感动，还是结束真的是一件很美好，值得铭记的事情？也许这两种都是一样的吧。  \n思来想去我只能说我不知道，彷佛生活不知从什么时候开始就变得很复杂，什么东西我都搞不太懂，也许复杂的不只是生活，或者说复杂的根本不是生活，复杂的是我。也许生活本来是很简单的，只是我太复杂了，所以把生活搞得也复杂了。诶，又或者说，生活很复杂，然后我被生活搞得很复杂……你看很复杂吧，我完全搞不懂。我不知道诶。\n  \n> 所有年轻人，年轻人，年轻人，问题出现我再告诉大家！\n  \n16、明知是假的却只能依赖，因为不这么做便活不下去。  \n或许人类注定是悲哀的生物，但是悲哀的命运也不妨碍我们去追寻美，去创造美。  \n即便是悲惨的命运也能创造出无比美丽的生物。\n  \n17、言语稚嫩，文笔不成熟又怎样呢？心中这份感情可是货真价实的，不把这么美妙宝贵的情感写下来的话，不是可惜了吗？是自己的可惜，也是全人类的可惜哦~  \n用自己的语言，文字记录自己的情感，没什么好难为情的，这是一件无比浪漫，足够引以为傲的事情。因为稚嫩的记述本身就是动人的。\n  \n18、\n  \n> 逃げちゃ駄目だ，逃げちゃ駄目だ，逃げちゃ駄目だ。\n  \n19、<ruby>燃烧了…<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">燃えたよ…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>直至雪白……<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">まっ白に…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>已经燃烧殆尽了…<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">燃えつきた…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>只剩下雪白的灰……<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">まっ白な灰に……</span></rt></ruby>\n  \n> <ruby>燃烧了…<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">燃えたよ…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>直至雪白……<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">まっ白に…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>已经燃烧殆尽了…<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">燃えつきた…</span></rt><span class=\"template-ruby-hidden\"></span></ruby><ruby>只剩下雪白的灰……<span class=\"template-ruby-hidden\"></span><rt><span lang=\"ja\">まっ白な灰に……</span></rt></ruby>\n  \n20、挽救烂尾的方式之一：播放结尾的时候配上最悲情、悲壮的音乐，不时穿插之前的回忆，人物不要发出声音，声音只放bgm就行，~~最后来个意识流从天空俯瞰，所有人围着主角，然后突然黑掉屏幕，赫然打上几个大字：“全剧终”~~。\n  \n21、最宝贵的情感只属于自己，若是有人能感怀一二对于自身来说便是极大的幸福了，很少有人去体悟别人的感情，自己的感情终究是属于自己的，他人不会关心，纵是共情，也是他人的悸动。\n  \n22、不深入涡流直面深渊，便没有评价的资本。\n  \n> 没有调查就没有发言权\n  \n23、没有能力的勇敢就是鲁莽，自己没有能力就什么都保护不了。\n  \n24、后来我才知道你也和我听一样的歌，我们也都一样，曾一样愤懑，曾一样踌躇，我不知道是什么样的原因，不知道是默契还是缘分，还是同样的时代背景，家庭环境？不，你应该过得比我好，一定要比我优渥。我很想浪漫的说，你我的相同是命运的馈赠，是千古最长情的缘分，可是也许这份共同是这个时代带给我们每个人的。  \n珈乐和焰火青年。\n  \n25、我突然明白了，我的心上已经有了口子，虽然会愈合，但是随着悸动，它的伤口会崩开、流出血来，想要止住血只能拿新的伤痛插在上面，可是这么一插血是止住了，也造就了新的创口。\n  \n26、其实张之铭每次晾内裤都会踩着杨崇兴的凳子，放心是脱了鞋的，这样的小恶作剧对于张之铭来说也算是一种乐趣，可是杨崇兴去实习了，张之铭再也没踩过那张凳子，也许是因为那个人走了就不再回来，也可能是因为那个人把在寝室剪头用来围脖子的破布放在了凳子上，张之铭怕脚沾上头发茬子。\n  \n27、网络浪潮有最迅猛的两个时候，一个是ta诞生的时候，另一个就是ta死的时候。\n  \n28、当我们欣赏过去的经典追忆过去时，是不是在追寻着眼中那个人的步履。聆听过去，也是追寻过去，体悟过去。\n  \n29、其实无私的爱是无比宝贵的，是可遇而不可求的，可是因为我们大多数人出生便得到了父母无私的、厚重的、广阔的爱，导致我们以为这种爱是常见的，乃至更有甚者认为是没有价值的。  \n等我长大与人接触后，才发现没有人爱我自己，曾经“最廉价”的爱居然是那么昂贵的。对周遭急切的期待，往往迎来的都是冰冷的“款待”。爱是一种可贵的能力，是一种宝贵的体验，无论是给予爱还是获得爱，我们所需要的第一件事就是爱自己。  \n希望所有人都能自爱自重，希望所有人都能收获爱，也希望所有人也有余力去爱。\n  \n30、\n  \n> 天下风云出我辈，一入江湖岁月催。  \n> 皇图霸业谈笑中，不胜人生一场醉。  \n>   \n> 提剑跨骑挥鬼雨，白骨如山鸟惊飞。  \n>   \n> 尘世如潮人如水，只叹江湖几人回。  \n>   \n> 英雄路远掌声近，莫问苍生问星辰。  \n>   \n> 天路有涯风有信，大海无量不见人。\n  \n> 本来无一物 何处惹尘埃\n  \n31、语言真是有意思，如果你直接说\"不明白\"，\"看不懂\"，\"不知道\"，人们可能不以为意，但是如果你说\"真有深度\"，不仅能欺骗自己，还能蛊惑他人，何乐而不为。  \n可是这种行事我终是觉得厌恶，而自己却不知意地做了，故而我也常常厌恶我自己。  \n这追慕虚荣的卑劣，就刻在了我们每个人的身子里，我厌恶我自己。\n  \n32、现在我才明白了，原来他是对的，真实竟然如此不堪，满是令人作呕，卑劣才是通性，高尚终是凤毛麟角。\n  \n> 因为我们不知道，所以错过了晚霞、潮汐和海浪。\n  \n> 你的实力是货真价实的，我南部赝作可以保证，这次绝不是虚张声势。\n  \n33、朋友的猫，吃了被老鼠药毒的老鼠中毒了，打了两针，现在情况也不到怎么样，那时只看见它趴伏在水泥地上，耷拉着头，也不理人，身上的毛脏脏的、有几根毛毛涔涔地立出来，它小巧的脚背上沾粘着灰色的土，水泥地有些年头了，上面裂开了几道七扭八歪的缝，缝里藏着红色的砖。不知道，明天还能不能再见到这只猫。  \n也许被耗子药毒死的猫并不少见，这也不是第一只、也许也不会是最后一只，但可能是朋友的最后一只。就同那些那些被冲垮的村落一样，也不是第一个也可能不是最后一个，但却是我们的最后一个。  \n*面对现代城市化的冲击，传统的小农经济不断遭受着挤压，那些用尽被碾压着的最后一丝气息给我留下美好回忆的乡村时光，已经是很久之前的记忆了，我不知道该说什么来表达这种感情，也不知道能做什么挽回点东西来宽慰自己，我只能像朋友那样打了两针，和猫一起坐在老旧的水泥地上，让阳光不舍地洒下一点夕阳，剩下的便只有孤独的陪伴。*  \n~~*这段话就是我给自己打的针，我就是那只猫。描写水泥地也是描写猫，不过我真的很担心朋友的猫怎么样了，希望猫没事🙏。表达对猫的缅怀，和城农冲突的无奈，对美好生活的思念，对农田生活的向往。*~~\n  \n34、这个世界真神奇，一方面游戏行业寒冬、版号缩水，另一方面国内经济情况低迷、人们消费意愿降低，国内厂商纷纷开源节流，而人才市场的竞争反而愈演愈烈，世界真魔幻啊，今年失业的恐怕是我。\n  \n35、时代的沙砾那么大，他却想爱每一个人。为什么我想做游戏，因为在我最难过的时候，是空洞骑士带给我了唯一的快乐，我不是想煽情的说，是他给了我活下去的勇气巴拉巴拉的，事实上我也没有勇敢的活下去，也没有变成优秀的大人，我还是和以前一样失去很多，依旧悲伤，但是它带给我的那些快乐是那么的深刻，再后来我玩旷野之息时，我再次体会到了这样的美好，在一个新的世界了，奇妙、自由没有烦恼，只有快乐。世界那么大，我却想爱每一个人，因为当初的我没有人爱。  \n之前爽鸭看到米的惊呼，我不以为意只觉得好笑，如今我望向米，发出“我超，米！”的惊叹，更甚于爽鸭。只觉得人生的悲哀罢了。\n  \n36、朋友的猫还活着，毛还是一样脏兮兮的，躺在混乱的电子设备堆里，嘴巴对着麦克风，朋友一直有一个歌手的梦，猫猫还活着我不知道为什么我会很开心，明明我的梦是那么遥远。\n  \n37、人生就是一个不断发现自己，认识自己，超脱自己，和解自己的过程，希望大家都能找到实现自我价值的方式和平台，满足自己的内心需求，活出只属于自己的人生，哪怕它没有那么缤纷多彩。\n  \n38、人生难免有遗憾，但是不要……不要……不要太多吧。  \n不是你的问题，是时间。时间就像深海，我们每个人都只能在中慢慢浮沉，无能为力。  \n时间是没有办法停止的，我们只能往下走了。  \n感情是人类最大的累赘，肉体是飞升的负担。  \n但真挚的情感总是可贵，令人动容。感情无法被人为模拟复现，真挚而可贵，也许正是这奇妙的心拥有超脱一切的力量。\n  \n39、我再也不看v了，原来我一直追寻虚假的过程只不过是寻找自己的投影，我在虚拟的身上几近疯狂地寻找真实的证明哪怕没有表表征，我的内心却是这样追寻的，我在人造的虚拟背后看到一丝真实的投影便自我感动地落泪，原来我是这般的不堪，我再也不看v了，我，再也不看v了。\n  \n40、如果不能在璀璨的烈焰中死去，便在无波的颓唐中磨平了一生。\n  \n41、如何创造一个悲剧——在路边抓来一个路人。\n  \n42、忽然发现自己什么都不会，成为了社会废人。\n  \n43、如果一个人不能得到生的光辉，便会理所应当地追求死的慷慨。\n  \n44、每当我体会到生的美妙，都会下意识的痛彻死的悲痛，因为我知道那些美妙终是虚幻的、终是离我遥远的是我无法触及的。\n  \n45、愈是压抑沉闷的今照，才能愈发凸显阴云散去、万里晴空的激动；在无数苦闷坚守的日夜后，迎来的朝阳更加痛彻心扉。  \n人被生活的枷锁所桎梏，在挫败与困顿中抗争，于失意绝望后而觉醒，坚韧的人性之光方显弥足珍贵。  \n“与天斗，其乐无穷。”\n  \n46、原以为最辉煌的日子是未来，没想到竟是毫无建树的过去，宛如雨后的积水只能映出一点赛博的霓虹，根本无法与日月争辉。又是入夜只留我暗自唔泣，待到朝阳氲氤被叶尖的露珠顶替。\n  \n47、我不是三峡好人，也游不到海水变蓝，我只是小武在站台上用一个桶所装载的忧愁。\n  \n48、22/10/13，在如此严峻的秋招环境中，有的人收获米哈游和网易雷火的offer，而有的人还在失业，我却一心只想摆烂当个废物，事实上我也完成了我成了一个只会摆烂自怨自艾的废物。  \n49、22/10/14，库洛测试题做的一塌糊涂，根本比不过别人，所以我选择摆烂了，技不如人，菜的自己想哭了，突然发现以前别人开的玩笑可能是真的，自己真的一点技术含量都没有。  \n50、22/10/16 18:21 如果能够死得壮烈我一定不会犹豫因为生命已经让我没有了欢愉，但我却不敢结束一切，因为我懦弱到了只想死去。  \n我不知道自己什么时候死了，我也不知道自己活了多久，只能记得如弥留之际看到他人的痛彻自己竟也受了感动，连一个死人都扮演不好，也许最终归宿也找寻不到了吧。  \n51、22/10/16 18:38 如果我死了请不要为我悲伤，用礼炮为我欢呼；如果我死了请不要怀念我，我的一生毫无建树；如果我死了请不要为我歌唱，因为我是生活的败者；如果我死了请不要为我激动，因为我是空中虚无；如果我死了请把我忘记，因为我已经离去。  \n52、22/10/16 18:38 我一直都是生活的失败者，做着不切实际的美梦立下旖旎的目标麻痹自己，现在秋天过半，寒冬踏着欢歌来到，朝露褪去夕阳沉沦，夜带着星光皎洁，我的梦也该醒了，早已枯死的花是时候凋落。  \n53、22/10/16 18:42 我还记得欢乐的感觉，沐浴在阳光里的温暖，但我未来马上就会将他们遗忘，曾经我体悟到的欢乐以后再也没有了，想到这在看见那阳光动人的笑脸，我的十指就刺痛了起来，原来快乐也会给人悲伤。  \n54、把狂妄无知当作清醒，把诡辩欺诈当作真理，拉帮结派狐假虎威狗仗人势，有什么可夸耀的，简直令人恶心至极。  \n55、如果不能在平静的海面上，补到伏在水底的鱼，便会寄予希望于疯狂的海啸，哪怕这灾难将会把自己席卷，破灭而来的希望也比枯死的等待更靓丽的多。\n  \n56、后来张之铭留在了平昌，他和以前一样早上会去书店门前的大树下看落叶，只是从此以后与他为伴的唯有晨朝的寒气，他就这样在那里等着，在秋季的冷风中。  \n57、我曾经的朋友已经许久未见，今日方得知原来她早就去了美国，群里的大佬知识技术也十分雄厚都有了不错的工作，有的人去了米哈游，有的人去了鹰角，看到他们我无比的羡慕，那是我曾憧憬的生活。但我的水平与他们差得太远，只知道自己差的多了，不会的多了……不知道心里这种感受是什么，也许是落寞吧。  \n58、每个人都喜欢酷姐姐，就像每个人都喜欢死亡。  \n59、如果爱就不要接近选择离开，爱和生活虽然都很难，但生活不是爱，爱也不是生活。  \n60、好冷啊，原来已经是冬天了吗？  \n我原以为我可以熬过这个冬天，但是素色的和服我终究没有收到，我想我应该不会活到夏季了。  \n61、安逸只能带来晨昏的死寂，而唯有痛彻方能焕发振奋的创作。  \n62、成长就是学会遗憾。\n  \n63、深情的缠绵尤为沉痛，人生的豁达也同样可贵，有的人死去却被人们怀念在心中，人生的感动永远留在民族的心中，作为我们共同的回忆。  \n64、世人多叹英雄迟暮，丈夫壮志难酬。惜少年踌躇，豪杰壮志，最后时过境迁物是人非，天下不定，生而不能如愿，如何不叹？  \n“死后葬于城北！”  \n“朕不能为弟报仇，虽有万里江山，何足为贵？”  \n“悠悠苍天何薄于我！”\n  \n65、发现自己找工作就像段誉和王语嫣聊天，王语嫣只想表哥，段誉却痴痴地想着王语嫣，面试官想要顶级人才，我却妄想一个工作机会，“我这辈子要是能一直哄着你开心就知足了”，我要是有一份工作就知足了。\"我不喜欢和轻浮的人交朋友\"，你好像不太适合这个岗位。  \n66、鸠摩智这个角色真是颇有佛缘，身为大轮明王通晓佛法道理，又有一身的武学修为，受人\"指点\"千里迢迢来到大理，段誉授其逆练心法，不曾想竟能成功练成少泽剑。  \n67、想不出活下去的理由，眼前所见都是赶快死去的事实。人生的旅途还未开始便受了一身的病，理想尚未起步，行业的寒冬就已经到来，千疮百孔的心智，学艺不精技不如人，残存的人生仿佛一眼就望到了头，我失去了活下去的理由，只能想到死的绝望，因为我是最软弱无能的妖怪。  \n68、GenShin上ys没什么好评价的，都说烂了，鸡场加堵场。从米看前有画月发家史，再有前车之鉴绷绷绷，从羊看前有尼、谷、丁，尼古丁，还有人搞什么“两岸猿声啼不住，轻舟已过万重山”，只有你是高贵的，狭隘的闵翠主义，”不识庐山真面目，只猿身在此山中“。  \n69、tnnd，都tm的怪段正淳！cao！  \n70、他人入我门，善果非常，我门破戒悔，罪无可恕。  \n71、打扰一个人的美梦残忍，还是让他沉沦其中残忍，我分不清。  \n72、每次看到那么奢华富贵的生活，我都在怀疑我是在革命前还是革命后，有时候再看几期牛事，我便更分不清了。  \n73、怎么样才能活下去啊。  \n74、我的人生这么funny，我是不是应该去做喜剧演员。  \n75、*西湖好，西湖好，九州百姓乐眉梢。群妖伏，魔首逃，九州春风万处飘，壮志凌云鲲鹏鸟，鲲鹏鸟。万圣好，万圣好，万圣明鉴平病灶。除岁炮，春来到，呕心沥血谱功劳。万圣锦旗昭，神州土木牢，土木牢。*  \n76、死亡对我来讲也许真的是甜蜜的，但却会有人因为这份甜蜜而伤心，所以我也失去了品尝这甜蜜的勇气。  \n77、回头看了看自己之前写的所谓感悟，原来我也思考过，也有那么一点有趣，我究竟是如何变成现在这个样子的啊。人都盲目地走在自以为正确的道路上越走越远，越走越远，直到找不到自己。  \n78、事到如今才明白我真正擅长的事啊，我既不聪明也不灵活，我所擅长的只有**逃避**罢了，一味的逃啊，逃啊，从现实逃向虚拟，又从虚拟逃向二者的夹缝之中，我就想躲在阴暗夹层的老鼠，只能窥视微弱的光，没有出去战斗的勇气，因为逃避是我最擅长的。  \n79、你为什么监视我？还是我们本来就都一样，在坠向地面的短暂一生中不甘着，渴望超脱。\n  \n80、事实比故事更荒诞，因为不仅真实还伤人，就在你我每一个人的身边。\n  \n> 前段时间在公园跑完步，看见有一个妈妈带着她的女儿在卖一些便宜的东西，我在她摊子上买了一个钥匙坠，她的女儿大约6-7岁左右，穿着粉红色的棉服，挺可爱的也不怕人。我随后坐在了旁边休息顺便刷抖音，小姑娘看见了就站我后面一起看，我也没在意。抖音视频有一条狗吃各种比较贵的食物。休息一会我准备回家，我听见小妹妹问她妈妈:妈妈，我想当一只狗狗。她妈问:为什么啊，琴琴(是这个读音，不确定字）小姑娘说:当狗狗可以每天吃肉啊，还有零食吃，我看大哥哥手机上的狗狗是这样的，我也想当那样的狗狗。她妈没有接话，只是伸出手扶正了小女孩的蝴蝶结。\n  \nb站狗吃奢华大餐：BV15E411P7Pz  \n我能理解宠物主人有给宠物吃各种各样东西的权力，但是我不甘和愤怒的是这背后更深层次的悲哀，在这荒诞视频的背后是阶级矛盾，是资产阶级对无产阶级的压迫，他们用无产者的辛苦劳动去喂养低贱的畜生，而我们的人民，我们的劳苦大众每天过着艰难的生活，甚至不如那吸血鬼所圈养的一条狗！牢记阶级苦！当阿廖莎再吃二遍苦受二茬罪时，他们会在父亲的大树下想起他曾经的教诲，那是无产者定会胜利，因为不胜利就会像今天一样迈向死亡，而死亡不属于无产者。\n  \n81、我感性时常落泪，有人也说我软弱或许吧，但是我的内心却实打实的痛到流出鲜红的泪。  \n82、你是要成为只会哀叹的懦夫，还是向生活奋起反击的勇者？  \n不畏艰险、不怕牺牲，敢于奉献的探索者精神和只会隅泣的逃兵哪个更值得歌颂。  \n我知道你饱受委屈和折磨，怕血肉模糊的心智再受折磨，可是逃避不能解决问题，愈合的肱骨才会更硬，羊啃食过的青草才会分蘖。  \n83、母弱出商贾，父强做侍郎，族望留原籍，家贫走他乡。    ——施耐庵  \n84、原来荒诞的才是现实，文学作品只是借用。  \n85、我不会拥有 [Happy End] 了，我的路途结束了，[Bad End] 就是我的 [Last End]，也是我的 [True End]。这个世界太糟糕了，我恨透他了，但是我最恨的是我自己，因为我只有 [Bad End]。  \n86、如果没有人关心我，我说出去的话又有谁懂呢？既然我说出去的话没有人懂，又怎么会有人关心我。  \n87、“虚伪”登堂入室，”真诚“嗤笑失意，这个世界已经不适合我了。  \n88、\"丐帮有多少弟子不是我说了算，是您说了算。如果您真的英明神武，又有谁愿意当乞丐。\"  \n89、我想回到过去，因为我能看见那些曾给我带来快乐的东西，曾让我温暖的东西，而未来却是黑漆漆的看不见的冰冷，至于现在……我在想过去。  \n90、\n  \n> 我明明没有喝酒，眼睛里却流出了酒。一想到大叔在某个地方从眼睛里流出酒来，酒就从我的眼睛里流个不停。  \n>   \n> 他明明没有喝酒，酒却从眼里流了出来。  \n>   \n> 嗯，我一直都知道的，MADAO早就开花了。  \n>   \n> MADAO是抛弃了一切英雄色彩的武士，却在每次人生的关键选择上，做出了最英雄主义的抉择  \n> MADAO其实早就已经开花了\n  \n91、我们每个人都是一座孤岛，只是恰巧在同一片海，被阳光映上彼此的影子。  \n92、我是一棵树，一棵树先生一样的树，所以我的根要向下，到那广袤深沉的泥土里去，作他们的一员。  \n93、中国太大了，大到里面装了好几个世界。  \n——神功盖世的吕大侠，源自b站视频[《被挂上热搜的“第一次吃华莱士”，背后藏着最残酷的底层之痛》](https://www.bilibili.com/video/BV1cM411w7D9)评论  \n94、他们是聪明人装糊涂，你以为他不知道？他只不知道咱们过得苦！他只知道怎么去骗我们，却装作不会骗我们的糊涂样子，根本不关心人民的死活。  \n95、  \n每年都有好建议，每年都没见落实，只有一天天变瘦的荷包，和一天天饿瘪的肚子，一天天萎靡的精神  \n一天天疲倦的身体，铸成城市梦幻的霓虹，用我们炽热的青春和血液，灌溉黑色的混凝土，发出耀眼的光  \n又到了夜晚，我很是不安，曾有这样无数的夜，我难以入睡，我一无所长却疲惫不堪，每时每刻都深陷不安。  \n96、看来是找不到工作了，不是被嫌弃菜，就是嫌弃没实习，要么就嫌弃没经验，还没开始就走到头了，人生已经肉眼可见的结束了。  \n97、23届的我最合适的结局竟是横死街头，在时间的长河中没人会在意我，前面有21，22的，后面有24的，只死我一个23的弱爆菜鸡，对这个世界也没有什么影响，时间根本不会在乎，没人关心我这具死在路边的尸体。  \n98、只是我一个人的寒冬罢了，我在广袤的狭小天地之间，踏着笨拙的舞步，雪花一片片排在我的身上，在温暖的春天里把我埋在最美丽的寒冬里，我能感受到他们携带着我的温暖向安逸的天堂飞去，我就在这只属于我一个人的寒冬中笨拙的挣扎，这是世界留给我最后的温柔。  \n99、我知道为什么我一直在寻找自己的影子了，我在同情自己投影的时候，是在可怜自己，我所有的悲痛欢喜愤懑都是为自己，我才发现原来自己是这样一个自私的人。  \n100、有时候真想毁灭啊，因为我所拥有的便是这一点仅存的名叫生命的能量，利用这微弱的力量绽放出不起眼的火花可能是我最大的成就了，但是我却缺少爆炸的勇气，因为我只是个胆小鬼罢了。  \n101、我目前最大的成就就是有关爱我的父母，我最大的罪恶就是没有回报他们。  \n102、不会解决问题只会喊人填表，要是填表就能实现共产主义，那东北大学在新时代就又一次成为革命领袖了，傻屄。  \n从根本上就不关心学生，只想着把自己那点破数据做得好看些，不能切实地帮助学生解决就业问题，那就恳请您别来浪费我的时间，肏你妈的，臭傻屄。  \n不仅浪费普通学生时间，还特么浪费学生干部的时间，臭傻屄。  \n只针对傻屄措施，不针对人，只针对形式主义，只针对情报特科，本人傻屄大龄愤青，脾气暴躁，思想极端。  \n103、“我只能看到一片黑暗，还有老大姐的背景。”杀哥这样说道，背景中是他常用的那首音乐，以往一样哀伤的旋律，竟格外的有诗意，杀哥躺下睡了，明天他还要去那片黑暗里探索生活，而我也一样只不过我看着这黑暗有些许难眠。  \n104、才发现自己C++不会，计组没学，计网没学，操作系统没学，图形学也不会。  \n我大学的四年究竟干了什么，为什么我什么都不会啊。  \n自己学了四年计算机什么都不会。  \n105、我还记得那天是小雨的天气，外面的乌云浮在天上，遮掩着太阳，他很轻松地说道：“我悟了，元凯，我得道了。”，说完他就转身走了，我只看见雨淅淅沥沥地落在他的肩上，后来我也离了道观，就再也没见过他，我至今也不知道他悟到了什么。  \n106、现在是2023/3/11原来罪恶王冠都已经是12年前的作品了，现在的二次元和那时的二次元已经有了天差地别的变化，我还是觉得那时候好，那时候的二次元给人一种独立、探索、思考的感觉、很有生命力比较干净，那时候总是有天马行空的幻想虽然很幼稚但是令人沉醉，如今大部分给我的感觉只是沉浸在娱乐里，我不能说哪种的好坏，因为我是带着滤镜去看过去，只能说我怀念那个时代，那个每部作品都个性分明、独有新意百花齐放的年代，如今的圈子虽然大了，但是我却再也找不到当年的味道了，也很少看新番了，偶尔想翻出过去的番剧看一看，也许我们这些老二次元都已经被生活压弯了腰，面对曾经的热爱已经没有多少力气去燃烧自己的生命，只能看着过去的背影映在夕阳橙红色的阳光里给自己一点安慰。  \n二次元变了，它变得不再是那个二次元了，二次元变了，它变得还是那个二次元。  \n二次元变了，他变得不再是那个二次元了，二次元变了，他变得还是那个二次元。  \n107、我看见棒棒拉了满满一摞的货，比快递三轮车的小仓库都大上一圈，但是他还是跨过公路，向左拉去了，他脸上没有什么情绪，只是一个普通的辛苦工人，日复一日的努力让他对生活的热情和未来的向往都消耗的差不多了，而迎着他开过去一辆不知道什么牌子的豪车。  \n108、为什么别人那么牛而我这么菜，nmd，地球怎么不爆炸。  \n109、“听丁大哥说啊，离咱们这一百多里地就是共产党，这个党啊，是我们工人自己的党，领袖是毛主席，领着好几百万大兵啊，叫解放军，只要他们到咱们这来啊，咱们的苦日子就熬到头了。”  \n一百多里地好远啊，一百多年好近啊，丁大哥，我上了当，我走错了。  \n110、npy问你什么时候跟她回家见家长，你不敢搭话，她说今天的鸡蛋又涨了，你摸了摸兜里的20块钱，皱巴巴的，全是汗渍，你鼓起勇气“我这还有20”，她却说“你拿着吧，吃点好的，在外面干活不容易。”  \n你吃完了饭感觉很难受，晚上你做了梦，梦里你有车有房，让辛苦了一辈子的父母过上了好日子。  \n111、等鸡长大，就变成了俄，等饿长大了就变成了洋，羊长大了就变成了new，牛鬼蛇神长大了啊，就……只有天知道了。  \n112、我是一块残留热血的肉贴在这钢铁、混凝土的树林，用热血和生命去浇筑，待到冷却、待到麻木，在树林中做最后的飞翔，却因桎梏太久只能坠落。他是一块残留热血的肉……  \n113、我要用的文字做一把利刃，像这个冷酷无情的世界奋力反击！哪怕我摔得粉碎，动作可笑滑稽，我也无所畏惧，因为即便我一败涂地，至少我拼劲全力愤怒过、燃烧过、绽放过，纵使这一切没那么绚烂美丽，但这也是我对这个无情宇宙的最大反叛。  \n[失业死宅日记](https://www.bilibili.com/video/BV1HN411F7KV)，[n站原本视频](https://acg.tv/sm11365022)  \n世界是以混沌残忍著称的混蛋，他用利刃把所有的敏感温柔全部搅碎，残酷麻木附着在刃上随着他的死亡之舞做着旋转，所有人在这疯狂的舞步中要么麻木、要么沉沦、要么受伤，然而即便随着他起舞最后也会和遍体鳞伤。他就像一只贪婪的野兽，舔舐鲜血痛苦为乐，也有天才的幸运儿站在中心绚丽的起舞，但那不是我，我只是一个被搅碎的、被蹂躏的发出悲鸣的懦弱的人。  \n每一个对抗生活的人都是勇敢的战士，即便普通却不意味着他们平凡，平凡是扎向他们的武器，在这场和自我、和世界的无尽对抗之中，踏上战场已经是一种荣耀。  \n114、明明判决的是违法者被绳之以法，可最后回头看来，却是一桩桩由人性深处的幽暗引起的惨案和悲剧。  \n115、以前我不知道为什么有人会觉得动漫角色是活的，我虽然很喜欢动漫，但是我应该只是觉得故事有趣，角色丰满，画面美丽等等，我应该是知道那些只是假的，是文学创作，直到今天听到ai阿尔托莉雅翻唱的富士山下，我真的获得了来自动漫角色安慰，我突然觉得她真的活过来了，就在我身边。  \n116、“别以为父母和钱和年轻和房间和T恤和我和你和银魂动画永远都有”\t——空知英秋  \n117、  \n“tmd“  \n”好像把人全杀光了啊“  \n”但我没本事只能杀我自己啊“  \n”我好像真的不正常了“  \n”是因为周一吗？“  \n”要是能永远都是万圣节就好了，这样大家都会以为我在Cosplay了“  \n118、像你们这种人中龙凤，英才豪杰自然是体会不到我等平平之辈的痛苦的。  \n119、我病了，我患了一种怪病，在这个冰冷的混凝土的世界里，在这个现实和虚幻边界愈渐模糊的时代，我渴望温暖，怀念过去，时光在一声声的排风中逃走了，我的思绪不知在哪里，我病了，我患上了一种奇怪的病。  \n120、我只是一个普通的人，一个再普通不过的普通人，我和你一样过着普通的生活，或者你比我艰难得多，或优渥得多，但我是像千千万万个这样的我一样平凡而普通的人，我只想用我自己的汗水让父母过上好的生活，我只想实现那仅存的支撑我活下去的所谓人生理想，我和千千万万的我一样是一个普通的人。  \n121、我这几天要动用我全部的思绪把他们都写下来，因为我马上就会离开这个世界，这是我能留给这个世界最后的东西，也是我能留下的唯一的痕迹了，但是在这个信息如海般的世界，我的文字只是空中微末的尘埃，后来的人啊不要像我一样，要努力地学习，要勇敢地去生活，去解放我们哪些还在遭受苦难和压迫、剥削的兄弟姐妹，不过这一天我终是看不见了，我要把我的肉体埋葬在一片鸟语花香的地方，这是我能想到的唯一的美好，我要把我悲哀的思绪带离这人世，若这世界上有我这样的悲哀那就只让他在我一个人身上发生就够了，我悲哀的灵魂我低劣的思想把我的人生带入了一场不能回头的悲剧，熟悉的陌生人啊不要重蹈我故事的覆辙，把我作为你的反面教材勇敢的前进下去吧。  \n122、刚才突发奇想的最喜欢的音乐制作人应该是[梶浦由记](https://zh.moegirl.org.cn/%E6%A2%B6%E6%B5%A6%E7%94%B1%E8%AE%B0)老师，啊，每次听到《晓之车》总是很感动，内心深处的某些东西被触动着，这样的歌实在是太优美了，有着很强的力量能够直击听众的内心，仿佛是只有在天上才能听到的，用中国话来说就是，“此曲只应天上有，人间能得几回闻”，这句话出自唐朝诗人杜甫的古诗作品《赠花卿》，那也是一首很美的诗。  \n123、没有神仙救世主，同志们我们只能靠自己！  \n124、重读《范进中举》有感，范进回到家只有挨饿多日、瘦骨嶙峋的母亲，母亲让他变卖了家里仅存的下蛋的母鸡，范进走上集市去买鸡，却被这社会又毒打了一顿，他倚在墙边，拖着满是伤痕的身体困倦了，恍惚中他看见有人对他说他中了举人，在这场举人梦里他发了疯，周围的人也发了疯，我也发了疯。  \n125、当阿廖莎在生产队的枯树下，吃二茬苦遭二茬罪时，会拾起他的思想，我们会找到一口井，他们当时就是在那样一口井边出发的，这口井会在各个地方涌现，这场征途我们只能靠自己，而且过程必然是残酷的，是要流血的，注定是不温和的，纵观过去温和的结果往往是招来团队的毁灭。我们是不怕斗争的，是不怕死亡的，我们是一定要胜利的。  \n126、别人一张嘴就是ssp，年薪百万，轻松的工作，优秀的同事，优渥的工作环境，充满前景的发展空间，而我只是想找一份游戏行业的工作养活自己，减轻父母的负担，我错在哪里，我不知道。  \n127、《西游记后传》还是不错的，《西游记》讲了一直发生的事而且很隐晦，其文学价值无需多言，而后传虽然通俗一些，但是讲的现在的过去发生的事，那时候的事都不提也看不清，但是他却讲了这么一个事，看起来很有意思，当然导演本人肯定没有这个想法我只是自己看着自己瞎想好玩。  \n128、鲁迅真的好厉害，他活在那么久之前，却清清楚楚地看清了我的样子，把我的现况，作为往事一篇篇写下。  \n129、人们不关心我，他们只在乎自己，他们凑过来不过是因为我的悲鸣比较可笑，他们只想听一声沉重的闷响然后在发表一些感动自我的深思，这之后人们就再也想不起来了，仿佛这一声闷响从未发生过，他们又等下一声闷响去了，却不知下一声闷响可能就是自己。  \n130、我像一首不符合时代旋律的歌，在时代的合奏中我的旋律格外刺耳，充斥着违和感和不协调。我融不进这美丽的时代，我在他们的映衬下是一首悲伤的歌。  \n131、怀着满腔热血想进入游戏行业，还没跨出半步就被这寒冬冻死，我像一块受了潮的木头，内外都感到刺骨，只希望我在最后能发出一点微弱的热量给这口炉子增添一点温度，此后便没有了我这块薪柴。  \n132、短评浅析[小岗同学葬礼](https://www.bilibili.com/video/BV1Vm4y167AC/)人未死去给自己办了一场告别仪式，我觉得还是挺有艺术气息的，人的内心深处都有着死亡的冲动，他用一种积极快乐的方式去向过去、向自我发起一场单方面的告别，因为这场和过去自己的告别是无疾而终的，从事实而言是无法达到的，从心理上讲是一种自我的分割。他用这样一种方式对自己发起反叛，对社会的固有认知发起一场属于自己的浪漫冲锋，他用众目睽睽向世界宣布过去死亡的宣言，然后让自己能够向着未来发起一场新的冲锋。  \n133、我恨人类，所以我挥刀向自己砍去。  \n134、理想主义者是这个世界最浪漫的人，但世界并不浪漫，所以理想和现实碰撞出的火花才格外绚烂。  \n135、有的人是真的逆天，就像我朋友说的“铁拳没砸到自己头上觉得自己挺能耐”，能说出比“何不食肉糜”还逆天的话，古人诚不欺我也。自己站在风口上便以为自己是时代的弄潮儿了，可惜这种人目光短浅又毫无同理之心，命比时代的浪还要短，只能看见自己顺着波涛拍动两下翅膀，看不见此波退去，下一波浪潮来临时的悲哀内有千百个自己的悲惨死相，还在这摇唇鼓舌，真是可笑，不骂他个八辈祖宗都是给他的面子了。  \n136、理想主义者是这个世界最浪漫的人，但世界并不浪漫，所以理想和现实碰撞出的火花才格外绚烂。  \n137、已经等不及想看后人如何评价我们了，自轰轰烈烈的公运失败后，这些叛徒朝着准备主意方向走去，却为了得到人民群众的信任不敢去承认，搞几波枪打出头鸟，后来再也没人敢在公共场合讨论，在网上日常说话发表评论都有敏感词看着，和过去的文字狱别无二致，阶级固化日益严峻，阶级矛盾愈演愈烈，过去地主小姐之流又出现在了这片土地上，革命先辈的血当真被这些投机倒把倒行逆施的叛徒们搞得白流了。  \n照这样看我想歌名的时间就快来了，不知是百年还是多久，这漫长的等待在史书上可能只有短短几页，但是一个人可能耗尽一生可能都望不到曙光，希望以后我们能实现真正的共产主义。  \n史记三页纸为轻，人生百世命何沉。  \n138、如果生活需要喜剧演员那我一定是一位出色的影帝，但是生活是一场闹剧，而我却偏偏里面演了一出喜剧，所以显得格外的悲剧，但是喜剧终是要人笑得，所以最后大家都露出了开心的笑容，只有我留下了悔恨的泪水。  \n139、“我只是想毁灭掉，这个，腐朽的世界”  \n既然超脱自我是如此的困难，那么追求毁灭和堕落，我想也是理所当然，情有可原的。  \n得不到的就期盼着它毁灭，还要在走向死寂的昏暗路口乞怜他人的宽慰，我不值得任何人为我哀叹，我不配任何人为我歌唱，我不配为任何人所留恋。  \n后来的人啊，如果你在人生的路牌上看见我的这番话，就不要像我一样沉沦，去冲破这命运的诅咒，去打破这可悲的诅咒，去勇往直前的做吧，去不断进取、不断学习吧，去放开手勇敢地爱吧，去活出精彩的、只属于你自己的样子吧。  \n后来的人啊，不要成为前面的人。  \n后来的人啊，祝你拥有幸福美满的一生。  \n140、后来我才知道，同理心是一种可贵的品质，这种品质不是每个人都有，甚至有的畜生遗忘了它。  \n141、网络真神奇啊，每个人都在上面聊着自己，对他人漠不关心，看似彼此能聊以安慰，仔细一看人家只不过在宽慰自己。  \n142、我一直都沉浸在难过的情绪中，以至不能自拔，我想痛苦也是一种毒药，而我就是他的吸食者。  \n143、我本质是一个糟糕透顶的人，我只是把我理想的样子伪装出来罢了，我一直都是祥林嫂，只不过在我死前呻吟一两声罢了，鲁迅在数十年前就写尽了我的荒唐。  \n144、因为我毫无建树，有没有特点，而且性格屌差，长得也丑，上有年迈的父母，我不能创造美好的生活报答他们的养育之恩，对于社会也没有帮助。  \n145、其实很多时候你们看那些我说出的哗众取宠之语，很多都是我肺腑之言，但是在这个荒谬的时代就成了令人哂笑的笑料，太多力，一时反而说不上来，就像面具戴在脸上时间久了就不自知了，就像悲伤沉浸其中时间久了就以痛苦为常态了。  \n146、生活是一个温柔并残酷的对手，他温柔的地方在于用名为平常的毒药渐渐损食人的心智磨灭热情和冲动，待回过神来已经在平凡中不能自拔；他残酷的地方在于这一过程没有表征，当看见别人鱼跃龙门时心中不少悸动，但是在两三下的挣扎后又再次沉浸在这沉沦的毒坛中。  \n若是你凭借超凡的毅力和坚韧战胜了自我，他还有压箱底的把式，用最残酷的方式终结你的抗争，可能是身体的也可能是精神的，正因为这对手如此的可怕，我们才会敬佩歌颂哪些坚韧不拔的英雄。  \n147、在心理学上有一种概念叫“缺失取向”，就是说一个人越是缺少什么越是表现什么。一个人越是极端地去表现积极乐观，他的内心就越是脆弱不堪，在他几近疯狂地、甚至令人感到违和不适的快乐面具下，可能隐藏着的是一颗遍体鳞伤的心，就像一张拉满弦的弓，一旦松手便是崩坏般的毁灭。  \n这种积极是悲哀的，只是在欺骗自我罢了，在生活中我曾见过这样的人，他是自知的，但是他无法放下，因为他弓弦的另一端是沉重的6便士，我什么都做不了，我听见他的笑声一下下刺痛我的鼓膜，看到他扭曲疯狂的笑容一幕幕映入我的眼帘，令我身心都感到些许的不适，我并不反感、或者说我没有资格反感，我只是感觉悲伤罢了。  \n148、我经常回忆过去因为他离我遥远、朦胧我能随意的想像令他完美，我不敢去想将来因为那是未知，我用尽一切方法逃离当下以远离未来，但无论我逃去何方他总能追上，在我于当下困顿时，我又想起过去，在过去中我从当下迈向未来。  \n149、骑士在扮演小丑，小丑在扮演骑士，这是个荒谬的时代，人们戴着不属于自己的假面，展露容颜者被称为异类，粉末假饰者收获赞美，人们被虚幻迷盖，对真实漠不关心，肉林的霓虹掩饰了沉重的担子，眼帘中都是狂欢迷醉，而死亡毁灭接踵而至。  \n150、和生活的这场战斗没有胜利可言，一旦开始便没有归途，最后的结果莫不是和解便是毁灭。  \n151、我想我是一个自私的人，每当我有所思考都是从自我的角度出发，很少想到他人，而想要说些什么欲从他人角度进行阐述，又有些不好意思，不知从何处下手。这应该是一个坏习惯我应该改一改，但是我又不知道怎么开始，很多事情我都是这样的，想要有所改变却迟迟迈不出手脚。  \n152、之前一直不理解《太吾绘卷》里的武学逆练是什么，因为在过去的教育过程中都是专心但粗糙地学习书本上、学校教授的知识不太理解，后来看见一个视频标题叫[[《官僚主义如何逆练群众理论》]](https://www.bilibili.com/video/BV1TX4y1z7D5)，再想想现实中藿香正气的例子便有些明白了，懂了理论但是为了自己的利益和欲望反其道而行之达到自己的预期，背离了知识的思想初衷，现在想想真是唏嘘。  \n153、我终是没发出光的，在这个炫丽的时代，寒冷的雨夜浇灭了我稚嫩的荧光，绮丽的世界不再希望炬火，因为和未来感的世界相衬起来是那么格格不入，在华丽的舞台背后，我在垃圾桶里等待死亡。  \n154、“莫说你一个宋慈就是十个八个也休想把这浑浊的世道变得天朗水清”，随着一把大火所有的罪证都化作灰烬，这些个衣冠禽兽都作了清白之身，刁光斗死在法不责众的乱拳之下，这场游戏，宋慈输了，刁光斗也输了，获得胜利的也只有王权一人，这场游戏从一开始就注定是王权之下的一桩悲剧罢了，所谓的你争我斗平反冤案，也只不是在王权的平台上的一幕而已。  \n155、人们总是在幻想中寻找认同，希望自己拥有打败一切的力量，希望自己能面对挫折坚毅不拔，从能打爆一切的勇者、拥有无数朋友的冒险家，面对残酷生活依旧坚韧的主人公，人们总是把自己的希望向外投影并追寻，但是摄像机是永远追不上投影屏的，想要成为幻想中的存在要自己行动。  \n156、我很害怕“结束”，仿佛只要没有“结束”一切都还来得及一切就都还有机会，我就还能在做些什么，但是“结束”是无可避免的无论如何逃避都要迎接“结束”。  \n157、今天是2023/05/11，晚上11点就是是《塞尔达：王国之泪》发售日了，在这个平凡的日子，世界上最伟大的游戏续作发售了，在这个伟大的发售日一切都那么平常，一切都仿佛没有发生，母亲还是在做饭，父亲还是辛苦的工作，我还是一如既往的失业，我还是没有解决生活的难题。虚拟世界的伟大波澜击不起我平凡生活的一丝浪花，人们用虚拟世界的梦幻来装饰糊涂的现实，世界上最荒诞的现实主义就在我身上发生。  \n158、突然想聊聊王家卫的抽帧，这种抽帧的手法营造了一种不真实感，这种不真实感就如同做梦，用这种去真作幻的手法去给观众想像感悟的空间，人在回忆时想像力是最强的因为不真切却又想极力看清所以就用想像弥补了空白，而王家卫的抽帧留给观众的是留白的画面，引起观众潜意识的想像补充，所以给人一种朦胧和梦幻的感觉。  \n159、我见过一家工厂，那里的材料要交钱才能变成罐头，这材料也是要分三六九等的，有的走了高级通道便通到什么堂皇的所在，不过我看应是颠倒过来的，叫荒唐才对。这样的流水线效率可高的呢，若是哪个落了队脱了群断是要不得的，他们说这是现代化，我是不懂的。  \n这样造出的罐头终是卖不出的，因为味道是差远了的，倒是那些堂皇的罐头是炙手可热的玩意。  \n160、那时候还有每天都会弹出来的腾讯新闻，可是这粗糙又美好的一切都成为了只能追忆的过去，眼前只有疲于奔命的现实和逐渐被压垮的身心，如果可以我希望在这场名为现实的噩梦中，回到过去。  \n161、无产者的哀伤竟被小资产阶级篡夺，作为生活的调剂和故作高深的资本，他妈的，你配吗？恶心。  \n162、人生的顿悟和无知竟是极为的相似，在无知时对自我没有喜欢讨厌不知其为何物，在学习中发现自己的闪光点心存喜爱不足心存悔过，这一过程知晓喜恶，在最后顿悟时接纳自己的一切有回到无厌喜的状态，虽然相似，但是也许应该有不同吧，我在漫长的学习过程中回滚到了无知的深渊，那顿悟的一朝我想我终是达到不了了。  \n163、  \n如果今天是你最后一次看见我，  \n你会对我说什么，  \n我想你什么都不会说，还会觉得我莫名其妙，  \n所以这结束还是由我来说更合适，  \n“再见，我将要去往新的明天。”\n  \n164、现在是2023/05/22晚22:02我的精神越发的不振了，我的精神几近癫狂，我想我很快就会病倒了，或者结束这一切了，我将死亡。\n  \n165、我是在做梦吗？我想这应该是一场噩梦吧，毕竟整个世界都没有人理睬我，难道我在梦里都不受人待见吗。在梦里也会肚子饿吗？在梦里也不能受到别人的眷顾吗？在梦里也不能受到他人的青睐吗？  \n那梦和现实有什么区别吗？那我还是在梦里死去吧，这样比较浪漫。  \n在自己的梦中死去算是自杀吗？在这个和现实一样悲哀的梦中死去。\n  \n166、“只要你还没意识到自己并非无所不能，那你就还是雏鸟。”\n  \n167、别着急，没什么，弗拉基米尔·伊里奇，他只是而昏过去了，等他醒来世界将再次插满红旗。\n  \n168、明年也许会有，也许不会，但是明年我的青春一定没有了。在每日的时光流逝中，随他而去的还有我曾以为无穷的可能性，我的一切生机活力都在慢慢消失，有人说这是长大的代价，但我只感到了死寂的悲凉。明天的太阳会再次升起，但明天我的生命也许不再蓬勃。\n  \n169、\"我的瓦西亚死了，\"妇人安静地说，悲哀的眼泪又沿着她憔悴的脸颊流下来，\"自然我的日子也完了，我活活的给人把心挖了去。然而汤是不应该糟蹋的，里面放得有盐呢。  \n---屠格涅夫<白菜汤>","slug":"New-Start","published":1,"updated":"2024-01-14T08:13:08.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti2000ebkbwd6a854ro","content":"<h2 id=\"隔离期间\">隔离期间</h2>\r\n<p>隔离期间搞一个自己的blog。<br />\r\n原名<code>New Start</code>，<br />\r\n记录一些自己的感悟。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"闲言碎语\">闲言碎语</h2>\r\n<p>1、刘明翼和周帆要考研了，杨崇兴过两天就要去实习了，只剩下我在所剩无几的大学时光等待着琐碎破败的人生到来，这个时候我才知道我曾做的一切是多么想暂缓逝而不返的时光，然而残酷的现实是——一切都是徒劳，生活没有什么预兆、也没有什么标识，一切就这么发生了，没有惊天动地的变故，没有振奋人心的庆典，一切都是那么平常，而这平常就是生活最大的残酷。</p>\r\n<p>一切都随着流水走向着尽头，走向着开始，而我注定和从前一样缅怀在自己卑谬的过去中，难看地呻吟。</p>\r\n<p>2、年龄越来越大，越能明白有个能畅所欲言的对象是多么可贵，如果这个对象能回应、甚至帮助你那就更为可贵了。有些话有些事只能自己挨着。真羡慕那些什么都能说，肆无忌惮的人，好轻松。不知什么时候开始，彷佛依赖上了内心流血的状态，就像用舌头舔刀刃上的血，明明血不会止住，反而迷恋上血的味道。</p>\r\n<p>没什么办法，那些面对巨大挫折却仍能坚持下来，没有丧失心智的人原来是这么的强大。</p>\r\n<blockquote>\r\n<p>世界上只有一种真正的英雄主义，那就是在认识生活的真相后依然热爱生活。</p>\r\n</blockquote>\r\n<p>3、全部是真实的，却是虚假的。</p>\r\n<p>用虚伪的去描绘最为真实的。我们的现实我们的感受，是虚伪的还是真实的呢？</p>\r\n<p>是他人的传递，还是萌生于我们的内在呢？我不知道，不管是自己还是他人，不同的真实也许是相同的虚幻，不同的虚幻也可能是相同的真实。我又在什么时候迷失了自己的灵魂呢……</p>\r\n<blockquote>\r\n<p>全都是真实的 却是虚假的</p>\r\n<p>用虚伪去描绘真实的</p>\r\n<p>用真实去欺骗虚假的</p>\r\n<p>我们的空洞眼神里</p>\r\n<p>诡异着 映射着 敏感着</p>\r\n<p>奇幻色彩的爆炸波</p>\r\n</blockquote>\r\n<p>4、明知是熊熊的烈火、不知前路如何，却仍能为了改变现状，为了更好的未来毅然献身，这样的理想主义者值得我们永远歌颂，如此高贵的品格才是人类最为珍贵的。也许有人歌颂英雄只是为了能让自己当个懦夫，但是我相信对英雄的呼唤和歌颂能唤醒这个世界隐藏的光明。</p>\r\n<p>5、昨天洗澡的时候突然发现自己为什么有屯物癖。小时候家里条件不是很好，每次自己有了新东西都会很开心，可是时间久了东西就会坏掉，我失去我的这些最珍贵的东西时我十分伤心，所以再后来就喜欢“备份”，同样的东西要有很多才会安心，总是怕他们离我而去，慢慢的慢慢的就成了无意识的举动，堆着堆着就成了习惯。也许我不是屯物癖吧，我只是害怕失去的感觉，堆积备份追寻自己的安心。</p>\r\n<p>6、我从不幻想着自己是特殊的、特别的，我只觉得自己是异常的，另类的。</p>\r\n<p>7、我不再年轻了，我开始听伍佰，开始知道人生总是充满着不完美，人生就是一个慢慢填满遗憾的过程，我不是在说自己变得成熟，只是觉得有了什么从前从未有过的感受，我不知道这种感受叫做什么，他们都说这叫长大，可是长大真的是这样吗？别人也会和我一样忧愁、抑郁吗？问题会有答案，但那也只是在教材上，生活中大多时候问题是没有答案的。我不知道，我不知道，我不知道。</p>\r\n<p>8、这个世界这么大，大到没有我的容身之处，而这个世界又是这么的小，小到我都不知道游乐场在哪？也许这个世界就是这样，像快乐套餐里没有快乐一样，荒诞合理。</p>\r\n<p>9、</p>\r\n<blockquote>\r\n<p>前方啊没有方向，身上啊没有了衣裳</p>\r\n<p>鲜血啊渗出了翅膀，我的眼泪湿透了胸膛</p>\r\n<p>飞翔着强忍着伤，逃离了猎人的枪</p>\r\n<p>我的双脚没有了知觉，我的心情下冰冷的雪</p>\r\n<p>亲爱的母亲挚爱的朋友，我会坚定好好的活</p>\r\n<p>沉默的大地沉默的天空，红色的血继续的流</p>\r\n<p>纵然带着永远的伤口，至少我还拥有自由</p>\r\n<p>飞翔吧飞在天空，用力吹吧无情的风</p>\r\n<p>我不会害怕也无须懦弱，流浪的路我自己走</p>\r\n<p>那是种骄傲阳光的洒脱，白云从我脚下掠过</p>\r\n<p>干枯的身影憔悴的面容，挥着翅膀不再回头</p>\r\n<p>纵然带着永远的伤口，至少我还拥有自由</p>\r\n<p>纵然带着永远的伤口，至少我还拥有自由</p>\r\n<p>至少我还拥有自由，至少我还拥有自由</p>\r\n<p>呜——</p>\r\n<p>——《白鸽》伍佰</p>\r\n</blockquote>\r\n<p>10、当她看见我没有所谓“餐票”便要阻止我就餐时，我仿佛看到了那个使用粮票、饭票的时代，那时候我们还是可以胜利的，贪婪的投机者和黑心的资本家还没有破坏我们的宝贵成功，我们走在一条崎岖但蓬勃的道路上。</p>\r\n<p>可是我面前的这一景象和那时已经截然不同了，她口中的那张纸不过同“优惠券”，“代金券”这些促销手段一样，是那些吸血鬼的把戏，一个劣质的谎言罢了，只不过是为了中饱私囊掏空他人腰包所想出来的卑劣的技俩罢了。</p>\r\n<p>11、你这么费力有什么用，到时候人家不过是领着ta去道个歉认个错，这事情也就罢了。上面松松口，走动走动，也就过去了，上面都松了手，你在底下还能一直死咬着不成？<br />\r\n我今天还就和你把话说透了，我倒是要教教你这法是什么法！法就是皇帝的法，就是皇家的法，任你个小芝麻再怎么搅和也休想把这官场给搅得天朗水清。咬到了最后你也只得落一句：“算了，草草结案吧！”</p>\r\n<p>12、某些所谓顶流，不过是套了个炫丽的虚假的外壳罢了，拿着剥削来的资源卖弄起来，竟也装做出砥柱的样子，不禁令人作呕。就像是马戏团的小丑换了一套滑稽的万圣节戏服罢了，里面装的都是铜臭糜烂。</p>\r\n<p>13、为什么一定要有什么思想、什么主旨呢？只是看着难道就不可以吗？<br />\r\n就只是看着就不能感受到作者传递出来的感情、思想、观念了吗？我一直认为人心是十分奇妙的东西，是强大的东西，我觉得就像这样看着他的感受也能传递给我，在潜移默化地影响我。只是单纯地看着就不可以的话，是我们太小瞧了这副作品，还是太小瞧了人心。</p>\r\n<p>14、我一直觉得土地很神奇，春种秋收。播下种子挥洒汗水，在种地种菜的过程中憧憬着未来，憧憬着美好的明天，用自己的劳动换取美好的生活，切身感受自然的奇迹，在这个过程中自我彷佛得到了救赎。<br />\r\n人终归是自然的一份子，在这个种菜劳作的过程中，也许也是我们追根溯源，回归自然的一个过程。作为自然的一员，这种回归的过程带给我们慰藉和安逸，让我得到身心的放松，道教认为小孩子生下来是最完美的，先天之气完足，没有尘世的侵扰，我认为某种程度也是一种我们人类最贴近自然的状态，神完气足和自然融为一体，和自然同在，感受美妙的世界，体悟生命的奇迹，让我们能够放下世俗的争扰，去追寻自己真正的内心。<br />\r\n<em>对了，黄瓜和苦瓜别种在一起，会串花粉，黄瓜会变苦的。</em></p>\r\n<p>15、我很喜欢给事物带来终结，或者说是去感悟事情的结束，因为我从小时候见到的一切，他们的结尾总是那么令人铭记于心、痛彻心扉，这样看来，结束彷佛是一件美好的事，可是真的是这样吗？是结束太过痛彻心扉，刻在了心上，造成了一种感情的涟漪让我感动，还是结束真的是一件很美好，值得铭记的事情？也许这两种都是一样的吧。<br />\r\n思来想去我只能说我不知道，彷佛生活不知从什么时候开始就变得很复杂，什么东西我都搞不太懂，也许复杂的不只是生活，或者说复杂的根本不是生活，复杂的是我。也许生活本来是很简单的，只是我太复杂了，所以把生活搞得也复杂了。诶，又或者说，生活很复杂，然后我被生活搞得很复杂……你看很复杂吧，我完全搞不懂。我不知道诶。</p>\r\n<blockquote>\r\n<p>所有年轻人，年轻人，年轻人，问题出现我再告诉大家！</p>\r\n</blockquote>\r\n<p>16、明知是假的却只能依赖，因为不这么做便活不下去。<br />\r\n或许人类注定是悲哀的生物，但是悲哀的命运也不妨碍我们去追寻美，去创造美。<br />\r\n即便是悲惨的命运也能创造出无比美丽的生物。</p>\r\n<p>17、言语稚嫩，文笔不成熟又怎样呢？心中这份感情可是货真价实的，不把这么美妙宝贵的情感写下来的话，不是可惜了吗？是自己的可惜，也是全人类的可惜哦~<br />\r\n用自己的语言，文字记录自己的情感，没什么好难为情的，这是一件无比浪漫，足够引以为傲的事情。因为稚嫩的记述本身就是动人的。</p>\r\n<p>18、</p>\r\n<blockquote>\r\n<p>逃げちゃ駄目だ，逃げちゃ駄目だ，逃げちゃ駄目だ。</p>\r\n</blockquote>\r\n<p>19、<ruby>燃烧了…<span class=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">燃えたよ…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>直至雪白……<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">まっ白に…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>已经燃烧殆尽了…<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">燃えつきた…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>只剩下雪白的灰……<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">まっ白な灰に……</span></rt></ruby></p>\r\n<blockquote>\r\n<p><ruby>燃烧了…<span class=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">燃えたよ…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>直至雪白……<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">まっ白に…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>已经燃烧殆尽了…<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">燃えつきた…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>只剩下雪白的灰……<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">まっ白な灰に……</span></rt></ruby></p>\r\n</blockquote>\r\n<p>20、挽救烂尾的方式之一：播放结尾的时候配上最悲情、悲壮的音乐，不时穿插之前的回忆，人物不要发出声音，声音只放bgm就行，<del>最后来个意识流从天空俯瞰，所有人围着主角，然后突然黑掉屏幕，赫然打上几个大字：“全剧终”</del>。</p>\r\n<p>21、最宝贵的情感只属于自己，若是有人能感怀一二对于自身来说便是极大的幸福了，很少有人去体悟别人的感情，自己的感情终究是属于自己的，他人不会关心，纵是共情，也是他人的悸动。</p>\r\n<p>22、不深入涡流直面深渊，便没有评价的资本。</p>\r\n<blockquote>\r\n<p>没有调查就没有发言权</p>\r\n</blockquote>\r\n<p>23、没有能力的勇敢就是鲁莽，自己没有能力就什么都保护不了。</p>\r\n<p>24、后来我才知道你也和我听一样的歌，我们也都一样，曾一样愤懑，曾一样踌躇，我不知道是什么样的原因，不知道是默契还是缘分，还是同样的时代背景，家庭环境？不，你应该过得比我好，一定要比我优渥。我很想浪漫的说，你我的相同是命运的馈赠，是千古最长情的缘分，可是也许这份共同是这个时代带给我们每个人的。<br />\r\n珈乐和焰火青年。</p>\r\n<p>25、我突然明白了，我的心上已经有了口子，虽然会愈合，但是随着悸动，它的伤口会崩开、流出血来，想要止住血只能拿新的伤痛插在上面，可是这么一插血是止住了，也造就了新的创口。</p>\r\n<p>26、其实张之铭每次晾内裤都会踩着杨崇兴的凳子，放心是脱了鞋的，这样的小恶作剧对于张之铭来说也算是一种乐趣，可是杨崇兴去实习了，张之铭再也没踩过那张凳子，也许是因为那个人走了就不再回来，也可能是因为那个人把在寝室剪头用来围脖子的破布放在了凳子上，张之铭怕脚沾上头发茬子。</p>\r\n<p>27、网络浪潮有最迅猛的两个时候，一个是ta诞生的时候，另一个就是ta死的时候。</p>\r\n<p>28、当我们欣赏过去的经典追忆过去时，是不是在追寻着眼中那个人的步履。聆听过去，也是追寻过去，体悟过去。</p>\r\n<p>29、其实无私的爱是无比宝贵的，是可遇而不可求的，可是因为我们大多数人出生便得到了父母无私的、厚重的、广阔的爱，导致我们以为这种爱是常见的，乃至更有甚者认为是没有价值的。<br />\r\n等我长大与人接触后，才发现没有人爱我自己，曾经“最廉价”的爱居然是那么昂贵的。对周遭急切的期待，往往迎来的都是冰冷的“款待”。爱是一种可贵的能力，是一种宝贵的体验，无论是给予爱还是获得爱，我们所需要的第一件事就是爱自己。<br />\r\n希望所有人都能自爱自重，希望所有人都能收获爱，也希望所有人也有余力去爱。</p>\r\n<p>30、</p>\r\n<blockquote>\r\n<p>天下风云出我辈，一入江湖岁月催。<br />\r\n皇图霸业谈笑中，不胜人生一场醉。</p>\r\n<p>提剑跨骑挥鬼雨，白骨如山鸟惊飞。</p>\r\n<p>尘世如潮人如水，只叹江湖几人回。</p>\r\n<p>英雄路远掌声近，莫问苍生问星辰。</p>\r\n<p>天路有涯风有信，大海无量不见人。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>本来无一物 何处惹尘埃</p>\r\n</blockquote>\r\n<p>31、语言真是有意思，如果你直接说\"不明白\"，\"看不懂\"，\"不知道\"，人们可能不以为意，但是如果你说\"真有深度\"，不仅能欺骗自己，还能蛊惑他人，何乐而不为。<br />\r\n可是这种行事我终是觉得厌恶，而自己却不知意地做了，故而我也常常厌恶我自己。<br />\r\n这追慕虚荣的卑劣，就刻在了我们每个人的身子里，我厌恶我自己。</p>\r\n<p>32、现在我才明白了，原来他是对的，真实竟然如此不堪，满是令人作呕，卑劣才是通性，高尚终是凤毛麟角。</p>\r\n<blockquote>\r\n<p>因为我们不知道，所以错过了晚霞、潮汐和海浪。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>你的实力是货真价实的，我南部赝作可以保证，这次绝不是虚张声势。</p>\r\n</blockquote>\r\n<p>33、朋友的猫，吃了被老鼠药毒的老鼠中毒了，打了两针，现在情况也不到怎么样，那时只看见它趴伏在水泥地上，耷拉着头，也不理人，身上的毛脏脏的、有几根毛毛涔涔地立出来，它小巧的脚背上沾粘着灰色的土，水泥地有些年头了，上面裂开了几道七扭八歪的缝，缝里藏着红色的砖。不知道，明天还能不能再见到这只猫。<br />\r\n也许被耗子药毒死的猫并不少见，这也不是第一只、也许也不会是最后一只，但可能是朋友的最后一只。就同那些那些被冲垮的村落一样，也不是第一个也可能不是最后一个，但却是我们的最后一个。<br />\r\n<em>面对现代城市化的冲击，传统的小农经济不断遭受着挤压，那些用尽被碾压着的最后一丝气息给我留下美好回忆的乡村时光，已经是很久之前的记忆了，我不知道该说什么来表达这种感情，也不知道能做什么挽回点东西来宽慰自己，我只能像朋友那样打了两针，和猫一起坐在老旧的水泥地上，让阳光不舍地洒下一点夕阳，剩下的便只有孤独的陪伴。</em><br />\r\n<del><em>这段话就是我给自己打的针，我就是那只猫。描写水泥地也是描写猫，不过我真的很担心朋友的猫怎么样了，希望猫没事🙏。表达对猫的缅怀，和城农冲突的无奈，对美好生活的思念，对农田生活的向往。</em></del></p>\r\n<p>34、这个世界真神奇，一方面游戏行业寒冬、版号缩水，另一方面国内经济情况低迷、人们消费意愿降低，国内厂商纷纷开源节流，而人才市场的竞争反而愈演愈烈，世界真魔幻啊，今年失业的恐怕是我。</p>\r\n<p>35、时代的沙砾那么大，他却想爱每一个人。为什么我想做游戏，因为在我最难过的时候，是空洞骑士带给我了唯一的快乐，我不是想煽情的说，是他给了我活下去的勇气巴拉巴拉的，事实上我也没有勇敢的活下去，也没有变成优秀的大人，我还是和以前一样失去很多，依旧悲伤，但是它带给我的那些快乐是那么的深刻，再后来我玩旷野之息时，我再次体会到了这样的美好，在一个新的世界了，奇妙、自由没有烦恼，只有快乐。世界那么大，我却想爱每一个人，因为当初的我没有人爱。<br />\r\n之前爽鸭看到米的惊呼，我不以为意只觉得好笑，如今我望向米，发出“我超，米！”的惊叹，更甚于爽鸭。只觉得人生的悲哀罢了。</p>\r\n<p>36、朋友的猫还活着，毛还是一样脏兮兮的，躺在混乱的电子设备堆里，嘴巴对着麦克风，朋友一直有一个歌手的梦，猫猫还活着我不知道为什么我会很开心，明明我的梦是那么遥远。</p>\r\n<p>37、人生就是一个不断发现自己，认识自己，超脱自己，和解自己的过程，希望大家都能找到实现自我价值的方式和平台，满足自己的内心需求，活出只属于自己的人生，哪怕它没有那么缤纷多彩。</p>\r\n<p>38、人生难免有遗憾，但是不要……不要……不要太多吧。<br />\r\n不是你的问题，是时间。时间就像深海，我们每个人都只能在中慢慢浮沉，无能为力。<br />\r\n时间是没有办法停止的，我们只能往下走了。<br />\r\n感情是人类最大的累赘，肉体是飞升的负担。<br />\r\n但真挚的情感总是可贵，令人动容。感情无法被人为模拟复现，真挚而可贵，也许正是这奇妙的心拥有超脱一切的力量。</p>\r\n<p>39、我再也不看v了，原来我一直追寻虚假的过程只不过是寻找自己的投影，我在虚拟的身上几近疯狂地寻找真实的证明哪怕没有表表征，我的内心却是这样追寻的，我在人造的虚拟背后看到一丝真实的投影便自我感动地落泪，原来我是这般的不堪，我再也不看v了，我，再也不看v了。</p>\r\n<p>40、如果不能在璀璨的烈焰中死去，便在无波的颓唐中磨平了一生。</p>\r\n<p>41、如何创造一个悲剧——在路边抓来一个路人。</p>\r\n<p>42、忽然发现自己什么都不会，成为了社会废人。</p>\r\n<p>43、如果一个人不能得到生的光辉，便会理所应当地追求死的慷慨。</p>\r\n<p>44、每当我体会到生的美妙，都会下意识的痛彻死的悲痛，因为我知道那些美妙终是虚幻的、终是离我遥远的是我无法触及的。</p>\r\n<p>45、愈是压抑沉闷的今照，才能愈发凸显阴云散去、万里晴空的激动；在无数苦闷坚守的日夜后，迎来的朝阳更加痛彻心扉。<br />\r\n人被生活的枷锁所桎梏，在挫败与困顿中抗争，于失意绝望后而觉醒，坚韧的人性之光方显弥足珍贵。<br />\r\n“与天斗，其乐无穷。”</p>\r\n<p>46、原以为最辉煌的日子是未来，没想到竟是毫无建树的过去，宛如雨后的积水只能映出一点赛博的霓虹，根本无法与日月争辉。又是入夜只留我暗自唔泣，待到朝阳氲氤被叶尖的露珠顶替。</p>\r\n<p>47、我不是三峡好人，也游不到海水变蓝，我只是小武在站台上用一个桶所装载的忧愁。</p>\r\n<p>48、22/10/13，在如此严峻的秋招环境中，有的人收获米哈游和网易雷火的offer，而有的人还在失业，我却一心只想摆烂当个废物，事实上我也完成了我成了一个只会摆烂自怨自艾的废物。<br />\r\n49、22/10/14，库洛测试题做的一塌糊涂，根本比不过别人，所以我选择摆烂了，技不如人，菜的自己想哭了，突然发现以前别人开的玩笑可能是真的，自己真的一点技术含量都没有。<br />\r\n50、22/10/16 18:21\r\n如果能够死得壮烈我一定不会犹豫因为生命已经让我没有了欢愉，但我却不敢结束一切，因为我懦弱到了只想死去。<br />\r\n我不知道自己什么时候死了，我也不知道自己活了多久，只能记得如弥留之际看到他人的痛彻自己竟也受了感动，连一个死人都扮演不好，也许最终归宿也找寻不到了吧。<br />\r\n51、22/10/16 18:38\r\n如果我死了请不要为我悲伤，用礼炮为我欢呼；如果我死了请不要怀念我，我的一生毫无建树；如果我死了请不要为我歌唱，因为我是生活的败者；如果我死了请不要为我激动，因为我是空中虚无；如果我死了请把我忘记，因为我已经离去。<br />\r\n52、22/10/16 18:38\r\n我一直都是生活的失败者，做着不切实际的美梦立下旖旎的目标麻痹自己，现在秋天过半，寒冬踏着欢歌来到，朝露褪去夕阳沉沦，夜带着星光皎洁，我的梦也该醒了，早已枯死的花是时候凋落。<br />\r\n53、22/10/16 18:42\r\n我还记得欢乐的感觉，沐浴在阳光里的温暖，但我未来马上就会将他们遗忘，曾经我体悟到的欢乐以后再也没有了，想到这在看见那阳光动人的笑脸，我的十指就刺痛了起来，原来快乐也会给人悲伤。<br />\r\n54、把狂妄无知当作清醒，把诡辩欺诈当作真理，拉帮结派狐假虎威狗仗人势，有什么可夸耀的，简直令人恶心至极。<br />\r\n55、如果不能在平静的海面上，补到伏在水底的鱼，便会寄予希望于疯狂的海啸，哪怕这灾难将会把自己席卷，破灭而来的希望也比枯死的等待更靓丽的多。</p>\r\n<p>56、后来张之铭留在了平昌，他和以前一样早上会去书店门前的大树下看落叶，只是从此以后与他为伴的唯有晨朝的寒气，他就这样在那里等着，在秋季的冷风中。<br />\r\n57、我曾经的朋友已经许久未见，今日方得知原来她早就去了美国，群里的大佬知识技术也十分雄厚都有了不错的工作，有的人去了米哈游，有的人去了鹰角，看到他们我无比的羡慕，那是我曾憧憬的生活。但我的水平与他们差得太远，只知道自己差的多了，不会的多了……不知道心里这种感受是什么，也许是落寞吧。<br />\r\n58、每个人都喜欢酷姐姐，就像每个人都喜欢死亡。<br />\r\n59、如果爱就不要接近选择离开，爱和生活虽然都很难，但生活不是爱，爱也不是生活。<br />\r\n60、好冷啊，原来已经是冬天了吗？<br />\r\n我原以为我可以熬过这个冬天，但是素色的和服我终究没有收到，我想我应该不会活到夏季了。<br />\r\n61、安逸只能带来晨昏的死寂，而唯有痛彻方能焕发振奋的创作。<br />\r\n62、成长就是学会遗憾。</p>\r\n<p>63、深情的缠绵尤为沉痛，人生的豁达也同样可贵，有的人死去却被人们怀念在心中，人生的感动永远留在民族的心中，作为我们共同的回忆。<br />\r\n64、世人多叹英雄迟暮，丈夫壮志难酬。惜少年踌躇，豪杰壮志，最后时过境迁物是人非，天下不定，生而不能如愿，如何不叹？<br />\r\n“死后葬于城北！”<br />\r\n“朕不能为弟报仇，虽有万里江山，何足为贵？”<br />\r\n“悠悠苍天何薄于我！”</p>\r\n<p>65、发现自己找工作就像段誉和王语嫣聊天，王语嫣只想表哥，段誉却痴痴地想着王语嫣，面试官想要顶级人才，我却妄想一个工作机会，“我这辈子要是能一直哄着你开心就知足了”，我要是有一份工作就知足了。\"我不喜欢和轻浮的人交朋友\"，你好像不太适合这个岗位。<br />\r\n66、鸠摩智这个角色真是颇有佛缘，身为大轮明王通晓佛法道理，又有一身的武学修为，受人\"指点\"千里迢迢来到大理，段誉授其逆练心法，不曾想竟能成功练成少泽剑。<br />\r\n67、想不出活下去的理由，眼前所见都是赶快死去的事实。人生的旅途还未开始便受了一身的病，理想尚未起步，行业的寒冬就已经到来，千疮百孔的心智，学艺不精技不如人，残存的人生仿佛一眼就望到了头，我失去了活下去的理由，只能想到死的绝望，因为我是最软弱无能的妖怪。<br />\r\n68、GenShin上ys没什么好评价的，都说烂了，鸡场加堵场。从米看前有画月发家史，再有前车之鉴绷绷绷，从羊看前有尼、谷、丁，尼古丁，还有人搞什么“两岸猿声啼不住，轻舟已过万重山”，只有你是高贵的，狭隘的闵翠主义，”不识庐山真面目，只猿身在此山中“。<br />\r\n69、tnnd，都tm的怪段正淳！cao！<br />\r\n70、他人入我门，善果非常，我门破戒悔，罪无可恕。<br />\r\n71、打扰一个人的美梦残忍，还是让他沉沦其中残忍，我分不清。<br />\r\n72、每次看到那么奢华富贵的生活，我都在怀疑我是在革命前还是革命后，有时候再看几期牛事，我便更分不清了。<br />\r\n73、怎么样才能活下去啊。<br />\r\n74、我的人生这么funny，我是不是应该去做喜剧演员。<br />\r\n75、<em>西湖好，西湖好，九州百姓乐眉梢。群妖伏，魔首逃，九州春风万处飘，壮志凌云鲲鹏鸟，鲲鹏鸟。万圣好，万圣好，万圣明鉴平病灶。除岁炮，春来到，呕心沥血谱功劳。万圣锦旗昭，神州土木牢，土木牢。</em><br />\r\n76、死亡对我来讲也许真的是甜蜜的，但却会有人因为这份甜蜜而伤心，所以我也失去了品尝这甜蜜的勇气。<br />\r\n77、回头看了看自己之前写的所谓感悟，原来我也思考过，也有那么一点有趣，我究竟是如何变成现在这个样子的啊。人都盲目地走在自以为正确的道路上越走越远，越走越远，直到找不到自己。<br />\r\n78、事到如今才明白我真正擅长的事啊，我既不聪明也不灵活，我所擅长的只有<strong>逃避</strong>罢了，一味的逃啊，逃啊，从现实逃向虚拟，又从虚拟逃向二者的夹缝之中，我就想躲在阴暗夹层的老鼠，只能窥视微弱的光，没有出去战斗的勇气，因为逃避是我最擅长的。<br />\r\n79、你为什么监视我？还是我们本来就都一样，在坠向地面的短暂一生中不甘着，渴望超脱。</p>\r\n<p>80、事实比故事更荒诞，因为不仅真实还伤人，就在你我每一个人的身边。</p>\r\n<blockquote>\r\n<p>前段时间在公园跑完步，看见有一个妈妈带着她的女儿在卖一些便宜的东西，我在她摊子上买了一个钥匙坠，她的女儿大约6-7岁左右，穿着粉红色的棉服，挺可爱的也不怕人。我随后坐在了旁边休息顺便刷抖音，小姑娘看见了就站我后面一起看，我也没在意。抖音视频有一条狗吃各种比较贵的食物。休息一会我准备回家，我听见小妹妹问她妈妈:妈妈，我想当一只狗狗。她妈问:为什么啊，琴琴(是这个读音，不确定字）小姑娘说:当狗狗可以每天吃肉啊，还有零食吃，我看大哥哥手机上的狗狗是这样的，我也想当那样的狗狗。她妈没有接话，只是伸出手扶正了小女孩的蝴蝶结。</p>\r\n</blockquote>\r\n<p>b站狗吃奢华大餐：BV15E411P7Pz<br />\r\n我能理解宠物主人有给宠物吃各种各样东西的权力，但是我不甘和愤怒的是这背后更深层次的悲哀，在这荒诞视频的背后是阶级矛盾，是资产阶级对无产阶级的压迫，他们用无产者的辛苦劳动去喂养低贱的畜生，而我们的人民，我们的劳苦大众每天过着艰难的生活，甚至不如那吸血鬼所圈养的一条狗！牢记阶级苦！当阿廖莎再吃二遍苦受二茬罪时，他们会在父亲的大树下想起他曾经的教诲，那是无产者定会胜利，因为不胜利就会像今天一样迈向死亡，而死亡不属于无产者。</p>\r\n<p>81、我感性时常落泪，有人也说我软弱或许吧，但是我的内心却实打实的痛到流出鲜红的泪。<br />\r\n82、你是要成为只会哀叹的懦夫，还是向生活奋起反击的勇者？<br />\r\n不畏艰险、不怕牺牲，敢于奉献的探索者精神和只会隅泣的逃兵哪个更值得歌颂。<br />\r\n我知道你饱受委屈和折磨，怕血肉模糊的心智再受折磨，可是逃避不能解决问题，愈合的肱骨才会更硬，羊啃食过的青草才会分蘖。<br />\r\n83、母弱出商贾，父强做侍郎，族望留原籍，家贫走他乡。    ——施耐庵<br />\r\n84、原来荒诞的才是现实，文学作品只是借用。<br />\r\n85、我不会拥有 [Happy End] 了，我的路途结束了，[Bad End] 就是我的 [Last\r\nEnd]，也是我的 [True\r\nEnd]。这个世界太糟糕了，我恨透他了，但是我最恨的是我自己，因为我只有\r\n[Bad End]。<br />\r\n86、如果没有人关心我，我说出去的话又有谁懂呢？既然我说出去的话没有人懂，又怎么会有人关心我。<br />\r\n87、“虚伪”登堂入室，”真诚“嗤笑失意，这个世界已经不适合我了。<br />\r\n88、\"丐帮有多少弟子不是我说了算，是您说了算。如果您真的英明神武，又有谁愿意当乞丐。\"<br />\r\n89、我想回到过去，因为我能看见那些曾给我带来快乐的东西，曾让我温暖的东西，而未来却是黑漆漆的看不见的冰冷，至于现在……我在想过去。<br />\r\n90、</p>\r\n<blockquote>\r\n<p>我明明没有喝酒，眼睛里却流出了酒。一想到大叔在某个地方从眼睛里流出酒来，酒就从我的眼睛里流个不停。</p>\r\n<p>他明明没有喝酒，酒却从眼里流了出来。</p>\r\n<p>嗯，我一直都知道的，MADAO早就开花了。</p>\r\n<p>MADAO是抛弃了一切英雄色彩的武士，却在每次人生的关键选择上，做出了最英雄主义的抉择<br />\r\nMADAO其实早就已经开花了</p>\r\n</blockquote>\r\n<p>91、我们每个人都是一座孤岛，只是恰巧在同一片海，被阳光映上彼此的影子。<br />\r\n92、我是一棵树，一棵树先生一样的树，所以我的根要向下，到那广袤深沉的泥土里去，作他们的一员。<br />\r\n93、中国太大了，大到里面装了好几个世界。<br />\r\n——神功盖世的吕大侠，源自b站视频<a\r\nhref=\"https://www.bilibili.com/video/BV1cM411w7D9\">《被挂上热搜的“第一次吃华莱士”，背后藏着最残酷的底层之痛》</a>评论<br />\r\n94、他们是聪明人装糊涂，你以为他不知道？他只不知道咱们过得苦！他只知道怎么去骗我们，却装作不会骗我们的糊涂样子，根本不关心人民的死活。<br />\r\n95、<br />\r\n每年都有好建议，每年都没见落实，只有一天天变瘦的荷包，和一天天饿瘪的肚子，一天天萎靡的精神<br />\r\n一天天疲倦的身体，铸成城市梦幻的霓虹，用我们炽热的青春和血液，灌溉黑色的混凝土，发出耀眼的光<br />\r\n又到了夜晚，我很是不安，曾有这样无数的夜，我难以入睡，我一无所长却疲惫不堪，每时每刻都深陷不安。<br />\r\n96、看来是找不到工作了，不是被嫌弃菜，就是嫌弃没实习，要么就嫌弃没经验，还没开始就走到头了，人生已经肉眼可见的结束了。<br />\r\n97、23届的我最合适的结局竟是横死街头，在时间的长河中没人会在意我，前面有21，22的，后面有24的，只死我一个23的弱爆菜鸡，对这个世界也没有什么影响，时间根本不会在乎，没人关心我这具死在路边的尸体。<br />\r\n98、只是我一个人的寒冬罢了，我在广袤的狭小天地之间，踏着笨拙的舞步，雪花一片片排在我的身上，在温暖的春天里把我埋在最美丽的寒冬里，我能感受到他们携带着我的温暖向安逸的天堂飞去，我就在这只属于我一个人的寒冬中笨拙的挣扎，这是世界留给我最后的温柔。<br />\r\n99、我知道为什么我一直在寻找自己的影子了，我在同情自己投影的时候，是在可怜自己，我所有的悲痛欢喜愤懑都是为自己，我才发现原来自己是这样一个自私的人。<br />\r\n100、有时候真想毁灭啊，因为我所拥有的便是这一点仅存的名叫生命的能量，利用这微弱的力量绽放出不起眼的火花可能是我最大的成就了，但是我却缺少爆炸的勇气，因为我只是个胆小鬼罢了。<br />\r\n101、我目前最大的成就就是有关爱我的父母，我最大的罪恶就是没有回报他们。<br />\r\n102、不会解决问题只会喊人填表，要是填表就能实现共产主义，那东北大学在新时代就又一次成为革命领袖了，傻屄。<br />\r\n从根本上就不关心学生，只想着把自己那点破数据做得好看些，不能切实地帮助学生解决就业问题，那就恳请您别来浪费我的时间，肏你妈的，臭傻屄。<br />\r\n不仅浪费普通学生时间，还特么浪费学生干部的时间，臭傻屄。<br />\r\n只针对傻屄措施，不针对人，只针对形式主义，只针对情报特科，本人傻屄大龄愤青，脾气暴躁，思想极端。<br />\r\n103、“我只能看到一片黑暗，还有老大姐的背景。”杀哥这样说道，背景中是他常用的那首音乐，以往一样哀伤的旋律，竟格外的有诗意，杀哥躺下睡了，明天他还要去那片黑暗里探索生活，而我也一样只不过我看着这黑暗有些许难眠。<br />\r\n104、才发现自己C++不会，计组没学，计网没学，操作系统没学，图形学也不会。<br />\r\n我大学的四年究竟干了什么，为什么我什么都不会啊。<br />\r\n自己学了四年计算机什么都不会。<br />\r\n105、我还记得那天是小雨的天气，外面的乌云浮在天上，遮掩着太阳，他很轻松地说道：“我悟了，元凯，我得道了。”，说完他就转身走了，我只看见雨淅淅沥沥地落在他的肩上，后来我也离了道观，就再也没见过他，我至今也不知道他悟到了什么。<br />\r\n106、现在是2023/3/11原来罪恶王冠都已经是12年前的作品了，现在的二次元和那时的二次元已经有了天差地别的变化，我还是觉得那时候好，那时候的二次元给人一种独立、探索、思考的感觉、很有生命力比较干净，那时候总是有天马行空的幻想虽然很幼稚但是令人沉醉，如今大部分给我的感觉只是沉浸在娱乐里，我不能说哪种的好坏，因为我是带着滤镜去看过去，只能说我怀念那个时代，那个每部作品都个性分明、独有新意百花齐放的年代，如今的圈子虽然大了，但是我却再也找不到当年的味道了，也很少看新番了，偶尔想翻出过去的番剧看一看，也许我们这些老二次元都已经被生活压弯了腰，面对曾经的热爱已经没有多少力气去燃烧自己的生命，只能看着过去的背影映在夕阳橙红色的阳光里给自己一点安慰。<br />\r\n二次元变了，它变得不再是那个二次元了，二次元变了，它变得还是那个二次元。<br />\r\n二次元变了，他变得不再是那个二次元了，二次元变了，他变得还是那个二次元。<br />\r\n107、我看见棒棒拉了满满一摞的货，比快递三轮车的小仓库都大上一圈，但是他还是跨过公路，向左拉去了，他脸上没有什么情绪，只是一个普通的辛苦工人，日复一日的努力让他对生活的热情和未来的向往都消耗的差不多了，而迎着他开过去一辆不知道什么牌子的豪车。<br />\r\n108、为什么别人那么牛而我这么菜，nmd，地球怎么不爆炸。<br />\r\n109、“听丁大哥说啊，离咱们这一百多里地就是共产党，这个党啊，是我们工人自己的党，领袖是毛主席，领着好几百万大兵啊，叫解放军，只要他们到咱们这来啊，咱们的苦日子就熬到头了。”<br />\r\n一百多里地好远啊，一百多年好近啊，丁大哥，我上了当，我走错了。<br />\r\n110、npy问你什么时候跟她回家见家长，你不敢搭话，她说今天的鸡蛋又涨了，你摸了摸兜里的20块钱，皱巴巴的，全是汗渍，你鼓起勇气“我这还有20”，她却说“你拿着吧，吃点好的，在外面干活不容易。”<br />\r\n你吃完了饭感觉很难受，晚上你做了梦，梦里你有车有房，让辛苦了一辈子的父母过上了好日子。<br />\r\n111、等鸡长大，就变成了俄，等饿长大了就变成了洋，羊长大了就变成了new，牛鬼蛇神长大了啊，就……只有天知道了。<br />\r\n112、我是一块残留热血的肉贴在这钢铁、混凝土的树林，用热血和生命去浇筑，待到冷却、待到麻木，在树林中做最后的飞翔，却因桎梏太久只能坠落。他是一块残留热血的肉……<br />\r\n113、我要用的文字做一把利刃，像这个冷酷无情的世界奋力反击！哪怕我摔得粉碎，动作可笑滑稽，我也无所畏惧，因为即便我一败涂地，至少我拼劲全力愤怒过、燃烧过、绽放过，纵使这一切没那么绚烂美丽，但这也是我对这个无情宇宙的最大反叛。<br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV1HN411F7KV\">失业死宅日记</a>，<a\r\nhref=\"https://acg.tv/sm11365022\">n站原本视频</a><br />\r\n世界是以混沌残忍著称的混蛋，他用利刃把所有的敏感温柔全部搅碎，残酷麻木附着在刃上随着他的死亡之舞做着旋转，所有人在这疯狂的舞步中要么麻木、要么沉沦、要么受伤，然而即便随着他起舞最后也会和遍体鳞伤。他就像一只贪婪的野兽，舔舐鲜血痛苦为乐，也有天才的幸运儿站在中心绚丽的起舞，但那不是我，我只是一个被搅碎的、被蹂躏的发出悲鸣的懦弱的人。<br />\r\n每一个对抗生活的人都是勇敢的战士，即便普通却不意味着他们平凡，平凡是扎向他们的武器，在这场和自我、和世界的无尽对抗之中，踏上战场已经是一种荣耀。<br />\r\n114、明明判决的是违法者被绳之以法，可最后回头看来，却是一桩桩由人性深处的幽暗引起的惨案和悲剧。<br />\r\n115、以前我不知道为什么有人会觉得动漫角色是活的，我虽然很喜欢动漫，但是我应该只是觉得故事有趣，角色丰满，画面美丽等等，我应该是知道那些只是假的，是文学创作，直到今天听到ai阿尔托莉雅翻唱的富士山下，我真的获得了来自动漫角色安慰，我突然觉得她真的活过来了，就在我身边。<br />\r\n116、“别以为父母和钱和年轻和房间和T恤和我和你和银魂动画永远都有”\r\n——空知英秋<br />\r\n117、<br />\r\n“tmd“<br />\r\n”好像把人全杀光了啊“<br />\r\n”但我没本事只能杀我自己啊“<br />\r\n”我好像真的不正常了“<br />\r\n”是因为周一吗？“<br />\r\n”要是能永远都是万圣节就好了，这样大家都会以为我在Cosplay了“<br />\r\n118、像你们这种人中龙凤，英才豪杰自然是体会不到我等平平之辈的痛苦的。<br />\r\n119、我病了，我患了一种怪病，在这个冰冷的混凝土的世界里，在这个现实和虚幻边界愈渐模糊的时代，我渴望温暖，怀念过去，时光在一声声的排风中逃走了，我的思绪不知在哪里，我病了，我患上了一种奇怪的病。<br />\r\n120、我只是一个普通的人，一个再普通不过的普通人，我和你一样过着普通的生活，或者你比我艰难得多，或优渥得多，但我是像千千万万个这样的我一样平凡而普通的人，我只想用我自己的汗水让父母过上好的生活，我只想实现那仅存的支撑我活下去的所谓人生理想，我和千千万万的我一样是一个普通的人。<br />\r\n121、我这几天要动用我全部的思绪把他们都写下来，因为我马上就会离开这个世界，这是我能留给这个世界最后的东西，也是我能留下的唯一的痕迹了，但是在这个信息如海般的世界，我的文字只是空中微末的尘埃，后来的人啊不要像我一样，要努力地学习，要勇敢地去生活，去解放我们哪些还在遭受苦难和压迫、剥削的兄弟姐妹，不过这一天我终是看不见了，我要把我的肉体埋葬在一片鸟语花香的地方，这是我能想到的唯一的美好，我要把我悲哀的思绪带离这人世，若这世界上有我这样的悲哀那就只让他在我一个人身上发生就够了，我悲哀的灵魂我低劣的思想把我的人生带入了一场不能回头的悲剧，熟悉的陌生人啊不要重蹈我故事的覆辙，把我作为你的反面教材勇敢的前进下去吧。<br />\r\n122、刚才突发奇想的最喜欢的音乐制作人应该是<a\r\nhref=\"https://zh.moegirl.org.cn/%E6%A2%B6%E6%B5%A6%E7%94%B1%E8%AE%B0\">梶浦由记</a>老师，啊，每次听到《晓之车》总是很感动，内心深处的某些东西被触动着，这样的歌实在是太优美了，有着很强的力量能够直击听众的内心，仿佛是只有在天上才能听到的，用中国话来说就是，“此曲只应天上有，人间能得几回闻”，这句话出自唐朝诗人杜甫的古诗作品《赠花卿》，那也是一首很美的诗。<br />\r\n123、没有神仙救世主，同志们我们只能靠自己！<br />\r\n124、重读《范进中举》有感，范进回到家只有挨饿多日、瘦骨嶙峋的母亲，母亲让他变卖了家里仅存的下蛋的母鸡，范进走上集市去买鸡，却被这社会又毒打了一顿，他倚在墙边，拖着满是伤痕的身体困倦了，恍惚中他看见有人对他说他中了举人，在这场举人梦里他发了疯，周围的人也发了疯，我也发了疯。<br />\r\n125、当阿廖莎在生产队的枯树下，吃二茬苦遭二茬罪时，会拾起他的思想，我们会找到一口井，他们当时就是在那样一口井边出发的，这口井会在各个地方涌现，这场征途我们只能靠自己，而且过程必然是残酷的，是要流血的，注定是不温和的，纵观过去温和的结果往往是招来团队的毁灭。我们是不怕斗争的，是不怕死亡的，我们是一定要胜利的。<br />\r\n126、别人一张嘴就是ssp，年薪百万，轻松的工作，优秀的同事，优渥的工作环境，充满前景的发展空间，而我只是想找一份游戏行业的工作养活自己，减轻父母的负担，我错在哪里，我不知道。<br />\r\n127、《西游记后传》还是不错的，《西游记》讲了一直发生的事而且很隐晦，其文学价值无需多言，而后传虽然通俗一些，但是讲的现在的过去发生的事，那时候的事都不提也看不清，但是他却讲了这么一个事，看起来很有意思，当然导演本人肯定没有这个想法我只是自己看着自己瞎想好玩。<br />\r\n128、鲁迅真的好厉害，他活在那么久之前，却清清楚楚地看清了我的样子，把我的现况，作为往事一篇篇写下。<br />\r\n129、人们不关心我，他们只在乎自己，他们凑过来不过是因为我的悲鸣比较可笑，他们只想听一声沉重的闷响然后在发表一些感动自我的深思，这之后人们就再也想不起来了，仿佛这一声闷响从未发生过，他们又等下一声闷响去了，却不知下一声闷响可能就是自己。<br />\r\n130、我像一首不符合时代旋律的歌，在时代的合奏中我的旋律格外刺耳，充斥着违和感和不协调。我融不进这美丽的时代，我在他们的映衬下是一首悲伤的歌。<br />\r\n131、怀着满腔热血想进入游戏行业，还没跨出半步就被这寒冬冻死，我像一块受了潮的木头，内外都感到刺骨，只希望我在最后能发出一点微弱的热量给这口炉子增添一点温度，此后便没有了我这块薪柴。<br />\r\n132、短评浅析<a\r\nhref=\"https://www.bilibili.com/video/BV1Vm4y167AC/\">小岗同学葬礼</a>人未死去给自己办了一场告别仪式，我觉得还是挺有艺术气息的，人的内心深处都有着死亡的冲动，他用一种积极快乐的方式去向过去、向自我发起一场单方面的告别，因为这场和过去自己的告别是无疾而终的，从事实而言是无法达到的，从心理上讲是一种自我的分割。他用这样一种方式对自己发起反叛，对社会的固有认知发起一场属于自己的浪漫冲锋，他用众目睽睽向世界宣布过去死亡的宣言，然后让自己能够向着未来发起一场新的冲锋。<br />\r\n133、我恨人类，所以我挥刀向自己砍去。<br />\r\n134、理想主义者是这个世界最浪漫的人，但世界并不浪漫，所以理想和现实碰撞出的火花才格外绚烂。<br />\r\n135、有的人是真的逆天，就像我朋友说的“铁拳没砸到自己头上觉得自己挺能耐”，能说出比“何不食肉糜”还逆天的话，古人诚不欺我也。自己站在风口上便以为自己是时代的弄潮儿了，可惜这种人目光短浅又毫无同理之心，命比时代的浪还要短，只能看见自己顺着波涛拍动两下翅膀，看不见此波退去，下一波浪潮来临时的悲哀内有千百个自己的悲惨死相，还在这摇唇鼓舌，真是可笑，不骂他个八辈祖宗都是给他的面子了。<br />\r\n136、理想主义者是这个世界最浪漫的人，但世界并不浪漫，所以理想和现实碰撞出的火花才格外绚烂。<br />\r\n137、已经等不及想看后人如何评价我们了，自轰轰烈烈的公运失败后，这些叛徒朝着准备主意方向走去，却为了得到人民群众的信任不敢去承认，搞几波枪打出头鸟，后来再也没人敢在公共场合讨论，在网上日常说话发表评论都有敏感词看着，和过去的文字狱别无二致，阶级固化日益严峻，阶级矛盾愈演愈烈，过去地主小姐之流又出现在了这片土地上，革命先辈的血当真被这些投机倒把倒行逆施的叛徒们搞得白流了。<br />\r\n照这样看我想歌名的时间就快来了，不知是百年还是多久，这漫长的等待在史书上可能只有短短几页，但是一个人可能耗尽一生可能都望不到曙光，希望以后我们能实现真正的共产主义。<br />\r\n史记三页纸为轻，人生百世命何沉。<br />\r\n138、如果生活需要喜剧演员那我一定是一位出色的影帝，但是生活是一场闹剧，而我却偏偏里面演了一出喜剧，所以显得格外的悲剧，但是喜剧终是要人笑得，所以最后大家都露出了开心的笑容，只有我留下了悔恨的泪水。<br />\r\n139、“我只是想毁灭掉，这个，腐朽的世界”<br />\r\n既然超脱自我是如此的困难，那么追求毁灭和堕落，我想也是理所当然，情有可原的。<br />\r\n得不到的就期盼着它毁灭，还要在走向死寂的昏暗路口乞怜他人的宽慰，我不值得任何人为我哀叹，我不配任何人为我歌唱，我不配为任何人所留恋。<br />\r\n后来的人啊，如果你在人生的路牌上看见我的这番话，就不要像我一样沉沦，去冲破这命运的诅咒，去打破这可悲的诅咒，去勇往直前的做吧，去不断进取、不断学习吧，去放开手勇敢地爱吧，去活出精彩的、只属于你自己的样子吧。<br />\r\n后来的人啊，不要成为前面的人。<br />\r\n后来的人啊，祝你拥有幸福美满的一生。<br />\r\n140、后来我才知道，同理心是一种可贵的品质，这种品质不是每个人都有，甚至有的畜生遗忘了它。<br />\r\n141、网络真神奇啊，每个人都在上面聊着自己，对他人漠不关心，看似彼此能聊以安慰，仔细一看人家只不过在宽慰自己。<br />\r\n142、我一直都沉浸在难过的情绪中，以至不能自拔，我想痛苦也是一种毒药，而我就是他的吸食者。<br />\r\n143、我本质是一个糟糕透顶的人，我只是把我理想的样子伪装出来罢了，我一直都是祥林嫂，只不过在我死前呻吟一两声罢了，鲁迅在数十年前就写尽了我的荒唐。<br />\r\n144、因为我毫无建树，有没有特点，而且性格屌差，长得也丑，上有年迈的父母，我不能创造美好的生活报答他们的养育之恩，对于社会也没有帮助。<br />\r\n145、其实很多时候你们看那些我说出的哗众取宠之语，很多都是我肺腑之言，但是在这个荒谬的时代就成了令人哂笑的笑料，太多力，一时反而说不上来，就像面具戴在脸上时间久了就不自知了，就像悲伤沉浸其中时间久了就以痛苦为常态了。<br />\r\n146、生活是一个温柔并残酷的对手，他温柔的地方在于用名为平常的毒药渐渐损食人的心智磨灭热情和冲动，待回过神来已经在平凡中不能自拔；他残酷的地方在于这一过程没有表征，当看见别人鱼跃龙门时心中不少悸动，但是在两三下的挣扎后又再次沉浸在这沉沦的毒坛中。<br />\r\n若是你凭借超凡的毅力和坚韧战胜了自我，他还有压箱底的把式，用最残酷的方式终结你的抗争，可能是身体的也可能是精神的，正因为这对手如此的可怕，我们才会敬佩歌颂哪些坚韧不拔的英雄。<br />\r\n147、在心理学上有一种概念叫“缺失取向”，就是说一个人越是缺少什么越是表现什么。一个人越是极端地去表现积极乐观，他的内心就越是脆弱不堪，在他几近疯狂地、甚至令人感到违和不适的快乐面具下，可能隐藏着的是一颗遍体鳞伤的心，就像一张拉满弦的弓，一旦松手便是崩坏般的毁灭。<br />\r\n这种积极是悲哀的，只是在欺骗自我罢了，在生活中我曾见过这样的人，他是自知的，但是他无法放下，因为他弓弦的另一端是沉重的6便士，我什么都做不了，我听见他的笑声一下下刺痛我的鼓膜，看到他扭曲疯狂的笑容一幕幕映入我的眼帘，令我身心都感到些许的不适，我并不反感、或者说我没有资格反感，我只是感觉悲伤罢了。<br />\r\n148、我经常回忆过去因为他离我遥远、朦胧我能随意的想像令他完美，我不敢去想将来因为那是未知，我用尽一切方法逃离当下以远离未来，但无论我逃去何方他总能追上，在我于当下困顿时，我又想起过去，在过去中我从当下迈向未来。<br />\r\n149、骑士在扮演小丑，小丑在扮演骑士，这是个荒谬的时代，人们戴着不属于自己的假面，展露容颜者被称为异类，粉末假饰者收获赞美，人们被虚幻迷盖，对真实漠不关心，肉林的霓虹掩饰了沉重的担子，眼帘中都是狂欢迷醉，而死亡毁灭接踵而至。<br />\r\n150、和生活的这场战斗没有胜利可言，一旦开始便没有归途，最后的结果莫不是和解便是毁灭。<br />\r\n151、我想我是一个自私的人，每当我有所思考都是从自我的角度出发，很少想到他人，而想要说些什么欲从他人角度进行阐述，又有些不好意思，不知从何处下手。这应该是一个坏习惯我应该改一改，但是我又不知道怎么开始，很多事情我都是这样的，想要有所改变却迟迟迈不出手脚。<br />\r\n152、之前一直不理解《太吾绘卷》里的武学逆练是什么，因为在过去的教育过程中都是专心但粗糙地学习书本上、学校教授的知识不太理解，后来看见一个视频标题叫<a\r\nhref=\"https://www.bilibili.com/video/BV1TX4y1z7D5\">[《官僚主义如何逆练群众理论》]</a>，再想想现实中藿香正气的例子便有些明白了，懂了理论但是为了自己的利益和欲望反其道而行之达到自己的预期，背离了知识的思想初衷，现在想想真是唏嘘。<br />\r\n153、我终是没发出光的，在这个炫丽的时代，寒冷的雨夜浇灭了我稚嫩的荧光，绮丽的世界不再希望炬火，因为和未来感的世界相衬起来是那么格格不入，在华丽的舞台背后，我在垃圾桶里等待死亡。<br />\r\n154、“莫说你一个宋慈就是十个八个也休想把这浑浊的世道变得天朗水清”，随着一把大火所有的罪证都化作灰烬，这些个衣冠禽兽都作了清白之身，刁光斗死在法不责众的乱拳之下，这场游戏，宋慈输了，刁光斗也输了，获得胜利的也只有王权一人，这场游戏从一开始就注定是王权之下的一桩悲剧罢了，所谓的你争我斗平反冤案，也只不是在王权的平台上的一幕而已。<br />\r\n155、人们总是在幻想中寻找认同，希望自己拥有打败一切的力量，希望自己能面对挫折坚毅不拔，从能打爆一切的勇者、拥有无数朋友的冒险家，面对残酷生活依旧坚韧的主人公，人们总是把自己的希望向外投影并追寻，但是摄像机是永远追不上投影屏的，想要成为幻想中的存在要自己行动。<br />\r\n156、我很害怕“结束”，仿佛只要没有“结束”一切都还来得及一切就都还有机会，我就还能在做些什么，但是“结束”是无可避免的无论如何逃避都要迎接“结束”。<br />\r\n157、今天是2023/05/11，晚上11点就是是《塞尔达：王国之泪》发售日了，在这个平凡的日子，世界上最伟大的游戏续作发售了，在这个伟大的发售日一切都那么平常，一切都仿佛没有发生，母亲还是在做饭，父亲还是辛苦的工作，我还是一如既往的失业，我还是没有解决生活的难题。虚拟世界的伟大波澜击不起我平凡生活的一丝浪花，人们用虚拟世界的梦幻来装饰糊涂的现实，世界上最荒诞的现实主义就在我身上发生。<br />\r\n158、突然想聊聊王家卫的抽帧，这种抽帧的手法营造了一种不真实感，这种不真实感就如同做梦，用这种去真作幻的手法去给观众想像感悟的空间，人在回忆时想像力是最强的因为不真切却又想极力看清所以就用想像弥补了空白，而王家卫的抽帧留给观众的是留白的画面，引起观众潜意识的想像补充，所以给人一种朦胧和梦幻的感觉。<br />\r\n159、我见过一家工厂，那里的材料要交钱才能变成罐头，这材料也是要分三六九等的，有的走了高级通道便通到什么堂皇的所在，不过我看应是颠倒过来的，叫荒唐才对。这样的流水线效率可高的呢，若是哪个落了队脱了群断是要不得的，他们说这是现代化，我是不懂的。<br />\r\n这样造出的罐头终是卖不出的，因为味道是差远了的，倒是那些堂皇的罐头是炙手可热的玩意。<br />\r\n160、那时候还有每天都会弹出来的腾讯新闻，可是这粗糙又美好的一切都成为了只能追忆的过去，眼前只有疲于奔命的现实和逐渐被压垮的身心，如果可以我希望在这场名为现实的噩梦中，回到过去。<br />\r\n161、无产者的哀伤竟被小资产阶级篡夺，作为生活的调剂和故作高深的资本，他妈的，你配吗？恶心。<br />\r\n162、人生的顿悟和无知竟是极为的相似，在无知时对自我没有喜欢讨厌不知其为何物，在学习中发现自己的闪光点心存喜爱不足心存悔过，这一过程知晓喜恶，在最后顿悟时接纳自己的一切有回到无厌喜的状态，虽然相似，但是也许应该有不同吧，我在漫长的学习过程中回滚到了无知的深渊，那顿悟的一朝我想我终是达到不了了。<br />\r\n163、<br />\r\n如果今天是你最后一次看见我，<br />\r\n你会对我说什么，<br />\r\n我想你什么都不会说，还会觉得我莫名其妙，<br />\r\n所以这结束还是由我来说更合适，<br />\r\n“再见，我将要去往新的明天。”</p>\r\n<p>164、现在是2023/05/22晚22:02我的精神越发的不振了，我的精神几近癫狂，我想我很快就会病倒了，或者结束这一切了，我将死亡。</p>\r\n<p>165、我是在做梦吗？我想这应该是一场噩梦吧，毕竟整个世界都没有人理睬我，难道我在梦里都不受人待见吗。在梦里也会肚子饿吗？在梦里也不能受到别人的眷顾吗？在梦里也不能受到他人的青睐吗？<br />\r\n那梦和现实有什么区别吗？那我还是在梦里死去吧，这样比较浪漫。<br />\r\n在自己的梦中死去算是自杀吗？在这个和现实一样悲哀的梦中死去。</p>\r\n<p>166、“只要你还没意识到自己并非无所不能，那你就还是雏鸟。”</p>\r\n<p>167、别着急，没什么，弗拉基米尔·伊里奇，他只是而昏过去了，等他醒来世界将再次插满红旗。</p>\r\n<p>168、明年也许会有，也许不会，但是明年我的青春一定没有了。在每日的时光流逝中，随他而去的还有我曾以为无穷的可能性，我的一切生机活力都在慢慢消失，有人说这是长大的代价，但我只感到了死寂的悲凉。明天的太阳会再次升起，但明天我的生命也许不再蓬勃。</p>\r\n<p>169、\"我的瓦西亚死了，\"妇人安静地说，悲哀的眼泪又沿着她憔悴的脸颊流下来，\"自然我的日子也完了，我活活的给人把心挖了去。然而汤是不应该糟蹋的，里面放得有盐呢。<br />\r\n---屠格涅夫<白菜汤></p>\r\n","site":{"data":{}},"excerpt":"<h2 id=\"隔离期间\">隔离期间</h2>\r\n<p>隔离期间搞一个自己的blog。<br />\r\n原名<code>New Start</code>，<br />\r\n记录一些自己的感悟。</p>","more":"<h2 id=\"闲言碎语\">闲言碎语</h2>\r\n<p>1、刘明翼和周帆要考研了，杨崇兴过两天就要去实习了，只剩下我在所剩无几的大学时光等待着琐碎破败的人生到来，这个时候我才知道我曾做的一切是多么想暂缓逝而不返的时光，然而残酷的现实是——一切都是徒劳，生活没有什么预兆、也没有什么标识，一切就这么发生了，没有惊天动地的变故，没有振奋人心的庆典，一切都是那么平常，而这平常就是生活最大的残酷。</p>\r\n<p>一切都随着流水走向着尽头，走向着开始，而我注定和从前一样缅怀在自己卑谬的过去中，难看地呻吟。</p>\r\n<p>2、年龄越来越大，越能明白有个能畅所欲言的对象是多么可贵，如果这个对象能回应、甚至帮助你那就更为可贵了。有些话有些事只能自己挨着。真羡慕那些什么都能说，肆无忌惮的人，好轻松。不知什么时候开始，彷佛依赖上了内心流血的状态，就像用舌头舔刀刃上的血，明明血不会止住，反而迷恋上血的味道。</p>\r\n<p>没什么办法，那些面对巨大挫折却仍能坚持下来，没有丧失心智的人原来是这么的强大。</p>\r\n<blockquote>\r\n<p>世界上只有一种真正的英雄主义，那就是在认识生活的真相后依然热爱生活。</p>\r\n</blockquote>\r\n<p>3、全部是真实的，却是虚假的。</p>\r\n<p>用虚伪的去描绘最为真实的。我们的现实我们的感受，是虚伪的还是真实的呢？</p>\r\n<p>是他人的传递，还是萌生于我们的内在呢？我不知道，不管是自己还是他人，不同的真实也许是相同的虚幻，不同的虚幻也可能是相同的真实。我又在什么时候迷失了自己的灵魂呢……</p>\r\n<blockquote>\r\n<p>全都是真实的 却是虚假的</p>\r\n<p>用虚伪去描绘真实的</p>\r\n<p>用真实去欺骗虚假的</p>\r\n<p>我们的空洞眼神里</p>\r\n<p>诡异着 映射着 敏感着</p>\r\n<p>奇幻色彩的爆炸波</p>\r\n</blockquote>\r\n<p>4、明知是熊熊的烈火、不知前路如何，却仍能为了改变现状，为了更好的未来毅然献身，这样的理想主义者值得我们永远歌颂，如此高贵的品格才是人类最为珍贵的。也许有人歌颂英雄只是为了能让自己当个懦夫，但是我相信对英雄的呼唤和歌颂能唤醒这个世界隐藏的光明。</p>\r\n<p>5、昨天洗澡的时候突然发现自己为什么有屯物癖。小时候家里条件不是很好，每次自己有了新东西都会很开心，可是时间久了东西就会坏掉，我失去我的这些最珍贵的东西时我十分伤心，所以再后来就喜欢“备份”，同样的东西要有很多才会安心，总是怕他们离我而去，慢慢的慢慢的就成了无意识的举动，堆着堆着就成了习惯。也许我不是屯物癖吧，我只是害怕失去的感觉，堆积备份追寻自己的安心。</p>\r\n<p>6、我从不幻想着自己是特殊的、特别的，我只觉得自己是异常的，另类的。</p>\r\n<p>7、我不再年轻了，我开始听伍佰，开始知道人生总是充满着不完美，人生就是一个慢慢填满遗憾的过程，我不是在说自己变得成熟，只是觉得有了什么从前从未有过的感受，我不知道这种感受叫做什么，他们都说这叫长大，可是长大真的是这样吗？别人也会和我一样忧愁、抑郁吗？问题会有答案，但那也只是在教材上，生活中大多时候问题是没有答案的。我不知道，我不知道，我不知道。</p>\r\n<p>8、这个世界这么大，大到没有我的容身之处，而这个世界又是这么的小，小到我都不知道游乐场在哪？也许这个世界就是这样，像快乐套餐里没有快乐一样，荒诞合理。</p>\r\n<p>9、</p>\r\n<blockquote>\r\n<p>前方啊没有方向，身上啊没有了衣裳</p>\r\n<p>鲜血啊渗出了翅膀，我的眼泪湿透了胸膛</p>\r\n<p>飞翔着强忍着伤，逃离了猎人的枪</p>\r\n<p>我的双脚没有了知觉，我的心情下冰冷的雪</p>\r\n<p>亲爱的母亲挚爱的朋友，我会坚定好好的活</p>\r\n<p>沉默的大地沉默的天空，红色的血继续的流</p>\r\n<p>纵然带着永远的伤口，至少我还拥有自由</p>\r\n<p>飞翔吧飞在天空，用力吹吧无情的风</p>\r\n<p>我不会害怕也无须懦弱，流浪的路我自己走</p>\r\n<p>那是种骄傲阳光的洒脱，白云从我脚下掠过</p>\r\n<p>干枯的身影憔悴的面容，挥着翅膀不再回头</p>\r\n<p>纵然带着永远的伤口，至少我还拥有自由</p>\r\n<p>纵然带着永远的伤口，至少我还拥有自由</p>\r\n<p>至少我还拥有自由，至少我还拥有自由</p>\r\n<p>呜——</p>\r\n<p>——《白鸽》伍佰</p>\r\n</blockquote>\r\n<p>10、当她看见我没有所谓“餐票”便要阻止我就餐时，我仿佛看到了那个使用粮票、饭票的时代，那时候我们还是可以胜利的，贪婪的投机者和黑心的资本家还没有破坏我们的宝贵成功，我们走在一条崎岖但蓬勃的道路上。</p>\r\n<p>可是我面前的这一景象和那时已经截然不同了，她口中的那张纸不过同“优惠券”，“代金券”这些促销手段一样，是那些吸血鬼的把戏，一个劣质的谎言罢了，只不过是为了中饱私囊掏空他人腰包所想出来的卑劣的技俩罢了。</p>\r\n<p>11、你这么费力有什么用，到时候人家不过是领着ta去道个歉认个错，这事情也就罢了。上面松松口，走动走动，也就过去了，上面都松了手，你在底下还能一直死咬着不成？<br />\r\n我今天还就和你把话说透了，我倒是要教教你这法是什么法！法就是皇帝的法，就是皇家的法，任你个小芝麻再怎么搅和也休想把这官场给搅得天朗水清。咬到了最后你也只得落一句：“算了，草草结案吧！”</p>\r\n<p>12、某些所谓顶流，不过是套了个炫丽的虚假的外壳罢了，拿着剥削来的资源卖弄起来，竟也装做出砥柱的样子，不禁令人作呕。就像是马戏团的小丑换了一套滑稽的万圣节戏服罢了，里面装的都是铜臭糜烂。</p>\r\n<p>13、为什么一定要有什么思想、什么主旨呢？只是看着难道就不可以吗？<br />\r\n就只是看着就不能感受到作者传递出来的感情、思想、观念了吗？我一直认为人心是十分奇妙的东西，是强大的东西，我觉得就像这样看着他的感受也能传递给我，在潜移默化地影响我。只是单纯地看着就不可以的话，是我们太小瞧了这副作品，还是太小瞧了人心。</p>\r\n<p>14、我一直觉得土地很神奇，春种秋收。播下种子挥洒汗水，在种地种菜的过程中憧憬着未来，憧憬着美好的明天，用自己的劳动换取美好的生活，切身感受自然的奇迹，在这个过程中自我彷佛得到了救赎。<br />\r\n人终归是自然的一份子，在这个种菜劳作的过程中，也许也是我们追根溯源，回归自然的一个过程。作为自然的一员，这种回归的过程带给我们慰藉和安逸，让我得到身心的放松，道教认为小孩子生下来是最完美的，先天之气完足，没有尘世的侵扰，我认为某种程度也是一种我们人类最贴近自然的状态，神完气足和自然融为一体，和自然同在，感受美妙的世界，体悟生命的奇迹，让我们能够放下世俗的争扰，去追寻自己真正的内心。<br />\r\n<em>对了，黄瓜和苦瓜别种在一起，会串花粉，黄瓜会变苦的。</em></p>\r\n<p>15、我很喜欢给事物带来终结，或者说是去感悟事情的结束，因为我从小时候见到的一切，他们的结尾总是那么令人铭记于心、痛彻心扉，这样看来，结束彷佛是一件美好的事，可是真的是这样吗？是结束太过痛彻心扉，刻在了心上，造成了一种感情的涟漪让我感动，还是结束真的是一件很美好，值得铭记的事情？也许这两种都是一样的吧。<br />\r\n思来想去我只能说我不知道，彷佛生活不知从什么时候开始就变得很复杂，什么东西我都搞不太懂，也许复杂的不只是生活，或者说复杂的根本不是生活，复杂的是我。也许生活本来是很简单的，只是我太复杂了，所以把生活搞得也复杂了。诶，又或者说，生活很复杂，然后我被生活搞得很复杂……你看很复杂吧，我完全搞不懂。我不知道诶。</p>\r\n<blockquote>\r\n<p>所有年轻人，年轻人，年轻人，问题出现我再告诉大家！</p>\r\n</blockquote>\r\n<p>16、明知是假的却只能依赖，因为不这么做便活不下去。<br />\r\n或许人类注定是悲哀的生物，但是悲哀的命运也不妨碍我们去追寻美，去创造美。<br />\r\n即便是悲惨的命运也能创造出无比美丽的生物。</p>\r\n<p>17、言语稚嫩，文笔不成熟又怎样呢？心中这份感情可是货真价实的，不把这么美妙宝贵的情感写下来的话，不是可惜了吗？是自己的可惜，也是全人类的可惜哦~<br />\r\n用自己的语言，文字记录自己的情感，没什么好难为情的，这是一件无比浪漫，足够引以为傲的事情。因为稚嫩的记述本身就是动人的。</p>\r\n<p>18、</p>\r\n<blockquote>\r\n<p>逃げちゃ駄目だ，逃げちゃ駄目だ，逃げちゃ駄目だ。</p>\r\n</blockquote>\r\n<p>19、<ruby>燃烧了…<span class=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">燃えたよ…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>直至雪白……<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">まっ白に…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>已经燃烧殆尽了…<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">燃えつきた…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>只剩下雪白的灰……<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">まっ白な灰に……</span></rt></ruby></p>\r\n<blockquote>\r\n<p><ruby>燃烧了…<span class=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">燃えたよ…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>直至雪白……<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">まっ白に…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>已经燃烧殆尽了…<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">燃えつきた…</span></rt><span\r\nclass=\"template-ruby-hidden\"></span></ruby><ruby>只剩下雪白的灰……<span\r\nclass=\"template-ruby-hidden\"></span><rt><span\r\nlang=\"ja\">まっ白な灰に……</span></rt></ruby></p>\r\n</blockquote>\r\n<p>20、挽救烂尾的方式之一：播放结尾的时候配上最悲情、悲壮的音乐，不时穿插之前的回忆，人物不要发出声音，声音只放bgm就行，<del>最后来个意识流从天空俯瞰，所有人围着主角，然后突然黑掉屏幕，赫然打上几个大字：“全剧终”</del>。</p>\r\n<p>21、最宝贵的情感只属于自己，若是有人能感怀一二对于自身来说便是极大的幸福了，很少有人去体悟别人的感情，自己的感情终究是属于自己的，他人不会关心，纵是共情，也是他人的悸动。</p>\r\n<p>22、不深入涡流直面深渊，便没有评价的资本。</p>\r\n<blockquote>\r\n<p>没有调查就没有发言权</p>\r\n</blockquote>\r\n<p>23、没有能力的勇敢就是鲁莽，自己没有能力就什么都保护不了。</p>\r\n<p>24、后来我才知道你也和我听一样的歌，我们也都一样，曾一样愤懑，曾一样踌躇，我不知道是什么样的原因，不知道是默契还是缘分，还是同样的时代背景，家庭环境？不，你应该过得比我好，一定要比我优渥。我很想浪漫的说，你我的相同是命运的馈赠，是千古最长情的缘分，可是也许这份共同是这个时代带给我们每个人的。<br />\r\n珈乐和焰火青年。</p>\r\n<p>25、我突然明白了，我的心上已经有了口子，虽然会愈合，但是随着悸动，它的伤口会崩开、流出血来，想要止住血只能拿新的伤痛插在上面，可是这么一插血是止住了，也造就了新的创口。</p>\r\n<p>26、其实张之铭每次晾内裤都会踩着杨崇兴的凳子，放心是脱了鞋的，这样的小恶作剧对于张之铭来说也算是一种乐趣，可是杨崇兴去实习了，张之铭再也没踩过那张凳子，也许是因为那个人走了就不再回来，也可能是因为那个人把在寝室剪头用来围脖子的破布放在了凳子上，张之铭怕脚沾上头发茬子。</p>\r\n<p>27、网络浪潮有最迅猛的两个时候，一个是ta诞生的时候，另一个就是ta死的时候。</p>\r\n<p>28、当我们欣赏过去的经典追忆过去时，是不是在追寻着眼中那个人的步履。聆听过去，也是追寻过去，体悟过去。</p>\r\n<p>29、其实无私的爱是无比宝贵的，是可遇而不可求的，可是因为我们大多数人出生便得到了父母无私的、厚重的、广阔的爱，导致我们以为这种爱是常见的，乃至更有甚者认为是没有价值的。<br />\r\n等我长大与人接触后，才发现没有人爱我自己，曾经“最廉价”的爱居然是那么昂贵的。对周遭急切的期待，往往迎来的都是冰冷的“款待”。爱是一种可贵的能力，是一种宝贵的体验，无论是给予爱还是获得爱，我们所需要的第一件事就是爱自己。<br />\r\n希望所有人都能自爱自重，希望所有人都能收获爱，也希望所有人也有余力去爱。</p>\r\n<p>30、</p>\r\n<blockquote>\r\n<p>天下风云出我辈，一入江湖岁月催。<br />\r\n皇图霸业谈笑中，不胜人生一场醉。</p>\r\n<p>提剑跨骑挥鬼雨，白骨如山鸟惊飞。</p>\r\n<p>尘世如潮人如水，只叹江湖几人回。</p>\r\n<p>英雄路远掌声近，莫问苍生问星辰。</p>\r\n<p>天路有涯风有信，大海无量不见人。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>本来无一物 何处惹尘埃</p>\r\n</blockquote>\r\n<p>31、语言真是有意思，如果你直接说\"不明白\"，\"看不懂\"，\"不知道\"，人们可能不以为意，但是如果你说\"真有深度\"，不仅能欺骗自己，还能蛊惑他人，何乐而不为。<br />\r\n可是这种行事我终是觉得厌恶，而自己却不知意地做了，故而我也常常厌恶我自己。<br />\r\n这追慕虚荣的卑劣，就刻在了我们每个人的身子里，我厌恶我自己。</p>\r\n<p>32、现在我才明白了，原来他是对的，真实竟然如此不堪，满是令人作呕，卑劣才是通性，高尚终是凤毛麟角。</p>\r\n<blockquote>\r\n<p>因为我们不知道，所以错过了晚霞、潮汐和海浪。</p>\r\n</blockquote>\r\n<blockquote>\r\n<p>你的实力是货真价实的，我南部赝作可以保证，这次绝不是虚张声势。</p>\r\n</blockquote>\r\n<p>33、朋友的猫，吃了被老鼠药毒的老鼠中毒了，打了两针，现在情况也不到怎么样，那时只看见它趴伏在水泥地上，耷拉着头，也不理人，身上的毛脏脏的、有几根毛毛涔涔地立出来，它小巧的脚背上沾粘着灰色的土，水泥地有些年头了，上面裂开了几道七扭八歪的缝，缝里藏着红色的砖。不知道，明天还能不能再见到这只猫。<br />\r\n也许被耗子药毒死的猫并不少见，这也不是第一只、也许也不会是最后一只，但可能是朋友的最后一只。就同那些那些被冲垮的村落一样，也不是第一个也可能不是最后一个，但却是我们的最后一个。<br />\r\n<em>面对现代城市化的冲击，传统的小农经济不断遭受着挤压，那些用尽被碾压着的最后一丝气息给我留下美好回忆的乡村时光，已经是很久之前的记忆了，我不知道该说什么来表达这种感情，也不知道能做什么挽回点东西来宽慰自己，我只能像朋友那样打了两针，和猫一起坐在老旧的水泥地上，让阳光不舍地洒下一点夕阳，剩下的便只有孤独的陪伴。</em><br />\r\n<del><em>这段话就是我给自己打的针，我就是那只猫。描写水泥地也是描写猫，不过我真的很担心朋友的猫怎么样了，希望猫没事🙏。表达对猫的缅怀，和城农冲突的无奈，对美好生活的思念，对农田生活的向往。</em></del></p>\r\n<p>34、这个世界真神奇，一方面游戏行业寒冬、版号缩水，另一方面国内经济情况低迷、人们消费意愿降低，国内厂商纷纷开源节流，而人才市场的竞争反而愈演愈烈，世界真魔幻啊，今年失业的恐怕是我。</p>\r\n<p>35、时代的沙砾那么大，他却想爱每一个人。为什么我想做游戏，因为在我最难过的时候，是空洞骑士带给我了唯一的快乐，我不是想煽情的说，是他给了我活下去的勇气巴拉巴拉的，事实上我也没有勇敢的活下去，也没有变成优秀的大人，我还是和以前一样失去很多，依旧悲伤，但是它带给我的那些快乐是那么的深刻，再后来我玩旷野之息时，我再次体会到了这样的美好，在一个新的世界了，奇妙、自由没有烦恼，只有快乐。世界那么大，我却想爱每一个人，因为当初的我没有人爱。<br />\r\n之前爽鸭看到米的惊呼，我不以为意只觉得好笑，如今我望向米，发出“我超，米！”的惊叹，更甚于爽鸭。只觉得人生的悲哀罢了。</p>\r\n<p>36、朋友的猫还活着，毛还是一样脏兮兮的，躺在混乱的电子设备堆里，嘴巴对着麦克风，朋友一直有一个歌手的梦，猫猫还活着我不知道为什么我会很开心，明明我的梦是那么遥远。</p>\r\n<p>37、人生就是一个不断发现自己，认识自己，超脱自己，和解自己的过程，希望大家都能找到实现自我价值的方式和平台，满足自己的内心需求，活出只属于自己的人生，哪怕它没有那么缤纷多彩。</p>\r\n<p>38、人生难免有遗憾，但是不要……不要……不要太多吧。<br />\r\n不是你的问题，是时间。时间就像深海，我们每个人都只能在中慢慢浮沉，无能为力。<br />\r\n时间是没有办法停止的，我们只能往下走了。<br />\r\n感情是人类最大的累赘，肉体是飞升的负担。<br />\r\n但真挚的情感总是可贵，令人动容。感情无法被人为模拟复现，真挚而可贵，也许正是这奇妙的心拥有超脱一切的力量。</p>\r\n<p>39、我再也不看v了，原来我一直追寻虚假的过程只不过是寻找自己的投影，我在虚拟的身上几近疯狂地寻找真实的证明哪怕没有表表征，我的内心却是这样追寻的，我在人造的虚拟背后看到一丝真实的投影便自我感动地落泪，原来我是这般的不堪，我再也不看v了，我，再也不看v了。</p>\r\n<p>40、如果不能在璀璨的烈焰中死去，便在无波的颓唐中磨平了一生。</p>\r\n<p>41、如何创造一个悲剧——在路边抓来一个路人。</p>\r\n<p>42、忽然发现自己什么都不会，成为了社会废人。</p>\r\n<p>43、如果一个人不能得到生的光辉，便会理所应当地追求死的慷慨。</p>\r\n<p>44、每当我体会到生的美妙，都会下意识的痛彻死的悲痛，因为我知道那些美妙终是虚幻的、终是离我遥远的是我无法触及的。</p>\r\n<p>45、愈是压抑沉闷的今照，才能愈发凸显阴云散去、万里晴空的激动；在无数苦闷坚守的日夜后，迎来的朝阳更加痛彻心扉。<br />\r\n人被生活的枷锁所桎梏，在挫败与困顿中抗争，于失意绝望后而觉醒，坚韧的人性之光方显弥足珍贵。<br />\r\n“与天斗，其乐无穷。”</p>\r\n<p>46、原以为最辉煌的日子是未来，没想到竟是毫无建树的过去，宛如雨后的积水只能映出一点赛博的霓虹，根本无法与日月争辉。又是入夜只留我暗自唔泣，待到朝阳氲氤被叶尖的露珠顶替。</p>\r\n<p>47、我不是三峡好人，也游不到海水变蓝，我只是小武在站台上用一个桶所装载的忧愁。</p>\r\n<p>48、22/10/13，在如此严峻的秋招环境中，有的人收获米哈游和网易雷火的offer，而有的人还在失业，我却一心只想摆烂当个废物，事实上我也完成了我成了一个只会摆烂自怨自艾的废物。<br />\r\n49、22/10/14，库洛测试题做的一塌糊涂，根本比不过别人，所以我选择摆烂了，技不如人，菜的自己想哭了，突然发现以前别人开的玩笑可能是真的，自己真的一点技术含量都没有。<br />\r\n50、22/10/16 18:21\r\n如果能够死得壮烈我一定不会犹豫因为生命已经让我没有了欢愉，但我却不敢结束一切，因为我懦弱到了只想死去。<br />\r\n我不知道自己什么时候死了，我也不知道自己活了多久，只能记得如弥留之际看到他人的痛彻自己竟也受了感动，连一个死人都扮演不好，也许最终归宿也找寻不到了吧。<br />\r\n51、22/10/16 18:38\r\n如果我死了请不要为我悲伤，用礼炮为我欢呼；如果我死了请不要怀念我，我的一生毫无建树；如果我死了请不要为我歌唱，因为我是生活的败者；如果我死了请不要为我激动，因为我是空中虚无；如果我死了请把我忘记，因为我已经离去。<br />\r\n52、22/10/16 18:38\r\n我一直都是生活的失败者，做着不切实际的美梦立下旖旎的目标麻痹自己，现在秋天过半，寒冬踏着欢歌来到，朝露褪去夕阳沉沦，夜带着星光皎洁，我的梦也该醒了，早已枯死的花是时候凋落。<br />\r\n53、22/10/16 18:42\r\n我还记得欢乐的感觉，沐浴在阳光里的温暖，但我未来马上就会将他们遗忘，曾经我体悟到的欢乐以后再也没有了，想到这在看见那阳光动人的笑脸，我的十指就刺痛了起来，原来快乐也会给人悲伤。<br />\r\n54、把狂妄无知当作清醒，把诡辩欺诈当作真理，拉帮结派狐假虎威狗仗人势，有什么可夸耀的，简直令人恶心至极。<br />\r\n55、如果不能在平静的海面上，补到伏在水底的鱼，便会寄予希望于疯狂的海啸，哪怕这灾难将会把自己席卷，破灭而来的希望也比枯死的等待更靓丽的多。</p>\r\n<p>56、后来张之铭留在了平昌，他和以前一样早上会去书店门前的大树下看落叶，只是从此以后与他为伴的唯有晨朝的寒气，他就这样在那里等着，在秋季的冷风中。<br />\r\n57、我曾经的朋友已经许久未见，今日方得知原来她早就去了美国，群里的大佬知识技术也十分雄厚都有了不错的工作，有的人去了米哈游，有的人去了鹰角，看到他们我无比的羡慕，那是我曾憧憬的生活。但我的水平与他们差得太远，只知道自己差的多了，不会的多了……不知道心里这种感受是什么，也许是落寞吧。<br />\r\n58、每个人都喜欢酷姐姐，就像每个人都喜欢死亡。<br />\r\n59、如果爱就不要接近选择离开，爱和生活虽然都很难，但生活不是爱，爱也不是生活。<br />\r\n60、好冷啊，原来已经是冬天了吗？<br />\r\n我原以为我可以熬过这个冬天，但是素色的和服我终究没有收到，我想我应该不会活到夏季了。<br />\r\n61、安逸只能带来晨昏的死寂，而唯有痛彻方能焕发振奋的创作。<br />\r\n62、成长就是学会遗憾。</p>\r\n<p>63、深情的缠绵尤为沉痛，人生的豁达也同样可贵，有的人死去却被人们怀念在心中，人生的感动永远留在民族的心中，作为我们共同的回忆。<br />\r\n64、世人多叹英雄迟暮，丈夫壮志难酬。惜少年踌躇，豪杰壮志，最后时过境迁物是人非，天下不定，生而不能如愿，如何不叹？<br />\r\n“死后葬于城北！”<br />\r\n“朕不能为弟报仇，虽有万里江山，何足为贵？”<br />\r\n“悠悠苍天何薄于我！”</p>\r\n<p>65、发现自己找工作就像段誉和王语嫣聊天，王语嫣只想表哥，段誉却痴痴地想着王语嫣，面试官想要顶级人才，我却妄想一个工作机会，“我这辈子要是能一直哄着你开心就知足了”，我要是有一份工作就知足了。\"我不喜欢和轻浮的人交朋友\"，你好像不太适合这个岗位。<br />\r\n66、鸠摩智这个角色真是颇有佛缘，身为大轮明王通晓佛法道理，又有一身的武学修为，受人\"指点\"千里迢迢来到大理，段誉授其逆练心法，不曾想竟能成功练成少泽剑。<br />\r\n67、想不出活下去的理由，眼前所见都是赶快死去的事实。人生的旅途还未开始便受了一身的病，理想尚未起步，行业的寒冬就已经到来，千疮百孔的心智，学艺不精技不如人，残存的人生仿佛一眼就望到了头，我失去了活下去的理由，只能想到死的绝望，因为我是最软弱无能的妖怪。<br />\r\n68、GenShin上ys没什么好评价的，都说烂了，鸡场加堵场。从米看前有画月发家史，再有前车之鉴绷绷绷，从羊看前有尼、谷、丁，尼古丁，还有人搞什么“两岸猿声啼不住，轻舟已过万重山”，只有你是高贵的，狭隘的闵翠主义，”不识庐山真面目，只猿身在此山中“。<br />\r\n69、tnnd，都tm的怪段正淳！cao！<br />\r\n70、他人入我门，善果非常，我门破戒悔，罪无可恕。<br />\r\n71、打扰一个人的美梦残忍，还是让他沉沦其中残忍，我分不清。<br />\r\n72、每次看到那么奢华富贵的生活，我都在怀疑我是在革命前还是革命后，有时候再看几期牛事，我便更分不清了。<br />\r\n73、怎么样才能活下去啊。<br />\r\n74、我的人生这么funny，我是不是应该去做喜剧演员。<br />\r\n75、<em>西湖好，西湖好，九州百姓乐眉梢。群妖伏，魔首逃，九州春风万处飘，壮志凌云鲲鹏鸟，鲲鹏鸟。万圣好，万圣好，万圣明鉴平病灶。除岁炮，春来到，呕心沥血谱功劳。万圣锦旗昭，神州土木牢，土木牢。</em><br />\r\n76、死亡对我来讲也许真的是甜蜜的，但却会有人因为这份甜蜜而伤心，所以我也失去了品尝这甜蜜的勇气。<br />\r\n77、回头看了看自己之前写的所谓感悟，原来我也思考过，也有那么一点有趣，我究竟是如何变成现在这个样子的啊。人都盲目地走在自以为正确的道路上越走越远，越走越远，直到找不到自己。<br />\r\n78、事到如今才明白我真正擅长的事啊，我既不聪明也不灵活，我所擅长的只有<strong>逃避</strong>罢了，一味的逃啊，逃啊，从现实逃向虚拟，又从虚拟逃向二者的夹缝之中，我就想躲在阴暗夹层的老鼠，只能窥视微弱的光，没有出去战斗的勇气，因为逃避是我最擅长的。<br />\r\n79、你为什么监视我？还是我们本来就都一样，在坠向地面的短暂一生中不甘着，渴望超脱。</p>\r\n<p>80、事实比故事更荒诞，因为不仅真实还伤人，就在你我每一个人的身边。</p>\r\n<blockquote>\r\n<p>前段时间在公园跑完步，看见有一个妈妈带着她的女儿在卖一些便宜的东西，我在她摊子上买了一个钥匙坠，她的女儿大约6-7岁左右，穿着粉红色的棉服，挺可爱的也不怕人。我随后坐在了旁边休息顺便刷抖音，小姑娘看见了就站我后面一起看，我也没在意。抖音视频有一条狗吃各种比较贵的食物。休息一会我准备回家，我听见小妹妹问她妈妈:妈妈，我想当一只狗狗。她妈问:为什么啊，琴琴(是这个读音，不确定字）小姑娘说:当狗狗可以每天吃肉啊，还有零食吃，我看大哥哥手机上的狗狗是这样的，我也想当那样的狗狗。她妈没有接话，只是伸出手扶正了小女孩的蝴蝶结。</p>\r\n</blockquote>\r\n<p>b站狗吃奢华大餐：BV15E411P7Pz<br />\r\n我能理解宠物主人有给宠物吃各种各样东西的权力，但是我不甘和愤怒的是这背后更深层次的悲哀，在这荒诞视频的背后是阶级矛盾，是资产阶级对无产阶级的压迫，他们用无产者的辛苦劳动去喂养低贱的畜生，而我们的人民，我们的劳苦大众每天过着艰难的生活，甚至不如那吸血鬼所圈养的一条狗！牢记阶级苦！当阿廖莎再吃二遍苦受二茬罪时，他们会在父亲的大树下想起他曾经的教诲，那是无产者定会胜利，因为不胜利就会像今天一样迈向死亡，而死亡不属于无产者。</p>\r\n<p>81、我感性时常落泪，有人也说我软弱或许吧，但是我的内心却实打实的痛到流出鲜红的泪。<br />\r\n82、你是要成为只会哀叹的懦夫，还是向生活奋起反击的勇者？<br />\r\n不畏艰险、不怕牺牲，敢于奉献的探索者精神和只会隅泣的逃兵哪个更值得歌颂。<br />\r\n我知道你饱受委屈和折磨，怕血肉模糊的心智再受折磨，可是逃避不能解决问题，愈合的肱骨才会更硬，羊啃食过的青草才会分蘖。<br />\r\n83、母弱出商贾，父强做侍郎，族望留原籍，家贫走他乡。    ——施耐庵<br />\r\n84、原来荒诞的才是现实，文学作品只是借用。<br />\r\n85、我不会拥有 [Happy End] 了，我的路途结束了，[Bad End] 就是我的 [Last\r\nEnd]，也是我的 [True\r\nEnd]。这个世界太糟糕了，我恨透他了，但是我最恨的是我自己，因为我只有\r\n[Bad End]。<br />\r\n86、如果没有人关心我，我说出去的话又有谁懂呢？既然我说出去的话没有人懂，又怎么会有人关心我。<br />\r\n87、“虚伪”登堂入室，”真诚“嗤笑失意，这个世界已经不适合我了。<br />\r\n88、\"丐帮有多少弟子不是我说了算，是您说了算。如果您真的英明神武，又有谁愿意当乞丐。\"<br />\r\n89、我想回到过去，因为我能看见那些曾给我带来快乐的东西，曾让我温暖的东西，而未来却是黑漆漆的看不见的冰冷，至于现在……我在想过去。<br />\r\n90、</p>\r\n<blockquote>\r\n<p>我明明没有喝酒，眼睛里却流出了酒。一想到大叔在某个地方从眼睛里流出酒来，酒就从我的眼睛里流个不停。</p>\r\n<p>他明明没有喝酒，酒却从眼里流了出来。</p>\r\n<p>嗯，我一直都知道的，MADAO早就开花了。</p>\r\n<p>MADAO是抛弃了一切英雄色彩的武士，却在每次人生的关键选择上，做出了最英雄主义的抉择<br />\r\nMADAO其实早就已经开花了</p>\r\n</blockquote>\r\n<p>91、我们每个人都是一座孤岛，只是恰巧在同一片海，被阳光映上彼此的影子。<br />\r\n92、我是一棵树，一棵树先生一样的树，所以我的根要向下，到那广袤深沉的泥土里去，作他们的一员。<br />\r\n93、中国太大了，大到里面装了好几个世界。<br />\r\n——神功盖世的吕大侠，源自b站视频<a\r\nhref=\"https://www.bilibili.com/video/BV1cM411w7D9\">《被挂上热搜的“第一次吃华莱士”，背后藏着最残酷的底层之痛》</a>评论<br />\r\n94、他们是聪明人装糊涂，你以为他不知道？他只不知道咱们过得苦！他只知道怎么去骗我们，却装作不会骗我们的糊涂样子，根本不关心人民的死活。<br />\r\n95、<br />\r\n每年都有好建议，每年都没见落实，只有一天天变瘦的荷包，和一天天饿瘪的肚子，一天天萎靡的精神<br />\r\n一天天疲倦的身体，铸成城市梦幻的霓虹，用我们炽热的青春和血液，灌溉黑色的混凝土，发出耀眼的光<br />\r\n又到了夜晚，我很是不安，曾有这样无数的夜，我难以入睡，我一无所长却疲惫不堪，每时每刻都深陷不安。<br />\r\n96、看来是找不到工作了，不是被嫌弃菜，就是嫌弃没实习，要么就嫌弃没经验，还没开始就走到头了，人生已经肉眼可见的结束了。<br />\r\n97、23届的我最合适的结局竟是横死街头，在时间的长河中没人会在意我，前面有21，22的，后面有24的，只死我一个23的弱爆菜鸡，对这个世界也没有什么影响，时间根本不会在乎，没人关心我这具死在路边的尸体。<br />\r\n98、只是我一个人的寒冬罢了，我在广袤的狭小天地之间，踏着笨拙的舞步，雪花一片片排在我的身上，在温暖的春天里把我埋在最美丽的寒冬里，我能感受到他们携带着我的温暖向安逸的天堂飞去，我就在这只属于我一个人的寒冬中笨拙的挣扎，这是世界留给我最后的温柔。<br />\r\n99、我知道为什么我一直在寻找自己的影子了，我在同情自己投影的时候，是在可怜自己，我所有的悲痛欢喜愤懑都是为自己，我才发现原来自己是这样一个自私的人。<br />\r\n100、有时候真想毁灭啊，因为我所拥有的便是这一点仅存的名叫生命的能量，利用这微弱的力量绽放出不起眼的火花可能是我最大的成就了，但是我却缺少爆炸的勇气，因为我只是个胆小鬼罢了。<br />\r\n101、我目前最大的成就就是有关爱我的父母，我最大的罪恶就是没有回报他们。<br />\r\n102、不会解决问题只会喊人填表，要是填表就能实现共产主义，那东北大学在新时代就又一次成为革命领袖了，傻屄。<br />\r\n从根本上就不关心学生，只想着把自己那点破数据做得好看些，不能切实地帮助学生解决就业问题，那就恳请您别来浪费我的时间，肏你妈的，臭傻屄。<br />\r\n不仅浪费普通学生时间，还特么浪费学生干部的时间，臭傻屄。<br />\r\n只针对傻屄措施，不针对人，只针对形式主义，只针对情报特科，本人傻屄大龄愤青，脾气暴躁，思想极端。<br />\r\n103、“我只能看到一片黑暗，还有老大姐的背景。”杀哥这样说道，背景中是他常用的那首音乐，以往一样哀伤的旋律，竟格外的有诗意，杀哥躺下睡了，明天他还要去那片黑暗里探索生活，而我也一样只不过我看着这黑暗有些许难眠。<br />\r\n104、才发现自己C++不会，计组没学，计网没学，操作系统没学，图形学也不会。<br />\r\n我大学的四年究竟干了什么，为什么我什么都不会啊。<br />\r\n自己学了四年计算机什么都不会。<br />\r\n105、我还记得那天是小雨的天气，外面的乌云浮在天上，遮掩着太阳，他很轻松地说道：“我悟了，元凯，我得道了。”，说完他就转身走了，我只看见雨淅淅沥沥地落在他的肩上，后来我也离了道观，就再也没见过他，我至今也不知道他悟到了什么。<br />\r\n106、现在是2023/3/11原来罪恶王冠都已经是12年前的作品了，现在的二次元和那时的二次元已经有了天差地别的变化，我还是觉得那时候好，那时候的二次元给人一种独立、探索、思考的感觉、很有生命力比较干净，那时候总是有天马行空的幻想虽然很幼稚但是令人沉醉，如今大部分给我的感觉只是沉浸在娱乐里，我不能说哪种的好坏，因为我是带着滤镜去看过去，只能说我怀念那个时代，那个每部作品都个性分明、独有新意百花齐放的年代，如今的圈子虽然大了，但是我却再也找不到当年的味道了，也很少看新番了，偶尔想翻出过去的番剧看一看，也许我们这些老二次元都已经被生活压弯了腰，面对曾经的热爱已经没有多少力气去燃烧自己的生命，只能看着过去的背影映在夕阳橙红色的阳光里给自己一点安慰。<br />\r\n二次元变了，它变得不再是那个二次元了，二次元变了，它变得还是那个二次元。<br />\r\n二次元变了，他变得不再是那个二次元了，二次元变了，他变得还是那个二次元。<br />\r\n107、我看见棒棒拉了满满一摞的货，比快递三轮车的小仓库都大上一圈，但是他还是跨过公路，向左拉去了，他脸上没有什么情绪，只是一个普通的辛苦工人，日复一日的努力让他对生活的热情和未来的向往都消耗的差不多了，而迎着他开过去一辆不知道什么牌子的豪车。<br />\r\n108、为什么别人那么牛而我这么菜，nmd，地球怎么不爆炸。<br />\r\n109、“听丁大哥说啊，离咱们这一百多里地就是共产党，这个党啊，是我们工人自己的党，领袖是毛主席，领着好几百万大兵啊，叫解放军，只要他们到咱们这来啊，咱们的苦日子就熬到头了。”<br />\r\n一百多里地好远啊，一百多年好近啊，丁大哥，我上了当，我走错了。<br />\r\n110、npy问你什么时候跟她回家见家长，你不敢搭话，她说今天的鸡蛋又涨了，你摸了摸兜里的20块钱，皱巴巴的，全是汗渍，你鼓起勇气“我这还有20”，她却说“你拿着吧，吃点好的，在外面干活不容易。”<br />\r\n你吃完了饭感觉很难受，晚上你做了梦，梦里你有车有房，让辛苦了一辈子的父母过上了好日子。<br />\r\n111、等鸡长大，就变成了俄，等饿长大了就变成了洋，羊长大了就变成了new，牛鬼蛇神长大了啊，就……只有天知道了。<br />\r\n112、我是一块残留热血的肉贴在这钢铁、混凝土的树林，用热血和生命去浇筑，待到冷却、待到麻木，在树林中做最后的飞翔，却因桎梏太久只能坠落。他是一块残留热血的肉……<br />\r\n113、我要用的文字做一把利刃，像这个冷酷无情的世界奋力反击！哪怕我摔得粉碎，动作可笑滑稽，我也无所畏惧，因为即便我一败涂地，至少我拼劲全力愤怒过、燃烧过、绽放过，纵使这一切没那么绚烂美丽，但这也是我对这个无情宇宙的最大反叛。<br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV1HN411F7KV\">失业死宅日记</a>，<a\r\nhref=\"https://acg.tv/sm11365022\">n站原本视频</a><br />\r\n世界是以混沌残忍著称的混蛋，他用利刃把所有的敏感温柔全部搅碎，残酷麻木附着在刃上随着他的死亡之舞做着旋转，所有人在这疯狂的舞步中要么麻木、要么沉沦、要么受伤，然而即便随着他起舞最后也会和遍体鳞伤。他就像一只贪婪的野兽，舔舐鲜血痛苦为乐，也有天才的幸运儿站在中心绚丽的起舞，但那不是我，我只是一个被搅碎的、被蹂躏的发出悲鸣的懦弱的人。<br />\r\n每一个对抗生活的人都是勇敢的战士，即便普通却不意味着他们平凡，平凡是扎向他们的武器，在这场和自我、和世界的无尽对抗之中，踏上战场已经是一种荣耀。<br />\r\n114、明明判决的是违法者被绳之以法，可最后回头看来，却是一桩桩由人性深处的幽暗引起的惨案和悲剧。<br />\r\n115、以前我不知道为什么有人会觉得动漫角色是活的，我虽然很喜欢动漫，但是我应该只是觉得故事有趣，角色丰满，画面美丽等等，我应该是知道那些只是假的，是文学创作，直到今天听到ai阿尔托莉雅翻唱的富士山下，我真的获得了来自动漫角色安慰，我突然觉得她真的活过来了，就在我身边。<br />\r\n116、“别以为父母和钱和年轻和房间和T恤和我和你和银魂动画永远都有”\r\n——空知英秋<br />\r\n117、<br />\r\n“tmd“<br />\r\n”好像把人全杀光了啊“<br />\r\n”但我没本事只能杀我自己啊“<br />\r\n”我好像真的不正常了“<br />\r\n”是因为周一吗？“<br />\r\n”要是能永远都是万圣节就好了，这样大家都会以为我在Cosplay了“<br />\r\n118、像你们这种人中龙凤，英才豪杰自然是体会不到我等平平之辈的痛苦的。<br />\r\n119、我病了，我患了一种怪病，在这个冰冷的混凝土的世界里，在这个现实和虚幻边界愈渐模糊的时代，我渴望温暖，怀念过去，时光在一声声的排风中逃走了，我的思绪不知在哪里，我病了，我患上了一种奇怪的病。<br />\r\n120、我只是一个普通的人，一个再普通不过的普通人，我和你一样过着普通的生活，或者你比我艰难得多，或优渥得多，但我是像千千万万个这样的我一样平凡而普通的人，我只想用我自己的汗水让父母过上好的生活，我只想实现那仅存的支撑我活下去的所谓人生理想，我和千千万万的我一样是一个普通的人。<br />\r\n121、我这几天要动用我全部的思绪把他们都写下来，因为我马上就会离开这个世界，这是我能留给这个世界最后的东西，也是我能留下的唯一的痕迹了，但是在这个信息如海般的世界，我的文字只是空中微末的尘埃，后来的人啊不要像我一样，要努力地学习，要勇敢地去生活，去解放我们哪些还在遭受苦难和压迫、剥削的兄弟姐妹，不过这一天我终是看不见了，我要把我的肉体埋葬在一片鸟语花香的地方，这是我能想到的唯一的美好，我要把我悲哀的思绪带离这人世，若这世界上有我这样的悲哀那就只让他在我一个人身上发生就够了，我悲哀的灵魂我低劣的思想把我的人生带入了一场不能回头的悲剧，熟悉的陌生人啊不要重蹈我故事的覆辙，把我作为你的反面教材勇敢的前进下去吧。<br />\r\n122、刚才突发奇想的最喜欢的音乐制作人应该是<a\r\nhref=\"https://zh.moegirl.org.cn/%E6%A2%B6%E6%B5%A6%E7%94%B1%E8%AE%B0\">梶浦由记</a>老师，啊，每次听到《晓之车》总是很感动，内心深处的某些东西被触动着，这样的歌实在是太优美了，有着很强的力量能够直击听众的内心，仿佛是只有在天上才能听到的，用中国话来说就是，“此曲只应天上有，人间能得几回闻”，这句话出自唐朝诗人杜甫的古诗作品《赠花卿》，那也是一首很美的诗。<br />\r\n123、没有神仙救世主，同志们我们只能靠自己！<br />\r\n124、重读《范进中举》有感，范进回到家只有挨饿多日、瘦骨嶙峋的母亲，母亲让他变卖了家里仅存的下蛋的母鸡，范进走上集市去买鸡，却被这社会又毒打了一顿，他倚在墙边，拖着满是伤痕的身体困倦了，恍惚中他看见有人对他说他中了举人，在这场举人梦里他发了疯，周围的人也发了疯，我也发了疯。<br />\r\n125、当阿廖莎在生产队的枯树下，吃二茬苦遭二茬罪时，会拾起他的思想，我们会找到一口井，他们当时就是在那样一口井边出发的，这口井会在各个地方涌现，这场征途我们只能靠自己，而且过程必然是残酷的，是要流血的，注定是不温和的，纵观过去温和的结果往往是招来团队的毁灭。我们是不怕斗争的，是不怕死亡的，我们是一定要胜利的。<br />\r\n126、别人一张嘴就是ssp，年薪百万，轻松的工作，优秀的同事，优渥的工作环境，充满前景的发展空间，而我只是想找一份游戏行业的工作养活自己，减轻父母的负担，我错在哪里，我不知道。<br />\r\n127、《西游记后传》还是不错的，《西游记》讲了一直发生的事而且很隐晦，其文学价值无需多言，而后传虽然通俗一些，但是讲的现在的过去发生的事，那时候的事都不提也看不清，但是他却讲了这么一个事，看起来很有意思，当然导演本人肯定没有这个想法我只是自己看着自己瞎想好玩。<br />\r\n128、鲁迅真的好厉害，他活在那么久之前，却清清楚楚地看清了我的样子，把我的现况，作为往事一篇篇写下。<br />\r\n129、人们不关心我，他们只在乎自己，他们凑过来不过是因为我的悲鸣比较可笑，他们只想听一声沉重的闷响然后在发表一些感动自我的深思，这之后人们就再也想不起来了，仿佛这一声闷响从未发生过，他们又等下一声闷响去了，却不知下一声闷响可能就是自己。<br />\r\n130、我像一首不符合时代旋律的歌，在时代的合奏中我的旋律格外刺耳，充斥着违和感和不协调。我融不进这美丽的时代，我在他们的映衬下是一首悲伤的歌。<br />\r\n131、怀着满腔热血想进入游戏行业，还没跨出半步就被这寒冬冻死，我像一块受了潮的木头，内外都感到刺骨，只希望我在最后能发出一点微弱的热量给这口炉子增添一点温度，此后便没有了我这块薪柴。<br />\r\n132、短评浅析<a\r\nhref=\"https://www.bilibili.com/video/BV1Vm4y167AC/\">小岗同学葬礼</a>人未死去给自己办了一场告别仪式，我觉得还是挺有艺术气息的，人的内心深处都有着死亡的冲动，他用一种积极快乐的方式去向过去、向自我发起一场单方面的告别，因为这场和过去自己的告别是无疾而终的，从事实而言是无法达到的，从心理上讲是一种自我的分割。他用这样一种方式对自己发起反叛，对社会的固有认知发起一场属于自己的浪漫冲锋，他用众目睽睽向世界宣布过去死亡的宣言，然后让自己能够向着未来发起一场新的冲锋。<br />\r\n133、我恨人类，所以我挥刀向自己砍去。<br />\r\n134、理想主义者是这个世界最浪漫的人，但世界并不浪漫，所以理想和现实碰撞出的火花才格外绚烂。<br />\r\n135、有的人是真的逆天，就像我朋友说的“铁拳没砸到自己头上觉得自己挺能耐”，能说出比“何不食肉糜”还逆天的话，古人诚不欺我也。自己站在风口上便以为自己是时代的弄潮儿了，可惜这种人目光短浅又毫无同理之心，命比时代的浪还要短，只能看见自己顺着波涛拍动两下翅膀，看不见此波退去，下一波浪潮来临时的悲哀内有千百个自己的悲惨死相，还在这摇唇鼓舌，真是可笑，不骂他个八辈祖宗都是给他的面子了。<br />\r\n136、理想主义者是这个世界最浪漫的人，但世界并不浪漫，所以理想和现实碰撞出的火花才格外绚烂。<br />\r\n137、已经等不及想看后人如何评价我们了，自轰轰烈烈的公运失败后，这些叛徒朝着准备主意方向走去，却为了得到人民群众的信任不敢去承认，搞几波枪打出头鸟，后来再也没人敢在公共场合讨论，在网上日常说话发表评论都有敏感词看着，和过去的文字狱别无二致，阶级固化日益严峻，阶级矛盾愈演愈烈，过去地主小姐之流又出现在了这片土地上，革命先辈的血当真被这些投机倒把倒行逆施的叛徒们搞得白流了。<br />\r\n照这样看我想歌名的时间就快来了，不知是百年还是多久，这漫长的等待在史书上可能只有短短几页，但是一个人可能耗尽一生可能都望不到曙光，希望以后我们能实现真正的共产主义。<br />\r\n史记三页纸为轻，人生百世命何沉。<br />\r\n138、如果生活需要喜剧演员那我一定是一位出色的影帝，但是生活是一场闹剧，而我却偏偏里面演了一出喜剧，所以显得格外的悲剧，但是喜剧终是要人笑得，所以最后大家都露出了开心的笑容，只有我留下了悔恨的泪水。<br />\r\n139、“我只是想毁灭掉，这个，腐朽的世界”<br />\r\n既然超脱自我是如此的困难，那么追求毁灭和堕落，我想也是理所当然，情有可原的。<br />\r\n得不到的就期盼着它毁灭，还要在走向死寂的昏暗路口乞怜他人的宽慰，我不值得任何人为我哀叹，我不配任何人为我歌唱，我不配为任何人所留恋。<br />\r\n后来的人啊，如果你在人生的路牌上看见我的这番话，就不要像我一样沉沦，去冲破这命运的诅咒，去打破这可悲的诅咒，去勇往直前的做吧，去不断进取、不断学习吧，去放开手勇敢地爱吧，去活出精彩的、只属于你自己的样子吧。<br />\r\n后来的人啊，不要成为前面的人。<br />\r\n后来的人啊，祝你拥有幸福美满的一生。<br />\r\n140、后来我才知道，同理心是一种可贵的品质，这种品质不是每个人都有，甚至有的畜生遗忘了它。<br />\r\n141、网络真神奇啊，每个人都在上面聊着自己，对他人漠不关心，看似彼此能聊以安慰，仔细一看人家只不过在宽慰自己。<br />\r\n142、我一直都沉浸在难过的情绪中，以至不能自拔，我想痛苦也是一种毒药，而我就是他的吸食者。<br />\r\n143、我本质是一个糟糕透顶的人，我只是把我理想的样子伪装出来罢了，我一直都是祥林嫂，只不过在我死前呻吟一两声罢了，鲁迅在数十年前就写尽了我的荒唐。<br />\r\n144、因为我毫无建树，有没有特点，而且性格屌差，长得也丑，上有年迈的父母，我不能创造美好的生活报答他们的养育之恩，对于社会也没有帮助。<br />\r\n145、其实很多时候你们看那些我说出的哗众取宠之语，很多都是我肺腑之言，但是在这个荒谬的时代就成了令人哂笑的笑料，太多力，一时反而说不上来，就像面具戴在脸上时间久了就不自知了，就像悲伤沉浸其中时间久了就以痛苦为常态了。<br />\r\n146、生活是一个温柔并残酷的对手，他温柔的地方在于用名为平常的毒药渐渐损食人的心智磨灭热情和冲动，待回过神来已经在平凡中不能自拔；他残酷的地方在于这一过程没有表征，当看见别人鱼跃龙门时心中不少悸动，但是在两三下的挣扎后又再次沉浸在这沉沦的毒坛中。<br />\r\n若是你凭借超凡的毅力和坚韧战胜了自我，他还有压箱底的把式，用最残酷的方式终结你的抗争，可能是身体的也可能是精神的，正因为这对手如此的可怕，我们才会敬佩歌颂哪些坚韧不拔的英雄。<br />\r\n147、在心理学上有一种概念叫“缺失取向”，就是说一个人越是缺少什么越是表现什么。一个人越是极端地去表现积极乐观，他的内心就越是脆弱不堪，在他几近疯狂地、甚至令人感到违和不适的快乐面具下，可能隐藏着的是一颗遍体鳞伤的心，就像一张拉满弦的弓，一旦松手便是崩坏般的毁灭。<br />\r\n这种积极是悲哀的，只是在欺骗自我罢了，在生活中我曾见过这样的人，他是自知的，但是他无法放下，因为他弓弦的另一端是沉重的6便士，我什么都做不了，我听见他的笑声一下下刺痛我的鼓膜，看到他扭曲疯狂的笑容一幕幕映入我的眼帘，令我身心都感到些许的不适，我并不反感、或者说我没有资格反感，我只是感觉悲伤罢了。<br />\r\n148、我经常回忆过去因为他离我遥远、朦胧我能随意的想像令他完美，我不敢去想将来因为那是未知，我用尽一切方法逃离当下以远离未来，但无论我逃去何方他总能追上，在我于当下困顿时，我又想起过去，在过去中我从当下迈向未来。<br />\r\n149、骑士在扮演小丑，小丑在扮演骑士，这是个荒谬的时代，人们戴着不属于自己的假面，展露容颜者被称为异类，粉末假饰者收获赞美，人们被虚幻迷盖，对真实漠不关心，肉林的霓虹掩饰了沉重的担子，眼帘中都是狂欢迷醉，而死亡毁灭接踵而至。<br />\r\n150、和生活的这场战斗没有胜利可言，一旦开始便没有归途，最后的结果莫不是和解便是毁灭。<br />\r\n151、我想我是一个自私的人，每当我有所思考都是从自我的角度出发，很少想到他人，而想要说些什么欲从他人角度进行阐述，又有些不好意思，不知从何处下手。这应该是一个坏习惯我应该改一改，但是我又不知道怎么开始，很多事情我都是这样的，想要有所改变却迟迟迈不出手脚。<br />\r\n152、之前一直不理解《太吾绘卷》里的武学逆练是什么，因为在过去的教育过程中都是专心但粗糙地学习书本上、学校教授的知识不太理解，后来看见一个视频标题叫<a\r\nhref=\"https://www.bilibili.com/video/BV1TX4y1z7D5\">[《官僚主义如何逆练群众理论》]</a>，再想想现实中藿香正气的例子便有些明白了，懂了理论但是为了自己的利益和欲望反其道而行之达到自己的预期，背离了知识的思想初衷，现在想想真是唏嘘。<br />\r\n153、我终是没发出光的，在这个炫丽的时代，寒冷的雨夜浇灭了我稚嫩的荧光，绮丽的世界不再希望炬火，因为和未来感的世界相衬起来是那么格格不入，在华丽的舞台背后，我在垃圾桶里等待死亡。<br />\r\n154、“莫说你一个宋慈就是十个八个也休想把这浑浊的世道变得天朗水清”，随着一把大火所有的罪证都化作灰烬，这些个衣冠禽兽都作了清白之身，刁光斗死在法不责众的乱拳之下，这场游戏，宋慈输了，刁光斗也输了，获得胜利的也只有王权一人，这场游戏从一开始就注定是王权之下的一桩悲剧罢了，所谓的你争我斗平反冤案，也只不是在王权的平台上的一幕而已。<br />\r\n155、人们总是在幻想中寻找认同，希望自己拥有打败一切的力量，希望自己能面对挫折坚毅不拔，从能打爆一切的勇者、拥有无数朋友的冒险家，面对残酷生活依旧坚韧的主人公，人们总是把自己的希望向外投影并追寻，但是摄像机是永远追不上投影屏的，想要成为幻想中的存在要自己行动。<br />\r\n156、我很害怕“结束”，仿佛只要没有“结束”一切都还来得及一切就都还有机会，我就还能在做些什么，但是“结束”是无可避免的无论如何逃避都要迎接“结束”。<br />\r\n157、今天是2023/05/11，晚上11点就是是《塞尔达：王国之泪》发售日了，在这个平凡的日子，世界上最伟大的游戏续作发售了，在这个伟大的发售日一切都那么平常，一切都仿佛没有发生，母亲还是在做饭，父亲还是辛苦的工作，我还是一如既往的失业，我还是没有解决生活的难题。虚拟世界的伟大波澜击不起我平凡生活的一丝浪花，人们用虚拟世界的梦幻来装饰糊涂的现实，世界上最荒诞的现实主义就在我身上发生。<br />\r\n158、突然想聊聊王家卫的抽帧，这种抽帧的手法营造了一种不真实感，这种不真实感就如同做梦，用这种去真作幻的手法去给观众想像感悟的空间，人在回忆时想像力是最强的因为不真切却又想极力看清所以就用想像弥补了空白，而王家卫的抽帧留给观众的是留白的画面，引起观众潜意识的想像补充，所以给人一种朦胧和梦幻的感觉。<br />\r\n159、我见过一家工厂，那里的材料要交钱才能变成罐头，这材料也是要分三六九等的，有的走了高级通道便通到什么堂皇的所在，不过我看应是颠倒过来的，叫荒唐才对。这样的流水线效率可高的呢，若是哪个落了队脱了群断是要不得的，他们说这是现代化，我是不懂的。<br />\r\n这样造出的罐头终是卖不出的，因为味道是差远了的，倒是那些堂皇的罐头是炙手可热的玩意。<br />\r\n160、那时候还有每天都会弹出来的腾讯新闻，可是这粗糙又美好的一切都成为了只能追忆的过去，眼前只有疲于奔命的现实和逐渐被压垮的身心，如果可以我希望在这场名为现实的噩梦中，回到过去。<br />\r\n161、无产者的哀伤竟被小资产阶级篡夺，作为生活的调剂和故作高深的资本，他妈的，你配吗？恶心。<br />\r\n162、人生的顿悟和无知竟是极为的相似，在无知时对自我没有喜欢讨厌不知其为何物，在学习中发现自己的闪光点心存喜爱不足心存悔过，这一过程知晓喜恶，在最后顿悟时接纳自己的一切有回到无厌喜的状态，虽然相似，但是也许应该有不同吧，我在漫长的学习过程中回滚到了无知的深渊，那顿悟的一朝我想我终是达到不了了。<br />\r\n163、<br />\r\n如果今天是你最后一次看见我，<br />\r\n你会对我说什么，<br />\r\n我想你什么都不会说，还会觉得我莫名其妙，<br />\r\n所以这结束还是由我来说更合适，<br />\r\n“再见，我将要去往新的明天。”</p>\r\n<p>164、现在是2023/05/22晚22:02我的精神越发的不振了，我的精神几近癫狂，我想我很快就会病倒了，或者结束这一切了，我将死亡。</p>\r\n<p>165、我是在做梦吗？我想这应该是一场噩梦吧，毕竟整个世界都没有人理睬我，难道我在梦里都不受人待见吗。在梦里也会肚子饿吗？在梦里也不能受到别人的眷顾吗？在梦里也不能受到他人的青睐吗？<br />\r\n那梦和现实有什么区别吗？那我还是在梦里死去吧，这样比较浪漫。<br />\r\n在自己的梦中死去算是自杀吗？在这个和现实一样悲哀的梦中死去。</p>\r\n<p>166、“只要你还没意识到自己并非无所不能，那你就还是雏鸟。”</p>\r\n<p>167、别着急，没什么，弗拉基米尔·伊里奇，他只是而昏过去了，等他醒来世界将再次插满红旗。</p>\r\n<p>168、明年也许会有，也许不会，但是明年我的青春一定没有了。在每日的时光流逝中，随他而去的还有我曾以为无穷的可能性，我的一切生机活力都在慢慢消失，有人说这是长大的代价，但我只感到了死寂的悲凉。明天的太阳会再次升起，但明天我的生命也许不再蓬勃。</p>\r\n<p>169、\"我的瓦西亚死了，\"妇人安静地说，悲哀的眼泪又沿着她憔悴的脸颊流下来，\"自然我的日子也完了，我活活的给人把心挖了去。然而汤是不应该糟蹋的，里面放得有盐呢。<br />\r\n---屠格涅夫<白菜汤></p>"},{"title":"一些环境配置教程","date":"2023-04-15T16:00:00.000Z","_content":"  \n自己配置环境时候经常遇到各种各样问题，所以记录一下比较好的配置环境的教程吧，日后也许有用。\n  \n<!--more-->\n  \n# GMP\n  \n## 在 Windows下，为 C++ 配置 GMP\n  \n[配置GMP，在windows下，Visual Studio 2019](https://blog.csdn.net/a675115471/article/details/104425406)  \n[如何在CMake中使用GMP:一个没解决的问题](https://github.com/microsoft/vcpkg/discussions/22418)  \n[How to use GMP with Cmake on CLion? ](https://intellij-support.jetbrains.com/hc/en-us/community/posts/360004135300-How-to-use-GMP-with-Cmake-on-CLion-)  ","source":"_posts/一些配置环境教程.md","raw":"---\ntitle: 一些环境配置教程\ndate: 2023/04/16\ntags: \n---\n  \n自己配置环境时候经常遇到各种各样问题，所以记录一下比较好的配置环境的教程吧，日后也许有用。\n  \n<!--more-->\n  \n# GMP\n  \n## 在 Windows下，为 C++ 配置 GMP\n  \n[配置GMP，在windows下，Visual Studio 2019](https://blog.csdn.net/a675115471/article/details/104425406)  \n[如何在CMake中使用GMP:一个没解决的问题](https://github.com/microsoft/vcpkg/discussions/22418)  \n[How to use GMP with Cmake on CLion? ](https://intellij-support.jetbrains.com/hc/en-us/community/posts/360004135300-How-to-use-GMP-with-Cmake-on-CLion-)  ","slug":"一些配置环境教程","published":1,"updated":"2024-01-14T08:13:08.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti2000gbkbw5vc10gzo","content":"<p>自己配置环境时候经常遇到各种各样问题，所以记录一下比较好的配置环境的教程吧，日后也许有用。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"gmp\">GMP</h1>\r\n<h2 id=\"在-windows下为-c-配置-gmp\">在 Windows下，为 C++ 配置 GMP</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/a675115471/article/details/104425406\">配置GMP，在windows下，Visual\r\nStudio 2019</a><br />\r\n<a\r\nhref=\"https://github.com/microsoft/vcpkg/discussions/22418\">如何在CMake中使用GMP:一个没解决的问题</a><br />\r\n<a\r\nhref=\"https://intellij-support.jetbrains.com/hc/en-us/community/posts/360004135300-How-to-use-GMP-with-Cmake-on-CLion-\">How\r\nto use GMP with Cmake on CLion?</a></p>\r\n","site":{"data":{}},"excerpt":"<p>自己配置环境时候经常遇到各种各样问题，所以记录一下比较好的配置环境的教程吧，日后也许有用。</p>","more":"<h1 id=\"gmp\">GMP</h1>\r\n<h2 id=\"在-windows下为-c-配置-gmp\">在 Windows下，为 C++ 配置 GMP</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/a675115471/article/details/104425406\">配置GMP，在windows下，Visual\r\nStudio 2019</a><br />\r\n<a\r\nhref=\"https://github.com/microsoft/vcpkg/discussions/22418\">如何在CMake中使用GMP:一个没解决的问题</a><br />\r\n<a\r\nhref=\"https://intellij-support.jetbrains.com/hc/en-us/community/posts/360004135300-How-to-use-GMP-with-Cmake-on-CLion-\">How\r\nto use GMP with Cmake on CLion?</a></p>"},{"title":"Visual Studio 解决项目默认的配置奇奇怪怪的问题","date":"2023-08-28T12:24:22.000Z","typora-root-url":"./..","_content":"  \n因为之前年轻配环境的时候不懂事，那时候应该是配OpenCv 直接配到用户默认的项目配置里面去了，不小心修改了默认的配置。\n  \n<!--more-->\n  \n# 修改默认配置\n  \n## 第一步：\n  \n打开：视图->属性管理器  \n<img src=\"/imgs/VisualStudioPro/Vs1.png\">\n  \n顺利的话会在右侧看见对应的窗口，然后修改 对应的 Microsoft.Cpp.x64.user(这个对应你自己要用的啊，我这里只用了 Debug|x64)  \n<img src=\"/imgs/VisualStudioPro/Vs2.png\">\n  \n后面应该不用教了吧，该配置里的库引用啊，lib还有连接器什么的……  \n这个都不会的话，可以多做几个需要外部库的项目，比如LearnOpenGL  \n然后可以理解一些编译，链接的东西，不是说去啃编译原理，我之前看过也不懂，做几个项目，或者看看视频，比如b站奇乐的有一期讲make还是cmake的我忘了，了解大概就行。  \n这个没什么技术难度，就是项目见的多少。  ","source":"_posts/VisualStudioPro.md","raw":"---\ntitle: Visual Studio 解决项目默认的配置奇奇怪怪的问题\ndate: 2023-08-28 20:24:22\ntags: \ntypora-root-url: ./..\n---\n  \n因为之前年轻配环境的时候不懂事，那时候应该是配OpenCv 直接配到用户默认的项目配置里面去了，不小心修改了默认的配置。\n  \n<!--more-->\n  \n# 修改默认配置\n  \n## 第一步：\n  \n打开：视图->属性管理器  \n<img src=\"/imgs/VisualStudioPro/Vs1.png\">\n  \n顺利的话会在右侧看见对应的窗口，然后修改 对应的 Microsoft.Cpp.x64.user(这个对应你自己要用的啊，我这里只用了 Debug|x64)  \n<img src=\"/imgs/VisualStudioPro/Vs2.png\">\n  \n后面应该不用教了吧，该配置里的库引用啊，lib还有连接器什么的……  \n这个都不会的话，可以多做几个需要外部库的项目，比如LearnOpenGL  \n然后可以理解一些编译，链接的东西，不是说去啃编译原理，我之前看过也不懂，做几个项目，或者看看视频，比如b站奇乐的有一期讲make还是cmake的我忘了，了解大概就行。  \n这个没什么技术难度，就是项目见的多少。  ","slug":"VisualStudioPro","published":1,"updated":"2024-01-14T08:13:08.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti3000ibkbwcpkb40k2","content":"<p>因为之前年轻配环境的时候不懂事，那时候应该是配OpenCv\r\n直接配到用户默认的项目配置里面去了，不小心修改了默认的配置。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"修改默认配置\">修改默认配置</h1>\r\n<h2 id=\"第一步\">第一步：</h2>\r\n<p>打开：视图-&gt;属性管理器<br />\r\n<img src=\"/imgs/VisualStudioPro/Vs1.png\"></p>\r\n<p>顺利的话会在右侧看见对应的窗口，然后修改 对应的\r\nMicrosoft.Cpp.x64.user(这个对应你自己要用的啊，我这里只用了\r\nDebug|x64)<br />\r\n<img src=\"/imgs/VisualStudioPro/Vs2.png\"></p>\r\n<p>后面应该不用教了吧，该配置里的库引用啊，lib还有连接器什么的……<br />\r\n这个都不会的话，可以多做几个需要外部库的项目，比如LearnOpenGL<br />\r\n然后可以理解一些编译，链接的东西，不是说去啃编译原理，我之前看过也不懂，做几个项目，或者看看视频，比如b站奇乐的有一期讲make还是cmake的我忘了，了解大概就行。<br />\r\n这个没什么技术难度，就是项目见的多少。</p>\r\n","site":{"data":{}},"excerpt":"<p>因为之前年轻配环境的时候不懂事，那时候应该是配OpenCv\r\n直接配到用户默认的项目配置里面去了，不小心修改了默认的配置。</p>","more":"<h1 id=\"修改默认配置\">修改默认配置</h1>\r\n<h2 id=\"第一步\">第一步：</h2>\r\n<p>打开：视图-&gt;属性管理器<br />\r\n<img src=\"/imgs/VisualStudioPro/Vs1.png\"></p>\r\n<p>顺利的话会在右侧看见对应的窗口，然后修改 对应的\r\nMicrosoft.Cpp.x64.user(这个对应你自己要用的啊，我这里只用了\r\nDebug|x64)<br />\r\n<img src=\"/imgs/VisualStudioPro/Vs2.png\"></p>\r\n<p>后面应该不用教了吧，该配置里的库引用啊，lib还有连接器什么的……<br />\r\n这个都不会的话，可以多做几个需要外部库的项目，比如LearnOpenGL<br />\r\n然后可以理解一些编译，链接的东西，不是说去啃编译原理，我之前看过也不懂，做几个项目，或者看看视频，比如b站奇乐的有一期讲make还是cmake的我忘了，了解大概就行。<br />\r\n这个没什么技术难度，就是项目见的多少。</p>"},{"title":"Learn PBR","math":true,"index_img":"/imgs/LearnPBR/pbr.png","banner_img":"/imgs/LearnPBR/pbr.png","date":"2023-11-13T16:00:00.000Z","typora-root-url":"../","_content":"\n关于PBR的一些知识点\n\n# Learn PBR\n\n# PBR理论\n\n## **简介**\n\n**PBR**（**Physically Based Rendering**）译成中文是基于物理的渲染。它是利用真实世界的原理和理论，通过各种数学方法推导或简化或模拟出一系列渲染方程，并依赖计算机硬件和图形API渲染出拟真画面的技术。\n\n### **PBR** **特征**\n\n更高质量的着色效果和更多复杂的材质特性。\n\n- 表面细节\n- 物体粗糙度\n- 区别明显的金属和绝缘体\n- 物体的浑浊程度\n- 菲涅尔现象：不同角度有不同强度的反射光\n- 半透明物体\n- 多层混合材质\n- 清漆效果\n- 其它更复杂的表面特征\n\n> 近今年，PBR的技术主要朝着更逼真、更复杂、效能更好的方向，或是结合若干种模型的综合性技术迈进。代表性技术有：\n>\n> - PBR Diffuse for GGX + Smith (2017)\n> - MultiScattering Diffuse (2018)\n> - Layers Material（分层材质）\n> - Mixed Material（混合材质）\n> - Mixed BxDF（混合BxDF）\n> - Advanced Rendering（进阶渲染）\n\n### **OutPut**\n\n![output](/imgs/LearnPBR/output.PNG)\n\n## **PBR** **和 游戏引擎**\n\n### **UE4 的** **PBR**\n\n- **Base Color**，基础的纹理颜色 非金属物体只有**单色**，即强度\n\n| Material                 | Base Color Intensity |\n| ------------------------ | -------------------- |\n| 木炭(Charcoal)           | 0.02                 |\n| 新沥青(Fresh asphalt)    | 0.02                 |\n| 旧沥青(Worn asphalt)     | 0.08                 |\n| 土壤(Bare soil)          | 0.13                 |\n| 绿草(Green Grass)        | 0.21                 |\n| 沙漠沙(desert sand)      | 0.36                 |\n| 新混泥土(Fresh concrete) | 0.51                 |\n| 海洋冰(Ocean Ice)        | 0.56                 |\n| 鲜雪(Fresh snow)         | 0.81                 |\n\n- **金属**材质，在 Linear 空间的值\n\n| 材质(Material) | 基础色(BaseColor)     |\n| -------------- | --------------------- |\n| 铁(Iron)       | (0.560, 0.570, 0.580) |\n| 银(Silver)     | (0.972, 0.960, 0.915) |\n| 铝(Aluminum)   | (0.913, 0.921, 0.925) |\n| 金(Gold)       | (1.000, 0.766, 0.336) |\n| 铜(Copper)     | (0.955, 0.637, 0.538) |\n| 铬(Chromium)   | (0.550, 0.556, 0.554) |\n| 镍(Nickel)     | (0.660, 0.609, 0.526) |\n| 钛(Titanium)   | (0.542, 0.497, 0.449) |\n| 钴(Cobalt)     | (0.662, 0.655, 0.634) |\n| 铂(Platinum)   | (0.672, 0.637, 0.585) |\n\n- **粗糙度(Roughness)**：表面的粗糙程度, [0,1]，越粗糙高光越弱。\n\n![roughness](/imgs/LearnPBR/roughness.png)\n\n![roughness2](/imgs/LearnPBR/roughness2.png)\n\n上为非金属，下为金属，粗糙度从0至1\n\n- **金属度(Metallic)**：表示材质像金属的程度，0是绝缘体(电介质)，1 是金属，金属只有镜面反射，没有漫反射。\n\n![metallic](/imgs/LearnPBR/metallic.png)\n\n金属度从0至1\n\n- **镜面度(Specular)**：表示物体镜面反射的强度，从0(完全没有镜面反射)到1(完全镜面反射)\n\n![specular](/imgs/LearnPBR/specular.png)\n\nFrom 0 ~ 1\n\n| 材质(Material) | 镜面度(Specular) |\n| -------------- | ---------------- |\n| 草(Glass)      | 0.5              |\n| 塑料(Plastic)  | 0.5              |\n| 石英(Quartz)   | 0.57             |\n| 冰(Ice)        | 0.224            |\n| 水(Water)      | 0.255            |\n| 牛奶(Milk)     | 0.277            |\n| 皮肤(Skin)     | 0.35             |\n\n### **Unity 的** **PBR**\n\n- **Albedo**，和 UE 的 Base Color 一样。 可以用颜色或者Tex\n- **Metallic**，可以用金属贴图，但是用了 Smoothness 参数就消失了\n- **Smoothness**，光滑度，和 UE 的 粗糙度正相反\n  - **Smoothness Source**，指定光滑度的存储通道，可选金属度、镜面贴图的 Alpha 或基础色的 Alpha\n- **Occlusion**：遮蔽图，指定材质接收间接光的光照强度和反射强度。 能够使物体经常是暗部的位置更暗，比如人的眼窝，脸和脖子的交接处。\n- **Fresnel**，物体边缘或者说物体法线和视线角度增大，物体的反射能力更强，Unity 里面是自动处理，越光滑越强，越粗糙 Fresnel 越弱。\n\n## **PBR** **基本原理**\n\n满足以下条件的光照模型才能称之为PBR光照模型：\n\n- 基于微平面模型（Be based on the microfacet surface model）。\n- 能量守恒（Be energy conserving）。\n- 使用基于物理的BRDF（Use a physically based BRDF）。\n\n### **微表面理论(Microfacet)**\n\n很多 PBR 技术都是基于理论 认为**在微观上**，所有的物体表面都是由很多的朝向不一的微小平面组成的。\n\n> 真实世界的物体表面其实不一定是这样的微小平面，可能会有弧度，甚至坑坑洼洼，但我们从肉眼观察、甚至*光栅化后的像素尺度*来看待的话，这种假设的结果和实际差别甚微。\n\n![microfacet](/imgs/LearnPBR/microfacet.png)\n\n基于这种假设，没有任何表面是光滑的，但由于这些微平面已经微小到逐像素无法对其进行细分，所以假设一个粗糙度 Roughness，用统计学的方法去估算微表面的粗糙度。\n\n...\n\n### **Energy Conservation (能量守恒)**\n\n在 Microfacet 中采用近似的能量守恒定律，出射光的总能量不能超过入射光的总能量(不含自发光)，\n\n所以材质粗糙度越大，反射的范围越大，整体的亮度会变低。\n\n#### **镜面反射(specular)和漫反射(diffuse)**\n\n一束光打到物体，会发生 **reflection** 反射 和 **refraction** 折射。反射的光直接离开，不进入物体发射了镜面反射光；折射的光进入物体内发生了吸收或散射，产生漫反射。 折射后的光若没被吸收会继续前进，在物体内部发生光和微粒的碰撞，这时有一部分能力转化为热量，有些光经过多次折射从表面射出，便形成漫反射光。\n\n![reflect](/imgs/LearnPBR/reflect.png)\n\n*照射在平面的光被分成镜面反射和折射光，折射光在跟物体微粒发生若干次碰撞之后，有可能发射出表面，成为漫反射。* 通常情况下，PBR会简化折射光，将平面上所有折射光都视为被完全吸收而不会散开。而有一些被称为次表面散射(Subsurface Scattering)技术的着色器技术会计算折射光散开后的模拟，它们可以显著提升一些材质（如皮肤、大理石或蜡质）的视觉效果，不过性能也会随着下降。 金属(Metallic)材质会立即吸收所有折射光，故而金属只有镜面反射，而没有折射光引起的漫反射。\n\n根据上面的能量守恒关系，可以先计算镜面反射部分，此部分等于入射光线被反射的能量所占的百分比。而折射部分可以由镜面反射部分计算得出。\n\nfloat kS = calculateSpecularComponent(...); // 反射/镜面部分\n\nfloat kD = 1.0 - kS;                        // 折射/漫反射部分\n\nks + kd 不会超过1，所以近似地能量守恒。\n\n### **Reflectance Equation**\n\n$$L_0(p,w_0)=\\int\\limits_{\\Omega}f_r(p,w_i,w_0)L_i(p,w_i)\\,\\mathrm{d}w_i$$\n\n## **辐射度量学**\n\n### **概念表**\n\n![chart1](/imgs/LearnPBR/chart1.png)\n\n![chart2](/imgs/LearnPBR/chart2.png)\n\n> 微分符号 d 的含义：首先来说下微分的定义：设f(x)定义在区间(a,b)上，x∈(a,b),给定自变量x的一个增量Δx，得到函数的一个增量Δy，如果有Δy=f(x+Δx)-f(x)=AΔx+o(Δx)(Δx→0)，则y=f(x)称在点x可微，函数增量的线性主部AΔx称为函数的微分，记为dy=df(x)=AΔx\n\n### **辐射通量（Radiant Flux)**\n\n光源单位时间内的输出$$\\Phi=\\frac{\\mathrm{d}Q}{\\mathrm{d}t}$$\n\n> 光是由多种不同波长的能量集合而成，每种波长与一种特定的（可见的）颜色相关。因此一个光源所放射出来的能量可以被视作这个光源包含的所有各种波长的一个函数。波长介于390nm（纳米）到700nm的光被认为是处于可见光光谱中，也就是说它们是人眼可见的波长。\n\n传统物理学上的辐射通量将会计算这个由不同波长构成的函数的总面积，这种计算很复杂，耗费大量性能。在PBR技术中，不直接使用波长的强度，而是使用三原色编码（RGB）来简化辐射通量的计算。虽然这种简化会带来一些信息上的损失，但是这对于视觉效果上的影响基本可以忽略。\n\n### **Radiant Insensity(辐射强度)**\n\n单位球面上，一个光源向单位立体角所投送的辐射通量。\n\n$$I=\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}w}$$\n\nthe power per unit angle\n\n假如光源均匀向四周发散\n\n$$I = \\frac{\\Phi}{4\\pi}$$\n\n### **Irradiance**\n\nThe power per (perpendicular/projected) unit area incident on a surface point.\n\n$$E(x)=\\frac{\\mathrm{d}\\Phi(x)}{\\mathrm{d}A^\\perp }$$\n\n面要和光源垂直。\n\n即 Lambert‘s Consine Law\n\n### **Radiance**\n\nThe radiance(luminance) is the power emitted, reflected, transmitted or received by a surface, *per unit solid angle, per projected unit area.* 在单位立体角并且在单位的面积上\n\n$$L(p,w)=\\frac{\\mathrm{d}^2\\Phi(p,w)}{\\mathrm{d}w\\,\\mathrm{d}A\\cos\\theta}=\\frac{\\mathrm{d}^2\\Phi(p,w)}{\\mathrm{d}w\\,\\mathrm{d}A^\\perp}$$\n\n- Irradiance: power per projected unit area\n- Intensity: power per solid angle\n\nSo\n\n- Radiance : Irrandiance pre solid angle\n- Radiance : Intensity pre unit projected area\n\nIrradiance 是 dA 收到的能量\n\nIrradiance per solid angle 是 dA 的能量向某一个方向辐射\n\n![Radiance](/imgs/LearnPBR/Radiance.png)\n\n该图为 Irrandicance per solid angle, 这的 cos 是不是应该写进 E 里面……\n\nIncident Radiance 延申理解：\n\n一小块面积 dA 向某个方向辐射的能量\n\n反过来就是，从一个方向打向一个小面，到达这个面时的能量\n\n$$L(p,w)=\\frac{\\mathrm{d}I(p,w)}{\\mathrm{d}A\\cos\\theta}=\\frac{\\mathrm{d}I(p,w)}{\\mathrm{d}A^\\perp}$$\n\n### **Irradiance vs. Radiace**\n\n$$\\mathrm{d}E(p,w)=L_i(p,w)\\cos\\theta\\,\\mathrm{d}w\\\\$$\n\n两边同时积分\n\n$$E(p)=\\int_H^2L_i(p,w)\\cos\\theta\\,\\mathrm{d}w\\\\ Uint\\;Hemisphere:H^2$$\n\n每个方向过来到 A 的能量, 这和渲染方程是异曲同工的。\n\n再回到渲染方程\n\n$$L_0(p,w_0)=\\int\\limits_\\Omega f_r(p,w_i,w_0)\\underbrace{L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i}_{Radiace}$$\n\n其中只有 f 项待解。\n\n## **BRDF(双向反射分布函数)** \n\nBidirectional Reflectance Distribution Function，BRDF\n\n一个使用入射光方向ωi作为输入参数的函数，输出参数为出射光ωo，表面法线为n，参数a表示的是微平面的粗糙度。\n\n![BRDF](/imgs/LearnPBR/BRDF.svg)\n\nBRDF 描述了不透明物体表面每个单独光线，对最终反射光线的影响。也就是光线打到该表面如何反射，\n\n假设BRDF描述的是完全镜面物体，只有当出射光线方向w0 完全符号 入射光线方向wi 的反射方向时，返回值会为1.0，其余情况为0.\n\n$$f_r(p,w_0,w_i)=\\frac{\\mathrm{d}L_0(p,w_0)}{\\mathrm{d}E(p,w_i)}=\\frac{\\mathrm{d}L_0(p,w_0)}{L_i(p,w_i)\\cos\\theta_i\\,\\mathrm{d}w_i}$$\n\nBRDF 有多种模拟表面光照的算法，实时渲染所用的基本是 **Cook-Torrance BRDF**\n\n### **参考**\n\n- **PBRT-BRDF章节：**[Surface Reflection (pbr-book.org)](https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Surface_Reflection)\n\n### **Cook-Torrance BRDF**\n\n$$f_r=k_df_{lambert}+k_sf_{cook-torrance}\\\\ k_d是入射光被折射比例，\\\\ k_s是被镜面反射比例$$\n\n而左侧的 f_lambert 表示漫反射部分，Lambertian Diffuse，一般是恒定的算式：\n\n$$f_{lambert}=\\frac{c}{\\pi}$$\n\nc 表示 Albedo，π 是为了归一化 漫反射，因为后面要积分的\n\n#### **BRDF的高光项**\n\n$$f_{cook-torrance}=\\frac{DFG}{4(w_0\\cdot n)(w_i\\cdot n)}$$\n\n- **D( Normal Distribution Function, NDF )** : 法线分布，估算在表面粗糙度的影响下，表现出的表面法线和半角向量(half Dir)的一致性或者说微表面的数量。 估算微表面的主要函数。\n- **F( Fresnel Equation )**：菲涅尔方程，描述菲涅尔现象，当视线和表面法线夹角变大时更容易发生光的反射。 不同表面角下，表面反射光线的比例。\n- **G( Geometry Function )** : 几何函数，描述了微表面自成影的现象，当一个微表面特别粗糙时，彼此之间可能相互遮挡，从而减少反射的光线。\n\n[brdf为什么要定义为一个单位是sr-1的量？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/28476602/answer/41003204) [brdf为什么要定义为一个单位是sr-1的量？ - 文刀秋二的回答:](https://www.zhihu.com/question/28476602/answer/41003204)\n\n### **D(Normal Distribution Function, NDF)**\n\n描述和微表面法线和半角向量的一致性，从统计学上近似 **Trowbridge-Reitz GGX(GGXTR) :** \n\n$${NDF}_{GGXTR}(n,h,\\alpha)=\\frac{\\alpha^2}{\\pi((n\\cdot h)^2(\\alpha^2-1)+1)^2}\\\\ h=normalize(viewDir+lightDir)\\\\ \\alpha={roughness}^2$$\n\n![ggx](/imgs/LearnPBR/ggx.png)\n\n[Trowbridge-Reitz GGX | Desmos](https://www.desmos.com/calculator/eks25xlifv?lang=zh-CN)\n\n当 粗糙度 为零时函数值变为零\n\n```OpenGL\nfloat DoubleDistributeGGX(float3 N, float3 H, float roughness)\n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(0.0, dot(N, H));\n    float NdotH2 = NdotH * NdotH;\n\n    float p = (NdotH2 * (a2 - 1.0) + 1.0);\n    p = PI * p * p;\n    return a2 / p;\n}\n\nroughness += 0.0001;\nfloat NDF = DoubleDistributeGGX(N, H, roughness);\n```\n\n[2013SiggraphPresentationsNotes-26915738.pdf (unrealengine.com): Specular D](https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf)\n\n#### **Generalized-Trowbridge-Reitz（GTR）分布**\n\nGTR分布不具备形状不变性（shape-invariant），导致其发布以来，无法被广泛使用。\n\n$$D_{GTR}(m)=\\frac{c}{(1+(n\\cdot m)^2(\\alpha^2-1))^\\gamma}$$\n\n- 关于形状不变性的好处，可以总结为：\n  - 方便推导出该NDF归一化的各向异性版本\n  - 方便推导出遮蔽阴影项 Smith G\n  - 方便基于NDF或可见法线分布推导其重要性采样\n    - 对于Smith G，可用低维函数或表格处理所有粗糙度和各向异性\n\n#### **参考**\n\n[【基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/69380665):关于形状不变性。\n\n### **F(Fresnel Equation)**\n\n$$F_{Schlick}(h,v,F_0)=F_0+(1-F_0)(1-(h,v))^5$$\n\nF_0 表示的基础反射率，利用折射指数(Indices Of Refraction)求得，F_0 越大菲涅尔反射现象越强。\n\n当越是向掠射角(又名切线角，和正視角相差90度)方向去看，菲涅尔现象越强，反光效果越明显。\n\n![fresnel](/imgs/LearnPBR/fresnel.png)\n\n**Fresnel-Schlick**只适用于绝缘体的表面算法。 金属表面需要其他的菲涅尔方程模拟。但是这样做很不方便，所以： 预计算出平面对法线入射的结果(F0)，基于观察角的Fresnel-Schlick近似对这个值进行插值，用这种方法进一步估算。 这样就可以使用同一个公式了。\n\n平面对于法向入射的响应或者说基础反射率可以在一些大型数据库中找到，比如[RefractiveIndex](http://refractiveindex.info/)。\n\n所有电介质材质表面的基础反射率都不会高于0.17，这其实是例外而非普遍情况。导体材质表面的基础反射率起点更高一些并且（大多）在0.5和1.0之间变化。此外，对于导体或者金属表面而言基础反射率一般是带有色彩的，这也是为什么F0要用RGB三原色来表示的原因（法向入射的反射率可随波长不同而不同）。这种现象我们**只能**在金属表面观察的到。\n\n![chart3](/imgs/LearnPBR/chart3.png)\n\n由于绝缘体和金属体存在多种的差异，其各自独有的特性引出了金属工作流，我们使用一个金属度调节材质表面特性，这个参数并非 非零即一 的布尔值，是因为我们要描述一些比如沙子、颗粒和被刮蹭后的金属表面，所以要有一个[0,1]的范围进行调整。\n\n我们通过预计算金属和绝缘体的 F_0 进行 Fresnel-Schlick 近似，但是对于金属表面通常这样做\n\n```OpenGL\nvec3 F0 = vec3(0.04,0.04,0.04);\nF0 = mix(F0, surfaceColor.rgb, metalness);\n```\n\n我们为大多数电介质表面定义了一个近似的基础反射率。F_0取最常见的电解质表面的平均值，这又是一个近似值。不过对于大多数电介质表面而言使用0.04作为基础反射率已经足够好了，而且可以在不需要输入额外表面参数的情况下得到物理可信的结果。然后，基于金属表面特性，我们要么使用电介质的基础反射率要么就使用F_0来作为表面颜色。因为金属表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用表面颜色纹理来作为它们的基础反射率。\n\n```OpenGL\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// cosTheta = dot(N,V)\n```\n\n这里的N是收到粗糙度影响的半角向量，在后面计算IBL时，因为预计算没办法考虑粗糙度，所以我们需要一个受粗糙度影响的 fresnelSchlick\n\n```OpenGL\nvec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n```\n\n关于金属和绝缘体的菲涅尔，在 PBRT 中有提到，8.2.1 Fresnel Reflection： [Specular Reflection and Transmission (pbr-book.org)](https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission)\n\n> 1. The first class is *dielectrics*, which are materials that don’t conduct electricity. They have real-valued indices of refraction (usually in the range 1-3) and transmit† a portion of the incident illumination. Examples of dielectrics are glass, mineral oil, water, and air.\n> 2. The second class consists of *conductors* such as metals. Valence electrons can freely move within the their atomic lattice, allowing electric currents to flow from one place to another. This fundamental atomic property translates into a profoundly different behavior when a conductor is subjected to electromagnetic radiation such as visible light: the material is opaque and reflects back a significant portion of the illumination. A portion of the light is also transmitted into the interior of the conductor, where it is rapidly absorbed: total absorption typically occurs within the top 0.1 μm of the material, hence only extremely thin metal films are capable of transmitting appreciable amounts of light. We ignore this effect in `pbrt` and only model the reflection component of conductors. In contrast to dielectrics, conductors have a complex-valued index of refraction n=n0+ik.\n> 3. Semiconductors such as silicon or germanium are the third class though we will not consider them in this book.\n> 4. The first class is dielectrics, which are materials that don't conduct electricity. They have real-valued indices of refraction (usually in the range 1-3) and transmitt a portion of the incident illumination. Examples of dielectrics are glass, mineral oil, water, and air.\n> 5. The second class consists of conductors such as metals. Valence electrons can freely move within the their atomic lattice, allowing electric currents to flow from one place to another. This fundamental atomic property translates into a profoundly different behavior when a conductor is subjected to electromagnetic radiation such as visible light: the material is opaque and reflects back a significant portion of the illumination. A portion of the light is also transmitted into the interior of the conductor, where it is rapidly absorbed: total absorption typically occurs within the top 0.1 um of the material, hence only extremely thin metal films are capable of transmitting appreciable amounts of light. We ignore this effect in pbrt and only model the reflection component of conductors. In contrast to dielectrics, conductors have a complex-valued index of refraction = n + ik.\n> 6. Semiconductors such as silicon or germanium are the third class though we will not consider them in this book.\n>\n>   第一类是介电材料，这是一种不导电的材料。它们具有实值折射率(通常在1-3范围内)，并透射一部分入射光。电介质的例子有玻璃、矿物油、水和空气。\n>\n>   第二类由金属等导体组成。价电子可以在其原子晶格内自由移动，从而使电流从一个地方流向另一个地方。当导体受到电磁辐射(如可见光)时，这种基本的原子性质会转化为一种截然不同的行为:这种材料是不透明的，会反射回相当一部分照明。一部分光也被传输到导体的内部，在那里它被迅速吸收:完全吸收通常发生在材料的顶部0.1微米内，因此只有极薄的金属薄膜才能传输相当数量的光。我们在pbrt中忽略了这种影响，只对导体的反射成分进行了建模。与电介质相比，导体具有复值折射率= n + ik。\n>\n>   硅或锗等半导体是第三类，但我们在本书中不考虑它们。\n\n### **G(Geometry Function)**\n\n几何遮蔽模拟微表面的互相遮挡导致光线能量丢失或减少的现象。\n\n类似 NDF，也使用 Roughness 作为输入，粗糙度越高意味着几何遮蔽的概率越大。 几何遮蔽有 GGX 和 Schlick-Beckmann 组合而成的模拟函数 **Schlick-GGX**：\n\n$$G_{SchlickGGX}(n,v,k)=\\frac{n\\cdot v}{(n\\cdot v)(1-k)+k}$$\n\n![G](/imgs/LearnPBR/G.png)\n\n这里的 k 由粗糙度 α 计算得来，用于直接光照和 IBL 光照的几何函数参数:\n\n$$k_{direct}=\\frac{(\\alpha+1)^2}{8}\\\\ k_{IBL}=\\frac{\\alpha^2}{2}$$\n\n这里的 α 取决于我们怎么从粗糙度转换。\n\n为了更好的模拟，我们可以同时考虑两个视角，视线方向(几何遮蔽)和光线方向(几何阴影) 几何遮蔽类似“看不到”，几何阴影类似“照不到”。 使用 **Smith** 函数将其放在一起:\n\n$$G(n,v,l,k)=G_{sub}(n,v,k)G_{sub}(n,l,k)$$\n\n```OpenGL\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom = NdotV;\n    float denom =  NdotV * (1 - k) + k;\n    return nom / denom;\n}\n\nfloat GeometeySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float Gsub = GeometrySchlickGGX(saturate(dot(N,V)), k);\n    float Gsub2 = GeometrySchlickGGX(saturate(dot(N,L)), k);\n    return Gsub * Gsub2;\n}\n```\n\n### **Kulla-Conty Approximation**\n\n由于几何遮蔽造成能量损失，使得粗糙度较大时物体表面较暗，但实际上光线在表面经过多次弹射后不会被遮挡，可以反射出去(不考虑热能损失)。BRDF 只是考虑一次反射罢了。\n\n所以使用经验模型去补全损失的能量，首先要知道有多少能量损失了。\n\n$$E(\\mu_o)=\\int_0^{2\\pi}\\int_0^1f_r(\\mu_o,\\mu_i,\\phi)u_i\\,\\mathrm{d}\\mu_i\\,\\mathrm{d}\\phi\\\\ u=\\sin\\theta$$\n\n- Key idea\n  - 损失的能量就是 1 - E(\\mu_o)，不过E(\\mu_o)是和观察方向相关的。 我要做的就是补上这部分能量，能量加起来就是1了啊。\n  - E(\\mu_0)是和观察方向相关的。\n  - 要补一种多次散射的BRDF结果，也就是用一个模型去模拟多次反射的计算结果，而且因为 BRDF 具有对称性，有1 - E(\\mu_o)那么应该也有一项1 - E(\\mu_i)，因为我们的这个经验式子是模拟一个多级的基于 BRDF 的反射，然后补上一个归一化的参数c，得到这样的结果： c(1-E(\\mu_i))(1 - E(\\mu_o)) 这么设计只是为了简单……\n  -  $$c=\\frac{1}{\\pi(1-E_{avg})}\\\\ E_{avg}=2\\int_0^1E(\\mu)\\mu\\,\\mathrm{d}\\mu\\\\ f_{ms}(\\mu_o,\\mu_i)=\\frac{(1-E(\\mu_i))(1 - E(\\mu_o))}{\\pi(1-E_{avg})}$$\n  - \n- 但E_{avg}还是不知道的，这个可以预计算。\n  - Precompute / tabulate\n  -  $$E_{avg}(\\mu_o)=2\\int_0^1E(\\mu_i)\\mu_i\\,\\mathrm{d}\\mu_i\\\\$$\n  - $$E_{avg}$$和$$\\mu_o$$, 以及 BRDF(或者说roughness) 相关 这个预计算的结果会根据 brdf 的不同而改变。\n\n![Kulla-Conty](/imgs/LearnPBR/Kulla-Conty.png)\n\n- 如果物体有颜色，就会有能量损失，这样积分一开始就不会是1. 我们先计算 没有颜色损失的 正确结果，最后计算时再考虑由于颜色引起的损失。\n- Define the average Fresnel 不管入射角多大，每次反射平均反射掉多少能量\n\n$$F_{avg}=\\frac{\\int_0^1F(\\mu)\\mu\\,\\mathrm{d}\\mu}{\\int_0^1\\mu\\,\\mathrm{d}\\mu}=2\\int_0^1F(\\mu)\\mu\\,\\mathrm{d}\\mu$$\n\n- $$E_{avg}$$ 表示有多少能量我们可以看到，这些能量不会发生多次的反射。 NOT participate in further bounces\n- 所以最后的 能量/颜色 \n  - 能够直接看到的 $$F_{avg}E_{avg}$$ \n  - 光反射一次被看到：$$F_{avg}(1-E_{avg})\\cdot F_{avg}E_{avg}$$  $$F_{avg}(1-E_{avg})$$是反射后(F)未能从物体表面反射出去的能量(1-E)， $$F_{avg}(1-E_{avg})\\underline{F_{avg}}$$ 未能出去的能量发生第二次 $$F_{avg}(1-E_{avg})\\cdot F_{avg}\\underline{E_{avg}}$$ 发生反射后有多少能量被看到\n  - 反射k次：F_{avg}^k(1-E_{avg})^k\\cdot F_{avg}E_{avg}\n  - 累加得到 color term：\n  -  $$\\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}$$\n  - 最后将 color term directly multiplied on the uncolored **additional BRDF**\n\n### **Cook-Torrance 反射方程**\n\n$$L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} + k_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n#### 直接光 + 附加光\n\n![output2](/imgs/LearnPBR/output2.PNG)\n\n## **IBL**\n\n### **Diffuse Irradiance**\n\nImaged base lighting, IBL 是一类光照技术的集合，若光源不是可分解的直接光源，比如可以用辐射度量学计算的的点光源方向光等等，**而是将周围环境整体视为一个大光源**。IBL( 取自现实世界或者在3D场景生成) 环境立方体贴图(cubemap)，我们可以将立方体贴图的每个像素视为光源，在渲染方程中直接使用，这样可以有效的捕获环境的全局光照和氛围，使物体更好的融入环境。 由于基于图像的光照算法会捕捉部分甚至全部的环境光照，通常认为它是一种更精确的环境光照输入格式，甚至也可以说是一种全局光照的粗略近似。基于此特性，IBL 对 PBR 很有意义，因为当我们将环境光纳入计算之后，物体在物理方面看起来会更加准确。\n\n$$L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} + k_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n对于反射方程的求解主要是在半球上对所有入射光方向 w_i 的积分。 直接光照的话，我们事先知道对积分有贡献的、若干精准的光线方向，但是来自环境的**每个**方向w_i都有可能具有一定的 Radiance，这就很麻烦了。 我们需要：\n\n- 对给定任何方向w_i，能获取到该方向的场景 Radiance。\n- 积分需要快，因为是实时渲染。\n\n第一个思路就是用 环境立方体贴图，每个纹素都视为一个光源，使用一个w_i采样即可。\n\n为了更高效的解决积分，我们需要对其中大部分结果做预处理，再来看反射方程:\n\n$$L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} + k_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i\\\\ Because\\;diffuse\\;k_d\\;and\\;specular\\;are\\;independent\\;for\\;each\\;other.\\\\ We\\;can\\;break\\;up.\\\\ L_0(p,w_0)=\\int_{\\Omega}k_d\\frac{c}{\\pi}L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i + \\int_{\\Omega}k_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)}L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n先来研究 diffuse，将常数提出，能得到只依赖于w_i的积分，我们就可以计算或预计算一个新的立方体贴图，它在每个采样方向——也就是纹素——中存储漫反射积分的结果，这些结果是通过卷积计算出来的。\n\n$$L_0(p,w_0)=k_d\\frac{c}{\\pi}\\int_{\\Omega}L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n卷积的特性是，对数据集中的一个条目做一些计算时，要考虑到数据集中的所有其他条目。这里的数据集就是场景的辐射度或环境贴图。因此，要对立方体贴图中的每个采样方向做计算，我们都会考虑半球 \\Omega 上的所有其他采样方向。\n\n为了对环境贴图进行卷积，我们通过对半球 \\Omega上的大量方向进行离散采样并对其辐射度取平均值，来计算每个输出采样方向 w_0的积分。用来采样方向 w_i 的半球，要面向卷积的输出采样方向 w_0 。\n\n![ibl1](/imgs/LearnPBR/ibl1.png)\n\n是不是看不懂，看不懂就对了，因为应该是这样的！\n\n![ibl2](/imgs/LearnPBR/ibl2.png)\n\n该预计算的立方体贴图在每个采样方向 w_0(n)上存储结果，也就是场景中所有能够击中表面朝向为w_0(n)的间接漫反射光的预计算和。\n\n辐射方程也依赖了位置 p ，不过这里我们假设它位于辐照度图的中心。这就意味着所有漫反射间接光只能来自同一个环境贴图，这样可能会破坏现实感（特别是在室内）。渲染引擎通过在场景中放置多个反射探针来解决此问题，每个反射探针单独预计算其周围环境的辐照度图。这样，位置 p 处的辐照度（以及辐射度）是取离其最近的反射探针之间的辐照度（辐射度）内插值\n\n关于在半球的积分，可以将立体角 soiled angle 展开\n\n$$L_0(p,w_0)= k_d\\frac{c}{\\pi} \\int_{\\phi=0}^{2\\pi}\\int_{\\theta=0}^{\\frac{1}{2}\\pi} L_i(p,\\phi_i,\\theta_i) \\cos\\theta\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi\\\\  Here\\;\\cos\\theta\\sin\\theta,\\;\\sin\\theta\\;for\\;soiled\\;angle,\\;\\cos\\theta\\;for\\;\\overrightarrow{up}:w_i\\cdot n\\\\  L_0(p,w_0)=k_d\\frac{c}{\\pi} \\frac{1}{n_1n_2}\\sum\\limits^{n_1}_{\\phi=0}\\sum\\limits^{n_2}_{\\theta=0} L_i(p,\\phi_i,\\theta_i) \\cos\\theta\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$$\n\n### **实现**\n\nRoughness in [0,1]->[0,5]\n\n做五级的skybox，存在cubemap tex内\n\n#### **参考**\n\n[漫反射辐照 - LearnOpenGL CN (learnopengl-cn.github.io)](https://learnopengl-cn.github.io/07 PBR/03 IBL/01 Diffuse irradiance/) [codinglabs.net/article_physically_based_rendering.aspx](http://www.codinglabs.net/article_physically_based_rendering.aspx)\n\n### **Specular IBL**\n\n#### **The Split Sum: 1st Stage**\n\n现在来看镜面反射部分，反射方程为：\n\n$$L_0(p,w_0)=\\int\\limits_\\Omega(k_d\\frac{c}{\\pi}+k_s\\frac{DFG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n这下坏了，因为 ks 是受入射光还有视角影响的。如果进行实时计算，视线和光线的组合数极其庞大，这样的开销是很昂贵的。 Epic Games 提出了一个解决方案，他们预计算镜面部分的卷积，为实时计算作了一些妥协，这种方案被称为分割求和近似法（**split sum approximation**）。 分割求和近似将方程的镜面部分分割成两个独立的部分，我们可以单独求卷积，然后在 PBR 着色器中求和，以用于间接镜面反射部分 IBL。分割求和近似法类似于我们之前求辐照图预卷积的方法，需要 HDR 环境贴图作为其卷积输入。为了理解，我们回顾一下反射方程，但这次只关注镜面反射部分：\n\n$$L_0(p,w_0)=\\int\\limits_\\Omega(k_s\\frac{DFG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i\\\\ =\\int\\limits_\\Omega f_r(p,w_i,w_0)L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n我们依然想计算出一个类似镜面 IBL 贴图的东西，然后使用pixel的法线采样，但是问题在于，辐照度图只依赖于 w_i，但是这次积分还依赖于 BRDF\n\n$$f_r(p,w_i,w_0)=\\frac{DFG}{4(w_0\\cdot n)(w_i\\cdot n)}$$\n\nBRDF内还有w_0，更不可能要用入射和出射光的组合了，那计算肯定爆掉了。\n\n$$\\int_{\\Omega}f(x)g(x)\\,\\mathrm{d}x\\approx\\frac{\\int_{\\Omega_G}f(x)\\,\\mathrm{d}x}{\\int_{\\Omega_G}\\,\\mathrm{d}x}\\cdot\\int_{\\Omega}g(x)\\,\\mathrm{d}x$$\n\n所以 E宝先将其分为两个部分求解，再将两个部分组合计算得到预计算结果。\n\n$$L_0(p,w_0)=\\int\\limits_\\Omega L_i(p,w_i)\\,\\mathrm{d}w_i*\\int\\limits_\\Omega f_r(p,w_i,w_0)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n卷积的第一部分被称为预滤波环境贴图，它类似于辐照度图，是预先计算的环境卷积贴图，但这次考虑了粗糙度。因为随着粗糙度的增加，参与环境贴图卷积的采样向量会更分散，导致反射更模糊，所以对于卷积的每个粗糙度级别，我们将按顺序把模糊后的结果存储在预滤波贴图的 mipmap 中。例如，预过滤的环境贴图在其 5 个 mipmap 级别中存储 5 个不同粗糙度值的预卷积结果，如下图所示：\n\n![IBLCubemap](/imgs/LearnPBR/IBLCubemap.png)\n\n为什么是不同粗糙度的图呢？这是因为对于不同的粗糙度，我们镜面反射是不同的，当表面越粗糙镜面反射越松散，我们观测的光照结果会越分散在更广的范围，而越光滑，反射范围越小越集中，视觉上也就是越清晰的。\n\n![iblAlpha](/imgs/LearnPBR/iblAlpha.png)\n\n从上图我们可以看到我们对r方向采样，实际上是对cubemap的一个橙色的 fliter 进行采样的，当越粗糙时这个 filter 越大。\n\n为什么两部分分开了还要前面项会受到 BRDF 影响，因为我们的采样方向其实就是会受到 BRDF 的影响的。\n\n![boban](/imgs/LearnPBR/boban.jpg)\n\n我们对cubemap的采样范围或者说采样的样本实际就是图中所示的波瓣，而根据 brdf 定义可知：\n\n$$R=reflection(w_o,n)，w_o就是\\overrightarrow{view}。$$\n\n**假设不同方向入射，波瓣变化不大**，我们可以得到:\n\n$$f(w_o,w_i(n),n)\\approx f(R,w_i(R),R)，也就是 N=V=R。$$ f(w_o,w_i(n),n)\\approx f(R,w_i(R),R)，也就是 N=V=R。\n\n![poban](/imgs/LearnPBR/poban.jpg)\n\n我们使用 Cook-Torrance BRDF 的法线分布函数(NDF)生成采样向量及其散射强度，该函数将法线和视角方向作为输入。由于我们在卷积环境贴图时事先不知道视角方向，因此 Epic Games 假设视角方向——也就是镜面反射方向——总是等于输出采样方向ωo，以作进一步近似。翻译成代码如下：\n\nvec3 N = normalize(w_o);\n\nvec3 R = N;\n\nvec3 V = R;\n\n但是这样的假设会导致在掠射角处失去各向异性，因为菲涅尔现象会导致不同w_o的反射方向或者反射现象是不一样的，所以基于波瓣不变的假设所做的结果必然会有缺失。\n\nMoving Frostbite to Physically Based Rendering 3.0-4.9.2 Light probe filtering\n\nTo simplify this evaluation, we can pre-integrate the integral by making some approximations. Pre-integrating this equation for every v and Θ would require a huge memory footprint. Thus, a first approximation is to remove the view dependency. This leads to a coarse approximation of the BRDF but it is an acceptable trade-off: the shape of a BRDF based on the micro-facets framework and/or half-angle parametrization is strongly dependent on the view angle as shown on Figure 54. At normal incident direction, the shape of a BRDF is isotropic. At grazing angles the shape of a BRDF is anisotropic. Removing the view dependency for pre-integrating Equation 46 would make the assumption that the BRDF shape is isotropic at all view angles. This leads to key visual differences, preventing stretched reflections. This approximation can be quite noticeable on flat surfaces as shown on Figure 55 but less on curvy surfaces38\n\n![ueReference](/imgs/LearnPBR/ueReference.png)\n\n#### **The Split Sum: 2nd Stage**\n\n$$Lo(p,w_o)\\approx\\frac{\\int_{\\Omega_{fr}}L_i(p,w_i)\\,\\mathrm{d}w_i}{\\int_{\\Omega_{fr}}\\,\\mathrm{d}w_i}\\cdot\\underline{\\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i}$$\n\n这部分计算和 F_0,\\alpha,\\theta相关，但是3D贴图太大了！！！\n\n菲涅项其实比较好拆，我们可以对这部分做一些处理\n\n$$R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\ R_0-R_0(1-\\cos\\theta)^5+(1-\\cos\\theta)^5\\\\ \\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i\\approx\\\\ R_0\\int_{\\Omega^+}\\frac{f_r}{F}(1-(1-\\cos\\theta)^5)\\cos\\theta_i\\,\\mathrm{d}w_i+\\int_{\\Omega^+}\\frac{f_r}{F}(1-\\cos\\theta)^5\\cos\\theta_i\\,\\mathrm{d}w_i$$\n\n![uecode1](/imgs/LearnPBR/uecode1.png)\n\n### **The Split Sum: 1st Stage Sample**\n\n在上一节教程中，我们使用球面坐标生成均匀分布在半球 $$\\Omega$$ 上的采样向量，以对环境贴图进行卷积。虽然这个方法非常适用于辐照度，但对于镜面反射效果较差。镜面反射依赖于表面的粗糙度，反射光线可能比较松散，也可能比较紧密，但是一定会围绕着反射向量r，除非表面极度粗糙：\n\n![sample](/imgs/LearnPBR/sample.png)\n\n所有可能出射的反射光构成的形状称为镜面波瓣。随着粗糙度的增加，镜面波瓣的大小增加；随着入射光方向不同，形状会发生变化。因此，镜面波瓣的形状高度依赖于材质。 在微表面模型里给定入射光方向，则镜面波瓣指向微平面的半向量的反射方向。考虑到大多数光线最终会反射到一个基于半向量的镜面波瓣内，采样时以类似的方式选取采样向量是有意义的，因为大部分其余的向量都被浪费掉了，这个过程称为重要性采样。\n\nF = FresnelSchlickFunction(F0, max(0.0, dot(N, H)), roughness);\n\nfloat3 spe_ibl = SAMPLE_TEXTURE2D_LOD(_MySplit1st, sampler_MySplit1st, float2(uv.xy), _Roughness * 4.0);\n\ncol += spe_ibl * (F * brdf.x + brdf.y)+ ev_diffuse*albedo;\n\n![uecode2](/imgs/LearnPBR/uecode2.png)\n\n### **蒙特卡洛(Monte Carlo)积分和重要性采样(Importance Sampling)**\n\n[蒙特卡洛积分 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/146144853)\n\n有了蒙特卡洛，那么如何对半球面上的进行采样。\n\n### **低差异序列**\n\nHammersley 序列\n\n```OpenGL\nfloat RadicalInverse_VdC(uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nfloat2 Hammersley(uint i, uint N)\n{\n    return float2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n```\n\n[看懂蒙特卡洛积分(三) 低差异采样序列](https://zhuanlan.zhihu.com/p/343666731) [低差异序列（一）- 常见序列的定义及性质 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/20197323) [低差异序列（二）- 高效实现以及应用 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/20374706)\n\n#### **GGX 重要性采样**\n\n```OpenGL\nfloat3 ImportanceSampleGGX(float2 Xi, float3 N, float roughness)\n{\n    // use roughness for better view\n    float alpha2 = roughness * roughness;\n\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt( (1.0 - Xi.y) / (1.0 + ( alpha2 * alpha2 - 1.0) * Xi.y));\n    float sinTheta = sqrt(1 - cosTheta * cosTheta);\n\n    float3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\n    float3 up = abs(N.z) < 0.999 ? float3(0.0, 0.0, 1.0) : float3(1.0, 0.0, 0.0);\n    float3 tangent = normalize(cross(up,N));\n    float3 biTangent = normalize(cross(N, tangent));\n\n    float3 sampleVec = tangent * H.x + biTangent * H.y + N * H.z;\n    return normalize(sampleVec);\n}\n```\n\n### The Split Sum\n\n```OpenGL\n// 1st\nvoid PrefilteredColor(float3 dir, uint3 id)\n{\n    float3 N = normalize(dir);\n    float3 R = N;\n    float3 V = R;\n\n    const uint SAMPLE_COUNT = 1024;\n    float totalWeight[5] = {0.0, 0.0, 0.0, 0.0, 0.0};\n    float3 preColor[5] = { float3(0.0,0.0,0.0), float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0)};\n    for(uint i = 0; i < SAMPLE_COUNT; ++i)\n    {\n        float2 Xi = Hammersley(i, SAMPLE_COUNT);\n        float3 H[5];\n        float3 L[5];\n        float NdotL[5];\n        for(uint a = 0; a < 5; a++)\n        {\n            H[a] = ImportanceSampleGGX(Xi, N, (float)a*2.0/10.0);\n            L[a] = normalize(2.0 * dot(V, H[a]) * H[a] - V);\n            NdotL[a] = max(0.0,dot(N,L[a]));\n            if(NdotL[a] > 0.0)\n            {\n                float D = DistributeGGX(N, H[a], (float)a/5.0);\n                float NdotH = max(0.0, dot(N, H[a]));\n                float HdotV = max(0.0, dot(H[a], V));\n                float pdf = D * NdotH / (4.0 * HdotV) + 0.0001;\n\n                float res = 512.0;\n                float saTexel = 4.0 * PI / (6.0 * res * res);\n                float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n                float roughness = (float)a / 5.0;\n                float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n                \n                preColor[a] += _SkyBoxTex.SampleLevel(LinearClampSampler, L[a], mipLevel).xyz * NdotL[a];\n                totalWeight[a] += NdotL[a];\n            }\n        }         \n    }\n    int powLog = 1;\n    for(uint b = 0; b < 5; b++)\n    {    \n        preColor[b] = preColor[b] / totalWeight[b];\n        _SplitSum1stMip[b][id.xy/powLog] = float4(preColor[b],1);\n        powLog *= 2;\n    }\n}\n\n// 2nd\nfloat2 IntegrateBRDF(float NdotV, float roughness)\n{\n    float3 V;\n    V.x = sqrt(1 - NdotV * NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    float3 N = float3(0.0, 0.0, 1.0);\n\n    int sampleCount = 1024;\n    for(int i = 0; i < sampleCount; ++i)\n    {\n        float2 Xi = Hammersley(i, sampleCount);\n        float3 H = ImportanceSampleGGX(Xi, N, roughness);       // D. NDF\n        float3 L = normalize(2.0 * dot(V,H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(0.0, dot(V, H));\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness * roughness / 2.0);      // G\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);    \n            float Fc = pow(1 - VdotH, 5.0);\n            \n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(sampleCount);\n    B /= float(sampleCount);\n    return float2(A, B);\n}\n```\n\n### **反射探针**\n\n在unity中添加 probe 然后 baked\n\n使用 sampleSH 对 probe 进行采样\n\n### Environment Diffuse + IBL Specular\n\n![output3](/imgs/LearnPBR/output3.PNG)\n\n中间是粗糙度越来越小 下面是金属度越来越大\n\n### **IBL 参考**\n\n[Image Based Lighting | Chetan Jags (wordpress.com)](https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/) [course_notes_moving_frostbite_to_pbr_v32.pdf (wordpress.com)](https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf):4.9章节 [镜面IBL - LearnOpenGL CN (learnopengl-cn.github.io)](https://learnopengl-cn.github.io/07 PBR/03 IBL/02 Specular IBL/) [深入理解 PBR/基于图像照明 (IBL) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/66518450) [Lecture5 Real-time Environment Mapping哔哩哔哩bilibili](https://www.bilibili.com/video/BV1YK4y1T7yY?p=5&vd_source=1fa1b82383f6efb8a2632316da9afad0): Split Sum\n\n## **杂项**\n\n- ComputeShader 使用 cubetex：[[Compute shader\\] Use TextureCube(Resolved)](https://forum.unity.com/threads/compute-shader-use-texturecube-resolved.628891/)\n- TextureCube<float4 cubemap; SamplerState _LinearClamp; float3 dir; cubemap.SampleLevel(_LinearClamp, dir, 0);\n- 如何向Tex指定mipmap层级写入，在 setrendertarget 指定\n- compute Shader sample\n  - `float4 c = tex[id];`\n  - mipmap: `float4 c = tex.mips[0][id]` or `tex.Load(uint3(id,0))`\n  - SampleLevel: \n  - SampleState Sampler1 {    Filter = MIN_LINEAR_MAG_MIP_POINT; }; float4 t = tex.SampleLevel(Sample1, uv, 0);\n- Sample filter [8.5 纹理采样 (enjoyphysics.cn)](https://enjoyphysics.cn/Article1554)\n\n```OpenGL\n// 在倍增、缩减、多级渐进纹理上使用线性过滤。\nSamplerState mySampler0 \n{\n    Filter = MIN_MAG_MIP_LINEAR; \n}; \n\n// 在缩减上使用线性过滤，倍增和多级渐进纹理上使用点过滤。\nSamplerState mySampler1 \n{ \n    Filter = MIN_LINEAR_MAG_MIP_POINT; \n}; \n\n// 在缩减上使用点过滤，倍增上使用线性过滤，多级渐进纹理上使用点过滤。\nSamplerState mySampler2 \n{ \n    Filter = MIN_POINT_MAG_LINEAR_MIP_POINT; \n}; \n\n// 在倍增、缩减、多级渐进纹理上使用各向异性过滤。\nSamplerState mySampler3 \n{ \n    Filter = ANISOTROPIC; \n    MaxAnisotropy = 4;\n};\n```\n\n### **Unity And Mipmap**\n\n[【渲染】用计算着色器生成Mipmap - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/419644293)\n\n### **Computer 指定 Mipmap 写入**\n\n```\ncomputeShader.SetTexture(kernal, “name”, tex, mipmapLevel);\n```\n\n### **不同光源的衰减**\n\n[投光物 - LearnOpenGL CN (learnopengl-cn.github.io)](https://learnopengl-cn.github.io/02 Lighting/05 Light casters/) [Point and Spot Lights (catlikecoding.com)](https://catlikecoding.com/unity/tutorials/custom-srp/point-and-spot-lights/)\n\n#### **Point Light**\n\n- $(\\,max(0, 1-(\\frac{d^2}{r^2})^2)\\,)^2$，r 是 point light 的范围\n- $\\frac{1.0}{K_c+K_l*d+K_q*d^2}$\n\n### **ShaderGUI**\n\n通过编写 ShaderGUI 在 Material 面板控制 shader properties\n\n或 en/dis able keyword\n\n```OpenGL\npublic class MyShaderGUI : ShaderGUI\n{\n    public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties)\n    {\n        base.OnGUI(materialEditor, properties);\n        Material material = materialEditor.target as Material;\n    }\n}\n```\n\n在 Shader 结尾加上\n\nCustomEditor \"MyLearnPBRGUI\";\n\n## **URP 光**\n\n[Light 组件参考 | Universal RP | 12.1.1 (unity3d.com)](https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/light-component.html) [光照模式 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/current/Manual/LightModes.html) [光源模式：Baked - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/current/Manual/LightMode-Baked.html)\n\n### **Lighting**\n\n- Scene/Mixed Lighting/Lighting Mode\n  - **Baked Indirect**: [Lighting Mode：Baked Indirect - Unity 手册](https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-BakedIndirect.html) 混合光源的行为类似于[实时光源](https://docs.unity.cn/cn/2022.3/Manual/LightMode-Realtime.html)，但有额外的好处是会**将间接光照烘焙到光照贴图中**。**混合(Mixed)光源照亮的游戏对象会投射实时阴影**，最大距离是在项目中定义的[阴影距离 (Shadow Distance)](https://docs.unity.cn/cn/2022.3/Manual/shadow-distance.html)。\n  - **Shadow Mask**: [Lighting Mode：Shadowmask - Unity 手册](https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Shadowmask.html) 与烘焙间接照明模式类似，阴影遮罩照明模式将**实时直接照明**与**[烘焙间接照明](https://docs.unity.cn/cn/2022.3/Manual/LightMode-Baked.html)****(Baked Indirect Lighting Mode)**相结合。但是，“阴影蒙版”照明模式与烘焙间接照明模式的不同之处在于它渲染阴影的方式。阴影蒙版光照模式使 Unity 可以在运行时组合烘焙阴影和实时阴影，并在远处渲染阴影。它通过使用称为阴影蒙版的附加光照贴图纹理，并在[光照探针](https://docs.unity.cn/cn/2022.3/Manual/LightProbes.html)中存储其他信息来实现此目的。Unity 为烘焙阴影生成阴影蒙版和 Light Probe 遮挡数据。\n  - **Subtractive**: [Lighting Mode：Subtractive - Unity 手册](https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Subtractive.html) 在 Subtractive 光照模式下，场景中的所有混合光源都提供烘焙直接光照和间接光照。Unity 将静态游戏对象投射的阴影烘焙到光照贴图中。除了烘焙阴影外，一种方向光（称为主方向光）还为动态游戏对象提供实时阴影。 因为阴影被烘焙到光照贴图中，所以 Unity 在运行时缺少将烘焙阴影和实时阴影准确地结合在一起所需的信息。但是，Unity 提供了 **Realtime Shadow Color** 属性来减少光照贴图的影响，从而在烘焙阴影和实时阴影之间创建正确的混合视觉效果。还可以调整颜色来实现某种艺术风格。 Subtractive 光照模式在低端硬件上非常有用，因为低端硬件需要注重性能，并且只需要一个实时阴影投射光源。这种光照模式不会提供特别逼真的光照效果，而是更适合风格化美学，例如卡通风格。\n\n## **Isotropic / Anisotropic BRDFs**\n\n$$f_r(\\theta_i,\\phi_i;\\theta_r,\\phi_r)\\ne f_r(\\theta_i,\\phi_i,\\phi_r-\\phi_i)\\\\ i\\;is\\;input,\\;r\\;is\\;reflection\\;dir.$$\n\n### **NDF**\n\n**形状不变性**\n\n- 是一个合格的法线分布函数需要具备的重要性质。具有形状不变性（shape-invariant）的法线分布函数，可以用于推导该函数的归一化的各向异性版本，并且可以很方便地推导出对应的遮蔽阴影项G。\n- 若一个各向同性的NDF可以改写成以下形式，则这个NDF具有形状不变性（shape-invariant）：\n- $$D(m)=\\frac{1}{\\alpha_2(n\\cdot m)^4}g(\\frac{\\sqrt{1-(n\\cdot m)^2}}{\\alpha(n\\cdot m)})$$\n\n- 其中g（）代表一个表示了NDF形状的一维函数。\n\n#### **Anisotropic Beckmann Distribution**\n\n$$D_{Baniso}(m)=\\frac{1}{\\pi\\alpha_x\\alpha_y(n\\cdot m)^4}exp(-\\frac{\\frac{(t\\cdot m)^2}{\\alpha_x^2}+\\frac{(b\\cdot m)^2}{\\alpha_y^2}}{(n\\cdot m)^2})$$\n\n```OpenGL\n// Anisotropic Beckmann\nfloat D_Beckmann_aniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )\n{\n    float XoH = dot( X, H );\n    float YoH = dot( Y, H );\n    float d = - (XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay)) / NoHNoH;\n*    return exp(d) / ( PI * ax*ay * NoH * NoH * NoH * NoH );\n}\n```\n\n#### **Trowbridge-Reitz GGX Anisotropic**\n\n$$D_{GGXaniso}(m)=\\frac{1}{\\pi\\alpha_x\\alpha_y}\\frac{1}{(\\frac{(x\\cdot m)^2}{\\alpha_x^2}+\\frac{(y\\cdot m)^2}{\\alpha_y^2}+(n\\cdot m))^2}$$\n\n```OpenGL\n// Anisotropic GGX\n// [Burley 2012, \"Physically-Based Shading at Disney\"]\nfloat D_GGXaniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )\n{\n    float XoH = dot( X, H );\n    float YoH = dot( Y, H );\n    float d = XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay) + NoHNoH;\n*    return 1 / ( PI * ax*ay * d*d );\n}\n```\n\n- 其中，X为tangent，t切线方向，Y为binormal，b，副法线方向\n- 需要注意的是，将法线贴图与各向异性BRDF组合时，重要的是要确保法线贴图扰动（perturbs）切线和副切线矢量以及法线\n\n[2010-anisobrdf.pdf (cuni.cz)](https://cgg.mff.cuni.cz/~jaroslav/papers/2010-anisobrdf/2010-anisobrdf.pdf) [Slope: GGX Anisotropic (shadertoy.com)](https://www.shadertoy.com/view/3tyXRt)\n\n### **Geometry Function**\n\n$$G_1(m,v)=\\frac{clamp(0,1,m\\cdot v)}{1+\\Lambda(v)}$$\n\n#### **Beckmann**\n\n$$\\Lambda(v)=\\frac{erf(a)-1}{2}+\\frac{1}{2a\\sqrt{\\pi}}exp(-a^2)\\\\ a=\\frac{1}{\\alpha\\tan\\theta_o}$$\n\n#### **GGX**\n\n$$\\Lambda(v)=\\frac{-1+\\sqrt{1+\\frac{1}{a^2}}}{2}\\\\ a=\\frac{1}{\\alpha\\tan\\theta_o}$$\n\n### **Anisotropic Geometry Function**\n\n#### **Smith**\n\n假设我们拉伸x轴，将各向同性的法线分布转变为各向异性的。\n\n假设各向异性的粗糙度参数有a_x,a_y，视线v(x_o,y_o,z_o)，通过拉伸x轴\\frac{a_x}{a_y}\n\n$$a_x'=a_x\\frac{a_y}{a_x}=a_y\\\\ a_y'=a_y$$\n\n也就是粗糙度\\alpha=\\alpha_y\n\n$$v'=(\\frac{\\alpha_x}{\\alpha_y}x_o,y_o,z_o)=(\\frac{\\alpha_x}{\\alpha_y}\\cos\\phi_o\\sin\\theta_o,\\sin\\phi_o\\sin\\theta_o,\\cos\\theta_o)\\\\ \\frac{1}{\\tan\\theta'_o}=\\frac{z_o}{\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}x_o^2+y_o^2}}=\\frac{1}{\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}\\cos^2\\phi_o+\\sin^2\\phi_o}\\cdot\\tan\\theta_o}\\\\ Because:a=\\frac{1}{\\alpha\\tan\\theta_o}\\\\ a'=\\frac{1}{a_y\\tan\\theta_o}=\\frac{1}{a_y\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}\\cos^2\\phi_o+\\sin^2\\phi_o}\\cdot\\tan\\theta_o}\\\\ =\\frac{1}{\\sqrt{\\alpha_x^2\\cos^2\\phi_o+\\alpha_y^2\\sin^2\\phi_o}\\cdot\\tan\\theta_o}$$\n\n[PBR 五 几何遮蔽函数遮蔽因子函数wuhaocat的博客-CSDN博客](https://blog.csdn.net/haozi2008/article/details/112284028)\n\n[PBR-White-Paper/content/part 5/README.md at master · QianMo/PBR-White-Paper (github.com)](https://github.com/QianMo/PBR-White-Paper/blob/master/content/part 5/README.md)\n\n### **Output**\n\n<img src=\"/imgs/LearnPBR/output4-1.PNG\" alt=\"output4-1\" style=\"zoom:50%;\" />\n\n<img src=\"/imgs/LearnPBR/AnisoSphere2.png\" alt=\"AnisoSphere2\" style=\"zoom:50%;\" />\n\n### **Anisotropic IBL**\n\n#### **Split Sum 2nd**\n\n$$R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\ R_0-R_0(1-\\cos\\theta)^5+(1-\\cos\\theta)^5\\\\ \\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i\\approx\\\\ R_0\\int_{\\Omega^+}\\frac{f_r}{F}(1-(1-\\cos\\theta)^5)\\cos\\theta_i\\,\\mathrm{d}w_i+\\int_{\\Omega^+}\\frac{f_r}{F}(1-\\cos\\theta)^5\\cos\\theta_i\\,\\mathrm{d}w_i$$\n\nroughness_x, roughness_y, theta 相关3D LUT了\n\n## **[TODO]动态天空的环境光怎么计算**\n\n提前烘焙，插值。\n\nTOD\n\n像大气散射，其实已经计算了 LUT 所以可以直接使用。\n\n\n\n## Unity Specular Cube0\n\n[Graphics/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlsl at 19518485b3edcf19f267f293f899d5d25e734a17 · Unity-Technologies/Graphics (github.com)](https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlsl#L620)\n\n~~~hlsl\nhalf mip = PerceptualRoughnessToMipmapLevel(perceptualRoughness);\n    half4 encodedIrradiance = SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip);\n    half3 irradiance = DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);\n    return irradiance * occlusion;\n~~~\n\n### PerceptualRoughnessToMipmapLevel\n\n[Graphics/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl at 19518485b3edcf19f267f293f899d5d25e734a17 · Unity-Technologies/Graphics (github.com)](https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl#L27)\n\n~~~\nreal PerceptualRoughnessToMipmapLevel(real perceptualRoughness, uint maxMipLevel)\n{\n    perceptualRoughness = perceptualRoughness * (1.7 - 0.7 * perceptualRoughness);\n\n    return perceptualRoughness * maxMipLevel;\n}\n~~~\n\n\n\nSAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip);\n\n## **参考**\n\n[由浅入深学习PBR的原理和实现 - 0向往0 - 博客园 (cnblogs.com)](https://www.cnblogs.com/timlly/p/10631718.html)   \n[course_notes_moving_frostbite_to_pbr_v32.pdf (wordpress.com)](https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf)   \n[【基于物理的渲染（PBR）白皮书】（一） 开篇：PBR核心知识体系总结与概览 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/53086060)   \n[Physically Based Rendering: From Theory to Implementation (pbr-book.org)](https://www.pbr-book.org/3ed-2018/contents)  \nReal-Time Rendering Fourth Edition 第九章   \n[Lecture10 Real-Time Physically-based Materials (surface models)哔哩哔哩bilibili](https://www.bilibili.com/video/BV1YK4y1T7yY?p=10&vd_source=1fa1b82383f6efb8a2632316da9afad0)   \n[Lecture11 Real-Time Physically-based Materials (surface models cont.)哔哩哔哩bilibili](https://www.bilibili.com/video/BV1YK4y1T7yY?p=11&vd_source=1fa1b82383f6efb8a2632316da9afad0)  \nUE4: [2013SiggraphPresentationsNotes-26915738.pdf (unrealengine.com)](https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf)   \n[寒霜引擎的PBR实践3.0（一）材质篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/144611412)  \n[寒霜引擎的PBR实践3.0（二）光照篇——光照强度与精确光源 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/158261389)   \n[寒霜引擎的PBR实践3.0（三）光照篇——光度学灯与区域光 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/186541854)   \n[[译\\]Real Shading in Unreal Engine 4（UE4中的真实渲染)(1) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/121719442)  \n[使用Compute Shader计算球谐全局光照 | ZZNEWCLEAR13](https://zznewclear13.github.io/posts/calculate-spherical-harmonics-using-compute-shader/)","source":"_posts/LearnPBR.md","raw":"---\ntitle: Learn PBR\ntags: 图形学\nmath: true\nindex_img: /imgs/LearnPBR/pbr.png\nbanner_img: /imgs/LearnPBR/pbr.png\ndate: 2023-11-14\ntypora-root-url: ../\n---\n\n关于PBR的一些知识点\n\n# Learn PBR\n\n# PBR理论\n\n## **简介**\n\n**PBR**（**Physically Based Rendering**）译成中文是基于物理的渲染。它是利用真实世界的原理和理论，通过各种数学方法推导或简化或模拟出一系列渲染方程，并依赖计算机硬件和图形API渲染出拟真画面的技术。\n\n### **PBR** **特征**\n\n更高质量的着色效果和更多复杂的材质特性。\n\n- 表面细节\n- 物体粗糙度\n- 区别明显的金属和绝缘体\n- 物体的浑浊程度\n- 菲涅尔现象：不同角度有不同强度的反射光\n- 半透明物体\n- 多层混合材质\n- 清漆效果\n- 其它更复杂的表面特征\n\n> 近今年，PBR的技术主要朝着更逼真、更复杂、效能更好的方向，或是结合若干种模型的综合性技术迈进。代表性技术有：\n>\n> - PBR Diffuse for GGX + Smith (2017)\n> - MultiScattering Diffuse (2018)\n> - Layers Material（分层材质）\n> - Mixed Material（混合材质）\n> - Mixed BxDF（混合BxDF）\n> - Advanced Rendering（进阶渲染）\n\n### **OutPut**\n\n![output](/imgs/LearnPBR/output.PNG)\n\n## **PBR** **和 游戏引擎**\n\n### **UE4 的** **PBR**\n\n- **Base Color**，基础的纹理颜色 非金属物体只有**单色**，即强度\n\n| Material                 | Base Color Intensity |\n| ------------------------ | -------------------- |\n| 木炭(Charcoal)           | 0.02                 |\n| 新沥青(Fresh asphalt)    | 0.02                 |\n| 旧沥青(Worn asphalt)     | 0.08                 |\n| 土壤(Bare soil)          | 0.13                 |\n| 绿草(Green Grass)        | 0.21                 |\n| 沙漠沙(desert sand)      | 0.36                 |\n| 新混泥土(Fresh concrete) | 0.51                 |\n| 海洋冰(Ocean Ice)        | 0.56                 |\n| 鲜雪(Fresh snow)         | 0.81                 |\n\n- **金属**材质，在 Linear 空间的值\n\n| 材质(Material) | 基础色(BaseColor)     |\n| -------------- | --------------------- |\n| 铁(Iron)       | (0.560, 0.570, 0.580) |\n| 银(Silver)     | (0.972, 0.960, 0.915) |\n| 铝(Aluminum)   | (0.913, 0.921, 0.925) |\n| 金(Gold)       | (1.000, 0.766, 0.336) |\n| 铜(Copper)     | (0.955, 0.637, 0.538) |\n| 铬(Chromium)   | (0.550, 0.556, 0.554) |\n| 镍(Nickel)     | (0.660, 0.609, 0.526) |\n| 钛(Titanium)   | (0.542, 0.497, 0.449) |\n| 钴(Cobalt)     | (0.662, 0.655, 0.634) |\n| 铂(Platinum)   | (0.672, 0.637, 0.585) |\n\n- **粗糙度(Roughness)**：表面的粗糙程度, [0,1]，越粗糙高光越弱。\n\n![roughness](/imgs/LearnPBR/roughness.png)\n\n![roughness2](/imgs/LearnPBR/roughness2.png)\n\n上为非金属，下为金属，粗糙度从0至1\n\n- **金属度(Metallic)**：表示材质像金属的程度，0是绝缘体(电介质)，1 是金属，金属只有镜面反射，没有漫反射。\n\n![metallic](/imgs/LearnPBR/metallic.png)\n\n金属度从0至1\n\n- **镜面度(Specular)**：表示物体镜面反射的强度，从0(完全没有镜面反射)到1(完全镜面反射)\n\n![specular](/imgs/LearnPBR/specular.png)\n\nFrom 0 ~ 1\n\n| 材质(Material) | 镜面度(Specular) |\n| -------------- | ---------------- |\n| 草(Glass)      | 0.5              |\n| 塑料(Plastic)  | 0.5              |\n| 石英(Quartz)   | 0.57             |\n| 冰(Ice)        | 0.224            |\n| 水(Water)      | 0.255            |\n| 牛奶(Milk)     | 0.277            |\n| 皮肤(Skin)     | 0.35             |\n\n### **Unity 的** **PBR**\n\n- **Albedo**，和 UE 的 Base Color 一样。 可以用颜色或者Tex\n- **Metallic**，可以用金属贴图，但是用了 Smoothness 参数就消失了\n- **Smoothness**，光滑度，和 UE 的 粗糙度正相反\n  - **Smoothness Source**，指定光滑度的存储通道，可选金属度、镜面贴图的 Alpha 或基础色的 Alpha\n- **Occlusion**：遮蔽图，指定材质接收间接光的光照强度和反射强度。 能够使物体经常是暗部的位置更暗，比如人的眼窝，脸和脖子的交接处。\n- **Fresnel**，物体边缘或者说物体法线和视线角度增大，物体的反射能力更强，Unity 里面是自动处理，越光滑越强，越粗糙 Fresnel 越弱。\n\n## **PBR** **基本原理**\n\n满足以下条件的光照模型才能称之为PBR光照模型：\n\n- 基于微平面模型（Be based on the microfacet surface model）。\n- 能量守恒（Be energy conserving）。\n- 使用基于物理的BRDF（Use a physically based BRDF）。\n\n### **微表面理论(Microfacet)**\n\n很多 PBR 技术都是基于理论 认为**在微观上**，所有的物体表面都是由很多的朝向不一的微小平面组成的。\n\n> 真实世界的物体表面其实不一定是这样的微小平面，可能会有弧度，甚至坑坑洼洼，但我们从肉眼观察、甚至*光栅化后的像素尺度*来看待的话，这种假设的结果和实际差别甚微。\n\n![microfacet](/imgs/LearnPBR/microfacet.png)\n\n基于这种假设，没有任何表面是光滑的，但由于这些微平面已经微小到逐像素无法对其进行细分，所以假设一个粗糙度 Roughness，用统计学的方法去估算微表面的粗糙度。\n\n...\n\n### **Energy Conservation (能量守恒)**\n\n在 Microfacet 中采用近似的能量守恒定律，出射光的总能量不能超过入射光的总能量(不含自发光)，\n\n所以材质粗糙度越大，反射的范围越大，整体的亮度会变低。\n\n#### **镜面反射(specular)和漫反射(diffuse)**\n\n一束光打到物体，会发生 **reflection** 反射 和 **refraction** 折射。反射的光直接离开，不进入物体发射了镜面反射光；折射的光进入物体内发生了吸收或散射，产生漫反射。 折射后的光若没被吸收会继续前进，在物体内部发生光和微粒的碰撞，这时有一部分能力转化为热量，有些光经过多次折射从表面射出，便形成漫反射光。\n\n![reflect](/imgs/LearnPBR/reflect.png)\n\n*照射在平面的光被分成镜面反射和折射光，折射光在跟物体微粒发生若干次碰撞之后，有可能发射出表面，成为漫反射。* 通常情况下，PBR会简化折射光，将平面上所有折射光都视为被完全吸收而不会散开。而有一些被称为次表面散射(Subsurface Scattering)技术的着色器技术会计算折射光散开后的模拟，它们可以显著提升一些材质（如皮肤、大理石或蜡质）的视觉效果，不过性能也会随着下降。 金属(Metallic)材质会立即吸收所有折射光，故而金属只有镜面反射，而没有折射光引起的漫反射。\n\n根据上面的能量守恒关系，可以先计算镜面反射部分，此部分等于入射光线被反射的能量所占的百分比。而折射部分可以由镜面反射部分计算得出。\n\nfloat kS = calculateSpecularComponent(...); // 反射/镜面部分\n\nfloat kD = 1.0 - kS;                        // 折射/漫反射部分\n\nks + kd 不会超过1，所以近似地能量守恒。\n\n### **Reflectance Equation**\n\n$$L_0(p,w_0)=\\int\\limits_{\\Omega}f_r(p,w_i,w_0)L_i(p,w_i)\\,\\mathrm{d}w_i$$\n\n## **辐射度量学**\n\n### **概念表**\n\n![chart1](/imgs/LearnPBR/chart1.png)\n\n![chart2](/imgs/LearnPBR/chart2.png)\n\n> 微分符号 d 的含义：首先来说下微分的定义：设f(x)定义在区间(a,b)上，x∈(a,b),给定自变量x的一个增量Δx，得到函数的一个增量Δy，如果有Δy=f(x+Δx)-f(x)=AΔx+o(Δx)(Δx→0)，则y=f(x)称在点x可微，函数增量的线性主部AΔx称为函数的微分，记为dy=df(x)=AΔx\n\n### **辐射通量（Radiant Flux)**\n\n光源单位时间内的输出$$\\Phi=\\frac{\\mathrm{d}Q}{\\mathrm{d}t}$$\n\n> 光是由多种不同波长的能量集合而成，每种波长与一种特定的（可见的）颜色相关。因此一个光源所放射出来的能量可以被视作这个光源包含的所有各种波长的一个函数。波长介于390nm（纳米）到700nm的光被认为是处于可见光光谱中，也就是说它们是人眼可见的波长。\n\n传统物理学上的辐射通量将会计算这个由不同波长构成的函数的总面积，这种计算很复杂，耗费大量性能。在PBR技术中，不直接使用波长的强度，而是使用三原色编码（RGB）来简化辐射通量的计算。虽然这种简化会带来一些信息上的损失，但是这对于视觉效果上的影响基本可以忽略。\n\n### **Radiant Insensity(辐射强度)**\n\n单位球面上，一个光源向单位立体角所投送的辐射通量。\n\n$$I=\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}w}$$\n\nthe power per unit angle\n\n假如光源均匀向四周发散\n\n$$I = \\frac{\\Phi}{4\\pi}$$\n\n### **Irradiance**\n\nThe power per (perpendicular/projected) unit area incident on a surface point.\n\n$$E(x)=\\frac{\\mathrm{d}\\Phi(x)}{\\mathrm{d}A^\\perp }$$\n\n面要和光源垂直。\n\n即 Lambert‘s Consine Law\n\n### **Radiance**\n\nThe radiance(luminance) is the power emitted, reflected, transmitted or received by a surface, *per unit solid angle, per projected unit area.* 在单位立体角并且在单位的面积上\n\n$$L(p,w)=\\frac{\\mathrm{d}^2\\Phi(p,w)}{\\mathrm{d}w\\,\\mathrm{d}A\\cos\\theta}=\\frac{\\mathrm{d}^2\\Phi(p,w)}{\\mathrm{d}w\\,\\mathrm{d}A^\\perp}$$\n\n- Irradiance: power per projected unit area\n- Intensity: power per solid angle\n\nSo\n\n- Radiance : Irrandiance pre solid angle\n- Radiance : Intensity pre unit projected area\n\nIrradiance 是 dA 收到的能量\n\nIrradiance per solid angle 是 dA 的能量向某一个方向辐射\n\n![Radiance](/imgs/LearnPBR/Radiance.png)\n\n该图为 Irrandicance per solid angle, 这的 cos 是不是应该写进 E 里面……\n\nIncident Radiance 延申理解：\n\n一小块面积 dA 向某个方向辐射的能量\n\n反过来就是，从一个方向打向一个小面，到达这个面时的能量\n\n$$L(p,w)=\\frac{\\mathrm{d}I(p,w)}{\\mathrm{d}A\\cos\\theta}=\\frac{\\mathrm{d}I(p,w)}{\\mathrm{d}A^\\perp}$$\n\n### **Irradiance vs. Radiace**\n\n$$\\mathrm{d}E(p,w)=L_i(p,w)\\cos\\theta\\,\\mathrm{d}w\\\\$$\n\n两边同时积分\n\n$$E(p)=\\int_H^2L_i(p,w)\\cos\\theta\\,\\mathrm{d}w\\\\ Uint\\;Hemisphere:H^2$$\n\n每个方向过来到 A 的能量, 这和渲染方程是异曲同工的。\n\n再回到渲染方程\n\n$$L_0(p,w_0)=\\int\\limits_\\Omega f_r(p,w_i,w_0)\\underbrace{L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i}_{Radiace}$$\n\n其中只有 f 项待解。\n\n## **BRDF(双向反射分布函数)** \n\nBidirectional Reflectance Distribution Function，BRDF\n\n一个使用入射光方向ωi作为输入参数的函数，输出参数为出射光ωo，表面法线为n，参数a表示的是微平面的粗糙度。\n\n![BRDF](/imgs/LearnPBR/BRDF.svg)\n\nBRDF 描述了不透明物体表面每个单独光线，对最终反射光线的影响。也就是光线打到该表面如何反射，\n\n假设BRDF描述的是完全镜面物体，只有当出射光线方向w0 完全符号 入射光线方向wi 的反射方向时，返回值会为1.0，其余情况为0.\n\n$$f_r(p,w_0,w_i)=\\frac{\\mathrm{d}L_0(p,w_0)}{\\mathrm{d}E(p,w_i)}=\\frac{\\mathrm{d}L_0(p,w_0)}{L_i(p,w_i)\\cos\\theta_i\\,\\mathrm{d}w_i}$$\n\nBRDF 有多种模拟表面光照的算法，实时渲染所用的基本是 **Cook-Torrance BRDF**\n\n### **参考**\n\n- **PBRT-BRDF章节：**[Surface Reflection (pbr-book.org)](https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Surface_Reflection)\n\n### **Cook-Torrance BRDF**\n\n$$f_r=k_df_{lambert}+k_sf_{cook-torrance}\\\\ k_d是入射光被折射比例，\\\\ k_s是被镜面反射比例$$\n\n而左侧的 f_lambert 表示漫反射部分，Lambertian Diffuse，一般是恒定的算式：\n\n$$f_{lambert}=\\frac{c}{\\pi}$$\n\nc 表示 Albedo，π 是为了归一化 漫反射，因为后面要积分的\n\n#### **BRDF的高光项**\n\n$$f_{cook-torrance}=\\frac{DFG}{4(w_0\\cdot n)(w_i\\cdot n)}$$\n\n- **D( Normal Distribution Function, NDF )** : 法线分布，估算在表面粗糙度的影响下，表现出的表面法线和半角向量(half Dir)的一致性或者说微表面的数量。 估算微表面的主要函数。\n- **F( Fresnel Equation )**：菲涅尔方程，描述菲涅尔现象，当视线和表面法线夹角变大时更容易发生光的反射。 不同表面角下，表面反射光线的比例。\n- **G( Geometry Function )** : 几何函数，描述了微表面自成影的现象，当一个微表面特别粗糙时，彼此之间可能相互遮挡，从而减少反射的光线。\n\n[brdf为什么要定义为一个单位是sr-1的量？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/28476602/answer/41003204) [brdf为什么要定义为一个单位是sr-1的量？ - 文刀秋二的回答:](https://www.zhihu.com/question/28476602/answer/41003204)\n\n### **D(Normal Distribution Function, NDF)**\n\n描述和微表面法线和半角向量的一致性，从统计学上近似 **Trowbridge-Reitz GGX(GGXTR) :** \n\n$${NDF}_{GGXTR}(n,h,\\alpha)=\\frac{\\alpha^2}{\\pi((n\\cdot h)^2(\\alpha^2-1)+1)^2}\\\\ h=normalize(viewDir+lightDir)\\\\ \\alpha={roughness}^2$$\n\n![ggx](/imgs/LearnPBR/ggx.png)\n\n[Trowbridge-Reitz GGX | Desmos](https://www.desmos.com/calculator/eks25xlifv?lang=zh-CN)\n\n当 粗糙度 为零时函数值变为零\n\n```OpenGL\nfloat DoubleDistributeGGX(float3 N, float3 H, float roughness)\n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(0.0, dot(N, H));\n    float NdotH2 = NdotH * NdotH;\n\n    float p = (NdotH2 * (a2 - 1.0) + 1.0);\n    p = PI * p * p;\n    return a2 / p;\n}\n\nroughness += 0.0001;\nfloat NDF = DoubleDistributeGGX(N, H, roughness);\n```\n\n[2013SiggraphPresentationsNotes-26915738.pdf (unrealengine.com): Specular D](https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf)\n\n#### **Generalized-Trowbridge-Reitz（GTR）分布**\n\nGTR分布不具备形状不变性（shape-invariant），导致其发布以来，无法被广泛使用。\n\n$$D_{GTR}(m)=\\frac{c}{(1+(n\\cdot m)^2(\\alpha^2-1))^\\gamma}$$\n\n- 关于形状不变性的好处，可以总结为：\n  - 方便推导出该NDF归一化的各向异性版本\n  - 方便推导出遮蔽阴影项 Smith G\n  - 方便基于NDF或可见法线分布推导其重要性采样\n    - 对于Smith G，可用低维函数或表格处理所有粗糙度和各向异性\n\n#### **参考**\n\n[【基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/69380665):关于形状不变性。\n\n### **F(Fresnel Equation)**\n\n$$F_{Schlick}(h,v,F_0)=F_0+(1-F_0)(1-(h,v))^5$$\n\nF_0 表示的基础反射率，利用折射指数(Indices Of Refraction)求得，F_0 越大菲涅尔反射现象越强。\n\n当越是向掠射角(又名切线角，和正視角相差90度)方向去看，菲涅尔现象越强，反光效果越明显。\n\n![fresnel](/imgs/LearnPBR/fresnel.png)\n\n**Fresnel-Schlick**只适用于绝缘体的表面算法。 金属表面需要其他的菲涅尔方程模拟。但是这样做很不方便，所以： 预计算出平面对法线入射的结果(F0)，基于观察角的Fresnel-Schlick近似对这个值进行插值，用这种方法进一步估算。 这样就可以使用同一个公式了。\n\n平面对于法向入射的响应或者说基础反射率可以在一些大型数据库中找到，比如[RefractiveIndex](http://refractiveindex.info/)。\n\n所有电介质材质表面的基础反射率都不会高于0.17，这其实是例外而非普遍情况。导体材质表面的基础反射率起点更高一些并且（大多）在0.5和1.0之间变化。此外，对于导体或者金属表面而言基础反射率一般是带有色彩的，这也是为什么F0要用RGB三原色来表示的原因（法向入射的反射率可随波长不同而不同）。这种现象我们**只能**在金属表面观察的到。\n\n![chart3](/imgs/LearnPBR/chart3.png)\n\n由于绝缘体和金属体存在多种的差异，其各自独有的特性引出了金属工作流，我们使用一个金属度调节材质表面特性，这个参数并非 非零即一 的布尔值，是因为我们要描述一些比如沙子、颗粒和被刮蹭后的金属表面，所以要有一个[0,1]的范围进行调整。\n\n我们通过预计算金属和绝缘体的 F_0 进行 Fresnel-Schlick 近似，但是对于金属表面通常这样做\n\n```OpenGL\nvec3 F0 = vec3(0.04,0.04,0.04);\nF0 = mix(F0, surfaceColor.rgb, metalness);\n```\n\n我们为大多数电介质表面定义了一个近似的基础反射率。F_0取最常见的电解质表面的平均值，这又是一个近似值。不过对于大多数电介质表面而言使用0.04作为基础反射率已经足够好了，而且可以在不需要输入额外表面参数的情况下得到物理可信的结果。然后，基于金属表面特性，我们要么使用电介质的基础反射率要么就使用F_0来作为表面颜色。因为金属表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用表面颜色纹理来作为它们的基础反射率。\n\n```OpenGL\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// cosTheta = dot(N,V)\n```\n\n这里的N是收到粗糙度影响的半角向量，在后面计算IBL时，因为预计算没办法考虑粗糙度，所以我们需要一个受粗糙度影响的 fresnelSchlick\n\n```OpenGL\nvec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n```\n\n关于金属和绝缘体的菲涅尔，在 PBRT 中有提到，8.2.1 Fresnel Reflection： [Specular Reflection and Transmission (pbr-book.org)](https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission)\n\n> 1. The first class is *dielectrics*, which are materials that don’t conduct electricity. They have real-valued indices of refraction (usually in the range 1-3) and transmit† a portion of the incident illumination. Examples of dielectrics are glass, mineral oil, water, and air.\n> 2. The second class consists of *conductors* such as metals. Valence electrons can freely move within the their atomic lattice, allowing electric currents to flow from one place to another. This fundamental atomic property translates into a profoundly different behavior when a conductor is subjected to electromagnetic radiation such as visible light: the material is opaque and reflects back a significant portion of the illumination. A portion of the light is also transmitted into the interior of the conductor, where it is rapidly absorbed: total absorption typically occurs within the top 0.1 μm of the material, hence only extremely thin metal films are capable of transmitting appreciable amounts of light. We ignore this effect in `pbrt` and only model the reflection component of conductors. In contrast to dielectrics, conductors have a complex-valued index of refraction n=n0+ik.\n> 3. Semiconductors such as silicon or germanium are the third class though we will not consider them in this book.\n> 4. The first class is dielectrics, which are materials that don't conduct electricity. They have real-valued indices of refraction (usually in the range 1-3) and transmitt a portion of the incident illumination. Examples of dielectrics are glass, mineral oil, water, and air.\n> 5. The second class consists of conductors such as metals. Valence electrons can freely move within the their atomic lattice, allowing electric currents to flow from one place to another. This fundamental atomic property translates into a profoundly different behavior when a conductor is subjected to electromagnetic radiation such as visible light: the material is opaque and reflects back a significant portion of the illumination. A portion of the light is also transmitted into the interior of the conductor, where it is rapidly absorbed: total absorption typically occurs within the top 0.1 um of the material, hence only extremely thin metal films are capable of transmitting appreciable amounts of light. We ignore this effect in pbrt and only model the reflection component of conductors. In contrast to dielectrics, conductors have a complex-valued index of refraction = n + ik.\n> 6. Semiconductors such as silicon or germanium are the third class though we will not consider them in this book.\n>\n>   第一类是介电材料，这是一种不导电的材料。它们具有实值折射率(通常在1-3范围内)，并透射一部分入射光。电介质的例子有玻璃、矿物油、水和空气。\n>\n>   第二类由金属等导体组成。价电子可以在其原子晶格内自由移动，从而使电流从一个地方流向另一个地方。当导体受到电磁辐射(如可见光)时，这种基本的原子性质会转化为一种截然不同的行为:这种材料是不透明的，会反射回相当一部分照明。一部分光也被传输到导体的内部，在那里它被迅速吸收:完全吸收通常发生在材料的顶部0.1微米内，因此只有极薄的金属薄膜才能传输相当数量的光。我们在pbrt中忽略了这种影响，只对导体的反射成分进行了建模。与电介质相比，导体具有复值折射率= n + ik。\n>\n>   硅或锗等半导体是第三类，但我们在本书中不考虑它们。\n\n### **G(Geometry Function)**\n\n几何遮蔽模拟微表面的互相遮挡导致光线能量丢失或减少的现象。\n\n类似 NDF，也使用 Roughness 作为输入，粗糙度越高意味着几何遮蔽的概率越大。 几何遮蔽有 GGX 和 Schlick-Beckmann 组合而成的模拟函数 **Schlick-GGX**：\n\n$$G_{SchlickGGX}(n,v,k)=\\frac{n\\cdot v}{(n\\cdot v)(1-k)+k}$$\n\n![G](/imgs/LearnPBR/G.png)\n\n这里的 k 由粗糙度 α 计算得来，用于直接光照和 IBL 光照的几何函数参数:\n\n$$k_{direct}=\\frac{(\\alpha+1)^2}{8}\\\\ k_{IBL}=\\frac{\\alpha^2}{2}$$\n\n这里的 α 取决于我们怎么从粗糙度转换。\n\n为了更好的模拟，我们可以同时考虑两个视角，视线方向(几何遮蔽)和光线方向(几何阴影) 几何遮蔽类似“看不到”，几何阴影类似“照不到”。 使用 **Smith** 函数将其放在一起:\n\n$$G(n,v,l,k)=G_{sub}(n,v,k)G_{sub}(n,l,k)$$\n\n```OpenGL\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom = NdotV;\n    float denom =  NdotV * (1 - k) + k;\n    return nom / denom;\n}\n\nfloat GeometeySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float Gsub = GeometrySchlickGGX(saturate(dot(N,V)), k);\n    float Gsub2 = GeometrySchlickGGX(saturate(dot(N,L)), k);\n    return Gsub * Gsub2;\n}\n```\n\n### **Kulla-Conty Approximation**\n\n由于几何遮蔽造成能量损失，使得粗糙度较大时物体表面较暗，但实际上光线在表面经过多次弹射后不会被遮挡，可以反射出去(不考虑热能损失)。BRDF 只是考虑一次反射罢了。\n\n所以使用经验模型去补全损失的能量，首先要知道有多少能量损失了。\n\n$$E(\\mu_o)=\\int_0^{2\\pi}\\int_0^1f_r(\\mu_o,\\mu_i,\\phi)u_i\\,\\mathrm{d}\\mu_i\\,\\mathrm{d}\\phi\\\\ u=\\sin\\theta$$\n\n- Key idea\n  - 损失的能量就是 1 - E(\\mu_o)，不过E(\\mu_o)是和观察方向相关的。 我要做的就是补上这部分能量，能量加起来就是1了啊。\n  - E(\\mu_0)是和观察方向相关的。\n  - 要补一种多次散射的BRDF结果，也就是用一个模型去模拟多次反射的计算结果，而且因为 BRDF 具有对称性，有1 - E(\\mu_o)那么应该也有一项1 - E(\\mu_i)，因为我们的这个经验式子是模拟一个多级的基于 BRDF 的反射，然后补上一个归一化的参数c，得到这样的结果： c(1-E(\\mu_i))(1 - E(\\mu_o)) 这么设计只是为了简单……\n  -  $$c=\\frac{1}{\\pi(1-E_{avg})}\\\\ E_{avg}=2\\int_0^1E(\\mu)\\mu\\,\\mathrm{d}\\mu\\\\ f_{ms}(\\mu_o,\\mu_i)=\\frac{(1-E(\\mu_i))(1 - E(\\mu_o))}{\\pi(1-E_{avg})}$$\n  - \n- 但E_{avg}还是不知道的，这个可以预计算。\n  - Precompute / tabulate\n  -  $$E_{avg}(\\mu_o)=2\\int_0^1E(\\mu_i)\\mu_i\\,\\mathrm{d}\\mu_i\\\\$$\n  - $$E_{avg}$$和$$\\mu_o$$, 以及 BRDF(或者说roughness) 相关 这个预计算的结果会根据 brdf 的不同而改变。\n\n![Kulla-Conty](/imgs/LearnPBR/Kulla-Conty.png)\n\n- 如果物体有颜色，就会有能量损失，这样积分一开始就不会是1. 我们先计算 没有颜色损失的 正确结果，最后计算时再考虑由于颜色引起的损失。\n- Define the average Fresnel 不管入射角多大，每次反射平均反射掉多少能量\n\n$$F_{avg}=\\frac{\\int_0^1F(\\mu)\\mu\\,\\mathrm{d}\\mu}{\\int_0^1\\mu\\,\\mathrm{d}\\mu}=2\\int_0^1F(\\mu)\\mu\\,\\mathrm{d}\\mu$$\n\n- $$E_{avg}$$ 表示有多少能量我们可以看到，这些能量不会发生多次的反射。 NOT participate in further bounces\n- 所以最后的 能量/颜色 \n  - 能够直接看到的 $$F_{avg}E_{avg}$$ \n  - 光反射一次被看到：$$F_{avg}(1-E_{avg})\\cdot F_{avg}E_{avg}$$  $$F_{avg}(1-E_{avg})$$是反射后(F)未能从物体表面反射出去的能量(1-E)， $$F_{avg}(1-E_{avg})\\underline{F_{avg}}$$ 未能出去的能量发生第二次 $$F_{avg}(1-E_{avg})\\cdot F_{avg}\\underline{E_{avg}}$$ 发生反射后有多少能量被看到\n  - 反射k次：F_{avg}^k(1-E_{avg})^k\\cdot F_{avg}E_{avg}\n  - 累加得到 color term：\n  -  $$\\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}$$\n  - 最后将 color term directly multiplied on the uncolored **additional BRDF**\n\n### **Cook-Torrance 反射方程**\n\n$$L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} + k_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n#### 直接光 + 附加光\n\n![output2](/imgs/LearnPBR/output2.PNG)\n\n## **IBL**\n\n### **Diffuse Irradiance**\n\nImaged base lighting, IBL 是一类光照技术的集合，若光源不是可分解的直接光源，比如可以用辐射度量学计算的的点光源方向光等等，**而是将周围环境整体视为一个大光源**。IBL( 取自现实世界或者在3D场景生成) 环境立方体贴图(cubemap)，我们可以将立方体贴图的每个像素视为光源，在渲染方程中直接使用，这样可以有效的捕获环境的全局光照和氛围，使物体更好的融入环境。 由于基于图像的光照算法会捕捉部分甚至全部的环境光照，通常认为它是一种更精确的环境光照输入格式，甚至也可以说是一种全局光照的粗略近似。基于此特性，IBL 对 PBR 很有意义，因为当我们将环境光纳入计算之后，物体在物理方面看起来会更加准确。\n\n$$L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} + k_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n对于反射方程的求解主要是在半球上对所有入射光方向 w_i 的积分。 直接光照的话，我们事先知道对积分有贡献的、若干精准的光线方向，但是来自环境的**每个**方向w_i都有可能具有一定的 Radiance，这就很麻烦了。 我们需要：\n\n- 对给定任何方向w_i，能获取到该方向的场景 Radiance。\n- 积分需要快，因为是实时渲染。\n\n第一个思路就是用 环境立方体贴图，每个纹素都视为一个光源，使用一个w_i采样即可。\n\n为了更高效的解决积分，我们需要对其中大部分结果做预处理，再来看反射方程:\n\n$$L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} + k_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i\\\\ Because\\;diffuse\\;k_d\\;and\\;specular\\;are\\;independent\\;for\\;each\\;other.\\\\ We\\;can\\;break\\;up.\\\\ L_0(p,w_0)=\\int_{\\Omega}k_d\\frac{c}{\\pi}L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i + \\int_{\\Omega}k_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)}L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n先来研究 diffuse，将常数提出，能得到只依赖于w_i的积分，我们就可以计算或预计算一个新的立方体贴图，它在每个采样方向——也就是纹素——中存储漫反射积分的结果，这些结果是通过卷积计算出来的。\n\n$$L_0(p,w_0)=k_d\\frac{c}{\\pi}\\int_{\\Omega}L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n卷积的特性是，对数据集中的一个条目做一些计算时，要考虑到数据集中的所有其他条目。这里的数据集就是场景的辐射度或环境贴图。因此，要对立方体贴图中的每个采样方向做计算，我们都会考虑半球 \\Omega 上的所有其他采样方向。\n\n为了对环境贴图进行卷积，我们通过对半球 \\Omega上的大量方向进行离散采样并对其辐射度取平均值，来计算每个输出采样方向 w_0的积分。用来采样方向 w_i 的半球，要面向卷积的输出采样方向 w_0 。\n\n![ibl1](/imgs/LearnPBR/ibl1.png)\n\n是不是看不懂，看不懂就对了，因为应该是这样的！\n\n![ibl2](/imgs/LearnPBR/ibl2.png)\n\n该预计算的立方体贴图在每个采样方向 w_0(n)上存储结果，也就是场景中所有能够击中表面朝向为w_0(n)的间接漫反射光的预计算和。\n\n辐射方程也依赖了位置 p ，不过这里我们假设它位于辐照度图的中心。这就意味着所有漫反射间接光只能来自同一个环境贴图，这样可能会破坏现实感（特别是在室内）。渲染引擎通过在场景中放置多个反射探针来解决此问题，每个反射探针单独预计算其周围环境的辐照度图。这样，位置 p 处的辐照度（以及辐射度）是取离其最近的反射探针之间的辐照度（辐射度）内插值\n\n关于在半球的积分，可以将立体角 soiled angle 展开\n\n$$L_0(p,w_0)= k_d\\frac{c}{\\pi} \\int_{\\phi=0}^{2\\pi}\\int_{\\theta=0}^{\\frac{1}{2}\\pi} L_i(p,\\phi_i,\\theta_i) \\cos\\theta\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi\\\\  Here\\;\\cos\\theta\\sin\\theta,\\;\\sin\\theta\\;for\\;soiled\\;angle,\\;\\cos\\theta\\;for\\;\\overrightarrow{up}:w_i\\cdot n\\\\  L_0(p,w_0)=k_d\\frac{c}{\\pi} \\frac{1}{n_1n_2}\\sum\\limits^{n_1}_{\\phi=0}\\sum\\limits^{n_2}_{\\theta=0} L_i(p,\\phi_i,\\theta_i) \\cos\\theta\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$$\n\n### **实现**\n\nRoughness in [0,1]->[0,5]\n\n做五级的skybox，存在cubemap tex内\n\n#### **参考**\n\n[漫反射辐照 - LearnOpenGL CN (learnopengl-cn.github.io)](https://learnopengl-cn.github.io/07 PBR/03 IBL/01 Diffuse irradiance/) [codinglabs.net/article_physically_based_rendering.aspx](http://www.codinglabs.net/article_physically_based_rendering.aspx)\n\n### **Specular IBL**\n\n#### **The Split Sum: 1st Stage**\n\n现在来看镜面反射部分，反射方程为：\n\n$$L_0(p,w_0)=\\int\\limits_\\Omega(k_d\\frac{c}{\\pi}+k_s\\frac{DFG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n这下坏了，因为 ks 是受入射光还有视角影响的。如果进行实时计算，视线和光线的组合数极其庞大，这样的开销是很昂贵的。 Epic Games 提出了一个解决方案，他们预计算镜面部分的卷积，为实时计算作了一些妥协，这种方案被称为分割求和近似法（**split sum approximation**）。 分割求和近似将方程的镜面部分分割成两个独立的部分，我们可以单独求卷积，然后在 PBR 着色器中求和，以用于间接镜面反射部分 IBL。分割求和近似法类似于我们之前求辐照图预卷积的方法，需要 HDR 环境贴图作为其卷积输入。为了理解，我们回顾一下反射方程，但这次只关注镜面反射部分：\n\n$$L_0(p,w_0)=\\int\\limits_\\Omega(k_s\\frac{DFG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i\\\\ =\\int\\limits_\\Omega f_r(p,w_i,w_0)L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n我们依然想计算出一个类似镜面 IBL 贴图的东西，然后使用pixel的法线采样，但是问题在于，辐照度图只依赖于 w_i，但是这次积分还依赖于 BRDF\n\n$$f_r(p,w_i,w_0)=\\frac{DFG}{4(w_0\\cdot n)(w_i\\cdot n)}$$\n\nBRDF内还有w_0，更不可能要用入射和出射光的组合了，那计算肯定爆掉了。\n\n$$\\int_{\\Omega}f(x)g(x)\\,\\mathrm{d}x\\approx\\frac{\\int_{\\Omega_G}f(x)\\,\\mathrm{d}x}{\\int_{\\Omega_G}\\,\\mathrm{d}x}\\cdot\\int_{\\Omega}g(x)\\,\\mathrm{d}x$$\n\n所以 E宝先将其分为两个部分求解，再将两个部分组合计算得到预计算结果。\n\n$$L_0(p,w_0)=\\int\\limits_\\Omega L_i(p,w_i)\\,\\mathrm{d}w_i*\\int\\limits_\\Omega f_r(p,w_i,w_0)n\\cdot w_i\\,\\mathrm{d}w_i$$\n\n卷积的第一部分被称为预滤波环境贴图，它类似于辐照度图，是预先计算的环境卷积贴图，但这次考虑了粗糙度。因为随着粗糙度的增加，参与环境贴图卷积的采样向量会更分散，导致反射更模糊，所以对于卷积的每个粗糙度级别，我们将按顺序把模糊后的结果存储在预滤波贴图的 mipmap 中。例如，预过滤的环境贴图在其 5 个 mipmap 级别中存储 5 个不同粗糙度值的预卷积结果，如下图所示：\n\n![IBLCubemap](/imgs/LearnPBR/IBLCubemap.png)\n\n为什么是不同粗糙度的图呢？这是因为对于不同的粗糙度，我们镜面反射是不同的，当表面越粗糙镜面反射越松散，我们观测的光照结果会越分散在更广的范围，而越光滑，反射范围越小越集中，视觉上也就是越清晰的。\n\n![iblAlpha](/imgs/LearnPBR/iblAlpha.png)\n\n从上图我们可以看到我们对r方向采样，实际上是对cubemap的一个橙色的 fliter 进行采样的，当越粗糙时这个 filter 越大。\n\n为什么两部分分开了还要前面项会受到 BRDF 影响，因为我们的采样方向其实就是会受到 BRDF 的影响的。\n\n![boban](/imgs/LearnPBR/boban.jpg)\n\n我们对cubemap的采样范围或者说采样的样本实际就是图中所示的波瓣，而根据 brdf 定义可知：\n\n$$R=reflection(w_o,n)，w_o就是\\overrightarrow{view}。$$\n\n**假设不同方向入射，波瓣变化不大**，我们可以得到:\n\n$$f(w_o,w_i(n),n)\\approx f(R,w_i(R),R)，也就是 N=V=R。$$ f(w_o,w_i(n),n)\\approx f(R,w_i(R),R)，也就是 N=V=R。\n\n![poban](/imgs/LearnPBR/poban.jpg)\n\n我们使用 Cook-Torrance BRDF 的法线分布函数(NDF)生成采样向量及其散射强度，该函数将法线和视角方向作为输入。由于我们在卷积环境贴图时事先不知道视角方向，因此 Epic Games 假设视角方向——也就是镜面反射方向——总是等于输出采样方向ωo，以作进一步近似。翻译成代码如下：\n\nvec3 N = normalize(w_o);\n\nvec3 R = N;\n\nvec3 V = R;\n\n但是这样的假设会导致在掠射角处失去各向异性，因为菲涅尔现象会导致不同w_o的反射方向或者反射现象是不一样的，所以基于波瓣不变的假设所做的结果必然会有缺失。\n\nMoving Frostbite to Physically Based Rendering 3.0-4.9.2 Light probe filtering\n\nTo simplify this evaluation, we can pre-integrate the integral by making some approximations. Pre-integrating this equation for every v and Θ would require a huge memory footprint. Thus, a first approximation is to remove the view dependency. This leads to a coarse approximation of the BRDF but it is an acceptable trade-off: the shape of a BRDF based on the micro-facets framework and/or half-angle parametrization is strongly dependent on the view angle as shown on Figure 54. At normal incident direction, the shape of a BRDF is isotropic. At grazing angles the shape of a BRDF is anisotropic. Removing the view dependency for pre-integrating Equation 46 would make the assumption that the BRDF shape is isotropic at all view angles. This leads to key visual differences, preventing stretched reflections. This approximation can be quite noticeable on flat surfaces as shown on Figure 55 but less on curvy surfaces38\n\n![ueReference](/imgs/LearnPBR/ueReference.png)\n\n#### **The Split Sum: 2nd Stage**\n\n$$Lo(p,w_o)\\approx\\frac{\\int_{\\Omega_{fr}}L_i(p,w_i)\\,\\mathrm{d}w_i}{\\int_{\\Omega_{fr}}\\,\\mathrm{d}w_i}\\cdot\\underline{\\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i}$$\n\n这部分计算和 F_0,\\alpha,\\theta相关，但是3D贴图太大了！！！\n\n菲涅项其实比较好拆，我们可以对这部分做一些处理\n\n$$R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\ R_0-R_0(1-\\cos\\theta)^5+(1-\\cos\\theta)^5\\\\ \\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i\\approx\\\\ R_0\\int_{\\Omega^+}\\frac{f_r}{F}(1-(1-\\cos\\theta)^5)\\cos\\theta_i\\,\\mathrm{d}w_i+\\int_{\\Omega^+}\\frac{f_r}{F}(1-\\cos\\theta)^5\\cos\\theta_i\\,\\mathrm{d}w_i$$\n\n![uecode1](/imgs/LearnPBR/uecode1.png)\n\n### **The Split Sum: 1st Stage Sample**\n\n在上一节教程中，我们使用球面坐标生成均匀分布在半球 $$\\Omega$$ 上的采样向量，以对环境贴图进行卷积。虽然这个方法非常适用于辐照度，但对于镜面反射效果较差。镜面反射依赖于表面的粗糙度，反射光线可能比较松散，也可能比较紧密，但是一定会围绕着反射向量r，除非表面极度粗糙：\n\n![sample](/imgs/LearnPBR/sample.png)\n\n所有可能出射的反射光构成的形状称为镜面波瓣。随着粗糙度的增加，镜面波瓣的大小增加；随着入射光方向不同，形状会发生变化。因此，镜面波瓣的形状高度依赖于材质。 在微表面模型里给定入射光方向，则镜面波瓣指向微平面的半向量的反射方向。考虑到大多数光线最终会反射到一个基于半向量的镜面波瓣内，采样时以类似的方式选取采样向量是有意义的，因为大部分其余的向量都被浪费掉了，这个过程称为重要性采样。\n\nF = FresnelSchlickFunction(F0, max(0.0, dot(N, H)), roughness);\n\nfloat3 spe_ibl = SAMPLE_TEXTURE2D_LOD(_MySplit1st, sampler_MySplit1st, float2(uv.xy), _Roughness * 4.0);\n\ncol += spe_ibl * (F * brdf.x + brdf.y)+ ev_diffuse*albedo;\n\n![uecode2](/imgs/LearnPBR/uecode2.png)\n\n### **蒙特卡洛(Monte Carlo)积分和重要性采样(Importance Sampling)**\n\n[蒙特卡洛积分 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/146144853)\n\n有了蒙特卡洛，那么如何对半球面上的进行采样。\n\n### **低差异序列**\n\nHammersley 序列\n\n```OpenGL\nfloat RadicalInverse_VdC(uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nfloat2 Hammersley(uint i, uint N)\n{\n    return float2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n```\n\n[看懂蒙特卡洛积分(三) 低差异采样序列](https://zhuanlan.zhihu.com/p/343666731) [低差异序列（一）- 常见序列的定义及性质 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/20197323) [低差异序列（二）- 高效实现以及应用 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/20374706)\n\n#### **GGX 重要性采样**\n\n```OpenGL\nfloat3 ImportanceSampleGGX(float2 Xi, float3 N, float roughness)\n{\n    // use roughness for better view\n    float alpha2 = roughness * roughness;\n\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt( (1.0 - Xi.y) / (1.0 + ( alpha2 * alpha2 - 1.0) * Xi.y));\n    float sinTheta = sqrt(1 - cosTheta * cosTheta);\n\n    float3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\n    float3 up = abs(N.z) < 0.999 ? float3(0.0, 0.0, 1.0) : float3(1.0, 0.0, 0.0);\n    float3 tangent = normalize(cross(up,N));\n    float3 biTangent = normalize(cross(N, tangent));\n\n    float3 sampleVec = tangent * H.x + biTangent * H.y + N * H.z;\n    return normalize(sampleVec);\n}\n```\n\n### The Split Sum\n\n```OpenGL\n// 1st\nvoid PrefilteredColor(float3 dir, uint3 id)\n{\n    float3 N = normalize(dir);\n    float3 R = N;\n    float3 V = R;\n\n    const uint SAMPLE_COUNT = 1024;\n    float totalWeight[5] = {0.0, 0.0, 0.0, 0.0, 0.0};\n    float3 preColor[5] = { float3(0.0,0.0,0.0), float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0)};\n    for(uint i = 0; i < SAMPLE_COUNT; ++i)\n    {\n        float2 Xi = Hammersley(i, SAMPLE_COUNT);\n        float3 H[5];\n        float3 L[5];\n        float NdotL[5];\n        for(uint a = 0; a < 5; a++)\n        {\n            H[a] = ImportanceSampleGGX(Xi, N, (float)a*2.0/10.0);\n            L[a] = normalize(2.0 * dot(V, H[a]) * H[a] - V);\n            NdotL[a] = max(0.0,dot(N,L[a]));\n            if(NdotL[a] > 0.0)\n            {\n                float D = DistributeGGX(N, H[a], (float)a/5.0);\n                float NdotH = max(0.0, dot(N, H[a]));\n                float HdotV = max(0.0, dot(H[a], V));\n                float pdf = D * NdotH / (4.0 * HdotV) + 0.0001;\n\n                float res = 512.0;\n                float saTexel = 4.0 * PI / (6.0 * res * res);\n                float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n                float roughness = (float)a / 5.0;\n                float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n                \n                preColor[a] += _SkyBoxTex.SampleLevel(LinearClampSampler, L[a], mipLevel).xyz * NdotL[a];\n                totalWeight[a] += NdotL[a];\n            }\n        }         \n    }\n    int powLog = 1;\n    for(uint b = 0; b < 5; b++)\n    {    \n        preColor[b] = preColor[b] / totalWeight[b];\n        _SplitSum1stMip[b][id.xy/powLog] = float4(preColor[b],1);\n        powLog *= 2;\n    }\n}\n\n// 2nd\nfloat2 IntegrateBRDF(float NdotV, float roughness)\n{\n    float3 V;\n    V.x = sqrt(1 - NdotV * NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    float3 N = float3(0.0, 0.0, 1.0);\n\n    int sampleCount = 1024;\n    for(int i = 0; i < sampleCount; ++i)\n    {\n        float2 Xi = Hammersley(i, sampleCount);\n        float3 H = ImportanceSampleGGX(Xi, N, roughness);       // D. NDF\n        float3 L = normalize(2.0 * dot(V,H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(0.0, dot(V, H));\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness * roughness / 2.0);      // G\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);    \n            float Fc = pow(1 - VdotH, 5.0);\n            \n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(sampleCount);\n    B /= float(sampleCount);\n    return float2(A, B);\n}\n```\n\n### **反射探针**\n\n在unity中添加 probe 然后 baked\n\n使用 sampleSH 对 probe 进行采样\n\n### Environment Diffuse + IBL Specular\n\n![output3](/imgs/LearnPBR/output3.PNG)\n\n中间是粗糙度越来越小 下面是金属度越来越大\n\n### **IBL 参考**\n\n[Image Based Lighting | Chetan Jags (wordpress.com)](https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/) [course_notes_moving_frostbite_to_pbr_v32.pdf (wordpress.com)](https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf):4.9章节 [镜面IBL - LearnOpenGL CN (learnopengl-cn.github.io)](https://learnopengl-cn.github.io/07 PBR/03 IBL/02 Specular IBL/) [深入理解 PBR/基于图像照明 (IBL) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/66518450) [Lecture5 Real-time Environment Mapping哔哩哔哩bilibili](https://www.bilibili.com/video/BV1YK4y1T7yY?p=5&vd_source=1fa1b82383f6efb8a2632316da9afad0): Split Sum\n\n## **杂项**\n\n- ComputeShader 使用 cubetex：[[Compute shader\\] Use TextureCube(Resolved)](https://forum.unity.com/threads/compute-shader-use-texturecube-resolved.628891/)\n- TextureCube<float4 cubemap; SamplerState _LinearClamp; float3 dir; cubemap.SampleLevel(_LinearClamp, dir, 0);\n- 如何向Tex指定mipmap层级写入，在 setrendertarget 指定\n- compute Shader sample\n  - `float4 c = tex[id];`\n  - mipmap: `float4 c = tex.mips[0][id]` or `tex.Load(uint3(id,0))`\n  - SampleLevel: \n  - SampleState Sampler1 {    Filter = MIN_LINEAR_MAG_MIP_POINT; }; float4 t = tex.SampleLevel(Sample1, uv, 0);\n- Sample filter [8.5 纹理采样 (enjoyphysics.cn)](https://enjoyphysics.cn/Article1554)\n\n```OpenGL\n// 在倍增、缩减、多级渐进纹理上使用线性过滤。\nSamplerState mySampler0 \n{\n    Filter = MIN_MAG_MIP_LINEAR; \n}; \n\n// 在缩减上使用线性过滤，倍增和多级渐进纹理上使用点过滤。\nSamplerState mySampler1 \n{ \n    Filter = MIN_LINEAR_MAG_MIP_POINT; \n}; \n\n// 在缩减上使用点过滤，倍增上使用线性过滤，多级渐进纹理上使用点过滤。\nSamplerState mySampler2 \n{ \n    Filter = MIN_POINT_MAG_LINEAR_MIP_POINT; \n}; \n\n// 在倍增、缩减、多级渐进纹理上使用各向异性过滤。\nSamplerState mySampler3 \n{ \n    Filter = ANISOTROPIC; \n    MaxAnisotropy = 4;\n};\n```\n\n### **Unity And Mipmap**\n\n[【渲染】用计算着色器生成Mipmap - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/419644293)\n\n### **Computer 指定 Mipmap 写入**\n\n```\ncomputeShader.SetTexture(kernal, “name”, tex, mipmapLevel);\n```\n\n### **不同光源的衰减**\n\n[投光物 - LearnOpenGL CN (learnopengl-cn.github.io)](https://learnopengl-cn.github.io/02 Lighting/05 Light casters/) [Point and Spot Lights (catlikecoding.com)](https://catlikecoding.com/unity/tutorials/custom-srp/point-and-spot-lights/)\n\n#### **Point Light**\n\n- $(\\,max(0, 1-(\\frac{d^2}{r^2})^2)\\,)^2$，r 是 point light 的范围\n- $\\frac{1.0}{K_c+K_l*d+K_q*d^2}$\n\n### **ShaderGUI**\n\n通过编写 ShaderGUI 在 Material 面板控制 shader properties\n\n或 en/dis able keyword\n\n```OpenGL\npublic class MyShaderGUI : ShaderGUI\n{\n    public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties)\n    {\n        base.OnGUI(materialEditor, properties);\n        Material material = materialEditor.target as Material;\n    }\n}\n```\n\n在 Shader 结尾加上\n\nCustomEditor \"MyLearnPBRGUI\";\n\n## **URP 光**\n\n[Light 组件参考 | Universal RP | 12.1.1 (unity3d.com)](https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/light-component.html) [光照模式 - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/current/Manual/LightModes.html) [光源模式：Baked - Unity 手册 (unity3d.com)](https://docs.unity3d.com/cn/current/Manual/LightMode-Baked.html)\n\n### **Lighting**\n\n- Scene/Mixed Lighting/Lighting Mode\n  - **Baked Indirect**: [Lighting Mode：Baked Indirect - Unity 手册](https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-BakedIndirect.html) 混合光源的行为类似于[实时光源](https://docs.unity.cn/cn/2022.3/Manual/LightMode-Realtime.html)，但有额外的好处是会**将间接光照烘焙到光照贴图中**。**混合(Mixed)光源照亮的游戏对象会投射实时阴影**，最大距离是在项目中定义的[阴影距离 (Shadow Distance)](https://docs.unity.cn/cn/2022.3/Manual/shadow-distance.html)。\n  - **Shadow Mask**: [Lighting Mode：Shadowmask - Unity 手册](https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Shadowmask.html) 与烘焙间接照明模式类似，阴影遮罩照明模式将**实时直接照明**与**[烘焙间接照明](https://docs.unity.cn/cn/2022.3/Manual/LightMode-Baked.html)****(Baked Indirect Lighting Mode)**相结合。但是，“阴影蒙版”照明模式与烘焙间接照明模式的不同之处在于它渲染阴影的方式。阴影蒙版光照模式使 Unity 可以在运行时组合烘焙阴影和实时阴影，并在远处渲染阴影。它通过使用称为阴影蒙版的附加光照贴图纹理，并在[光照探针](https://docs.unity.cn/cn/2022.3/Manual/LightProbes.html)中存储其他信息来实现此目的。Unity 为烘焙阴影生成阴影蒙版和 Light Probe 遮挡数据。\n  - **Subtractive**: [Lighting Mode：Subtractive - Unity 手册](https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Subtractive.html) 在 Subtractive 光照模式下，场景中的所有混合光源都提供烘焙直接光照和间接光照。Unity 将静态游戏对象投射的阴影烘焙到光照贴图中。除了烘焙阴影外，一种方向光（称为主方向光）还为动态游戏对象提供实时阴影。 因为阴影被烘焙到光照贴图中，所以 Unity 在运行时缺少将烘焙阴影和实时阴影准确地结合在一起所需的信息。但是，Unity 提供了 **Realtime Shadow Color** 属性来减少光照贴图的影响，从而在烘焙阴影和实时阴影之间创建正确的混合视觉效果。还可以调整颜色来实现某种艺术风格。 Subtractive 光照模式在低端硬件上非常有用，因为低端硬件需要注重性能，并且只需要一个实时阴影投射光源。这种光照模式不会提供特别逼真的光照效果，而是更适合风格化美学，例如卡通风格。\n\n## **Isotropic / Anisotropic BRDFs**\n\n$$f_r(\\theta_i,\\phi_i;\\theta_r,\\phi_r)\\ne f_r(\\theta_i,\\phi_i,\\phi_r-\\phi_i)\\\\ i\\;is\\;input,\\;r\\;is\\;reflection\\;dir.$$\n\n### **NDF**\n\n**形状不变性**\n\n- 是一个合格的法线分布函数需要具备的重要性质。具有形状不变性（shape-invariant）的法线分布函数，可以用于推导该函数的归一化的各向异性版本，并且可以很方便地推导出对应的遮蔽阴影项G。\n- 若一个各向同性的NDF可以改写成以下形式，则这个NDF具有形状不变性（shape-invariant）：\n- $$D(m)=\\frac{1}{\\alpha_2(n\\cdot m)^4}g(\\frac{\\sqrt{1-(n\\cdot m)^2}}{\\alpha(n\\cdot m)})$$\n\n- 其中g（）代表一个表示了NDF形状的一维函数。\n\n#### **Anisotropic Beckmann Distribution**\n\n$$D_{Baniso}(m)=\\frac{1}{\\pi\\alpha_x\\alpha_y(n\\cdot m)^4}exp(-\\frac{\\frac{(t\\cdot m)^2}{\\alpha_x^2}+\\frac{(b\\cdot m)^2}{\\alpha_y^2}}{(n\\cdot m)^2})$$\n\n```OpenGL\n// Anisotropic Beckmann\nfloat D_Beckmann_aniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )\n{\n    float XoH = dot( X, H );\n    float YoH = dot( Y, H );\n    float d = - (XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay)) / NoHNoH;\n*    return exp(d) / ( PI * ax*ay * NoH * NoH * NoH * NoH );\n}\n```\n\n#### **Trowbridge-Reitz GGX Anisotropic**\n\n$$D_{GGXaniso}(m)=\\frac{1}{\\pi\\alpha_x\\alpha_y}\\frac{1}{(\\frac{(x\\cdot m)^2}{\\alpha_x^2}+\\frac{(y\\cdot m)^2}{\\alpha_y^2}+(n\\cdot m))^2}$$\n\n```OpenGL\n// Anisotropic GGX\n// [Burley 2012, \"Physically-Based Shading at Disney\"]\nfloat D_GGXaniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )\n{\n    float XoH = dot( X, H );\n    float YoH = dot( Y, H );\n    float d = XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay) + NoHNoH;\n*    return 1 / ( PI * ax*ay * d*d );\n}\n```\n\n- 其中，X为tangent，t切线方向，Y为binormal，b，副法线方向\n- 需要注意的是，将法线贴图与各向异性BRDF组合时，重要的是要确保法线贴图扰动（perturbs）切线和副切线矢量以及法线\n\n[2010-anisobrdf.pdf (cuni.cz)](https://cgg.mff.cuni.cz/~jaroslav/papers/2010-anisobrdf/2010-anisobrdf.pdf) [Slope: GGX Anisotropic (shadertoy.com)](https://www.shadertoy.com/view/3tyXRt)\n\n### **Geometry Function**\n\n$$G_1(m,v)=\\frac{clamp(0,1,m\\cdot v)}{1+\\Lambda(v)}$$\n\n#### **Beckmann**\n\n$$\\Lambda(v)=\\frac{erf(a)-1}{2}+\\frac{1}{2a\\sqrt{\\pi}}exp(-a^2)\\\\ a=\\frac{1}{\\alpha\\tan\\theta_o}$$\n\n#### **GGX**\n\n$$\\Lambda(v)=\\frac{-1+\\sqrt{1+\\frac{1}{a^2}}}{2}\\\\ a=\\frac{1}{\\alpha\\tan\\theta_o}$$\n\n### **Anisotropic Geometry Function**\n\n#### **Smith**\n\n假设我们拉伸x轴，将各向同性的法线分布转变为各向异性的。\n\n假设各向异性的粗糙度参数有a_x,a_y，视线v(x_o,y_o,z_o)，通过拉伸x轴\\frac{a_x}{a_y}\n\n$$a_x'=a_x\\frac{a_y}{a_x}=a_y\\\\ a_y'=a_y$$\n\n也就是粗糙度\\alpha=\\alpha_y\n\n$$v'=(\\frac{\\alpha_x}{\\alpha_y}x_o,y_o,z_o)=(\\frac{\\alpha_x}{\\alpha_y}\\cos\\phi_o\\sin\\theta_o,\\sin\\phi_o\\sin\\theta_o,\\cos\\theta_o)\\\\ \\frac{1}{\\tan\\theta'_o}=\\frac{z_o}{\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}x_o^2+y_o^2}}=\\frac{1}{\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}\\cos^2\\phi_o+\\sin^2\\phi_o}\\cdot\\tan\\theta_o}\\\\ Because:a=\\frac{1}{\\alpha\\tan\\theta_o}\\\\ a'=\\frac{1}{a_y\\tan\\theta_o}=\\frac{1}{a_y\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}\\cos^2\\phi_o+\\sin^2\\phi_o}\\cdot\\tan\\theta_o}\\\\ =\\frac{1}{\\sqrt{\\alpha_x^2\\cos^2\\phi_o+\\alpha_y^2\\sin^2\\phi_o}\\cdot\\tan\\theta_o}$$\n\n[PBR 五 几何遮蔽函数遮蔽因子函数wuhaocat的博客-CSDN博客](https://blog.csdn.net/haozi2008/article/details/112284028)\n\n[PBR-White-Paper/content/part 5/README.md at master · QianMo/PBR-White-Paper (github.com)](https://github.com/QianMo/PBR-White-Paper/blob/master/content/part 5/README.md)\n\n### **Output**\n\n<img src=\"/imgs/LearnPBR/output4-1.PNG\" alt=\"output4-1\" style=\"zoom:50%;\" />\n\n<img src=\"/imgs/LearnPBR/AnisoSphere2.png\" alt=\"AnisoSphere2\" style=\"zoom:50%;\" />\n\n### **Anisotropic IBL**\n\n#### **Split Sum 2nd**\n\n$$R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\ R_0-R_0(1-\\cos\\theta)^5+(1-\\cos\\theta)^5\\\\ \\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i\\approx\\\\ R_0\\int_{\\Omega^+}\\frac{f_r}{F}(1-(1-\\cos\\theta)^5)\\cos\\theta_i\\,\\mathrm{d}w_i+\\int_{\\Omega^+}\\frac{f_r}{F}(1-\\cos\\theta)^5\\cos\\theta_i\\,\\mathrm{d}w_i$$\n\nroughness_x, roughness_y, theta 相关3D LUT了\n\n## **[TODO]动态天空的环境光怎么计算**\n\n提前烘焙，插值。\n\nTOD\n\n像大气散射，其实已经计算了 LUT 所以可以直接使用。\n\n\n\n## Unity Specular Cube0\n\n[Graphics/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlsl at 19518485b3edcf19f267f293f899d5d25e734a17 · Unity-Technologies/Graphics (github.com)](https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlsl#L620)\n\n~~~hlsl\nhalf mip = PerceptualRoughnessToMipmapLevel(perceptualRoughness);\n    half4 encodedIrradiance = SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip);\n    half3 irradiance = DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);\n    return irradiance * occlusion;\n~~~\n\n### PerceptualRoughnessToMipmapLevel\n\n[Graphics/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl at 19518485b3edcf19f267f293f899d5d25e734a17 · Unity-Technologies/Graphics (github.com)](https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl#L27)\n\n~~~\nreal PerceptualRoughnessToMipmapLevel(real perceptualRoughness, uint maxMipLevel)\n{\n    perceptualRoughness = perceptualRoughness * (1.7 - 0.7 * perceptualRoughness);\n\n    return perceptualRoughness * maxMipLevel;\n}\n~~~\n\n\n\nSAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip);\n\n## **参考**\n\n[由浅入深学习PBR的原理和实现 - 0向往0 - 博客园 (cnblogs.com)](https://www.cnblogs.com/timlly/p/10631718.html)   \n[course_notes_moving_frostbite_to_pbr_v32.pdf (wordpress.com)](https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf)   \n[【基于物理的渲染（PBR）白皮书】（一） 开篇：PBR核心知识体系总结与概览 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/53086060)   \n[Physically Based Rendering: From Theory to Implementation (pbr-book.org)](https://www.pbr-book.org/3ed-2018/contents)  \nReal-Time Rendering Fourth Edition 第九章   \n[Lecture10 Real-Time Physically-based Materials (surface models)哔哩哔哩bilibili](https://www.bilibili.com/video/BV1YK4y1T7yY?p=10&vd_source=1fa1b82383f6efb8a2632316da9afad0)   \n[Lecture11 Real-Time Physically-based Materials (surface models cont.)哔哩哔哩bilibili](https://www.bilibili.com/video/BV1YK4y1T7yY?p=11&vd_source=1fa1b82383f6efb8a2632316da9afad0)  \nUE4: [2013SiggraphPresentationsNotes-26915738.pdf (unrealengine.com)](https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf)   \n[寒霜引擎的PBR实践3.0（一）材质篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/144611412)  \n[寒霜引擎的PBR实践3.0（二）光照篇——光照强度与精确光源 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/158261389)   \n[寒霜引擎的PBR实践3.0（三）光照篇——光度学灯与区域光 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/186541854)   \n[[译\\]Real Shading in Unreal Engine 4（UE4中的真实渲染)(1) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/121719442)  \n[使用Compute Shader计算球谐全局光照 | ZZNEWCLEAR13](https://zznewclear13.github.io/posts/calculate-spherical-harmonics-using-compute-shader/)","slug":"LearnPBR","published":1,"updated":"2024-05-05T12:40:24.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti3000lbkbwghf1bi6a","content":"<p>关于PBR的一些知识点</p>\r\n<h1 id=\"learn-pbr\">Learn PBR</h1>\r\n<h1 id=\"pbr理论\">PBR理论</h1>\r\n<h2 id=\"简介\"><strong>简介</strong></h2>\r\n<p><strong>PBR</strong>（<strong>Physically Based\r\nRendering</strong>）译成中文是基于物理的渲染。它是利用真实世界的原理和理论，通过各种数学方法推导或简化或模拟出一系列渲染方程，并依赖计算机硬件和图形API渲染出拟真画面的技术。</p>\r\n<h3 id=\"pbr-特征\"><strong>PBR</strong> <strong>特征</strong></h3>\r\n<p>更高质量的着色效果和更多复杂的材质特性。</p>\r\n<ul>\r\n<li>表面细节</li>\r\n<li>物体粗糙度</li>\r\n<li>区别明显的金属和绝缘体</li>\r\n<li>物体的浑浊程度</li>\r\n<li>菲涅尔现象：不同角度有不同强度的反射光</li>\r\n<li>半透明物体</li>\r\n<li>多层混合材质</li>\r\n<li>清漆效果</li>\r\n<li>其它更复杂的表面特征</li>\r\n</ul>\r\n<blockquote>\r\n<p>近今年，PBR的技术主要朝着更逼真、更复杂、效能更好的方向，或是结合若干种模型的综合性技术迈进。代表性技术有：</p>\r\n<ul>\r\n<li>PBR Diffuse for GGX + Smith (2017)</li>\r\n<li>MultiScattering Diffuse (2018)</li>\r\n<li>Layers Material（分层材质）</li>\r\n<li>Mixed Material（混合材质）</li>\r\n<li>Mixed BxDF（混合BxDF）</li>\r\n<li>Advanced Rendering（进阶渲染）</li>\r\n</ul>\r\n</blockquote>\r\n<h3 id=\"output\"><strong>OutPut</strong></h3>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/output.PNG\" alt=\"output\" />\r\n<figcaption aria-hidden=\"true\">output</figcaption>\r\n</figure>\r\n<h2 id=\"pbr-和-游戏引擎\"><strong>PBR</strong> <strong>和\r\n游戏引擎</strong></h2>\r\n<h3 id=\"ue4-的-pbr\"><strong>UE4 的</strong> <strong>PBR</strong></h3>\r\n<ul>\r\n<li><strong>Base Color</strong>，基础的纹理颜色\r\n非金属物体只有<strong>单色</strong>，即强度</li>\r\n</ul>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>Material</th>\r\n<th>Base Color Intensity</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>木炭(Charcoal)</td>\r\n<td>0.02</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>新沥青(Fresh asphalt)</td>\r\n<td>0.02</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>旧沥青(Worn asphalt)</td>\r\n<td>0.08</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>土壤(Bare soil)</td>\r\n<td>0.13</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>绿草(Green Grass)</td>\r\n<td>0.21</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>沙漠沙(desert sand)</td>\r\n<td>0.36</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>新混泥土(Fresh concrete)</td>\r\n<td>0.51</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>海洋冰(Ocean Ice)</td>\r\n<td>0.56</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>鲜雪(Fresh snow)</td>\r\n<td>0.81</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li><strong>金属</strong>材质，在 Linear 空间的值</li>\r\n</ul>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>材质(Material)</th>\r\n<th>基础色(BaseColor)</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>铁(Iron)</td>\r\n<td>(0.560, 0.570, 0.580)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>银(Silver)</td>\r\n<td>(0.972, 0.960, 0.915)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>铝(Aluminum)</td>\r\n<td>(0.913, 0.921, 0.925)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>金(Gold)</td>\r\n<td>(1.000, 0.766, 0.336)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>铜(Copper)</td>\r\n<td>(0.955, 0.637, 0.538)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>铬(Chromium)</td>\r\n<td>(0.550, 0.556, 0.554)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>镍(Nickel)</td>\r\n<td>(0.660, 0.609, 0.526)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>钛(Titanium)</td>\r\n<td>(0.542, 0.497, 0.449)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>钴(Cobalt)</td>\r\n<td>(0.662, 0.655, 0.634)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>铂(Platinum)</td>\r\n<td>(0.672, 0.637, 0.585)</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li><strong>粗糙度(Roughness)</strong>：表面的粗糙程度,\r\n[0,1]，越粗糙高光越弱。</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/roughness.png\" alt=\"roughness\" />\r\n<figcaption aria-hidden=\"true\">roughness</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/roughness2.png\" alt=\"roughness2\" />\r\n<figcaption aria-hidden=\"true\">roughness2</figcaption>\r\n</figure>\r\n<p>上为非金属，下为金属，粗糙度从0至1</p>\r\n<ul>\r\n<li><strong>金属度(Metallic)</strong>：表示材质像金属的程度，0是绝缘体(电介质)，1\r\n是金属，金属只有镜面反射，没有漫反射。</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/metallic.png\" alt=\"metallic\" />\r\n<figcaption aria-hidden=\"true\">metallic</figcaption>\r\n</figure>\r\n<p>金属度从0至1</p>\r\n<ul>\r\n<li><strong>镜面度(Specular)</strong>：表示物体镜面反射的强度，从0(完全没有镜面反射)到1(完全镜面反射)</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/specular.png\" alt=\"specular\" />\r\n<figcaption aria-hidden=\"true\">specular</figcaption>\r\n</figure>\r\n<p>From 0 ~ 1</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>材质(Material)</th>\r\n<th>镜面度(Specular)</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>草(Glass)</td>\r\n<td>0.5</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>塑料(Plastic)</td>\r\n<td>0.5</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>石英(Quartz)</td>\r\n<td>0.57</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>冰(Ice)</td>\r\n<td>0.224</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>水(Water)</td>\r\n<td>0.255</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>牛奶(Milk)</td>\r\n<td>0.277</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>皮肤(Skin)</td>\r\n<td>0.35</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"unity-的-pbr\"><strong>Unity 的</strong>\r\n<strong>PBR</strong></h3>\r\n<ul>\r\n<li><strong>Albedo</strong>，和 UE 的 Base Color 一样。\r\n可以用颜色或者Tex</li>\r\n<li><strong>Metallic</strong>，可以用金属贴图，但是用了 Smoothness\r\n参数就消失了</li>\r\n<li><strong>Smoothness</strong>，光滑度，和 UE 的 粗糙度正相反\r\n<ul>\r\n<li><strong>Smoothness\r\nSource</strong>，指定光滑度的存储通道，可选金属度、镜面贴图的 Alpha\r\n或基础色的 Alpha</li>\r\n</ul></li>\r\n<li><strong>Occlusion</strong>：遮蔽图，指定材质接收间接光的光照强度和反射强度。\r\n能够使物体经常是暗部的位置更暗，比如人的眼窝，脸和脖子的交接处。</li>\r\n<li><strong>Fresnel</strong>，物体边缘或者说物体法线和视线角度增大，物体的反射能力更强，Unity\r\n里面是自动处理，越光滑越强，越粗糙 Fresnel 越弱。</li>\r\n</ul>\r\n<h2 id=\"pbr-基本原理\"><strong>PBR</strong>\r\n<strong>基本原理</strong></h2>\r\n<p>满足以下条件的光照模型才能称之为PBR光照模型：</p>\r\n<ul>\r\n<li>基于微平面模型（Be based on the microfacet surface model）。</li>\r\n<li>能量守恒（Be energy conserving）。</li>\r\n<li>使用基于物理的BRDF（Use a physically based BRDF）。</li>\r\n</ul>\r\n<h3\r\nid=\"微表面理论microfacet\"><strong>微表面理论(Microfacet)</strong></h3>\r\n<p>很多 PBR 技术都是基于理论\r\n认为<strong>在微观上</strong>，所有的物体表面都是由很多的朝向不一的微小平面组成的。</p>\r\n<blockquote>\r\n<p>真实世界的物体表面其实不一定是这样的微小平面，可能会有弧度，甚至坑坑洼洼，但我们从肉眼观察、甚至<em>光栅化后的像素尺度</em>来看待的话，这种假设的结果和实际差别甚微。</p>\r\n</blockquote>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/microfacet.png\" alt=\"microfacet\" />\r\n<figcaption aria-hidden=\"true\">microfacet</figcaption>\r\n</figure>\r\n<p>基于这种假设，没有任何表面是光滑的，但由于这些微平面已经微小到逐像素无法对其进行细分，所以假设一个粗糙度\r\nRoughness，用统计学的方法去估算微表面的粗糙度。</p>\r\n<p>...</p>\r\n<h3 id=\"energy-conservation-能量守恒\"><strong>Energy Conservation\r\n(能量守恒)</strong></h3>\r\n<p>在 Microfacet\r\n中采用近似的能量守恒定律，出射光的总能量不能超过入射光的总能量(不含自发光)，</p>\r\n<p>所以材质粗糙度越大，反射的范围越大，整体的亮度会变低。</p>\r\n<h4\r\nid=\"镜面反射specular和漫反射diffuse\"><strong>镜面反射(specular)和漫反射(diffuse)</strong></h4>\r\n<p>一束光打到物体，会发生 <strong>reflection</strong> 反射 和\r\n<strong>refraction</strong>\r\n折射。反射的光直接离开，不进入物体发射了镜面反射光；折射的光进入物体内发生了吸收或散射，产生漫反射。\r\n折射后的光若没被吸收会继续前进，在物体内部发生光和微粒的碰撞，这时有一部分能力转化为热量，有些光经过多次折射从表面射出，便形成漫反射光。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/reflect.png\" alt=\"reflect\" />\r\n<figcaption aria-hidden=\"true\">reflect</figcaption>\r\n</figure>\r\n<p><em>照射在平面的光被分成镜面反射和折射光，折射光在跟物体微粒发生若干次碰撞之后，有可能发射出表面，成为漫反射。</em>\r\n通常情况下，PBR会简化折射光，将平面上所有折射光都视为被完全吸收而不会散开。而有一些被称为次表面散射(Subsurface\r\nScattering)技术的着色器技术会计算折射光散开后的模拟，它们可以显著提升一些材质（如皮肤、大理石或蜡质）的视觉效果，不过性能也会随着下降。\r\n金属(Metallic)材质会立即吸收所有折射光，故而金属只有镜面反射，而没有折射光引起的漫反射。</p>\r\n<p>根据上面的能量守恒关系，可以先计算镜面反射部分，此部分等于入射光线被反射的能量所占的百分比。而折射部分可以由镜面反射部分计算得出。</p>\r\n<p>float kS = calculateSpecularComponent(...); // 反射/镜面部分</p>\r\n<p>float kD = 1.0 - kS; // 折射/漫反射部分</p>\r\n<p>ks + kd 不会超过1，所以近似地能量守恒。</p>\r\n<h3 id=\"reflectance-equation\"><strong>Reflectance Equation</strong></h3>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int\\limits_{\\Omega}f_r(p,w_i,w_0)L_i(p,w_i)\\,\\mathrm{d}w_i\\]</span></p>\r\n<h2 id=\"辐射度量学\"><strong>辐射度量学</strong></h2>\r\n<h3 id=\"概念表\"><strong>概念表</strong></h3>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/chart1.png\" alt=\"chart1\" />\r\n<figcaption aria-hidden=\"true\">chart1</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/chart2.png\" alt=\"chart2\" />\r\n<figcaption aria-hidden=\"true\">chart2</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>微分符号 d\r\n的含义：首先来说下微分的定义：设f(x)定义在区间(a,b)上，x∈(a,b),给定自变量x的一个增量Δx，得到函数的一个增量Δy，如果有Δy=f(x+Δx)-f(x)=AΔx+o(Δx)(Δx→0)，则y=f(x)称在点x可微，函数增量的线性主部AΔx称为函数的微分，记为dy=df(x)=AΔx</p>\r\n</blockquote>\r\n<h3 id=\"辐射通量radiant-flux\"><strong>辐射通量（Radiant\r\nFlux)</strong></h3>\r\n<p>光源单位时间内的输出<span\r\nclass=\"math display\">\\[\\Phi=\\frac{\\mathrm{d}Q}{\\mathrm{d}t}\\]</span></p>\r\n<blockquote>\r\n<p>光是由多种不同波长的能量集合而成，每种波长与一种特定的（可见的）颜色相关。因此一个光源所放射出来的能量可以被视作这个光源包含的所有各种波长的一个函数。波长介于390nm（纳米）到700nm的光被认为是处于可见光光谱中，也就是说它们是人眼可见的波长。</p>\r\n</blockquote>\r\n<p>传统物理学上的辐射通量将会计算这个由不同波长构成的函数的总面积，这种计算很复杂，耗费大量性能。在PBR技术中，不直接使用波长的强度，而是使用三原色编码（RGB）来简化辐射通量的计算。虽然这种简化会带来一些信息上的损失，但是这对于视觉效果上的影响基本可以忽略。</p>\r\n<h3 id=\"radiant-insensity辐射强度\"><strong>Radiant\r\nInsensity(辐射强度)</strong></h3>\r\n<p>单位球面上，一个光源向单位立体角所投送的辐射通量。</p>\r\n<p><span\r\nclass=\"math display\">\\[I=\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}w}\\]</span></p>\r\n<p>the power per unit angle</p>\r\n<p>假如光源均匀向四周发散</p>\r\n<p><span class=\"math display\">\\[I = \\frac{\\Phi}{4\\pi}\\]</span></p>\r\n<h3 id=\"irradiance\"><strong>Irradiance</strong></h3>\r\n<p>The power per (perpendicular/projected) unit area incident on a\r\nsurface point.</p>\r\n<p><span\r\nclass=\"math display\">\\[E(x)=\\frac{\\mathrm{d}\\Phi(x)}{\\mathrm{d}A^\\perp\r\n}\\]</span></p>\r\n<p>面要和光源垂直。</p>\r\n<p>即 Lambert‘s Consine Law</p>\r\n<h3 id=\"radiance\"><strong>Radiance</strong></h3>\r\n<p>The radiance(luminance) is the power emitted, reflected, transmitted\r\nor received by a surface, <em>per unit solid angle, per projected unit\r\narea.</em> 在单位立体角并且在单位的面积上</p>\r\n<p><span\r\nclass=\"math display\">\\[L(p,w)=\\frac{\\mathrm{d}^2\\Phi(p,w)}{\\mathrm{d}w\\,\\mathrm{d}A\\cos\\theta}=\\frac{\\mathrm{d}^2\\Phi(p,w)}{\\mathrm{d}w\\,\\mathrm{d}A^\\perp}\\]</span></p>\r\n<ul>\r\n<li>Irradiance: power per projected unit area</li>\r\n<li>Intensity: power per solid angle</li>\r\n</ul>\r\n<p>So</p>\r\n<ul>\r\n<li>Radiance : Irrandiance pre solid angle</li>\r\n<li>Radiance : Intensity pre unit projected area</li>\r\n</ul>\r\n<p>Irradiance 是 dA 收到的能量</p>\r\n<p>Irradiance per solid angle 是 dA 的能量向某一个方向辐射</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/Radiance.png\" alt=\"Radiance\" />\r\n<figcaption aria-hidden=\"true\">Radiance</figcaption>\r\n</figure>\r\n<p>该图为 Irrandicance per solid angle, 这的 cos 是不是应该写进 E\r\n里面……</p>\r\n<p>Incident Radiance 延申理解：</p>\r\n<p>一小块面积 dA 向某个方向辐射的能量</p>\r\n<p>反过来就是，从一个方向打向一个小面，到达这个面时的能量</p>\r\n<p><span\r\nclass=\"math display\">\\[L(p,w)=\\frac{\\mathrm{d}I(p,w)}{\\mathrm{d}A\\cos\\theta}=\\frac{\\mathrm{d}I(p,w)}{\\mathrm{d}A^\\perp}\\]</span></p>\r\n<h3 id=\"irradiance-vs.-radiace\"><strong>Irradiance vs.\r\nRadiace</strong></h3>\r\n<p><span\r\nclass=\"math display\">\\[\\mathrm{d}E(p,w)=L_i(p,w)\\cos\\theta\\,\\mathrm{d}w\\\\\\]</span></p>\r\n<p>两边同时积分</p>\r\n<p><span\r\nclass=\"math display\">\\[E(p)=\\int_H^2L_i(p,w)\\cos\\theta\\,\\mathrm{d}w\\\\\r\nUint\\;Hemisphere:H^2\\]</span></p>\r\n<p>每个方向过来到 A 的能量, 这和渲染方程是异曲同工的。</p>\r\n<p>再回到渲染方程</p>\r\n<p><span class=\"math display\">\\[L_0(p,w_0)=\\int\\limits_\\Omega\r\nf_r(p,w_i,w_0)\\underbrace{L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i}_{Radiace}\\]</span></p>\r\n<p>其中只有 f 项待解。</p>\r\n<h2\r\nid=\"brdf双向反射分布函数\"><strong>BRDF(双向反射分布函数)</strong></h2>\r\n<p>Bidirectional Reflectance Distribution Function，BRDF</p>\r\n<p>一个使用入射光方向ωi作为输入参数的函数，输出参数为出射光ωo，表面法线为n，参数a表示的是微平面的粗糙度。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/BRDF.svg\" alt=\"BRDF\" />\r\n<figcaption aria-hidden=\"true\">BRDF</figcaption>\r\n</figure>\r\n<p>BRDF\r\n描述了不透明物体表面每个单独光线，对最终反射光线的影响。也就是光线打到该表面如何反射，</p>\r\n<p>假设BRDF描述的是完全镜面物体，只有当出射光线方向w0 完全符号\r\n入射光线方向wi 的反射方向时，返回值会为1.0，其余情况为0.</p>\r\n<p><span\r\nclass=\"math display\">\\[f_r(p,w_0,w_i)=\\frac{\\mathrm{d}L_0(p,w_0)}{\\mathrm{d}E(p,w_i)}=\\frac{\\mathrm{d}L_0(p,w_0)}{L_i(p,w_i)\\cos\\theta_i\\,\\mathrm{d}w_i}\\]</span></p>\r\n<p>BRDF 有多种模拟表面光照的算法，实时渲染所用的基本是\r\n<strong>Cook-Torrance BRDF</strong></p>\r\n<h3 id=\"参考\"><strong>参考</strong></h3>\r\n<ul>\r\n<li><strong>PBRT-BRDF章节：</strong><a\r\nhref=\"https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Surface_Reflection\">Surface\r\nReflection (pbr-book.org)</a></li>\r\n</ul>\r\n<h3 id=\"cook-torrance-brdf\"><strong>Cook-Torrance BRDF</strong></h3>\r\n<p><span\r\nclass=\"math display\">\\[f_r=k_df_{lambert}+k_sf_{cook-torrance}\\\\\r\nk_d是入射光被折射比例，\\\\ k_s是被镜面反射比例\\]</span></p>\r\n<p>而左侧的 f_lambert 表示漫反射部分，Lambertian\r\nDiffuse，一般是恒定的算式：</p>\r\n<p><span class=\"math display\">\\[f_{lambert}=\\frac{c}{\\pi}\\]</span></p>\r\n<p>c 表示 Albedo，π 是为了归一化 漫反射，因为后面要积分的</p>\r\n<h4 id=\"brdf的高光项\"><strong>BRDF的高光项</strong></h4>\r\n<p><span class=\"math display\">\\[f_{cook-torrance}=\\frac{DFG}{4(w_0\\cdot\r\nn)(w_i\\cdot n)}\\]</span></p>\r\n<ul>\r\n<li><strong>D( Normal Distribution Function, NDF )</strong> :\r\n法线分布，估算在表面粗糙度的影响下，表现出的表面法线和半角向量(half\r\nDir)的一致性或者说微表面的数量。 估算微表面的主要函数。</li>\r\n<li><strong>F( Fresnel Equation\r\n)</strong>：菲涅尔方程，描述菲涅尔现象，当视线和表面法线夹角变大时更容易发生光的反射。\r\n不同表面角下，表面反射光线的比例。</li>\r\n<li><strong>G( Geometry Function )</strong> :\r\n几何函数，描述了微表面自成影的现象，当一个微表面特别粗糙时，彼此之间可能相互遮挡，从而减少反射的光线。</li>\r\n</ul>\r\n<p><a\r\nhref=\"https://www.zhihu.com/question/28476602/answer/41003204\">brdf为什么要定义为一个单位是sr-1的量？\r\n- 知乎 (zhihu.com)</a> <a\r\nhref=\"https://www.zhihu.com/question/28476602/answer/41003204\">brdf为什么要定义为一个单位是sr-1的量？\r\n- 文刀秋二的回答:</a></p>\r\n<h3 id=\"dnormal-distribution-function-ndf\"><strong>D(Normal Distribution\r\nFunction, NDF)</strong></h3>\r\n<p>描述和微表面法线和半角向量的一致性，从统计学上近似\r\n<strong>Trowbridge-Reitz GGX(GGXTR) :</strong></p>\r\n<p><span\r\nclass=\"math display\">\\[{NDF}_{GGXTR}(n,h,\\alpha)=\\frac{\\alpha^2}{\\pi((n\\cdot\r\nh)^2(\\alpha^2-1)+1)^2}\\\\ h=normalize(viewDir+lightDir)\\\\\r\n\\alpha={roughness}^2\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/ggx.png\" alt=\"ggx\" />\r\n<figcaption aria-hidden=\"true\">ggx</figcaption>\r\n</figure>\r\n<p><a\r\nhref=\"https://www.desmos.com/calculator/eks25xlifv?lang=zh-CN\">Trowbridge-Reitz\r\nGGX | Desmos</a></p>\r\n<p>当 粗糙度 为零时函数值变为零</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">float DoubleDistributeGGX(float3 N, float3 H, float roughness)<br>&#123;<br>    float a = roughness * roughness;<br>    float a2 = a * a;<br>    float NdotH = max(0.0, dot(N, H));<br>    float NdotH2 = NdotH * NdotH;<br><br>    float p = (NdotH2 * (a2 - 1.0) + 1.0);<br>    p = PI * p * p;<br>    return a2 / p;<br>&#125;<br><br>roughness += 0.0001;<br>float NDF = DoubleDistributeGGX(N, H, roughness);<br></code></pre></td></tr></table></figure>\r\n<p><a\r\nhref=\"https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\">2013SiggraphPresentationsNotes-26915738.pdf\r\n(unrealengine.com): Specular D</a></p>\r\n<h4\r\nid=\"generalized-trowbridge-reitzgtr分布\"><strong>Generalized-Trowbridge-Reitz（GTR）分布</strong></h4>\r\n<p>GTR分布不具备形状不变性（shape-invariant），导致其发布以来，无法被广泛使用。</p>\r\n<p><span class=\"math display\">\\[D_{GTR}(m)=\\frac{c}{(1+(n\\cdot\r\nm)^2(\\alpha^2-1))^\\gamma}\\]</span></p>\r\n<ul>\r\n<li>关于形状不变性的好处，可以总结为：\r\n<ul>\r\n<li>方便推导出该NDF归一化的各向异性版本</li>\r\n<li>方便推导出遮蔽阴影项 Smith G</li>\r\n<li>方便基于NDF或可见法线分布推导其重要性采样\r\n<ul>\r\n<li>对于Smith G，可用低维函数或表格处理所有粗糙度和各向异性</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"参考-1\"><strong>参考</strong></h4>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/69380665\">【基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结\r\n- 知乎 (zhihu.com)</a>:关于形状不变性。</p>\r\n<h3 id=\"ffresnel-equation\"><strong>F(Fresnel Equation)</strong></h3>\r\n<p><span\r\nclass=\"math display\">\\[F_{Schlick}(h,v,F_0)=F_0+(1-F_0)(1-(h,v))^5\\]</span></p>\r\n<p>F_0 表示的基础反射率，利用折射指数(Indices Of Refraction)求得，F_0\r\n越大菲涅尔反射现象越强。</p>\r\n<p>当越是向掠射角(又名切线角，和正視角相差90度)方向去看，菲涅尔现象越强，反光效果越明显。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/fresnel.png\" alt=\"fresnel\" />\r\n<figcaption aria-hidden=\"true\">fresnel</figcaption>\r\n</figure>\r\n<p><strong>Fresnel-Schlick</strong>只适用于绝缘体的表面算法。\r\n金属表面需要其他的菲涅尔方程模拟。但是这样做很不方便，所以：\r\n预计算出平面对法线入射的结果(F0)，基于观察角的Fresnel-Schlick近似对这个值进行插值，用这种方法进一步估算。\r\n这样就可以使用同一个公式了。</p>\r\n<p>平面对于法向入射的响应或者说基础反射率可以在一些大型数据库中找到，比如<a\r\nhref=\"http://refractiveindex.info/\">RefractiveIndex</a>。</p>\r\n<p>所有电介质材质表面的基础反射率都不会高于0.17，这其实是例外而非普遍情况。导体材质表面的基础反射率起点更高一些并且（大多）在0.5和1.0之间变化。此外，对于导体或者金属表面而言基础反射率一般是带有色彩的，这也是为什么F0要用RGB三原色来表示的原因（法向入射的反射率可随波长不同而不同）。这种现象我们<strong>只能</strong>在金属表面观察的到。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/chart3.png\" alt=\"chart3\" />\r\n<figcaption aria-hidden=\"true\">chart3</figcaption>\r\n</figure>\r\n<p>由于绝缘体和金属体存在多种的差异，其各自独有的特性引出了金属工作流，我们使用一个金属度调节材质表面特性，这个参数并非\r\n非零即一\r\n的布尔值，是因为我们要描述一些比如沙子、颗粒和被刮蹭后的金属表面，所以要有一个[0,1]的范围进行调整。</p>\r\n<p>我们通过预计算金属和绝缘体的 F_0 进行 Fresnel-Schlick\r\n近似，但是对于金属表面通常这样做</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">vec3 F0 = vec3(0.04,0.04,0.04);<br>F0 = mix(F0, surfaceColor.rgb, metalness);<br></code></pre></td></tr></table></figure>\r\n<p>我们为大多数电介质表面定义了一个近似的基础反射率。F_0取最常见的电解质表面的平均值，这又是一个近似值。不过对于大多数电介质表面而言使用0.04作为基础反射率已经足够好了，而且可以在不需要输入额外表面参数的情况下得到物理可信的结果。然后，基于金属表面特性，我们要么使用电介质的基础反射率要么就使用F_0来作为表面颜色。因为金属表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用表面颜色纹理来作为它们的基础反射率。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">vec3 fresnelSchlick(float cosTheta, vec3 F0)<br>&#123;<br>    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);<br>&#125;<br>// cosTheta = dot(N,V)<br></code></pre></td></tr></table></figure>\r\n<p>这里的N是收到粗糙度影响的半角向量，在后面计算IBL时，因为预计算没办法考虑粗糙度，所以我们需要一个受粗糙度影响的\r\nfresnelSchlick</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)<br>&#123;<br>    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>关于金属和绝缘体的菲涅尔，在 PBRT 中有提到，8.2.1 Fresnel\r\nReflection： <a\r\nhref=\"https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission\">Specular\r\nReflection and Transmission (pbr-book.org)</a></p>\r\n<blockquote>\r\n<ol type=\"1\">\r\n<li>The first class is <em>dielectrics</em>, which are materials that\r\ndon’t conduct electricity. They have real-valued indices of refraction\r\n(usually in the range 1-3) and transmit† a portion of the incident\r\nillumination. Examples of dielectrics are glass, mineral oil, water, and\r\nair.</li>\r\n<li>The second class consists of <em>conductors</em> such as metals.\r\nValence electrons can freely move within the their atomic lattice,\r\nallowing electric currents to flow from one place to another. This\r\nfundamental atomic property translates into a profoundly different\r\nbehavior when a conductor is subjected to electromagnetic radiation such\r\nas visible light: the material is opaque and reflects back a significant\r\nportion of the illumination. A portion of the light is also transmitted\r\ninto the interior of the conductor, where it is rapidly absorbed: total\r\nabsorption typically occurs within the top 0.1 μm of the material, hence\r\nonly extremely thin metal films are capable of transmitting appreciable\r\namounts of light. We ignore this effect in <code>pbrt</code> and only\r\nmodel the reflection component of conductors. In contrast to\r\ndielectrics, conductors have a complex-valued index of refraction\r\nn=n0+ik.</li>\r\n<li>Semiconductors such as silicon or germanium are the third class\r\nthough we will not consider them in this book.</li>\r\n<li>The first class is dielectrics, which are materials that don't\r\nconduct electricity. They have real-valued indices of refraction\r\n(usually in the range 1-3) and transmitt a portion of the incident\r\nillumination. Examples of dielectrics are glass, mineral oil, water, and\r\nair.</li>\r\n<li>The second class consists of conductors such as metals. Valence\r\nelectrons can freely move within the their atomic lattice, allowing\r\nelectric currents to flow from one place to another. This fundamental\r\natomic property translates into a profoundly different behavior when a\r\nconductor is subjected to electromagnetic radiation such as visible\r\nlight: the material is opaque and reflects back a significant portion of\r\nthe illumination. A portion of the light is also transmitted into the\r\ninterior of the conductor, where it is rapidly absorbed: total\r\nabsorption typically occurs within the top 0.1 um of the material, hence\r\nonly extremely thin metal films are capable of transmitting appreciable\r\namounts of light. We ignore this effect in pbrt and only model the\r\nreflection component of conductors. In contrast to dielectrics,\r\nconductors have a complex-valued index of refraction = n + ik.</li>\r\n<li>Semiconductors such as silicon or germanium are the third class\r\nthough we will not consider them in this book.</li>\r\n</ol>\r\n<p>第一类是介电材料，这是一种不导电的材料。它们具有实值折射率(通常在1-3范围内)，并透射一部分入射光。电介质的例子有玻璃、矿物油、水和空气。</p>\r\n<p>第二类由金属等导体组成。价电子可以在其原子晶格内自由移动，从而使电流从一个地方流向另一个地方。当导体受到电磁辐射(如可见光)时，这种基本的原子性质会转化为一种截然不同的行为:这种材料是不透明的，会反射回相当一部分照明。一部分光也被传输到导体的内部，在那里它被迅速吸收:完全吸收通常发生在材料的顶部0.1微米内，因此只有极薄的金属薄膜才能传输相当数量的光。我们在pbrt中忽略了这种影响，只对导体的反射成分进行了建模。与电介质相比，导体具有复值折射率=\r\nn + ik。</p>\r\n<p>硅或锗等半导体是第三类，但我们在本书中不考虑它们。</p>\r\n</blockquote>\r\n<h3 id=\"ggeometry-function\"><strong>G(Geometry Function)</strong></h3>\r\n<p>几何遮蔽模拟微表面的互相遮挡导致光线能量丢失或减少的现象。</p>\r\n<p>类似 NDF，也使用 Roughness\r\n作为输入，粗糙度越高意味着几何遮蔽的概率越大。 几何遮蔽有 GGX 和\r\nSchlick-Beckmann 组合而成的模拟函数 <strong>Schlick-GGX</strong>：</p>\r\n<p><span class=\"math display\">\\[G_{SchlickGGX}(n,v,k)=\\frac{n\\cdot\r\nv}{(n\\cdot v)(1-k)+k}\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/G.png\" alt=\"G\" />\r\n<figcaption aria-hidden=\"true\">G</figcaption>\r\n</figure>\r\n<p>这里的 k 由粗糙度 α 计算得来，用于直接光照和 IBL\r\n光照的几何函数参数:</p>\r\n<p><span class=\"math display\">\\[k_{direct}=\\frac{(\\alpha+1)^2}{8}\\\\\r\nk_{IBL}=\\frac{\\alpha^2}{2}\\]</span></p>\r\n<p>这里的 α 取决于我们怎么从粗糙度转换。</p>\r\n<p>为了更好的模拟，我们可以同时考虑两个视角，视线方向(几何遮蔽)和光线方向(几何阴影)\r\n几何遮蔽类似“看不到”，几何阴影类似“照不到”。 使用 <strong>Smith</strong>\r\n函数将其放在一起:</p>\r\n<p><span\r\nclass=\"math display\">\\[G(n,v,l,k)=G_{sub}(n,v,k)G_{sub}(n,l,k)\\]</span></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">float GeometrySchlickGGX(float NdotV, float k)<br>&#123;<br>    float nom = NdotV;<br>    float denom =  NdotV * (1 - k) + k;<br>    return nom / denom;<br>&#125;<br><br>float GeometeySmith(vec3 N, vec3 V, vec3 L, float k)<br>&#123;<br>    float Gsub = GeometrySchlickGGX(saturate(dot(N,V)), k);<br>    float Gsub2 = GeometrySchlickGGX(saturate(dot(N,L)), k);<br>    return Gsub * Gsub2;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"kulla-conty-approximation\"><strong>Kulla-Conty\r\nApproximation</strong></h3>\r\n<p>由于几何遮蔽造成能量损失，使得粗糙度较大时物体表面较暗，但实际上光线在表面经过多次弹射后不会被遮挡，可以反射出去(不考虑热能损失)。BRDF\r\n只是考虑一次反射罢了。</p>\r\n<p>所以使用经验模型去补全损失的能量，首先要知道有多少能量损失了。</p>\r\n<p><span\r\nclass=\"math display\">\\[E(\\mu_o)=\\int_0^{2\\pi}\\int_0^1f_r(\\mu_o,\\mu_i,\\phi)u_i\\,\\mathrm{d}\\mu_i\\,\\mathrm{d}\\phi\\\\\r\nu=\\sin\\theta\\]</span></p>\r\n<ul>\r\n<li>Key idea\r\n<ul>\r\n<li>损失的能量就是 1 - E(_o)，不过E(_o)是和观察方向相关的。\r\n我要做的就是补上这部分能量，能量加起来就是1了啊。</li>\r\n<li>E(_0)是和观察方向相关的。</li>\r\n<li>要补一种多次散射的BRDF结果，也就是用一个模型去模拟多次反射的计算结果，而且因为\r\nBRDF 具有对称性，有1 - E(_o)那么应该也有一项1 -\r\nE(_i)，因为我们的这个经验式子是模拟一个多级的基于 BRDF\r\n的反射，然后补上一个归一化的参数c，得到这样的结果： c(1-E(_i))(1 -\r\nE(_o)) 这么设计只是为了简单……</li>\r\n<li><span class=\"math display\">\\[c=\\frac{1}{\\pi(1-E_{avg})}\\\\\r\nE_{avg}=2\\int_0^1E(\\mu)\\mu\\,\\mathrm{d}\\mu\\\\\r\nf_{ms}(\\mu_o,\\mu_i)=\\frac{(1-E(\\mu_i))(1 -\r\nE(\\mu_o))}{\\pi(1-E_{avg})}\\]</span></li>\r\n<li></li>\r\n</ul></li>\r\n<li>但E_{avg}还是不知道的，这个可以预计算。\r\n<ul>\r\n<li>Precompute / tabulate</li>\r\n<li><span\r\nclass=\"math display\">\\[E_{avg}(\\mu_o)=2\\int_0^1E(\\mu_i)\\mu_i\\,\\mathrm{d}\\mu_i\\\\\\]</span></li>\r\n<li><span class=\"math display\">\\[E_{avg}\\]</span>和<span\r\nclass=\"math display\">\\[\\mu_o\\]</span>, 以及 BRDF(或者说roughness) 相关\r\n这个预计算的结果会根据 brdf 的不同而改变。</li>\r\n</ul></li>\r\n</ul>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/Kulla-Conty.png\" alt=\"Kulla-Conty\" />\r\n<figcaption aria-hidden=\"true\">Kulla-Conty</figcaption>\r\n</figure>\r\n<ul>\r\n<li>如果物体有颜色，就会有能量损失，这样积分一开始就不会是1. 我们先计算\r\n没有颜色损失的 正确结果，最后计算时再考虑由于颜色引起的损失。</li>\r\n<li>Define the average Fresnel\r\n不管入射角多大，每次反射平均反射掉多少能量</li>\r\n</ul>\r\n<p><span\r\nclass=\"math display\">\\[F_{avg}=\\frac{\\int_0^1F(\\mu)\\mu\\,\\mathrm{d}\\mu}{\\int_0^1\\mu\\,\\mathrm{d}\\mu}=2\\int_0^1F(\\mu)\\mu\\,\\mathrm{d}\\mu\\]</span></p>\r\n<ul>\r\n<li><span class=\"math display\">\\[E_{avg}\\]</span>\r\n表示有多少能量我们可以看到，这些能量不会发生多次的反射。 NOT participate\r\nin further bounces</li>\r\n<li>所以最后的 能量/颜色\r\n<ul>\r\n<li>能够直接看到的 <span\r\nclass=\"math display\">\\[F_{avg}E_{avg}\\]</span></li>\r\n<li>光反射一次被看到：<span\r\nclass=\"math display\">\\[F_{avg}(1-E_{avg})\\cdot F_{avg}E_{avg}\\]</span>\r\n<span\r\nclass=\"math display\">\\[F_{avg}(1-E_{avg})\\]</span>是反射后(F)未能从物体表面反射出去的能量(1-E)，\r\n<span\r\nclass=\"math display\">\\[F_{avg}(1-E_{avg})\\underline{F_{avg}}\\]</span>\r\n未能出去的能量发生第二次 <span\r\nclass=\"math display\">\\[F_{avg}(1-E_{avg})\\cdot\r\nF_{avg}\\underline{E_{avg}}\\]</span> 发生反射后有多少能量被看到</li>\r\n<li>反射k次：F_{avg}<sup>k(1-E_{avg})</sup>kF_{avg}E_{avg}</li>\r\n<li>累加得到 color term：</li>\r\n<li><span\r\nclass=\"math display\">\\[\\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}\\]</span></li>\r\n<li>最后将 color term directly multiplied on the uncolored\r\n<strong>additional BRDF</strong></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"cook-torrance-反射方程\"><strong>Cook-Torrance\r\n反射方程</strong></h3>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} +\r\nk_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<h4 id=\"直接光-附加光\">直接光 + 附加光</h4>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/output2.PNG\" alt=\"output2\" />\r\n<figcaption aria-hidden=\"true\">output2</figcaption>\r\n</figure>\r\n<h2 id=\"ibl\"><strong>IBL</strong></h2>\r\n<h3 id=\"diffuse-irradiance\"><strong>Diffuse Irradiance</strong></h3>\r\n<p>Imaged base lighting, IBL\r\n是一类光照技术的集合，若光源不是可分解的直接光源，比如可以用辐射度量学计算的的点光源方向光等等，<strong>而是将周围环境整体视为一个大光源</strong>。IBL(\r\n取自现实世界或者在3D场景生成)\r\n环境立方体贴图(cubemap)，我们可以将立方体贴图的每个像素视为光源，在渲染方程中直接使用，这样可以有效的捕获环境的全局光照和氛围，使物体更好的融入环境。\r\n由于基于图像的光照算法会捕捉部分甚至全部的环境光照，通常认为它是一种更精确的环境光照输入格式，甚至也可以说是一种全局光照的粗略近似。基于此特性，IBL\r\n对 PBR\r\n很有意义，因为当我们将环境光纳入计算之后，物体在物理方面看起来会更加准确。</p>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} +\r\nk_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>对于反射方程的求解主要是在半球上对所有入射光方向 w_i 的积分。\r\n直接光照的话，我们事先知道对积分有贡献的、若干精准的光线方向，但是来自环境的<strong>每个</strong>方向w_i都有可能具有一定的\r\nRadiance，这就很麻烦了。 我们需要：</p>\r\n<ul>\r\n<li>对给定任何方向w_i，能获取到该方向的场景 Radiance。</li>\r\n<li>积分需要快，因为是实时渲染。</li>\r\n</ul>\r\n<p>第一个思路就是用\r\n环境立方体贴图，每个纹素都视为一个光源，使用一个w_i采样即可。</p>\r\n<p>为了更高效的解决积分，我们需要对其中大部分结果做预处理，再来看反射方程:</p>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} +\r\nk_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\\\\r\nBecause\\;diffuse\\;k_d\\;and\\;specular\\;are\\;independent\\;for\\;each\\;other.\\\\\r\nWe\\;can\\;break\\;up.\\\\\r\nL_0(p,w_0)=\\int_{\\Omega}k_d\\frac{c}{\\pi}L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i + \\int_{\\Omega}k_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot\r\nn)}L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>先来研究\r\ndiffuse，将常数提出，能得到只依赖于w_i的积分，我们就可以计算或预计算一个新的立方体贴图，它在每个采样方向——也就是纹素——中存储漫反射积分的结果，这些结果是通过卷积计算出来的。</p>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=k_d\\frac{c}{\\pi}\\int_{\\Omega}L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>卷积的特性是，对数据集中的一个条目做一些计算时，要考虑到数据集中的所有其他条目。这里的数据集就是场景的辐射度或环境贴图。因此，要对立方体贴图中的每个采样方向做计算，我们都会考虑半球\r\n上的所有其他采样方向。</p>\r\n<p>为了对环境贴图进行卷积，我们通过对半球 ，来计算每个输出采样方向\r\nw_0的积分。用来采样方向 w_i 的半球，要面向卷积的输出采样方向 w_0 。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/ibl1.png\" alt=\"ibl1\" />\r\n<figcaption aria-hidden=\"true\">ibl1</figcaption>\r\n</figure>\r\n<p>是不是看不懂，看不懂就对了，因为应该是这样的！</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/ibl2.png\" alt=\"ibl2\" />\r\n<figcaption aria-hidden=\"true\">ibl2</figcaption>\r\n</figure>\r\n<p>该预计算的立方体贴图在每个采样方向\r\nw_0(n)上存储结果，也就是场景中所有能够击中表面朝向为w_0(n)的间接漫反射光的预计算和。</p>\r\n<p>辐射方程也依赖了位置 p\r\n，不过这里我们假设它位于辐照度图的中心。这就意味着所有漫反射间接光只能来自同一个环境贴图，这样可能会破坏现实感（特别是在室内）。渲染引擎通过在场景中放置多个反射探针来解决此问题，每个反射探针单独预计算其周围环境的辐照度图。这样，位置\r\np\r\n处的辐照度（以及辐射度）是取离其最近的反射探针之间的辐照度（辐射度）内插值</p>\r\n<p>关于在半球的积分，可以将立体角 soiled angle 展开</p>\r\n<p><span class=\"math display\">\\[L_0(p,w_0)= k_d\\frac{c}{\\pi}\r\n\\int_{\\phi=0}^{2\\pi}\\int_{\\theta=0}^{\\frac{1}{2}\\pi}\r\nL_i(p,\\phi_i,\\theta_i)\r\n\\cos\\theta\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi\\\\  Here\\;\\cos\\theta\\sin\\theta,\\;\\sin\\theta\\;for\\;soiled\\;angle,\\;\\cos\\theta\\;for\\;\\overrightarrow{up}:w_i\\cdot\r\nn\\\\  L_0(p,w_0)=k_d\\frac{c}{\\pi}\r\n\\frac{1}{n_1n_2}\\sum\\limits^{n_1}_{\\phi=0}\\sum\\limits^{n_2}_{\\theta=0}\r\nL_i(p,\\phi_i,\\theta_i)\r\n\\cos\\theta\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi\\]</span></p>\r\n<h3 id=\"实现\"><strong>实现</strong></h3>\r\n<p>Roughness in [0,1]-&gt;[0,5]</p>\r\n<p>做五级的skybox，存在cubemap tex内</p>\r\n<h4 id=\"参考-2\"><strong>参考</strong></h4>\r\n<p><a\r\nhref=\"https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/\">漫反射辐照\r\n- LearnOpenGL CN (learnopengl-cn.github.io)</a> <a\r\nhref=\"http://www.codinglabs.net/article_physically_based_rendering.aspx\">codinglabs.net/article_physically_based_rendering.aspx</a></p>\r\n<h3 id=\"specular-ibl\"><strong>Specular IBL</strong></h3>\r\n<h4 id=\"the-split-sum-1st-stage\"><strong>The Split Sum: 1st\r\nStage</strong></h4>\r\n<p>现在来看镜面反射部分，反射方程为：</p>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int\\limits_\\Omega(k_d\\frac{c}{\\pi}+k_s\\frac{DFG}{4(w_0\\cdot\r\nn)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>这下坏了，因为 ks\r\n是受入射光还有视角影响的。如果进行实时计算，视线和光线的组合数极其庞大，这样的开销是很昂贵的。\r\nEpic Games\r\n提出了一个解决方案，他们预计算镜面部分的卷积，为实时计算作了一些妥协，这种方案被称为分割求和近似法（<strong>split\r\nsum approximation</strong>）。\r\n分割求和近似将方程的镜面部分分割成两个独立的部分，我们可以单独求卷积，然后在\r\nPBR 着色器中求和，以用于间接镜面反射部分\r\nIBL。分割求和近似法类似于我们之前求辐照图预卷积的方法，需要 HDR\r\n环境贴图作为其卷积输入。为了理解，我们回顾一下反射方程，但这次只关注镜面反射部分：</p>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int\\limits_\\Omega(k_s\\frac{DFG}{4(w_0\\cdot\r\nn)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i\\\\\r\n=\\int\\limits_\\Omega f_r(p,w_i,w_0)L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>我们依然想计算出一个类似镜面 IBL\r\n贴图的东西，然后使用pixel的法线采样，但是问题在于，辐照度图只依赖于\r\nw_i，但是这次积分还依赖于 BRDF</p>\r\n<p><span class=\"math display\">\\[f_r(p,w_i,w_0)=\\frac{DFG}{4(w_0\\cdot\r\nn)(w_i\\cdot n)}\\]</span></p>\r\n<p>BRDF内还有w_0，更不可能要用入射和出射光的组合了，那计算肯定爆掉了。</p>\r\n<p><span\r\nclass=\"math display\">\\[\\int_{\\Omega}f(x)g(x)\\,\\mathrm{d}x\\approx\\frac{\\int_{\\Omega_G}f(x)\\,\\mathrm{d}x}{\\int_{\\Omega_G}\\,\\mathrm{d}x}\\cdot\\int_{\\Omega}g(x)\\,\\mathrm{d}x\\]</span></p>\r\n<p>所以\r\nE宝先将其分为两个部分求解，再将两个部分组合计算得到预计算结果。</p>\r\n<p><span class=\"math display\">\\[L_0(p,w_0)=\\int\\limits_\\Omega\r\nL_i(p,w_i)\\,\\mathrm{d}w_i*\\int\\limits_\\Omega f_r(p,w_i,w_0)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>卷积的第一部分被称为预滤波环境贴图，它类似于辐照度图，是预先计算的环境卷积贴图，但这次考虑了粗糙度。因为随着粗糙度的增加，参与环境贴图卷积的采样向量会更分散，导致反射更模糊，所以对于卷积的每个粗糙度级别，我们将按顺序把模糊后的结果存储在预滤波贴图的\r\nmipmap 中。例如，预过滤的环境贴图在其 5 个 mipmap 级别中存储 5\r\n个不同粗糙度值的预卷积结果，如下图所示：</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/IBLCubemap.png\" alt=\"IBLCubemap\" />\r\n<figcaption aria-hidden=\"true\">IBLCubemap</figcaption>\r\n</figure>\r\n<p>为什么是不同粗糙度的图呢？这是因为对于不同的粗糙度，我们镜面反射是不同的，当表面越粗糙镜面反射越松散，我们观测的光照结果会越分散在更广的范围，而越光滑，反射范围越小越集中，视觉上也就是越清晰的。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/iblAlpha.png\" alt=\"iblAlpha\" />\r\n<figcaption aria-hidden=\"true\">iblAlpha</figcaption>\r\n</figure>\r\n<p>从上图我们可以看到我们对r方向采样，实际上是对cubemap的一个橙色的\r\nfliter 进行采样的，当越粗糙时这个 filter 越大。</p>\r\n<p>为什么两部分分开了还要前面项会受到 BRDF\r\n影响，因为我们的采样方向其实就是会受到 BRDF 的影响的。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/boban.jpg\" alt=\"boban\" />\r\n<figcaption aria-hidden=\"true\">boban</figcaption>\r\n</figure>\r\n<p>我们对cubemap的采样范围或者说采样的样本实际就是图中所示的波瓣，而根据\r\nbrdf 定义可知：</p>\r\n<p><span\r\nclass=\"math display\">\\[R=reflection(w_o,n)，w_o就是\\overrightarrow{view}。\\]</span></p>\r\n<p><strong>假设不同方向入射，波瓣变化不大</strong>，我们可以得到:</p>\r\n<p><span class=\"math display\">\\[f(w_o,w_i(n),n)\\approx\r\nf(R,w_i(R),R)，也就是 N=V=R。\\]</span>\r\nf(w_o,w_i(n),n)f(R,w_i(R),R)，也就是 N=V=R。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/poban.jpg\" alt=\"poban\" />\r\n<figcaption aria-hidden=\"true\">poban</figcaption>\r\n</figure>\r\n<p>我们使用 Cook-Torrance BRDF\r\n的法线分布函数(NDF)生成采样向量及其散射强度，该函数将法线和视角方向作为输入。由于我们在卷积环境贴图时事先不知道视角方向，因此\r\nEpic Games\r\n假设视角方向——也就是镜面反射方向——总是等于输出采样方向ωo，以作进一步近似。翻译成代码如下：</p>\r\n<p>vec3 N = normalize(w_o);</p>\r\n<p>vec3 R = N;</p>\r\n<p>vec3 V = R;</p>\r\n<p>但是这样的假设会导致在掠射角处失去各向异性，因为菲涅尔现象会导致不同w_o的反射方向或者反射现象是不一样的，所以基于波瓣不变的假设所做的结果必然会有缺失。</p>\r\n<p>Moving Frostbite to Physically Based Rendering 3.0-4.9.2 Light probe\r\nfiltering</p>\r\n<p>To simplify this evaluation, we can pre-integrate the integral by\r\nmaking some approximations. Pre-integrating this equation for every v\r\nand Θ would require a huge memory footprint. Thus, a first approximation\r\nis to remove the view dependency. This leads to a coarse approximation\r\nof the BRDF but it is an acceptable trade-off: the shape of a BRDF based\r\non the micro-facets framework and/or half-angle parametrization is\r\nstrongly dependent on the view angle as shown on Figure 54. At normal\r\nincident direction, the shape of a BRDF is isotropic. At grazing angles\r\nthe shape of a BRDF is anisotropic. Removing the view dependency for\r\npre-integrating Equation 46 would make the assumption that the BRDF\r\nshape is isotropic at all view angles. This leads to key visual\r\ndifferences, preventing stretched reflections. This approximation can be\r\nquite noticeable on flat surfaces as shown on Figure 55 but less on\r\ncurvy surfaces38</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/ueReference.png\" alt=\"ueReference\" />\r\n<figcaption aria-hidden=\"true\">ueReference</figcaption>\r\n</figure>\r\n<h4 id=\"the-split-sum-2nd-stage\"><strong>The Split Sum: 2nd\r\nStage</strong></h4>\r\n<p><span\r\nclass=\"math display\">\\[Lo(p,w_o)\\approx\\frac{\\int_{\\Omega_{fr}}L_i(p,w_i)\\,\\mathrm{d}w_i}{\\int_{\\Omega_{fr}}\\,\\mathrm{d}w_i}\\cdot\\underline{\\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i}\\]</span></p>\r\n<p>这部分计算和 F_0,,，但是3D贴图太大了！！！</p>\r\n<p>菲涅项其实比较好拆，我们可以对这部分做一些处理</p>\r\n<p><span class=\"math display\">\\[R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\\r\nR_0-R_0(1-\\cos\\theta)^5+(1-\\cos\\theta)^5\\\\\r\n\\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i\\approx\\\\\r\nR_0\\int_{\\Omega^+}\\frac{f_r}{F}(1-(1-\\cos\\theta)^5)\\cos\\theta_i\\,\\mathrm{d}w_i+\\int_{\\Omega^+}\\frac{f_r}{F}(1-\\cos\\theta)^5\\cos\\theta_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/uecode1.png\" alt=\"uecode1\" />\r\n<figcaption aria-hidden=\"true\">uecode1</figcaption>\r\n</figure>\r\n<h3 id=\"the-split-sum-1st-stage-sample\"><strong>The Split Sum: 1st Stage\r\nSample</strong></h3>\r\n<p>在上一节教程中，我们使用球面坐标生成均匀分布在半球 <span\r\nclass=\"math display\">\\[\\Omega\\]</span>\r\n上的采样向量，以对环境贴图进行卷积。虽然这个方法非常适用于辐照度，但对于镜面反射效果较差。镜面反射依赖于表面的粗糙度，反射光线可能比较松散，也可能比较紧密，但是一定会围绕着反射向量r，除非表面极度粗糙：</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/sample.png\" alt=\"sample\" />\r\n<figcaption aria-hidden=\"true\">sample</figcaption>\r\n</figure>\r\n<p>所有可能出射的反射光构成的形状称为镜面波瓣。随着粗糙度的增加，镜面波瓣的大小增加；随着入射光方向不同，形状会发生变化。因此，镜面波瓣的形状高度依赖于材质。\r\n在微表面模型里给定入射光方向，则镜面波瓣指向微平面的半向量的反射方向。考虑到大多数光线最终会反射到一个基于半向量的镜面波瓣内，采样时以类似的方式选取采样向量是有意义的，因为大部分其余的向量都被浪费掉了，这个过程称为重要性采样。</p>\r\n<p>F = FresnelSchlickFunction(F0, max(0.0, dot(N, H)), roughness);</p>\r\n<p>float3 spe_ibl = SAMPLE_TEXTURE2D_LOD(_MySplit1st,\r\nsampler_MySplit1st, float2(uv.xy), _Roughness * 4.0);</p>\r\n<p>col += spe_ibl * (F * brdf.x + brdf.y)+ ev_diffuse*albedo;</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/uecode2.png\" alt=\"uecode2\" />\r\n<figcaption aria-hidden=\"true\">uecode2</figcaption>\r\n</figure>\r\n<h3\r\nid=\"蒙特卡洛monte-carlo积分和重要性采样importance-sampling\"><strong>蒙特卡洛(Monte\r\nCarlo)积分和重要性采样(Importance Sampling)</strong></h3>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/146144853\">蒙特卡洛积分 - 知乎\r\n(zhihu.com)</a></p>\r\n<p>有了蒙特卡洛，那么如何对半球面上的进行采样。</p>\r\n<h3 id=\"低差异序列\"><strong>低差异序列</strong></h3>\r\n<p>Hammersley 序列</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">float RadicalInverse_VdC(uint bits)<br>&#123;<br>    bits = (bits &lt;&lt; 16u) | (bits &gt;&gt; 16u);<br>    bits = ((bits &amp; 0x55555555u) &lt;&lt; 1u) | ((bits &amp; 0xAAAAAAAAu) &gt;&gt; 1u);<br>    bits = ((bits &amp; 0x33333333u) &lt;&lt; 2u) | ((bits &amp; 0xCCCCCCCCu) &gt;&gt; 2u);<br>    bits = ((bits &amp; 0x0F0F0F0Fu) &lt;&lt; 4u) | ((bits &amp; 0xF0F0F0F0u) &gt;&gt; 4u);<br>    bits = ((bits &amp; 0x00FF00FFu) &lt;&lt; 8u) | ((bits &amp; 0xFF00FF00u) &gt;&gt; 8u);<br>    return float(bits) * 2.3283064365386963e-10; // / 0x100000000<br>&#125;<br>// ----------------------------------------------------------------------------<br>float2 Hammersley(uint i, uint N)<br>&#123;<br>    return float2(float(i)/float(N), RadicalInverse_VdC(i));<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/343666731\">看懂蒙特卡洛积分(三)\r\n低差异采样序列</a> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/20197323\">低差异序列（一）-\r\n常见序列的定义及性质 - 知乎 (zhihu.com)</a> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/20374706\">低差异序列（二）-\r\n高效实现以及应用 - 知乎 (zhihu.com)</a></p>\r\n<h4 id=\"ggx-重要性采样\"><strong>GGX 重要性采样</strong></h4>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">float3 ImportanceSampleGGX(float2 Xi, float3 N, float roughness)<br>&#123;<br>    // use roughness for better view<br>    float alpha2 = roughness * roughness;<br><br>    float phi = 2.0 * PI * Xi.x;<br>    float cosTheta = sqrt( (1.0 - Xi.y) / (1.0 + ( alpha2 * alpha2 - 1.0) * Xi.y));<br>    float sinTheta = sqrt(1 - cosTheta * cosTheta);<br><br>    float3 H;<br>    H.x = cos(phi) * sinTheta;<br>    H.y = sin(phi) * sinTheta;<br>    H.z = cosTheta;<br><br>    float3 up = abs(N.z) &lt; 0.999 ? float3(0.0, 0.0, 1.0) : float3(1.0, 0.0, 0.0);<br>    float3 tangent = normalize(cross(up,N));<br>    float3 biTangent = normalize(cross(N, tangent));<br><br>    float3 sampleVec = tangent * H.x + biTangent * H.y + N * H.z;<br>    return normalize(sampleVec);<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"the-split-sum\">The Split Sum</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">// 1st<br>void PrefilteredColor(float3 dir, uint3 id)<br>&#123;<br>    float3 N = normalize(dir);<br>    float3 R = N;<br>    float3 V = R;<br><br>    const uint SAMPLE_COUNT = 1024;<br>    float totalWeight[5] = &#123;0.0, 0.0, 0.0, 0.0, 0.0&#125;;<br>    float3 preColor[5] = &#123; float3(0.0,0.0,0.0), float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0)&#125;;<br>    for(uint i = 0; i &lt; SAMPLE_COUNT; ++i)<br>    &#123;<br>        float2 Xi = Hammersley(i, SAMPLE_COUNT);<br>        float3 H[5];<br>        float3 L[5];<br>        float NdotL[5];<br>        for(uint a = 0; a &lt; 5; a++)<br>        &#123;<br>            H[a] = ImportanceSampleGGX(Xi, N, (float)a*2.0/10.0);<br>            L[a] = normalize(2.0 * dot(V, H[a]) * H[a] - V);<br>            NdotL[a] = max(0.0,dot(N,L[a]));<br>            if(NdotL[a] &gt; 0.0)<br>            &#123;<br>                float D = DistributeGGX(N, H[a], (float)a/5.0);<br>                float NdotH = max(0.0, dot(N, H[a]));<br>                float HdotV = max(0.0, dot(H[a], V));<br>                float pdf = D * NdotH / (4.0 * HdotV) + 0.0001;<br><br>                float res = 512.0;<br>                float saTexel = 4.0 * PI / (6.0 * res * res);<br>                float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);<br>                float roughness = (float)a / 5.0;<br>                float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); <br>                <br>                preColor[a] += _SkyBoxTex.SampleLevel(LinearClampSampler, L[a], mipLevel).xyz * NdotL[a];<br>                totalWeight[a] += NdotL[a];<br>            &#125;<br>        &#125;         <br>    &#125;<br>    int powLog = 1;<br>    for(uint b = 0; b &lt; 5; b++)<br>    &#123;    <br>        preColor[b] = preColor[b] / totalWeight[b];<br>        _SplitSum1stMip[b][id.xy/powLog] = float4(preColor[b],1);<br>        powLog *= 2;<br>    &#125;<br>&#125;<br><br>// 2nd<br>float2 IntegrateBRDF(float NdotV, float roughness)<br>&#123;<br>    float3 V;<br>    V.x = sqrt(1 - NdotV * NdotV);<br>    V.y = 0.0;<br>    V.z = NdotV;<br><br>    float A = 0.0;<br>    float B = 0.0;<br><br>    float3 N = float3(0.0, 0.0, 1.0);<br><br>    int sampleCount = 1024;<br>    for(int i = 0; i &lt; sampleCount; ++i)<br>    &#123;<br>        float2 Xi = Hammersley(i, sampleCount);<br>        float3 H = ImportanceSampleGGX(Xi, N, roughness);       // D. NDF<br>        float3 L = normalize(2.0 * dot(V,H) * H - V);<br><br>        float NdotL = max(L.z, 0.0);<br>        float NdotH = max(H.z, 0.0);<br>        float VdotH = max(0.0, dot(V, H));<br><br>        if(NdotL &gt; 0.0)<br>        &#123;<br>            float G = GeometrySmith(N, V, L, roughness * roughness / 2.0);      // G<br>            float G_Vis = (G * VdotH) / (NdotH * NdotV);    <br>            float Fc = pow(1 - VdotH, 5.0);<br>            <br>            A += (1.0 - Fc) * G_Vis;<br>            B += Fc * G_Vis;<br>        &#125;<br>    &#125;<br>    A /= float(sampleCount);<br>    B /= float(sampleCount);<br>    return float2(A, B);<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"反射探针\"><strong>反射探针</strong></h3>\r\n<p>在unity中添加 probe 然后 baked</p>\r\n<p>使用 sampleSH 对 probe 进行采样</p>\r\n<h3 id=\"environment-diffuse-ibl-specular\">Environment Diffuse + IBL\r\nSpecular</h3>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/output3.PNG\" alt=\"output3\" />\r\n<figcaption aria-hidden=\"true\">output3</figcaption>\r\n</figure>\r\n<p>中间是粗糙度越来越小 下面是金属度越来越大</p>\r\n<h3 id=\"ibl-参考\"><strong>IBL 参考</strong></h3>\r\n<p><a\r\nhref=\"https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/\">Image\r\nBased Lighting | Chetan Jags (wordpress.com)</a> <a\r\nhref=\"https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\">course_notes_moving_frostbite_to_pbr_v32.pdf\r\n(wordpress.com)</a>:4.9章节 <a\r\nhref=\"https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/\">镜面IBL\r\n- LearnOpenGL CN (learnopengl-cn.github.io)</a> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/66518450\">深入理解 PBR/基于图像照明\r\n(IBL) - 知乎 (zhihu.com)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1YK4y1T7yY?p=5&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0\">Lecture5\r\nReal-time Environment Mapping哔哩哔哩bilibili</a>: Split Sum</p>\r\n<h2 id=\"杂项\"><strong>杂项</strong></h2>\r\n<ul>\r\n<li>ComputeShader 使用 cubetex：[<a\r\nhref=\"https://forum.unity.com/threads/compute-shader-use-texturecube-resolved.628891/\">Compute\r\nshader] Use TextureCube(Resolved)</a></li>\r\n<li>TextureCube&lt;float4 cubemap; SamplerState _LinearClamp; float3\r\ndir; cubemap.SampleLevel(_LinearClamp, dir, 0);</li>\r\n<li>如何向Tex指定mipmap层级写入，在 setrendertarget 指定</li>\r\n<li>compute Shader sample\r\n<ul>\r\n<li><code>float4 c = tex[id];</code></li>\r\n<li>mipmap: <code>float4 c = tex.mips[0][id]</code> or\r\n<code>tex.Load(uint3(id,0))</code></li>\r\n<li>SampleLevel:</li>\r\n<li>SampleState Sampler1 { Filter = MIN_LINEAR_MAG_MIP_POINT; }; float4\r\nt = tex.SampleLevel(Sample1, uv, 0);</li>\r\n</ul></li>\r\n<li>Sample filter <a href=\"https://enjoyphysics.cn/Article1554\">8.5\r\n纹理采样 (enjoyphysics.cn)</a></li>\r\n</ul>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">// 在倍增、缩减、多级渐进纹理上使用线性过滤。<br>SamplerState mySampler0 <br>&#123;<br>    Filter = MIN_MAG_MIP_LINEAR; <br>&#125;; <br><br>// 在缩减上使用线性过滤，倍增和多级渐进纹理上使用点过滤。<br>SamplerState mySampler1 <br>&#123; <br>    Filter = MIN_LINEAR_MAG_MIP_POINT; <br>&#125;; <br><br>// 在缩减上使用点过滤，倍增上使用线性过滤，多级渐进纹理上使用点过滤。<br>SamplerState mySampler2 <br>&#123; <br>    Filter = MIN_POINT_MAG_LINEAR_MIP_POINT; <br>&#125;; <br><br>// 在倍增、缩减、多级渐进纹理上使用各向异性过滤。<br>SamplerState mySampler3 <br>&#123; <br>    Filter = ANISOTROPIC; <br>    MaxAnisotropy = 4;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"unity-and-mipmap\"><strong>Unity And Mipmap</strong></h3>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/419644293\">【渲染】用计算着色器生成Mipmap\r\n- 知乎 (zhihu.com)</a></p>\r\n<h3 id=\"computer-指定-mipmap-写入\"><strong>Computer 指定 Mipmap\r\n写入</strong></h3>\r\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\">computeShader.SetTexture(kernal, “<span class=\"hljs-keyword\">name</span>”, tex, mipmapLevel);<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"不同光源的衰减\"><strong>不同光源的衰减</strong></h3>\r\n<p><a\r\nhref=\"https://learnopengl-cn.github.io/02%20Lighting/05%20Light%20casters/\">投光物\r\n- LearnOpenGL CN (learnopengl-cn.github.io)</a> <a\r\nhref=\"https://catlikecoding.com/unity/tutorials/custom-srp/point-and-spot-lights/\">Point\r\nand Spot Lights (catlikecoding.com)</a></p>\r\n<h4 id=\"point-light\"><strong>Point Light</strong></h4>\r\n<ul>\r\n<li><span class=\"math inline\">\\((\\,max(0,\r\n1-(\\frac{d^2}{r^2})^2)\\,)^2\\)</span>，r 是 point light 的范围</li>\r\n<li><span\r\nclass=\"math inline\">\\(\\frac{1.0}{K_c+K_l*d+K_q*d^2}\\)</span></li>\r\n</ul>\r\n<h3 id=\"shadergui\"><strong>ShaderGUI</strong></h3>\r\n<p>通过编写 ShaderGUI 在 Material 面板控制 shader properties</p>\r\n<p>或 en/dis able keyword</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">public class MyShaderGUI : ShaderGUI<br>&#123;<br>    public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties)<br>    &#123;<br>        base.OnGUI(materialEditor, properties);<br>        Material material = materialEditor.target as Material;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>在 Shader 结尾加上</p>\r\n<p>CustomEditor \"MyLearnPBRGUI\";</p>\r\n<h2 id=\"urp-光\"><strong>URP 光</strong></h2>\r\n<p><a\r\nhref=\"https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/light-component.html\">Light\r\n组件参考 | Universal RP | 12.1.1 (unity3d.com)</a> <a\r\nhref=\"https://docs.unity3d.com/cn/current/Manual/LightModes.html\">光照模式\r\n- Unity 手册 (unity3d.com)</a> <a\r\nhref=\"https://docs.unity3d.com/cn/current/Manual/LightMode-Baked.html\">光源模式：Baked\r\n- Unity 手册 (unity3d.com)</a></p>\r\n<h3 id=\"lighting\"><strong>Lighting</strong></h3>\r\n<ul>\r\n<li>Scene/Mixed Lighting/Lighting Mode\r\n<ul>\r\n<li><strong>Baked Indirect</strong>: <a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-BakedIndirect.html\">Lighting\r\nMode：Baked Indirect - Unity 手册</a> 混合光源的行为类似于<a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightMode-Realtime.html\">实时光源</a>，但有额外的好处是会<strong>将间接光照烘焙到光照贴图中</strong>。<strong>混合(Mixed)光源照亮的游戏对象会投射实时阴影</strong>，最大距离是在项目中定义的<a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/shadow-distance.html\">阴影距离\r\n(Shadow Distance)</a>。</li>\r\n<li><strong>Shadow Mask</strong>: <a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Shadowmask.html\">Lighting\r\nMode：Shadowmask - Unity 手册</a>\r\n与烘焙间接照明模式类似，阴影遮罩照明模式将<strong>实时直接照明</strong>与<strong><a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightMode-Baked.html\">烘焙间接照明</a>(Baked\r\nIndirect Lighting\r\nMode)</strong>相结合。但是，“阴影蒙版”照明模式与烘焙间接照明模式的不同之处在于它渲染阴影的方式。阴影蒙版光照模式使\r\nUnity\r\n可以在运行时组合烘焙阴影和实时阴影，并在远处渲染阴影。它通过使用称为阴影蒙版的附加光照贴图纹理，并在<a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightProbes.html\">光照探针</a>中存储其他信息来实现此目的。Unity\r\n为烘焙阴影生成阴影蒙版和 Light Probe 遮挡数据。</li>\r\n<li><strong>Subtractive</strong>: <a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Subtractive.html\">Lighting\r\nMode：Subtractive - Unity 手册</a> 在 Subtractive\r\n光照模式下，场景中的所有混合光源都提供烘焙直接光照和间接光照。Unity\r\n将静态游戏对象投射的阴影烘焙到光照贴图中。除了烘焙阴影外，一种方向光（称为主方向光）还为动态游戏对象提供实时阴影。\r\n因为阴影被烘焙到光照贴图中，所以 Unity\r\n在运行时缺少将烘焙阴影和实时阴影准确地结合在一起所需的信息。但是，Unity\r\n提供了 <strong>Realtime Shadow Color</strong>\r\n属性来减少光照贴图的影响，从而在烘焙阴影和实时阴影之间创建正确的混合视觉效果。还可以调整颜色来实现某种艺术风格。\r\nSubtractive\r\n光照模式在低端硬件上非常有用，因为低端硬件需要注重性能，并且只需要一个实时阴影投射光源。这种光照模式不会提供特别逼真的光照效果，而是更适合风格化美学，例如卡通风格。</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"isotropic-anisotropic-brdfs\"><strong>Isotropic / Anisotropic\r\nBRDFs</strong></h2>\r\n<p><span class=\"math display\">\\[f_r(\\theta_i,\\phi_i;\\theta_r,\\phi_r)\\ne\r\nf_r(\\theta_i,\\phi_i,\\phi_r-\\phi_i)\\\\\r\ni\\;is\\;input,\\;r\\;is\\;reflection\\;dir.\\]</span></p>\r\n<h3 id=\"ndf\"><strong>NDF</strong></h3>\r\n<p><strong>形状不变性</strong></p>\r\n<ul>\r\n<li><p>是一个合格的法线分布函数需要具备的重要性质。具有形状不变性（shape-invariant）的法线分布函数，可以用于推导该函数的归一化的各向异性版本，并且可以很方便地推导出对应的遮蔽阴影项G。</p></li>\r\n<li><p>若一个各向同性的NDF可以改写成以下形式，则这个NDF具有形状不变性（shape-invariant）：</p></li>\r\n<li><p><span class=\"math display\">\\[D(m)=\\frac{1}{\\alpha_2(n\\cdot\r\nm)^4}g(\\frac{\\sqrt{1-(n\\cdot m)^2}}{\\alpha(n\\cdot m)})\\]</span></p></li>\r\n<li><p>其中g（）代表一个表示了NDF形状的一维函数。</p></li>\r\n</ul>\r\n<h4 id=\"anisotropic-beckmann-distribution\"><strong>Anisotropic Beckmann\r\nDistribution</strong></h4>\r\n<p><span\r\nclass=\"math display\">\\[D_{Baniso}(m)=\\frac{1}{\\pi\\alpha_x\\alpha_y(n\\cdot\r\nm)^4}exp(-\\frac{\\frac{(t\\cdot m)^2}{\\alpha_x^2}+\\frac{(b\\cdot\r\nm)^2}{\\alpha_y^2}}{(n\\cdot m)^2})\\]</span></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">// Anisotropic Beckmann<br>float D_Beckmann_aniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )<br>&#123;<br>    float XoH = dot( X, H );<br>    float YoH = dot( Y, H );<br>    float d = - (XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay)) / NoHNoH;<br>*    return exp(d) / ( PI * ax*ay * NoH * NoH * NoH * NoH );<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"trowbridge-reitz-ggx-anisotropic\"><strong>Trowbridge-Reitz GGX\r\nAnisotropic</strong></h4>\r\n<p><span\r\nclass=\"math display\">\\[D_{GGXaniso}(m)=\\frac{1}{\\pi\\alpha_x\\alpha_y}\\frac{1}{(\\frac{(x\\cdot\r\nm)^2}{\\alpha_x^2}+\\frac{(y\\cdot m)^2}{\\alpha_y^2}+(n\\cdot\r\nm))^2}\\]</span></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">// Anisotropic GGX<br>// [Burley 2012, &quot;Physically-Based Shading at Disney&quot;]<br>float D_GGXaniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )<br>&#123;<br>    float XoH = dot( X, H );<br>    float YoH = dot( Y, H );<br>    float d = XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay) + NoHNoH;<br>*    return 1 / ( PI * ax*ay * d*d );<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>其中，X为tangent，t切线方向，Y为binormal，b，副法线方向</li>\r\n<li>需要注意的是，将法线贴图与各向异性BRDF组合时，重要的是要确保法线贴图扰动（perturbs）切线和副切线矢量以及法线</li>\r\n</ul>\r\n<p><a\r\nhref=\"https://cgg.mff.cuni.cz/~jaroslav/papers/2010-anisobrdf/2010-anisobrdf.pdf\">2010-anisobrdf.pdf\r\n(cuni.cz)</a> <a href=\"https://www.shadertoy.com/view/3tyXRt\">Slope: GGX\r\nAnisotropic (shadertoy.com)</a></p>\r\n<h3 id=\"geometry-function\"><strong>Geometry Function</strong></h3>\r\n<p><span class=\"math display\">\\[G_1(m,v)=\\frac{clamp(0,1,m\\cdot\r\nv)}{1+\\Lambda(v)}\\]</span></p>\r\n<h4 id=\"beckmann\"><strong>Beckmann</strong></h4>\r\n<p><span\r\nclass=\"math display\">\\[\\Lambda(v)=\\frac{erf(a)-1}{2}+\\frac{1}{2a\\sqrt{\\pi}}exp(-a^2)\\\\\r\na=\\frac{1}{\\alpha\\tan\\theta_o}\\]</span></p>\r\n<h4 id=\"ggx\"><strong>GGX</strong></h4>\r\n<p><span\r\nclass=\"math display\">\\[\\Lambda(v)=\\frac{-1+\\sqrt{1+\\frac{1}{a^2}}}{2}\\\\\r\na=\\frac{1}{\\alpha\\tan\\theta_o}\\]</span></p>\r\n<h3 id=\"anisotropic-geometry-function\"><strong>Anisotropic Geometry\r\nFunction</strong></h3>\r\n<h4 id=\"smith\"><strong>Smith</strong></h4>\r\n<p>假设我们拉伸x轴，将各向同性的法线分布转变为各向异性的。</p>\r\n<p>假设各向异性的粗糙度参数有a_x,a_y，视线v(x_o,y_o,z_o)，通过拉伸x轴</p>\r\n<p><span class=\"math display\">\\[a_x&#39;=a_x\\frac{a_y}{a_x}=a_y\\\\\r\na_y&#39;=a_y\\]</span></p>\r\n<p>也就是粗糙度=_y</p>\r\n<p><span\r\nclass=\"math display\">\\[v&#39;=(\\frac{\\alpha_x}{\\alpha_y}x_o,y_o,z_o)=(\\frac{\\alpha_x}{\\alpha_y}\\cos\\phi_o\\sin\\theta_o,\\sin\\phi_o\\sin\\theta_o,\\cos\\theta_o)\\\\\r\n\\frac{1}{\\tan\\theta&#39;_o}=\\frac{z_o}{\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}x_o^2+y_o^2}}=\\frac{1}{\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}\\cos^2\\phi_o+\\sin^2\\phi_o}\\cdot\\tan\\theta_o}\\\\\r\nBecause:a=\\frac{1}{\\alpha\\tan\\theta_o}\\\\\r\na&#39;=\\frac{1}{a_y\\tan\\theta_o}=\\frac{1}{a_y\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}\\cos^2\\phi_o+\\sin^2\\phi_o}\\cdot\\tan\\theta_o}\\\\\r\n=\\frac{1}{\\sqrt{\\alpha_x^2\\cos^2\\phi_o+\\alpha_y^2\\sin^2\\phi_o}\\cdot\\tan\\theta_o}\\]</span></p>\r\n<p><a\r\nhref=\"https://blog.csdn.net/haozi2008/article/details/112284028\">PBR 五\r\n几何遮蔽函数遮蔽因子函数wuhaocat的博客-CSDN博客</a></p>\r\n<p><a\r\nhref=\"https://github.com/QianMo/PBR-White-Paper/blob/master/content/part%205/README.md\">PBR-White-Paper/content/part\r\n5/README.md at master · QianMo/PBR-White-Paper (github.com)</a></p>\r\n<h3 id=\"output-1\"><strong>Output</strong></h3>\r\n<p><img src=\"/imgs/LearnPBR/output4-1.PNG\" alt=\"output4-1\" style=\"zoom:50%;\" /></p>\r\n<p><img src=\"/imgs/LearnPBR/AnisoSphere2.png\" alt=\"AnisoSphere2\" style=\"zoom:50%;\" /></p>\r\n<h3 id=\"anisotropic-ibl\"><strong>Anisotropic IBL</strong></h3>\r\n<h4 id=\"split-sum-2nd\"><strong>Split Sum 2nd</strong></h4>\r\n<p><span class=\"math display\">\\[R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\\r\nR_0-R_0(1-\\cos\\theta)^5+(1-\\cos\\theta)^5\\\\\r\n\\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i\\approx\\\\\r\nR_0\\int_{\\Omega^+}\\frac{f_r}{F}(1-(1-\\cos\\theta)^5)\\cos\\theta_i\\,\\mathrm{d}w_i+\\int_{\\Omega^+}\\frac{f_r}{F}(1-\\cos\\theta)^5\\cos\\theta_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>roughness_x, roughness_y, theta 相关3D LUT了</p>\r\n<h2\r\nid=\"todo动态天空的环境光怎么计算\"><strong>[TODO]动态天空的环境光怎么计算</strong></h2>\r\n<p>提前烘焙，插值。</p>\r\n<p>TOD</p>\r\n<p>像大气散射，其实已经计算了 LUT 所以可以直接使用。</p>\r\n<h2 id=\"unity-specular-cube0\">Unity Specular Cube0</h2>\r\n<p><a\r\nhref=\"https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlsl#L620\">Graphics/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlsl\r\nat 19518485b3edcf19f267f293f899d5d25e734a17 ·\r\nUnity-Technologies/Graphics (github.com)</a></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs hlsl\">half mip = PerceptualRoughnessToMipmapLevel(perceptualRoughness);<br>    half4 encodedIrradiance = SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip);<br>    half3 irradiance = DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);<br>    return irradiance * occlusion;<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"perceptualroughnesstomipmaplevel\">PerceptualRoughnessToMipmapLevel</h3>\r\n<p><a\r\nhref=\"https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl#L27\">Graphics/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl\r\nat 19518485b3edcf19f267f293f899d5d25e734a17 ·\r\nUnity-Technologies/Graphics (github.com)</a></p>\r\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs d\"><span class=\"hljs-built_in\">real</span> PerceptualRoughnessToMipmapLevel(<span class=\"hljs-built_in\">real</span> perceptualRoughness, <span class=\"hljs-built_in\">uint</span> maxMipLevel)<br>&#123;<br>    perceptualRoughness = perceptualRoughness * (<span class=\"hljs-number\">1.7</span> - <span class=\"hljs-number\">0.7</span> * perceptualRoughness);<br><br>    <span class=\"hljs-keyword\">return</span> perceptualRoughness * maxMipLevel;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0,\r\nreflectVector, mip);</p>\r\n<h2 id=\"参考-3\"><strong>参考</strong></h2>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/timlly/p/10631718.html\">由浅入深学习PBR的原理和实现\r\n- 0向往0 - 博客园 (cnblogs.com)</a><br />\r\n<a\r\nhref=\"https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\">course_notes_moving_frostbite_to_pbr_v32.pdf\r\n(wordpress.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/53086060\">【基于物理的渲染（PBR）白皮书】（一）\r\n开篇：PBR核心知识体系总结与概览 - 知乎 (zhihu.com)</a><br />\r\n<a href=\"https://www.pbr-book.org/3ed-2018/contents\">Physically Based\r\nRendering: From Theory to Implementation (pbr-book.org)</a><br />\r\nReal-Time Rendering Fourth Edition 第九章<br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV1YK4y1T7yY?p=10&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0\">Lecture10\r\nReal-Time Physically-based Materials (surface\r\nmodels)哔哩哔哩bilibili</a><br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV1YK4y1T7yY?p=11&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0\">Lecture11\r\nReal-Time Physically-based Materials (surface models\r\ncont.)哔哩哔哩bilibili</a><br />\r\nUE4: <a\r\nhref=\"https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\">2013SiggraphPresentationsNotes-26915738.pdf\r\n(unrealengine.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/144611412\">寒霜引擎的PBR实践3.0（一）材质篇\r\n- 知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/158261389\">寒霜引擎的PBR实践3.0（二）光照篇——光照强度与精确光源\r\n- 知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/186541854\">寒霜引擎的PBR实践3.0（三）光照篇——光度学灯与区域光\r\n- 知乎 (zhihu.com)</a><br />\r\n[<a href=\"https://zhuanlan.zhihu.com/p/121719442\">译]Real Shading in\r\nUnreal Engine 4（UE4中的真实渲染)(1) - 知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://zznewclear13.github.io/posts/calculate-spherical-harmonics-using-compute-shader/\">使用Compute\r\nShader计算球谐全局光照 | ZZNEWCLEAR13</a></p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>关于PBR的一些知识点</p>\r\n<h1 id=\"learn-pbr\">Learn PBR</h1>\r\n<h1 id=\"pbr理论\">PBR理论</h1>\r\n<h2 id=\"简介\"><strong>简介</strong></h2>\r\n<p><strong>PBR</strong>（<strong>Physically Based\r\nRendering</strong>）译成中文是基于物理的渲染。它是利用真实世界的原理和理论，通过各种数学方法推导或简化或模拟出一系列渲染方程，并依赖计算机硬件和图形API渲染出拟真画面的技术。</p>\r\n<h3 id=\"pbr-特征\"><strong>PBR</strong> <strong>特征</strong></h3>\r\n<p>更高质量的着色效果和更多复杂的材质特性。</p>\r\n<ul>\r\n<li>表面细节</li>\r\n<li>物体粗糙度</li>\r\n<li>区别明显的金属和绝缘体</li>\r\n<li>物体的浑浊程度</li>\r\n<li>菲涅尔现象：不同角度有不同强度的反射光</li>\r\n<li>半透明物体</li>\r\n<li>多层混合材质</li>\r\n<li>清漆效果</li>\r\n<li>其它更复杂的表面特征</li>\r\n</ul>\r\n<blockquote>\r\n<p>近今年，PBR的技术主要朝着更逼真、更复杂、效能更好的方向，或是结合若干种模型的综合性技术迈进。代表性技术有：</p>\r\n<ul>\r\n<li>PBR Diffuse for GGX + Smith (2017)</li>\r\n<li>MultiScattering Diffuse (2018)</li>\r\n<li>Layers Material（分层材质）</li>\r\n<li>Mixed Material（混合材质）</li>\r\n<li>Mixed BxDF（混合BxDF）</li>\r\n<li>Advanced Rendering（进阶渲染）</li>\r\n</ul>\r\n</blockquote>\r\n<h3 id=\"output\"><strong>OutPut</strong></h3>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/output.PNG\" alt=\"output\" />\r\n<figcaption aria-hidden=\"true\">output</figcaption>\r\n</figure>\r\n<h2 id=\"pbr-和-游戏引擎\"><strong>PBR</strong> <strong>和\r\n游戏引擎</strong></h2>\r\n<h3 id=\"ue4-的-pbr\"><strong>UE4 的</strong> <strong>PBR</strong></h3>\r\n<ul>\r\n<li><strong>Base Color</strong>，基础的纹理颜色\r\n非金属物体只有<strong>单色</strong>，即强度</li>\r\n</ul>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>Material</th>\r\n<th>Base Color Intensity</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>木炭(Charcoal)</td>\r\n<td>0.02</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>新沥青(Fresh asphalt)</td>\r\n<td>0.02</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>旧沥青(Worn asphalt)</td>\r\n<td>0.08</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>土壤(Bare soil)</td>\r\n<td>0.13</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>绿草(Green Grass)</td>\r\n<td>0.21</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>沙漠沙(desert sand)</td>\r\n<td>0.36</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>新混泥土(Fresh concrete)</td>\r\n<td>0.51</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>海洋冰(Ocean Ice)</td>\r\n<td>0.56</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>鲜雪(Fresh snow)</td>\r\n<td>0.81</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li><strong>金属</strong>材质，在 Linear 空间的值</li>\r\n</ul>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>材质(Material)</th>\r\n<th>基础色(BaseColor)</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>铁(Iron)</td>\r\n<td>(0.560, 0.570, 0.580)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>银(Silver)</td>\r\n<td>(0.972, 0.960, 0.915)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>铝(Aluminum)</td>\r\n<td>(0.913, 0.921, 0.925)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>金(Gold)</td>\r\n<td>(1.000, 0.766, 0.336)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>铜(Copper)</td>\r\n<td>(0.955, 0.637, 0.538)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>铬(Chromium)</td>\r\n<td>(0.550, 0.556, 0.554)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>镍(Nickel)</td>\r\n<td>(0.660, 0.609, 0.526)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>钛(Titanium)</td>\r\n<td>(0.542, 0.497, 0.449)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>钴(Cobalt)</td>\r\n<td>(0.662, 0.655, 0.634)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>铂(Platinum)</td>\r\n<td>(0.672, 0.637, 0.585)</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li><strong>粗糙度(Roughness)</strong>：表面的粗糙程度,\r\n[0,1]，越粗糙高光越弱。</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/roughness.png\" alt=\"roughness\" />\r\n<figcaption aria-hidden=\"true\">roughness</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/roughness2.png\" alt=\"roughness2\" />\r\n<figcaption aria-hidden=\"true\">roughness2</figcaption>\r\n</figure>\r\n<p>上为非金属，下为金属，粗糙度从0至1</p>\r\n<ul>\r\n<li><strong>金属度(Metallic)</strong>：表示材质像金属的程度，0是绝缘体(电介质)，1\r\n是金属，金属只有镜面反射，没有漫反射。</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/metallic.png\" alt=\"metallic\" />\r\n<figcaption aria-hidden=\"true\">metallic</figcaption>\r\n</figure>\r\n<p>金属度从0至1</p>\r\n<ul>\r\n<li><strong>镜面度(Specular)</strong>：表示物体镜面反射的强度，从0(完全没有镜面反射)到1(完全镜面反射)</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/specular.png\" alt=\"specular\" />\r\n<figcaption aria-hidden=\"true\">specular</figcaption>\r\n</figure>\r\n<p>From 0 ~ 1</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>材质(Material)</th>\r\n<th>镜面度(Specular)</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>草(Glass)</td>\r\n<td>0.5</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>塑料(Plastic)</td>\r\n<td>0.5</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>石英(Quartz)</td>\r\n<td>0.57</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>冰(Ice)</td>\r\n<td>0.224</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>水(Water)</td>\r\n<td>0.255</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>牛奶(Milk)</td>\r\n<td>0.277</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>皮肤(Skin)</td>\r\n<td>0.35</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"unity-的-pbr\"><strong>Unity 的</strong>\r\n<strong>PBR</strong></h3>\r\n<ul>\r\n<li><strong>Albedo</strong>，和 UE 的 Base Color 一样。\r\n可以用颜色或者Tex</li>\r\n<li><strong>Metallic</strong>，可以用金属贴图，但是用了 Smoothness\r\n参数就消失了</li>\r\n<li><strong>Smoothness</strong>，光滑度，和 UE 的 粗糙度正相反\r\n<ul>\r\n<li><strong>Smoothness\r\nSource</strong>，指定光滑度的存储通道，可选金属度、镜面贴图的 Alpha\r\n或基础色的 Alpha</li>\r\n</ul></li>\r\n<li><strong>Occlusion</strong>：遮蔽图，指定材质接收间接光的光照强度和反射强度。\r\n能够使物体经常是暗部的位置更暗，比如人的眼窝，脸和脖子的交接处。</li>\r\n<li><strong>Fresnel</strong>，物体边缘或者说物体法线和视线角度增大，物体的反射能力更强，Unity\r\n里面是自动处理，越光滑越强，越粗糙 Fresnel 越弱。</li>\r\n</ul>\r\n<h2 id=\"pbr-基本原理\"><strong>PBR</strong>\r\n<strong>基本原理</strong></h2>\r\n<p>满足以下条件的光照模型才能称之为PBR光照模型：</p>\r\n<ul>\r\n<li>基于微平面模型（Be based on the microfacet surface model）。</li>\r\n<li>能量守恒（Be energy conserving）。</li>\r\n<li>使用基于物理的BRDF（Use a physically based BRDF）。</li>\r\n</ul>\r\n<h3\r\nid=\"微表面理论microfacet\"><strong>微表面理论(Microfacet)</strong></h3>\r\n<p>很多 PBR 技术都是基于理论\r\n认为<strong>在微观上</strong>，所有的物体表面都是由很多的朝向不一的微小平面组成的。</p>\r\n<blockquote>\r\n<p>真实世界的物体表面其实不一定是这样的微小平面，可能会有弧度，甚至坑坑洼洼，但我们从肉眼观察、甚至<em>光栅化后的像素尺度</em>来看待的话，这种假设的结果和实际差别甚微。</p>\r\n</blockquote>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/microfacet.png\" alt=\"microfacet\" />\r\n<figcaption aria-hidden=\"true\">microfacet</figcaption>\r\n</figure>\r\n<p>基于这种假设，没有任何表面是光滑的，但由于这些微平面已经微小到逐像素无法对其进行细分，所以假设一个粗糙度\r\nRoughness，用统计学的方法去估算微表面的粗糙度。</p>\r\n<p>...</p>\r\n<h3 id=\"energy-conservation-能量守恒\"><strong>Energy Conservation\r\n(能量守恒)</strong></h3>\r\n<p>在 Microfacet\r\n中采用近似的能量守恒定律，出射光的总能量不能超过入射光的总能量(不含自发光)，</p>\r\n<p>所以材质粗糙度越大，反射的范围越大，整体的亮度会变低。</p>\r\n<h4\r\nid=\"镜面反射specular和漫反射diffuse\"><strong>镜面反射(specular)和漫反射(diffuse)</strong></h4>\r\n<p>一束光打到物体，会发生 <strong>reflection</strong> 反射 和\r\n<strong>refraction</strong>\r\n折射。反射的光直接离开，不进入物体发射了镜面反射光；折射的光进入物体内发生了吸收或散射，产生漫反射。\r\n折射后的光若没被吸收会继续前进，在物体内部发生光和微粒的碰撞，这时有一部分能力转化为热量，有些光经过多次折射从表面射出，便形成漫反射光。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/reflect.png\" alt=\"reflect\" />\r\n<figcaption aria-hidden=\"true\">reflect</figcaption>\r\n</figure>\r\n<p><em>照射在平面的光被分成镜面反射和折射光，折射光在跟物体微粒发生若干次碰撞之后，有可能发射出表面，成为漫反射。</em>\r\n通常情况下，PBR会简化折射光，将平面上所有折射光都视为被完全吸收而不会散开。而有一些被称为次表面散射(Subsurface\r\nScattering)技术的着色器技术会计算折射光散开后的模拟，它们可以显著提升一些材质（如皮肤、大理石或蜡质）的视觉效果，不过性能也会随着下降。\r\n金属(Metallic)材质会立即吸收所有折射光，故而金属只有镜面反射，而没有折射光引起的漫反射。</p>\r\n<p>根据上面的能量守恒关系，可以先计算镜面反射部分，此部分等于入射光线被反射的能量所占的百分比。而折射部分可以由镜面反射部分计算得出。</p>\r\n<p>float kS = calculateSpecularComponent(...); // 反射/镜面部分</p>\r\n<p>float kD = 1.0 - kS; // 折射/漫反射部分</p>\r\n<p>ks + kd 不会超过1，所以近似地能量守恒。</p>\r\n<h3 id=\"reflectance-equation\"><strong>Reflectance Equation</strong></h3>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int\\limits_{\\Omega}f_r(p,w_i,w_0)L_i(p,w_i)\\,\\mathrm{d}w_i\\]</span></p>\r\n<h2 id=\"辐射度量学\"><strong>辐射度量学</strong></h2>\r\n<h3 id=\"概念表\"><strong>概念表</strong></h3>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/chart1.png\" alt=\"chart1\" />\r\n<figcaption aria-hidden=\"true\">chart1</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/chart2.png\" alt=\"chart2\" />\r\n<figcaption aria-hidden=\"true\">chart2</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>微分符号 d\r\n的含义：首先来说下微分的定义：设f(x)定义在区间(a,b)上，x∈(a,b),给定自变量x的一个增量Δx，得到函数的一个增量Δy，如果有Δy=f(x+Δx)-f(x)=AΔx+o(Δx)(Δx→0)，则y=f(x)称在点x可微，函数增量的线性主部AΔx称为函数的微分，记为dy=df(x)=AΔx</p>\r\n</blockquote>\r\n<h3 id=\"辐射通量radiant-flux\"><strong>辐射通量（Radiant\r\nFlux)</strong></h3>\r\n<p>光源单位时间内的输出<span\r\nclass=\"math display\">\\[\\Phi=\\frac{\\mathrm{d}Q}{\\mathrm{d}t}\\]</span></p>\r\n<blockquote>\r\n<p>光是由多种不同波长的能量集合而成，每种波长与一种特定的（可见的）颜色相关。因此一个光源所放射出来的能量可以被视作这个光源包含的所有各种波长的一个函数。波长介于390nm（纳米）到700nm的光被认为是处于可见光光谱中，也就是说它们是人眼可见的波长。</p>\r\n</blockquote>\r\n<p>传统物理学上的辐射通量将会计算这个由不同波长构成的函数的总面积，这种计算很复杂，耗费大量性能。在PBR技术中，不直接使用波长的强度，而是使用三原色编码（RGB）来简化辐射通量的计算。虽然这种简化会带来一些信息上的损失，但是这对于视觉效果上的影响基本可以忽略。</p>\r\n<h3 id=\"radiant-insensity辐射强度\"><strong>Radiant\r\nInsensity(辐射强度)</strong></h3>\r\n<p>单位球面上，一个光源向单位立体角所投送的辐射通量。</p>\r\n<p><span\r\nclass=\"math display\">\\[I=\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}w}\\]</span></p>\r\n<p>the power per unit angle</p>\r\n<p>假如光源均匀向四周发散</p>\r\n<p><span class=\"math display\">\\[I = \\frac{\\Phi}{4\\pi}\\]</span></p>\r\n<h3 id=\"irradiance\"><strong>Irradiance</strong></h3>\r\n<p>The power per (perpendicular/projected) unit area incident on a\r\nsurface point.</p>\r\n<p><span\r\nclass=\"math display\">\\[E(x)=\\frac{\\mathrm{d}\\Phi(x)}{\\mathrm{d}A^\\perp\r\n}\\]</span></p>\r\n<p>面要和光源垂直。</p>\r\n<p>即 Lambert‘s Consine Law</p>\r\n<h3 id=\"radiance\"><strong>Radiance</strong></h3>\r\n<p>The radiance(luminance) is the power emitted, reflected, transmitted\r\nor received by a surface, <em>per unit solid angle, per projected unit\r\narea.</em> 在单位立体角并且在单位的面积上</p>\r\n<p><span\r\nclass=\"math display\">\\[L(p,w)=\\frac{\\mathrm{d}^2\\Phi(p,w)}{\\mathrm{d}w\\,\\mathrm{d}A\\cos\\theta}=\\frac{\\mathrm{d}^2\\Phi(p,w)}{\\mathrm{d}w\\,\\mathrm{d}A^\\perp}\\]</span></p>\r\n<ul>\r\n<li>Irradiance: power per projected unit area</li>\r\n<li>Intensity: power per solid angle</li>\r\n</ul>\r\n<p>So</p>\r\n<ul>\r\n<li>Radiance : Irrandiance pre solid angle</li>\r\n<li>Radiance : Intensity pre unit projected area</li>\r\n</ul>\r\n<p>Irradiance 是 dA 收到的能量</p>\r\n<p>Irradiance per solid angle 是 dA 的能量向某一个方向辐射</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/Radiance.png\" alt=\"Radiance\" />\r\n<figcaption aria-hidden=\"true\">Radiance</figcaption>\r\n</figure>\r\n<p>该图为 Irrandicance per solid angle, 这的 cos 是不是应该写进 E\r\n里面……</p>\r\n<p>Incident Radiance 延申理解：</p>\r\n<p>一小块面积 dA 向某个方向辐射的能量</p>\r\n<p>反过来就是，从一个方向打向一个小面，到达这个面时的能量</p>\r\n<p><span\r\nclass=\"math display\">\\[L(p,w)=\\frac{\\mathrm{d}I(p,w)}{\\mathrm{d}A\\cos\\theta}=\\frac{\\mathrm{d}I(p,w)}{\\mathrm{d}A^\\perp}\\]</span></p>\r\n<h3 id=\"irradiance-vs.-radiace\"><strong>Irradiance vs.\r\nRadiace</strong></h3>\r\n<p><span\r\nclass=\"math display\">\\[\\mathrm{d}E(p,w)=L_i(p,w)\\cos\\theta\\,\\mathrm{d}w\\\\\\]</span></p>\r\n<p>两边同时积分</p>\r\n<p><span\r\nclass=\"math display\">\\[E(p)=\\int_H^2L_i(p,w)\\cos\\theta\\,\\mathrm{d}w\\\\\r\nUint\\;Hemisphere:H^2\\]</span></p>\r\n<p>每个方向过来到 A 的能量, 这和渲染方程是异曲同工的。</p>\r\n<p>再回到渲染方程</p>\r\n<p><span class=\"math display\">\\[L_0(p,w_0)=\\int\\limits_\\Omega\r\nf_r(p,w_i,w_0)\\underbrace{L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i}_{Radiace}\\]</span></p>\r\n<p>其中只有 f 项待解。</p>\r\n<h2\r\nid=\"brdf双向反射分布函数\"><strong>BRDF(双向反射分布函数)</strong></h2>\r\n<p>Bidirectional Reflectance Distribution Function，BRDF</p>\r\n<p>一个使用入射光方向ωi作为输入参数的函数，输出参数为出射光ωo，表面法线为n，参数a表示的是微平面的粗糙度。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/BRDF.svg\" alt=\"BRDF\" />\r\n<figcaption aria-hidden=\"true\">BRDF</figcaption>\r\n</figure>\r\n<p>BRDF\r\n描述了不透明物体表面每个单独光线，对最终反射光线的影响。也就是光线打到该表面如何反射，</p>\r\n<p>假设BRDF描述的是完全镜面物体，只有当出射光线方向w0 完全符号\r\n入射光线方向wi 的反射方向时，返回值会为1.0，其余情况为0.</p>\r\n<p><span\r\nclass=\"math display\">\\[f_r(p,w_0,w_i)=\\frac{\\mathrm{d}L_0(p,w_0)}{\\mathrm{d}E(p,w_i)}=\\frac{\\mathrm{d}L_0(p,w_0)}{L_i(p,w_i)\\cos\\theta_i\\,\\mathrm{d}w_i}\\]</span></p>\r\n<p>BRDF 有多种模拟表面光照的算法，实时渲染所用的基本是\r\n<strong>Cook-Torrance BRDF</strong></p>\r\n<h3 id=\"参考\"><strong>参考</strong></h3>\r\n<ul>\r\n<li><strong>PBRT-BRDF章节：</strong><a\r\nhref=\"https://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Surface_Reflection\">Surface\r\nReflection (pbr-book.org)</a></li>\r\n</ul>\r\n<h3 id=\"cook-torrance-brdf\"><strong>Cook-Torrance BRDF</strong></h3>\r\n<p><span\r\nclass=\"math display\">\\[f_r=k_df_{lambert}+k_sf_{cook-torrance}\\\\\r\nk_d是入射光被折射比例，\\\\ k_s是被镜面反射比例\\]</span></p>\r\n<p>而左侧的 f_lambert 表示漫反射部分，Lambertian\r\nDiffuse，一般是恒定的算式：</p>\r\n<p><span class=\"math display\">\\[f_{lambert}=\\frac{c}{\\pi}\\]</span></p>\r\n<p>c 表示 Albedo，π 是为了归一化 漫反射，因为后面要积分的</p>\r\n<h4 id=\"brdf的高光项\"><strong>BRDF的高光项</strong></h4>\r\n<p><span class=\"math display\">\\[f_{cook-torrance}=\\frac{DFG}{4(w_0\\cdot\r\nn)(w_i\\cdot n)}\\]</span></p>\r\n<ul>\r\n<li><strong>D( Normal Distribution Function, NDF )</strong> :\r\n法线分布，估算在表面粗糙度的影响下，表现出的表面法线和半角向量(half\r\nDir)的一致性或者说微表面的数量。 估算微表面的主要函数。</li>\r\n<li><strong>F( Fresnel Equation\r\n)</strong>：菲涅尔方程，描述菲涅尔现象，当视线和表面法线夹角变大时更容易发生光的反射。\r\n不同表面角下，表面反射光线的比例。</li>\r\n<li><strong>G( Geometry Function )</strong> :\r\n几何函数，描述了微表面自成影的现象，当一个微表面特别粗糙时，彼此之间可能相互遮挡，从而减少反射的光线。</li>\r\n</ul>\r\n<p><a\r\nhref=\"https://www.zhihu.com/question/28476602/answer/41003204\">brdf为什么要定义为一个单位是sr-1的量？\r\n- 知乎 (zhihu.com)</a> <a\r\nhref=\"https://www.zhihu.com/question/28476602/answer/41003204\">brdf为什么要定义为一个单位是sr-1的量？\r\n- 文刀秋二的回答:</a></p>\r\n<h3 id=\"dnormal-distribution-function-ndf\"><strong>D(Normal Distribution\r\nFunction, NDF)</strong></h3>\r\n<p>描述和微表面法线和半角向量的一致性，从统计学上近似\r\n<strong>Trowbridge-Reitz GGX(GGXTR) :</strong></p>\r\n<p><span\r\nclass=\"math display\">\\[{NDF}_{GGXTR}(n,h,\\alpha)=\\frac{\\alpha^2}{\\pi((n\\cdot\r\nh)^2(\\alpha^2-1)+1)^2}\\\\ h=normalize(viewDir+lightDir)\\\\\r\n\\alpha={roughness}^2\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/ggx.png\" alt=\"ggx\" />\r\n<figcaption aria-hidden=\"true\">ggx</figcaption>\r\n</figure>\r\n<p><a\r\nhref=\"https://www.desmos.com/calculator/eks25xlifv?lang=zh-CN\">Trowbridge-Reitz\r\nGGX | Desmos</a></p>\r\n<p>当 粗糙度 为零时函数值变为零</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">float DoubleDistributeGGX(float3 N, float3 H, float roughness)<br>&#123;<br>    float a = roughness * roughness;<br>    float a2 = a * a;<br>    float NdotH = max(0.0, dot(N, H));<br>    float NdotH2 = NdotH * NdotH;<br><br>    float p = (NdotH2 * (a2 - 1.0) + 1.0);<br>    p = PI * p * p;<br>    return a2 / p;<br>&#125;<br><br>roughness += 0.0001;<br>float NDF = DoubleDistributeGGX(N, H, roughness);<br></code></pre></td></tr></table></figure>\r\n<p><a\r\nhref=\"https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\">2013SiggraphPresentationsNotes-26915738.pdf\r\n(unrealengine.com): Specular D</a></p>\r\n<h4\r\nid=\"generalized-trowbridge-reitzgtr分布\"><strong>Generalized-Trowbridge-Reitz（GTR）分布</strong></h4>\r\n<p>GTR分布不具备形状不变性（shape-invariant），导致其发布以来，无法被广泛使用。</p>\r\n<p><span class=\"math display\">\\[D_{GTR}(m)=\\frac{c}{(1+(n\\cdot\r\nm)^2(\\alpha^2-1))^\\gamma}\\]</span></p>\r\n<ul>\r\n<li>关于形状不变性的好处，可以总结为：\r\n<ul>\r\n<li>方便推导出该NDF归一化的各向异性版本</li>\r\n<li>方便推导出遮蔽阴影项 Smith G</li>\r\n<li>方便基于NDF或可见法线分布推导其重要性采样\r\n<ul>\r\n<li>对于Smith G，可用低维函数或表格处理所有粗糙度和各向异性</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"参考-1\"><strong>参考</strong></h4>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/69380665\">【基于物理的渲染（PBR）白皮书】（四）法线分布函数相关总结\r\n- 知乎 (zhihu.com)</a>:关于形状不变性。</p>\r\n<h3 id=\"ffresnel-equation\"><strong>F(Fresnel Equation)</strong></h3>\r\n<p><span\r\nclass=\"math display\">\\[F_{Schlick}(h,v,F_0)=F_0+(1-F_0)(1-(h,v))^5\\]</span></p>\r\n<p>F_0 表示的基础反射率，利用折射指数(Indices Of Refraction)求得，F_0\r\n越大菲涅尔反射现象越强。</p>\r\n<p>当越是向掠射角(又名切线角，和正視角相差90度)方向去看，菲涅尔现象越强，反光效果越明显。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/fresnel.png\" alt=\"fresnel\" />\r\n<figcaption aria-hidden=\"true\">fresnel</figcaption>\r\n</figure>\r\n<p><strong>Fresnel-Schlick</strong>只适用于绝缘体的表面算法。\r\n金属表面需要其他的菲涅尔方程模拟。但是这样做很不方便，所以：\r\n预计算出平面对法线入射的结果(F0)，基于观察角的Fresnel-Schlick近似对这个值进行插值，用这种方法进一步估算。\r\n这样就可以使用同一个公式了。</p>\r\n<p>平面对于法向入射的响应或者说基础反射率可以在一些大型数据库中找到，比如<a\r\nhref=\"http://refractiveindex.info/\">RefractiveIndex</a>。</p>\r\n<p>所有电介质材质表面的基础反射率都不会高于0.17，这其实是例外而非普遍情况。导体材质表面的基础反射率起点更高一些并且（大多）在0.5和1.0之间变化。此外，对于导体或者金属表面而言基础反射率一般是带有色彩的，这也是为什么F0要用RGB三原色来表示的原因（法向入射的反射率可随波长不同而不同）。这种现象我们<strong>只能</strong>在金属表面观察的到。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/chart3.png\" alt=\"chart3\" />\r\n<figcaption aria-hidden=\"true\">chart3</figcaption>\r\n</figure>\r\n<p>由于绝缘体和金属体存在多种的差异，其各自独有的特性引出了金属工作流，我们使用一个金属度调节材质表面特性，这个参数并非\r\n非零即一\r\n的布尔值，是因为我们要描述一些比如沙子、颗粒和被刮蹭后的金属表面，所以要有一个[0,1]的范围进行调整。</p>\r\n<p>我们通过预计算金属和绝缘体的 F_0 进行 Fresnel-Schlick\r\n近似，但是对于金属表面通常这样做</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">vec3 F0 = vec3(0.04,0.04,0.04);<br>F0 = mix(F0, surfaceColor.rgb, metalness);<br></code></pre></td></tr></table></figure>\r\n<p>我们为大多数电介质表面定义了一个近似的基础反射率。F_0取最常见的电解质表面的平均值，这又是一个近似值。不过对于大多数电介质表面而言使用0.04作为基础反射率已经足够好了，而且可以在不需要输入额外表面参数的情况下得到物理可信的结果。然后，基于金属表面特性，我们要么使用电介质的基础反射率要么就使用F_0来作为表面颜色。因为金属表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用表面颜色纹理来作为它们的基础反射率。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">vec3 fresnelSchlick(float cosTheta, vec3 F0)<br>&#123;<br>    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);<br>&#125;<br>// cosTheta = dot(N,V)<br></code></pre></td></tr></table></figure>\r\n<p>这里的N是收到粗糙度影响的半角向量，在后面计算IBL时，因为预计算没办法考虑粗糙度，所以我们需要一个受粗糙度影响的\r\nfresnelSchlick</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">vec3 fresnelSchlick(float cosTheta, vec3 F0, float roughness)<br>&#123;<br>    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>关于金属和绝缘体的菲涅尔，在 PBRT 中有提到，8.2.1 Fresnel\r\nReflection： <a\r\nhref=\"https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission\">Specular\r\nReflection and Transmission (pbr-book.org)</a></p>\r\n<blockquote>\r\n<ol type=\"1\">\r\n<li>The first class is <em>dielectrics</em>, which are materials that\r\ndon’t conduct electricity. They have real-valued indices of refraction\r\n(usually in the range 1-3) and transmit† a portion of the incident\r\nillumination. Examples of dielectrics are glass, mineral oil, water, and\r\nair.</li>\r\n<li>The second class consists of <em>conductors</em> such as metals.\r\nValence electrons can freely move within the their atomic lattice,\r\nallowing electric currents to flow from one place to another. This\r\nfundamental atomic property translates into a profoundly different\r\nbehavior when a conductor is subjected to electromagnetic radiation such\r\nas visible light: the material is opaque and reflects back a significant\r\nportion of the illumination. A portion of the light is also transmitted\r\ninto the interior of the conductor, where it is rapidly absorbed: total\r\nabsorption typically occurs within the top 0.1 μm of the material, hence\r\nonly extremely thin metal films are capable of transmitting appreciable\r\namounts of light. We ignore this effect in <code>pbrt</code> and only\r\nmodel the reflection component of conductors. In contrast to\r\ndielectrics, conductors have a complex-valued index of refraction\r\nn=n0+ik.</li>\r\n<li>Semiconductors such as silicon or germanium are the third class\r\nthough we will not consider them in this book.</li>\r\n<li>The first class is dielectrics, which are materials that don't\r\nconduct electricity. They have real-valued indices of refraction\r\n(usually in the range 1-3) and transmitt a portion of the incident\r\nillumination. Examples of dielectrics are glass, mineral oil, water, and\r\nair.</li>\r\n<li>The second class consists of conductors such as metals. Valence\r\nelectrons can freely move within the their atomic lattice, allowing\r\nelectric currents to flow from one place to another. This fundamental\r\natomic property translates into a profoundly different behavior when a\r\nconductor is subjected to electromagnetic radiation such as visible\r\nlight: the material is opaque and reflects back a significant portion of\r\nthe illumination. A portion of the light is also transmitted into the\r\ninterior of the conductor, where it is rapidly absorbed: total\r\nabsorption typically occurs within the top 0.1 um of the material, hence\r\nonly extremely thin metal films are capable of transmitting appreciable\r\namounts of light. We ignore this effect in pbrt and only model the\r\nreflection component of conductors. In contrast to dielectrics,\r\nconductors have a complex-valued index of refraction = n + ik.</li>\r\n<li>Semiconductors such as silicon or germanium are the third class\r\nthough we will not consider them in this book.</li>\r\n</ol>\r\n<p>第一类是介电材料，这是一种不导电的材料。它们具有实值折射率(通常在1-3范围内)，并透射一部分入射光。电介质的例子有玻璃、矿物油、水和空气。</p>\r\n<p>第二类由金属等导体组成。价电子可以在其原子晶格内自由移动，从而使电流从一个地方流向另一个地方。当导体受到电磁辐射(如可见光)时，这种基本的原子性质会转化为一种截然不同的行为:这种材料是不透明的，会反射回相当一部分照明。一部分光也被传输到导体的内部，在那里它被迅速吸收:完全吸收通常发生在材料的顶部0.1微米内，因此只有极薄的金属薄膜才能传输相当数量的光。我们在pbrt中忽略了这种影响，只对导体的反射成分进行了建模。与电介质相比，导体具有复值折射率=\r\nn + ik。</p>\r\n<p>硅或锗等半导体是第三类，但我们在本书中不考虑它们。</p>\r\n</blockquote>\r\n<h3 id=\"ggeometry-function\"><strong>G(Geometry Function)</strong></h3>\r\n<p>几何遮蔽模拟微表面的互相遮挡导致光线能量丢失或减少的现象。</p>\r\n<p>类似 NDF，也使用 Roughness\r\n作为输入，粗糙度越高意味着几何遮蔽的概率越大。 几何遮蔽有 GGX 和\r\nSchlick-Beckmann 组合而成的模拟函数 <strong>Schlick-GGX</strong>：</p>\r\n<p><span class=\"math display\">\\[G_{SchlickGGX}(n,v,k)=\\frac{n\\cdot\r\nv}{(n\\cdot v)(1-k)+k}\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/G.png\" alt=\"G\" />\r\n<figcaption aria-hidden=\"true\">G</figcaption>\r\n</figure>\r\n<p>这里的 k 由粗糙度 α 计算得来，用于直接光照和 IBL\r\n光照的几何函数参数:</p>\r\n<p><span class=\"math display\">\\[k_{direct}=\\frac{(\\alpha+1)^2}{8}\\\\\r\nk_{IBL}=\\frac{\\alpha^2}{2}\\]</span></p>\r\n<p>这里的 α 取决于我们怎么从粗糙度转换。</p>\r\n<p>为了更好的模拟，我们可以同时考虑两个视角，视线方向(几何遮蔽)和光线方向(几何阴影)\r\n几何遮蔽类似“看不到”，几何阴影类似“照不到”。 使用 <strong>Smith</strong>\r\n函数将其放在一起:</p>\r\n<p><span\r\nclass=\"math display\">\\[G(n,v,l,k)=G_{sub}(n,v,k)G_{sub}(n,l,k)\\]</span></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">float GeometrySchlickGGX(float NdotV, float k)<br>&#123;<br>    float nom = NdotV;<br>    float denom =  NdotV * (1 - k) + k;<br>    return nom / denom;<br>&#125;<br><br>float GeometeySmith(vec3 N, vec3 V, vec3 L, float k)<br>&#123;<br>    float Gsub = GeometrySchlickGGX(saturate(dot(N,V)), k);<br>    float Gsub2 = GeometrySchlickGGX(saturate(dot(N,L)), k);<br>    return Gsub * Gsub2;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"kulla-conty-approximation\"><strong>Kulla-Conty\r\nApproximation</strong></h3>\r\n<p>由于几何遮蔽造成能量损失，使得粗糙度较大时物体表面较暗，但实际上光线在表面经过多次弹射后不会被遮挡，可以反射出去(不考虑热能损失)。BRDF\r\n只是考虑一次反射罢了。</p>\r\n<p>所以使用经验模型去补全损失的能量，首先要知道有多少能量损失了。</p>\r\n<p><span\r\nclass=\"math display\">\\[E(\\mu_o)=\\int_0^{2\\pi}\\int_0^1f_r(\\mu_o,\\mu_i,\\phi)u_i\\,\\mathrm{d}\\mu_i\\,\\mathrm{d}\\phi\\\\\r\nu=\\sin\\theta\\]</span></p>\r\n<ul>\r\n<li>Key idea\r\n<ul>\r\n<li>损失的能量就是 1 - E(_o)，不过E(_o)是和观察方向相关的。\r\n我要做的就是补上这部分能量，能量加起来就是1了啊。</li>\r\n<li>E(_0)是和观察方向相关的。</li>\r\n<li>要补一种多次散射的BRDF结果，也就是用一个模型去模拟多次反射的计算结果，而且因为\r\nBRDF 具有对称性，有1 - E(_o)那么应该也有一项1 -\r\nE(_i)，因为我们的这个经验式子是模拟一个多级的基于 BRDF\r\n的反射，然后补上一个归一化的参数c，得到这样的结果： c(1-E(_i))(1 -\r\nE(_o)) 这么设计只是为了简单……</li>\r\n<li><span class=\"math display\">\\[c=\\frac{1}{\\pi(1-E_{avg})}\\\\\r\nE_{avg}=2\\int_0^1E(\\mu)\\mu\\,\\mathrm{d}\\mu\\\\\r\nf_{ms}(\\mu_o,\\mu_i)=\\frac{(1-E(\\mu_i))(1 -\r\nE(\\mu_o))}{\\pi(1-E_{avg})}\\]</span></li>\r\n<li></li>\r\n</ul></li>\r\n<li>但E_{avg}还是不知道的，这个可以预计算。\r\n<ul>\r\n<li>Precompute / tabulate</li>\r\n<li><span\r\nclass=\"math display\">\\[E_{avg}(\\mu_o)=2\\int_0^1E(\\mu_i)\\mu_i\\,\\mathrm{d}\\mu_i\\\\\\]</span></li>\r\n<li><span class=\"math display\">\\[E_{avg}\\]</span>和<span\r\nclass=\"math display\">\\[\\mu_o\\]</span>, 以及 BRDF(或者说roughness) 相关\r\n这个预计算的结果会根据 brdf 的不同而改变。</li>\r\n</ul></li>\r\n</ul>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/Kulla-Conty.png\" alt=\"Kulla-Conty\" />\r\n<figcaption aria-hidden=\"true\">Kulla-Conty</figcaption>\r\n</figure>\r\n<ul>\r\n<li>如果物体有颜色，就会有能量损失，这样积分一开始就不会是1. 我们先计算\r\n没有颜色损失的 正确结果，最后计算时再考虑由于颜色引起的损失。</li>\r\n<li>Define the average Fresnel\r\n不管入射角多大，每次反射平均反射掉多少能量</li>\r\n</ul>\r\n<p><span\r\nclass=\"math display\">\\[F_{avg}=\\frac{\\int_0^1F(\\mu)\\mu\\,\\mathrm{d}\\mu}{\\int_0^1\\mu\\,\\mathrm{d}\\mu}=2\\int_0^1F(\\mu)\\mu\\,\\mathrm{d}\\mu\\]</span></p>\r\n<ul>\r\n<li><span class=\"math display\">\\[E_{avg}\\]</span>\r\n表示有多少能量我们可以看到，这些能量不会发生多次的反射。 NOT participate\r\nin further bounces</li>\r\n<li>所以最后的 能量/颜色\r\n<ul>\r\n<li>能够直接看到的 <span\r\nclass=\"math display\">\\[F_{avg}E_{avg}\\]</span></li>\r\n<li>光反射一次被看到：<span\r\nclass=\"math display\">\\[F_{avg}(1-E_{avg})\\cdot F_{avg}E_{avg}\\]</span>\r\n<span\r\nclass=\"math display\">\\[F_{avg}(1-E_{avg})\\]</span>是反射后(F)未能从物体表面反射出去的能量(1-E)，\r\n<span\r\nclass=\"math display\">\\[F_{avg}(1-E_{avg})\\underline{F_{avg}}\\]</span>\r\n未能出去的能量发生第二次 <span\r\nclass=\"math display\">\\[F_{avg}(1-E_{avg})\\cdot\r\nF_{avg}\\underline{E_{avg}}\\]</span> 发生反射后有多少能量被看到</li>\r\n<li>反射k次：F_{avg}<sup>k(1-E_{avg})</sup>kF_{avg}E_{avg}</li>\r\n<li>累加得到 color term：</li>\r\n<li><span\r\nclass=\"math display\">\\[\\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}\\]</span></li>\r\n<li>最后将 color term directly multiplied on the uncolored\r\n<strong>additional BRDF</strong></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"cook-torrance-反射方程\"><strong>Cook-Torrance\r\n反射方程</strong></h3>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} +\r\nk_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<h4 id=\"直接光-附加光\">直接光 + 附加光</h4>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/output2.PNG\" alt=\"output2\" />\r\n<figcaption aria-hidden=\"true\">output2</figcaption>\r\n</figure>\r\n<h2 id=\"ibl\"><strong>IBL</strong></h2>\r\n<h3 id=\"diffuse-irradiance\"><strong>Diffuse Irradiance</strong></h3>\r\n<p>Imaged base lighting, IBL\r\n是一类光照技术的集合，若光源不是可分解的直接光源，比如可以用辐射度量学计算的的点光源方向光等等，<strong>而是将周围环境整体视为一个大光源</strong>。IBL(\r\n取自现实世界或者在3D场景生成)\r\n环境立方体贴图(cubemap)，我们可以将立方体贴图的每个像素视为光源，在渲染方程中直接使用，这样可以有效的捕获环境的全局光照和氛围，使物体更好的融入环境。\r\n由于基于图像的光照算法会捕捉部分甚至全部的环境光照，通常认为它是一种更精确的环境光照输入格式，甚至也可以说是一种全局光照的粗略近似。基于此特性，IBL\r\n对 PBR\r\n很有意义，因为当我们将环境光纳入计算之后，物体在物理方面看起来会更加准确。</p>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} +\r\nk_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>对于反射方程的求解主要是在半球上对所有入射光方向 w_i 的积分。\r\n直接光照的话，我们事先知道对积分有贡献的、若干精准的光线方向，但是来自环境的<strong>每个</strong>方向w_i都有可能具有一定的\r\nRadiance，这就很麻烦了。 我们需要：</p>\r\n<ul>\r\n<li>对给定任何方向w_i，能获取到该方向的场景 Radiance。</li>\r\n<li>积分需要快，因为是实时渲染。</li>\r\n</ul>\r\n<p>第一个思路就是用\r\n环境立方体贴图，每个纹素都视为一个光源，使用一个w_i采样即可。</p>\r\n<p>为了更高效的解决积分，我们需要对其中大部分结果做预处理，再来看反射方程:</p>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int_{\\Omega}(k_d\\frac{c}{\\pi} +\r\nk_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot n)})L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\\\\r\nBecause\\;diffuse\\;k_d\\;and\\;specular\\;are\\;independent\\;for\\;each\\;other.\\\\\r\nWe\\;can\\;break\\;up.\\\\\r\nL_0(p,w_0)=\\int_{\\Omega}k_d\\frac{c}{\\pi}L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i + \\int_{\\Omega}k_s\\frac{FDG}{4(w_0\\cdot n)(w_i\\cdot\r\nn)}L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>先来研究\r\ndiffuse，将常数提出，能得到只依赖于w_i的积分，我们就可以计算或预计算一个新的立方体贴图，它在每个采样方向——也就是纹素——中存储漫反射积分的结果，这些结果是通过卷积计算出来的。</p>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=k_d\\frac{c}{\\pi}\\int_{\\Omega}L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>卷积的特性是，对数据集中的一个条目做一些计算时，要考虑到数据集中的所有其他条目。这里的数据集就是场景的辐射度或环境贴图。因此，要对立方体贴图中的每个采样方向做计算，我们都会考虑半球\r\n上的所有其他采样方向。</p>\r\n<p>为了对环境贴图进行卷积，我们通过对半球 ，来计算每个输出采样方向\r\nw_0的积分。用来采样方向 w_i 的半球，要面向卷积的输出采样方向 w_0 。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/ibl1.png\" alt=\"ibl1\" />\r\n<figcaption aria-hidden=\"true\">ibl1</figcaption>\r\n</figure>\r\n<p>是不是看不懂，看不懂就对了，因为应该是这样的！</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/ibl2.png\" alt=\"ibl2\" />\r\n<figcaption aria-hidden=\"true\">ibl2</figcaption>\r\n</figure>\r\n<p>该预计算的立方体贴图在每个采样方向\r\nw_0(n)上存储结果，也就是场景中所有能够击中表面朝向为w_0(n)的间接漫反射光的预计算和。</p>\r\n<p>辐射方程也依赖了位置 p\r\n，不过这里我们假设它位于辐照度图的中心。这就意味着所有漫反射间接光只能来自同一个环境贴图，这样可能会破坏现实感（特别是在室内）。渲染引擎通过在场景中放置多个反射探针来解决此问题，每个反射探针单独预计算其周围环境的辐照度图。这样，位置\r\np\r\n处的辐照度（以及辐射度）是取离其最近的反射探针之间的辐照度（辐射度）内插值</p>\r\n<p>关于在半球的积分，可以将立体角 soiled angle 展开</p>\r\n<p><span class=\"math display\">\\[L_0(p,w_0)= k_d\\frac{c}{\\pi}\r\n\\int_{\\phi=0}^{2\\pi}\\int_{\\theta=0}^{\\frac{1}{2}\\pi}\r\nL_i(p,\\phi_i,\\theta_i)\r\n\\cos\\theta\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi\\\\  Here\\;\\cos\\theta\\sin\\theta,\\;\\sin\\theta\\;for\\;soiled\\;angle,\\;\\cos\\theta\\;for\\;\\overrightarrow{up}:w_i\\cdot\r\nn\\\\  L_0(p,w_0)=k_d\\frac{c}{\\pi}\r\n\\frac{1}{n_1n_2}\\sum\\limits^{n_1}_{\\phi=0}\\sum\\limits^{n_2}_{\\theta=0}\r\nL_i(p,\\phi_i,\\theta_i)\r\n\\cos\\theta\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi\\]</span></p>\r\n<h3 id=\"实现\"><strong>实现</strong></h3>\r\n<p>Roughness in [0,1]-&gt;[0,5]</p>\r\n<p>做五级的skybox，存在cubemap tex内</p>\r\n<h4 id=\"参考-2\"><strong>参考</strong></h4>\r\n<p><a\r\nhref=\"https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/\">漫反射辐照\r\n- LearnOpenGL CN (learnopengl-cn.github.io)</a> <a\r\nhref=\"http://www.codinglabs.net/article_physically_based_rendering.aspx\">codinglabs.net/article_physically_based_rendering.aspx</a></p>\r\n<h3 id=\"specular-ibl\"><strong>Specular IBL</strong></h3>\r\n<h4 id=\"the-split-sum-1st-stage\"><strong>The Split Sum: 1st\r\nStage</strong></h4>\r\n<p>现在来看镜面反射部分，反射方程为：</p>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int\\limits_\\Omega(k_d\\frac{c}{\\pi}+k_s\\frac{DFG}{4(w_0\\cdot\r\nn)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>这下坏了，因为 ks\r\n是受入射光还有视角影响的。如果进行实时计算，视线和光线的组合数极其庞大，这样的开销是很昂贵的。\r\nEpic Games\r\n提出了一个解决方案，他们预计算镜面部分的卷积，为实时计算作了一些妥协，这种方案被称为分割求和近似法（<strong>split\r\nsum approximation</strong>）。\r\n分割求和近似将方程的镜面部分分割成两个独立的部分，我们可以单独求卷积，然后在\r\nPBR 着色器中求和，以用于间接镜面反射部分\r\nIBL。分割求和近似法类似于我们之前求辐照图预卷积的方法，需要 HDR\r\n环境贴图作为其卷积输入。为了理解，我们回顾一下反射方程，但这次只关注镜面反射部分：</p>\r\n<p><span\r\nclass=\"math display\">\\[L_0(p,w_0)=\\int\\limits_\\Omega(k_s\\frac{DFG}{4(w_0\\cdot\r\nn)(w_i\\cdot n)})L_i(p,w_i)n\\cdot w_i\\,\\mathrm{d}w_i\\\\\r\n=\\int\\limits_\\Omega f_r(p,w_i,w_0)L_i(p,w_i)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>我们依然想计算出一个类似镜面 IBL\r\n贴图的东西，然后使用pixel的法线采样，但是问题在于，辐照度图只依赖于\r\nw_i，但是这次积分还依赖于 BRDF</p>\r\n<p><span class=\"math display\">\\[f_r(p,w_i,w_0)=\\frac{DFG}{4(w_0\\cdot\r\nn)(w_i\\cdot n)}\\]</span></p>\r\n<p>BRDF内还有w_0，更不可能要用入射和出射光的组合了，那计算肯定爆掉了。</p>\r\n<p><span\r\nclass=\"math display\">\\[\\int_{\\Omega}f(x)g(x)\\,\\mathrm{d}x\\approx\\frac{\\int_{\\Omega_G}f(x)\\,\\mathrm{d}x}{\\int_{\\Omega_G}\\,\\mathrm{d}x}\\cdot\\int_{\\Omega}g(x)\\,\\mathrm{d}x\\]</span></p>\r\n<p>所以\r\nE宝先将其分为两个部分求解，再将两个部分组合计算得到预计算结果。</p>\r\n<p><span class=\"math display\">\\[L_0(p,w_0)=\\int\\limits_\\Omega\r\nL_i(p,w_i)\\,\\mathrm{d}w_i*\\int\\limits_\\Omega f_r(p,w_i,w_0)n\\cdot\r\nw_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>卷积的第一部分被称为预滤波环境贴图，它类似于辐照度图，是预先计算的环境卷积贴图，但这次考虑了粗糙度。因为随着粗糙度的增加，参与环境贴图卷积的采样向量会更分散，导致反射更模糊，所以对于卷积的每个粗糙度级别，我们将按顺序把模糊后的结果存储在预滤波贴图的\r\nmipmap 中。例如，预过滤的环境贴图在其 5 个 mipmap 级别中存储 5\r\n个不同粗糙度值的预卷积结果，如下图所示：</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/IBLCubemap.png\" alt=\"IBLCubemap\" />\r\n<figcaption aria-hidden=\"true\">IBLCubemap</figcaption>\r\n</figure>\r\n<p>为什么是不同粗糙度的图呢？这是因为对于不同的粗糙度，我们镜面反射是不同的，当表面越粗糙镜面反射越松散，我们观测的光照结果会越分散在更广的范围，而越光滑，反射范围越小越集中，视觉上也就是越清晰的。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/iblAlpha.png\" alt=\"iblAlpha\" />\r\n<figcaption aria-hidden=\"true\">iblAlpha</figcaption>\r\n</figure>\r\n<p>从上图我们可以看到我们对r方向采样，实际上是对cubemap的一个橙色的\r\nfliter 进行采样的，当越粗糙时这个 filter 越大。</p>\r\n<p>为什么两部分分开了还要前面项会受到 BRDF\r\n影响，因为我们的采样方向其实就是会受到 BRDF 的影响的。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/boban.jpg\" alt=\"boban\" />\r\n<figcaption aria-hidden=\"true\">boban</figcaption>\r\n</figure>\r\n<p>我们对cubemap的采样范围或者说采样的样本实际就是图中所示的波瓣，而根据\r\nbrdf 定义可知：</p>\r\n<p><span\r\nclass=\"math display\">\\[R=reflection(w_o,n)，w_o就是\\overrightarrow{view}。\\]</span></p>\r\n<p><strong>假设不同方向入射，波瓣变化不大</strong>，我们可以得到:</p>\r\n<p><span class=\"math display\">\\[f(w_o,w_i(n),n)\\approx\r\nf(R,w_i(R),R)，也就是 N=V=R。\\]</span>\r\nf(w_o,w_i(n),n)f(R,w_i(R),R)，也就是 N=V=R。</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/poban.jpg\" alt=\"poban\" />\r\n<figcaption aria-hidden=\"true\">poban</figcaption>\r\n</figure>\r\n<p>我们使用 Cook-Torrance BRDF\r\n的法线分布函数(NDF)生成采样向量及其散射强度，该函数将法线和视角方向作为输入。由于我们在卷积环境贴图时事先不知道视角方向，因此\r\nEpic Games\r\n假设视角方向——也就是镜面反射方向——总是等于输出采样方向ωo，以作进一步近似。翻译成代码如下：</p>\r\n<p>vec3 N = normalize(w_o);</p>\r\n<p>vec3 R = N;</p>\r\n<p>vec3 V = R;</p>\r\n<p>但是这样的假设会导致在掠射角处失去各向异性，因为菲涅尔现象会导致不同w_o的反射方向或者反射现象是不一样的，所以基于波瓣不变的假设所做的结果必然会有缺失。</p>\r\n<p>Moving Frostbite to Physically Based Rendering 3.0-4.9.2 Light probe\r\nfiltering</p>\r\n<p>To simplify this evaluation, we can pre-integrate the integral by\r\nmaking some approximations. Pre-integrating this equation for every v\r\nand Θ would require a huge memory footprint. Thus, a first approximation\r\nis to remove the view dependency. This leads to a coarse approximation\r\nof the BRDF but it is an acceptable trade-off: the shape of a BRDF based\r\non the micro-facets framework and/or half-angle parametrization is\r\nstrongly dependent on the view angle as shown on Figure 54. At normal\r\nincident direction, the shape of a BRDF is isotropic. At grazing angles\r\nthe shape of a BRDF is anisotropic. Removing the view dependency for\r\npre-integrating Equation 46 would make the assumption that the BRDF\r\nshape is isotropic at all view angles. This leads to key visual\r\ndifferences, preventing stretched reflections. This approximation can be\r\nquite noticeable on flat surfaces as shown on Figure 55 but less on\r\ncurvy surfaces38</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/ueReference.png\" alt=\"ueReference\" />\r\n<figcaption aria-hidden=\"true\">ueReference</figcaption>\r\n</figure>\r\n<h4 id=\"the-split-sum-2nd-stage\"><strong>The Split Sum: 2nd\r\nStage</strong></h4>\r\n<p><span\r\nclass=\"math display\">\\[Lo(p,w_o)\\approx\\frac{\\int_{\\Omega_{fr}}L_i(p,w_i)\\,\\mathrm{d}w_i}{\\int_{\\Omega_{fr}}\\,\\mathrm{d}w_i}\\cdot\\underline{\\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i}\\]</span></p>\r\n<p>这部分计算和 F_0,,，但是3D贴图太大了！！！</p>\r\n<p>菲涅项其实比较好拆，我们可以对这部分做一些处理</p>\r\n<p><span class=\"math display\">\\[R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\\r\nR_0-R_0(1-\\cos\\theta)^5+(1-\\cos\\theta)^5\\\\\r\n\\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i\\approx\\\\\r\nR_0\\int_{\\Omega^+}\\frac{f_r}{F}(1-(1-\\cos\\theta)^5)\\cos\\theta_i\\,\\mathrm{d}w_i+\\int_{\\Omega^+}\\frac{f_r}{F}(1-\\cos\\theta)^5\\cos\\theta_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/uecode1.png\" alt=\"uecode1\" />\r\n<figcaption aria-hidden=\"true\">uecode1</figcaption>\r\n</figure>\r\n<h3 id=\"the-split-sum-1st-stage-sample\"><strong>The Split Sum: 1st Stage\r\nSample</strong></h3>\r\n<p>在上一节教程中，我们使用球面坐标生成均匀分布在半球 <span\r\nclass=\"math display\">\\[\\Omega\\]</span>\r\n上的采样向量，以对环境贴图进行卷积。虽然这个方法非常适用于辐照度，但对于镜面反射效果较差。镜面反射依赖于表面的粗糙度，反射光线可能比较松散，也可能比较紧密，但是一定会围绕着反射向量r，除非表面极度粗糙：</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/sample.png\" alt=\"sample\" />\r\n<figcaption aria-hidden=\"true\">sample</figcaption>\r\n</figure>\r\n<p>所有可能出射的反射光构成的形状称为镜面波瓣。随着粗糙度的增加，镜面波瓣的大小增加；随着入射光方向不同，形状会发生变化。因此，镜面波瓣的形状高度依赖于材质。\r\n在微表面模型里给定入射光方向，则镜面波瓣指向微平面的半向量的反射方向。考虑到大多数光线最终会反射到一个基于半向量的镜面波瓣内，采样时以类似的方式选取采样向量是有意义的，因为大部分其余的向量都被浪费掉了，这个过程称为重要性采样。</p>\r\n<p>F = FresnelSchlickFunction(F0, max(0.0, dot(N, H)), roughness);</p>\r\n<p>float3 spe_ibl = SAMPLE_TEXTURE2D_LOD(_MySplit1st,\r\nsampler_MySplit1st, float2(uv.xy), _Roughness * 4.0);</p>\r\n<p>col += spe_ibl * (F * brdf.x + brdf.y)+ ev_diffuse*albedo;</p>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/uecode2.png\" alt=\"uecode2\" />\r\n<figcaption aria-hidden=\"true\">uecode2</figcaption>\r\n</figure>\r\n<h3\r\nid=\"蒙特卡洛monte-carlo积分和重要性采样importance-sampling\"><strong>蒙特卡洛(Monte\r\nCarlo)积分和重要性采样(Importance Sampling)</strong></h3>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/146144853\">蒙特卡洛积分 - 知乎\r\n(zhihu.com)</a></p>\r\n<p>有了蒙特卡洛，那么如何对半球面上的进行采样。</p>\r\n<h3 id=\"低差异序列\"><strong>低差异序列</strong></h3>\r\n<p>Hammersley 序列</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">float RadicalInverse_VdC(uint bits)<br>&#123;<br>    bits = (bits &lt;&lt; 16u) | (bits &gt;&gt; 16u);<br>    bits = ((bits &amp; 0x55555555u) &lt;&lt; 1u) | ((bits &amp; 0xAAAAAAAAu) &gt;&gt; 1u);<br>    bits = ((bits &amp; 0x33333333u) &lt;&lt; 2u) | ((bits &amp; 0xCCCCCCCCu) &gt;&gt; 2u);<br>    bits = ((bits &amp; 0x0F0F0F0Fu) &lt;&lt; 4u) | ((bits &amp; 0xF0F0F0F0u) &gt;&gt; 4u);<br>    bits = ((bits &amp; 0x00FF00FFu) &lt;&lt; 8u) | ((bits &amp; 0xFF00FF00u) &gt;&gt; 8u);<br>    return float(bits) * 2.3283064365386963e-10; // / 0x100000000<br>&#125;<br>// ----------------------------------------------------------------------------<br>float2 Hammersley(uint i, uint N)<br>&#123;<br>    return float2(float(i)/float(N), RadicalInverse_VdC(i));<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/343666731\">看懂蒙特卡洛积分(三)\r\n低差异采样序列</a> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/20197323\">低差异序列（一）-\r\n常见序列的定义及性质 - 知乎 (zhihu.com)</a> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/20374706\">低差异序列（二）-\r\n高效实现以及应用 - 知乎 (zhihu.com)</a></p>\r\n<h4 id=\"ggx-重要性采样\"><strong>GGX 重要性采样</strong></h4>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">float3 ImportanceSampleGGX(float2 Xi, float3 N, float roughness)<br>&#123;<br>    // use roughness for better view<br>    float alpha2 = roughness * roughness;<br><br>    float phi = 2.0 * PI * Xi.x;<br>    float cosTheta = sqrt( (1.0 - Xi.y) / (1.0 + ( alpha2 * alpha2 - 1.0) * Xi.y));<br>    float sinTheta = sqrt(1 - cosTheta * cosTheta);<br><br>    float3 H;<br>    H.x = cos(phi) * sinTheta;<br>    H.y = sin(phi) * sinTheta;<br>    H.z = cosTheta;<br><br>    float3 up = abs(N.z) &lt; 0.999 ? float3(0.0, 0.0, 1.0) : float3(1.0, 0.0, 0.0);<br>    float3 tangent = normalize(cross(up,N));<br>    float3 biTangent = normalize(cross(N, tangent));<br><br>    float3 sampleVec = tangent * H.x + biTangent * H.y + N * H.z;<br>    return normalize(sampleVec);<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"the-split-sum\">The Split Sum</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">// 1st<br>void PrefilteredColor(float3 dir, uint3 id)<br>&#123;<br>    float3 N = normalize(dir);<br>    float3 R = N;<br>    float3 V = R;<br><br>    const uint SAMPLE_COUNT = 1024;<br>    float totalWeight[5] = &#123;0.0, 0.0, 0.0, 0.0, 0.0&#125;;<br>    float3 preColor[5] = &#123; float3(0.0,0.0,0.0), float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0),float3(0.0,0.0,0.0)&#125;;<br>    for(uint i = 0; i &lt; SAMPLE_COUNT; ++i)<br>    &#123;<br>        float2 Xi = Hammersley(i, SAMPLE_COUNT);<br>        float3 H[5];<br>        float3 L[5];<br>        float NdotL[5];<br>        for(uint a = 0; a &lt; 5; a++)<br>        &#123;<br>            H[a] = ImportanceSampleGGX(Xi, N, (float)a*2.0/10.0);<br>            L[a] = normalize(2.0 * dot(V, H[a]) * H[a] - V);<br>            NdotL[a] = max(0.0,dot(N,L[a]));<br>            if(NdotL[a] &gt; 0.0)<br>            &#123;<br>                float D = DistributeGGX(N, H[a], (float)a/5.0);<br>                float NdotH = max(0.0, dot(N, H[a]));<br>                float HdotV = max(0.0, dot(H[a], V));<br>                float pdf = D * NdotH / (4.0 * HdotV) + 0.0001;<br><br>                float res = 512.0;<br>                float saTexel = 4.0 * PI / (6.0 * res * res);<br>                float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);<br>                float roughness = (float)a / 5.0;<br>                float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); <br>                <br>                preColor[a] += _SkyBoxTex.SampleLevel(LinearClampSampler, L[a], mipLevel).xyz * NdotL[a];<br>                totalWeight[a] += NdotL[a];<br>            &#125;<br>        &#125;         <br>    &#125;<br>    int powLog = 1;<br>    for(uint b = 0; b &lt; 5; b++)<br>    &#123;    <br>        preColor[b] = preColor[b] / totalWeight[b];<br>        _SplitSum1stMip[b][id.xy/powLog] = float4(preColor[b],1);<br>        powLog *= 2;<br>    &#125;<br>&#125;<br><br>// 2nd<br>float2 IntegrateBRDF(float NdotV, float roughness)<br>&#123;<br>    float3 V;<br>    V.x = sqrt(1 - NdotV * NdotV);<br>    V.y = 0.0;<br>    V.z = NdotV;<br><br>    float A = 0.0;<br>    float B = 0.0;<br><br>    float3 N = float3(0.0, 0.0, 1.0);<br><br>    int sampleCount = 1024;<br>    for(int i = 0; i &lt; sampleCount; ++i)<br>    &#123;<br>        float2 Xi = Hammersley(i, sampleCount);<br>        float3 H = ImportanceSampleGGX(Xi, N, roughness);       // D. NDF<br>        float3 L = normalize(2.0 * dot(V,H) * H - V);<br><br>        float NdotL = max(L.z, 0.0);<br>        float NdotH = max(H.z, 0.0);<br>        float VdotH = max(0.0, dot(V, H));<br><br>        if(NdotL &gt; 0.0)<br>        &#123;<br>            float G = GeometrySmith(N, V, L, roughness * roughness / 2.0);      // G<br>            float G_Vis = (G * VdotH) / (NdotH * NdotV);    <br>            float Fc = pow(1 - VdotH, 5.0);<br>            <br>            A += (1.0 - Fc) * G_Vis;<br>            B += Fc * G_Vis;<br>        &#125;<br>    &#125;<br>    A /= float(sampleCount);<br>    B /= float(sampleCount);<br>    return float2(A, B);<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"反射探针\"><strong>反射探针</strong></h3>\r\n<p>在unity中添加 probe 然后 baked</p>\r\n<p>使用 sampleSH 对 probe 进行采样</p>\r\n<h3 id=\"environment-diffuse-ibl-specular\">Environment Diffuse + IBL\r\nSpecular</h3>\r\n<figure>\r\n<img src=\"/imgs/LearnPBR/output3.PNG\" alt=\"output3\" />\r\n<figcaption aria-hidden=\"true\">output3</figcaption>\r\n</figure>\r\n<p>中间是粗糙度越来越小 下面是金属度越来越大</p>\r\n<h3 id=\"ibl-参考\"><strong>IBL 参考</strong></h3>\r\n<p><a\r\nhref=\"https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/\">Image\r\nBased Lighting | Chetan Jags (wordpress.com)</a> <a\r\nhref=\"https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\">course_notes_moving_frostbite_to_pbr_v32.pdf\r\n(wordpress.com)</a>:4.9章节 <a\r\nhref=\"https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/\">镜面IBL\r\n- LearnOpenGL CN (learnopengl-cn.github.io)</a> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/66518450\">深入理解 PBR/基于图像照明\r\n(IBL) - 知乎 (zhihu.com)</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1YK4y1T7yY?p=5&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0\">Lecture5\r\nReal-time Environment Mapping哔哩哔哩bilibili</a>: Split Sum</p>\r\n<h2 id=\"杂项\"><strong>杂项</strong></h2>\r\n<ul>\r\n<li>ComputeShader 使用 cubetex：[<a\r\nhref=\"https://forum.unity.com/threads/compute-shader-use-texturecube-resolved.628891/\">Compute\r\nshader] Use TextureCube(Resolved)</a></li>\r\n<li>TextureCube&lt;float4 cubemap; SamplerState _LinearClamp; float3\r\ndir; cubemap.SampleLevel(_LinearClamp, dir, 0);</li>\r\n<li>如何向Tex指定mipmap层级写入，在 setrendertarget 指定</li>\r\n<li>compute Shader sample\r\n<ul>\r\n<li><code>float4 c = tex[id];</code></li>\r\n<li>mipmap: <code>float4 c = tex.mips[0][id]</code> or\r\n<code>tex.Load(uint3(id,0))</code></li>\r\n<li>SampleLevel:</li>\r\n<li>SampleState Sampler1 { Filter = MIN_LINEAR_MAG_MIP_POINT; }; float4\r\nt = tex.SampleLevel(Sample1, uv, 0);</li>\r\n</ul></li>\r\n<li>Sample filter <a href=\"https://enjoyphysics.cn/Article1554\">8.5\r\n纹理采样 (enjoyphysics.cn)</a></li>\r\n</ul>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">// 在倍增、缩减、多级渐进纹理上使用线性过滤。<br>SamplerState mySampler0 <br>&#123;<br>    Filter = MIN_MAG_MIP_LINEAR; <br>&#125;; <br><br>// 在缩减上使用线性过滤，倍增和多级渐进纹理上使用点过滤。<br>SamplerState mySampler1 <br>&#123; <br>    Filter = MIN_LINEAR_MAG_MIP_POINT; <br>&#125;; <br><br>// 在缩减上使用点过滤，倍增上使用线性过滤，多级渐进纹理上使用点过滤。<br>SamplerState mySampler2 <br>&#123; <br>    Filter = MIN_POINT_MAG_LINEAR_MIP_POINT; <br>&#125;; <br><br>// 在倍增、缩减、多级渐进纹理上使用各向异性过滤。<br>SamplerState mySampler3 <br>&#123; <br>    Filter = ANISOTROPIC; <br>    MaxAnisotropy = 4;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"unity-and-mipmap\"><strong>Unity And Mipmap</strong></h3>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/419644293\">【渲染】用计算着色器生成Mipmap\r\n- 知乎 (zhihu.com)</a></p>\r\n<h3 id=\"computer-指定-mipmap-写入\"><strong>Computer 指定 Mipmap\r\n写入</strong></h3>\r\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\">computeShader.SetTexture(kernal, “<span class=\"hljs-keyword\">name</span>”, tex, mipmapLevel);<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"不同光源的衰减\"><strong>不同光源的衰减</strong></h3>\r\n<p><a\r\nhref=\"https://learnopengl-cn.github.io/02%20Lighting/05%20Light%20casters/\">投光物\r\n- LearnOpenGL CN (learnopengl-cn.github.io)</a> <a\r\nhref=\"https://catlikecoding.com/unity/tutorials/custom-srp/point-and-spot-lights/\">Point\r\nand Spot Lights (catlikecoding.com)</a></p>\r\n<h4 id=\"point-light\"><strong>Point Light</strong></h4>\r\n<ul>\r\n<li><span class=\"math inline\">\\((\\,max(0,\r\n1-(\\frac{d^2}{r^2})^2)\\,)^2\\)</span>，r 是 point light 的范围</li>\r\n<li><span\r\nclass=\"math inline\">\\(\\frac{1.0}{K_c+K_l*d+K_q*d^2}\\)</span></li>\r\n</ul>\r\n<h3 id=\"shadergui\"><strong>ShaderGUI</strong></h3>\r\n<p>通过编写 ShaderGUI 在 Material 面板控制 shader properties</p>\r\n<p>或 en/dis able keyword</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">public class MyShaderGUI : ShaderGUI<br>&#123;<br>    public override void OnGUI(MaterialEditor materialEditor, MaterialProperty[] properties)<br>    &#123;<br>        base.OnGUI(materialEditor, properties);<br>        Material material = materialEditor.target as Material;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>在 Shader 结尾加上</p>\r\n<p>CustomEditor \"MyLearnPBRGUI\";</p>\r\n<h2 id=\"urp-光\"><strong>URP 光</strong></h2>\r\n<p><a\r\nhref=\"https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.universal@12.1/manual/light-component.html\">Light\r\n组件参考 | Universal RP | 12.1.1 (unity3d.com)</a> <a\r\nhref=\"https://docs.unity3d.com/cn/current/Manual/LightModes.html\">光照模式\r\n- Unity 手册 (unity3d.com)</a> <a\r\nhref=\"https://docs.unity3d.com/cn/current/Manual/LightMode-Baked.html\">光源模式：Baked\r\n- Unity 手册 (unity3d.com)</a></p>\r\n<h3 id=\"lighting\"><strong>Lighting</strong></h3>\r\n<ul>\r\n<li>Scene/Mixed Lighting/Lighting Mode\r\n<ul>\r\n<li><strong>Baked Indirect</strong>: <a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-BakedIndirect.html\">Lighting\r\nMode：Baked Indirect - Unity 手册</a> 混合光源的行为类似于<a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightMode-Realtime.html\">实时光源</a>，但有额外的好处是会<strong>将间接光照烘焙到光照贴图中</strong>。<strong>混合(Mixed)光源照亮的游戏对象会投射实时阴影</strong>，最大距离是在项目中定义的<a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/shadow-distance.html\">阴影距离\r\n(Shadow Distance)</a>。</li>\r\n<li><strong>Shadow Mask</strong>: <a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Shadowmask.html\">Lighting\r\nMode：Shadowmask - Unity 手册</a>\r\n与烘焙间接照明模式类似，阴影遮罩照明模式将<strong>实时直接照明</strong>与<strong><a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightMode-Baked.html\">烘焙间接照明</a>(Baked\r\nIndirect Lighting\r\nMode)</strong>相结合。但是，“阴影蒙版”照明模式与烘焙间接照明模式的不同之处在于它渲染阴影的方式。阴影蒙版光照模式使\r\nUnity\r\n可以在运行时组合烘焙阴影和实时阴影，并在远处渲染阴影。它通过使用称为阴影蒙版的附加光照贴图纹理，并在<a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightProbes.html\">光照探针</a>中存储其他信息来实现此目的。Unity\r\n为烘焙阴影生成阴影蒙版和 Light Probe 遮挡数据。</li>\r\n<li><strong>Subtractive</strong>: <a\r\nhref=\"https://docs.unity.cn/cn/2022.3/Manual/LightMode-Mixed-Subtractive.html\">Lighting\r\nMode：Subtractive - Unity 手册</a> 在 Subtractive\r\n光照模式下，场景中的所有混合光源都提供烘焙直接光照和间接光照。Unity\r\n将静态游戏对象投射的阴影烘焙到光照贴图中。除了烘焙阴影外，一种方向光（称为主方向光）还为动态游戏对象提供实时阴影。\r\n因为阴影被烘焙到光照贴图中，所以 Unity\r\n在运行时缺少将烘焙阴影和实时阴影准确地结合在一起所需的信息。但是，Unity\r\n提供了 <strong>Realtime Shadow Color</strong>\r\n属性来减少光照贴图的影响，从而在烘焙阴影和实时阴影之间创建正确的混合视觉效果。还可以调整颜色来实现某种艺术风格。\r\nSubtractive\r\n光照模式在低端硬件上非常有用，因为低端硬件需要注重性能，并且只需要一个实时阴影投射光源。这种光照模式不会提供特别逼真的光照效果，而是更适合风格化美学，例如卡通风格。</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"isotropic-anisotropic-brdfs\"><strong>Isotropic / Anisotropic\r\nBRDFs</strong></h2>\r\n<p><span class=\"math display\">\\[f_r(\\theta_i,\\phi_i;\\theta_r,\\phi_r)\\ne\r\nf_r(\\theta_i,\\phi_i,\\phi_r-\\phi_i)\\\\\r\ni\\;is\\;input,\\;r\\;is\\;reflection\\;dir.\\]</span></p>\r\n<h3 id=\"ndf\"><strong>NDF</strong></h3>\r\n<p><strong>形状不变性</strong></p>\r\n<ul>\r\n<li><p>是一个合格的法线分布函数需要具备的重要性质。具有形状不变性（shape-invariant）的法线分布函数，可以用于推导该函数的归一化的各向异性版本，并且可以很方便地推导出对应的遮蔽阴影项G。</p></li>\r\n<li><p>若一个各向同性的NDF可以改写成以下形式，则这个NDF具有形状不变性（shape-invariant）：</p></li>\r\n<li><p><span class=\"math display\">\\[D(m)=\\frac{1}{\\alpha_2(n\\cdot\r\nm)^4}g(\\frac{\\sqrt{1-(n\\cdot m)^2}}{\\alpha(n\\cdot m)})\\]</span></p></li>\r\n<li><p>其中g（）代表一个表示了NDF形状的一维函数。</p></li>\r\n</ul>\r\n<h4 id=\"anisotropic-beckmann-distribution\"><strong>Anisotropic Beckmann\r\nDistribution</strong></h4>\r\n<p><span\r\nclass=\"math display\">\\[D_{Baniso}(m)=\\frac{1}{\\pi\\alpha_x\\alpha_y(n\\cdot\r\nm)^4}exp(-\\frac{\\frac{(t\\cdot m)^2}{\\alpha_x^2}+\\frac{(b\\cdot\r\nm)^2}{\\alpha_y^2}}{(n\\cdot m)^2})\\]</span></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">// Anisotropic Beckmann<br>float D_Beckmann_aniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )<br>&#123;<br>    float XoH = dot( X, H );<br>    float YoH = dot( Y, H );<br>    float d = - (XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay)) / NoHNoH;<br>*    return exp(d) / ( PI * ax*ay * NoH * NoH * NoH * NoH );<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"trowbridge-reitz-ggx-anisotropic\"><strong>Trowbridge-Reitz GGX\r\nAnisotropic</strong></h4>\r\n<p><span\r\nclass=\"math display\">\\[D_{GGXaniso}(m)=\\frac{1}{\\pi\\alpha_x\\alpha_y}\\frac{1}{(\\frac{(x\\cdot\r\nm)^2}{\\alpha_x^2}+\\frac{(y\\cdot m)^2}{\\alpha_y^2}+(n\\cdot\r\nm))^2}\\]</span></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs OpenGL\">// Anisotropic GGX<br>// [Burley 2012, &quot;Physically-Based Shading at Disney&quot;]<br>float D_GGXaniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )<br>&#123;<br>    float XoH = dot( X, H );<br>    float YoH = dot( Y, H );<br>    float d = XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay) + NoHNoH;<br>*    return 1 / ( PI * ax*ay * d*d );<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<ul>\r\n<li>其中，X为tangent，t切线方向，Y为binormal，b，副法线方向</li>\r\n<li>需要注意的是，将法线贴图与各向异性BRDF组合时，重要的是要确保法线贴图扰动（perturbs）切线和副切线矢量以及法线</li>\r\n</ul>\r\n<p><a\r\nhref=\"https://cgg.mff.cuni.cz/~jaroslav/papers/2010-anisobrdf/2010-anisobrdf.pdf\">2010-anisobrdf.pdf\r\n(cuni.cz)</a> <a href=\"https://www.shadertoy.com/view/3tyXRt\">Slope: GGX\r\nAnisotropic (shadertoy.com)</a></p>\r\n<h3 id=\"geometry-function\"><strong>Geometry Function</strong></h3>\r\n<p><span class=\"math display\">\\[G_1(m,v)=\\frac{clamp(0,1,m\\cdot\r\nv)}{1+\\Lambda(v)}\\]</span></p>\r\n<h4 id=\"beckmann\"><strong>Beckmann</strong></h4>\r\n<p><span\r\nclass=\"math display\">\\[\\Lambda(v)=\\frac{erf(a)-1}{2}+\\frac{1}{2a\\sqrt{\\pi}}exp(-a^2)\\\\\r\na=\\frac{1}{\\alpha\\tan\\theta_o}\\]</span></p>\r\n<h4 id=\"ggx\"><strong>GGX</strong></h4>\r\n<p><span\r\nclass=\"math display\">\\[\\Lambda(v)=\\frac{-1+\\sqrt{1+\\frac{1}{a^2}}}{2}\\\\\r\na=\\frac{1}{\\alpha\\tan\\theta_o}\\]</span></p>\r\n<h3 id=\"anisotropic-geometry-function\"><strong>Anisotropic Geometry\r\nFunction</strong></h3>\r\n<h4 id=\"smith\"><strong>Smith</strong></h4>\r\n<p>假设我们拉伸x轴，将各向同性的法线分布转变为各向异性的。</p>\r\n<p>假设各向异性的粗糙度参数有a_x,a_y，视线v(x_o,y_o,z_o)，通过拉伸x轴</p>\r\n<p><span class=\"math display\">\\[a_x&#39;=a_x\\frac{a_y}{a_x}=a_y\\\\\r\na_y&#39;=a_y\\]</span></p>\r\n<p>也就是粗糙度=_y</p>\r\n<p><span\r\nclass=\"math display\">\\[v&#39;=(\\frac{\\alpha_x}{\\alpha_y}x_o,y_o,z_o)=(\\frac{\\alpha_x}{\\alpha_y}\\cos\\phi_o\\sin\\theta_o,\\sin\\phi_o\\sin\\theta_o,\\cos\\theta_o)\\\\\r\n\\frac{1}{\\tan\\theta&#39;_o}=\\frac{z_o}{\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}x_o^2+y_o^2}}=\\frac{1}{\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}\\cos^2\\phi_o+\\sin^2\\phi_o}\\cdot\\tan\\theta_o}\\\\\r\nBecause:a=\\frac{1}{\\alpha\\tan\\theta_o}\\\\\r\na&#39;=\\frac{1}{a_y\\tan\\theta_o}=\\frac{1}{a_y\\sqrt{\\frac{\\alpha_x^2}{\\alpha_y^2}\\cos^2\\phi_o+\\sin^2\\phi_o}\\cdot\\tan\\theta_o}\\\\\r\n=\\frac{1}{\\sqrt{\\alpha_x^2\\cos^2\\phi_o+\\alpha_y^2\\sin^2\\phi_o}\\cdot\\tan\\theta_o}\\]</span></p>\r\n<p><a\r\nhref=\"https://blog.csdn.net/haozi2008/article/details/112284028\">PBR 五\r\n几何遮蔽函数遮蔽因子函数wuhaocat的博客-CSDN博客</a></p>\r\n<p><a\r\nhref=\"https://github.com/QianMo/PBR-White-Paper/blob/master/content/part%205/README.md\">PBR-White-Paper/content/part\r\n5/README.md at master · QianMo/PBR-White-Paper (github.com)</a></p>\r\n<h3 id=\"output-1\"><strong>Output</strong></h3>\r\n<p><img src=\"/imgs/LearnPBR/output4-1.PNG\" alt=\"output4-1\" style=\"zoom:50%;\" /></p>\r\n<p><img src=\"/imgs/LearnPBR/AnisoSphere2.png\" alt=\"AnisoSphere2\" style=\"zoom:50%;\" /></p>\r\n<h3 id=\"anisotropic-ibl\"><strong>Anisotropic IBL</strong></h3>\r\n<h4 id=\"split-sum-2nd\"><strong>Split Sum 2nd</strong></h4>\r\n<p><span class=\"math display\">\\[R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\\r\nR_0-R_0(1-\\cos\\theta)^5+(1-\\cos\\theta)^5\\\\\r\n\\int_{\\Omega^+}f_r(p,w_i,w_o)\\cos\\theta_i\\,\\mathrm{d}w_i\\approx\\\\\r\nR_0\\int_{\\Omega^+}\\frac{f_r}{F}(1-(1-\\cos\\theta)^5)\\cos\\theta_i\\,\\mathrm{d}w_i+\\int_{\\Omega^+}\\frac{f_r}{F}(1-\\cos\\theta)^5\\cos\\theta_i\\,\\mathrm{d}w_i\\]</span></p>\r\n<p>roughness_x, roughness_y, theta 相关3D LUT了</p>\r\n<h2\r\nid=\"todo动态天空的环境光怎么计算\"><strong>[TODO]动态天空的环境光怎么计算</strong></h2>\r\n<p>提前烘焙，插值。</p>\r\n<p>TOD</p>\r\n<p>像大气散射，其实已经计算了 LUT 所以可以直接使用。</p>\r\n<h2 id=\"unity-specular-cube0\">Unity Specular Cube0</h2>\r\n<p><a\r\nhref=\"https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlsl#L620\">Graphics/Packages/com.unity.shadergraph/Editor/Generation/Targets/BuiltIn/ShaderLibrary/Lighting.hlsl\r\nat 19518485b3edcf19f267f293f899d5d25e734a17 ·\r\nUnity-Technologies/Graphics (github.com)</a></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs hlsl\">half mip = PerceptualRoughnessToMipmapLevel(perceptualRoughness);<br>    half4 encodedIrradiance = SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip);<br>    half3 irradiance = DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);<br>    return irradiance * occlusion;<br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"perceptualroughnesstomipmaplevel\">PerceptualRoughnessToMipmapLevel</h3>\r\n<p><a\r\nhref=\"https://github.com/Unity-Technologies/Graphics/blob/19518485b3edcf19f267f293f899d5d25e734a17/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl#L27\">Graphics/Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl\r\nat 19518485b3edcf19f267f293f899d5d25e734a17 ·\r\nUnity-Technologies/Graphics (github.com)</a></p>\r\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs d\"><span class=\"hljs-built_in\">real</span> PerceptualRoughnessToMipmapLevel(<span class=\"hljs-built_in\">real</span> perceptualRoughness, <span class=\"hljs-built_in\">uint</span> maxMipLevel)<br>&#123;<br>    perceptualRoughness = perceptualRoughness * (<span class=\"hljs-number\">1.7</span> - <span class=\"hljs-number\">0.7</span> * perceptualRoughness);<br><br>    <span class=\"hljs-keyword\">return</span> perceptualRoughness * maxMipLevel;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0,\r\nreflectVector, mip);</p>\r\n<h2 id=\"参考-3\"><strong>参考</strong></h2>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/timlly/p/10631718.html\">由浅入深学习PBR的原理和实现\r\n- 0向往0 - 博客园 (cnblogs.com)</a><br />\r\n<a\r\nhref=\"https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\">course_notes_moving_frostbite_to_pbr_v32.pdf\r\n(wordpress.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/53086060\">【基于物理的渲染（PBR）白皮书】（一）\r\n开篇：PBR核心知识体系总结与概览 - 知乎 (zhihu.com)</a><br />\r\n<a href=\"https://www.pbr-book.org/3ed-2018/contents\">Physically Based\r\nRendering: From Theory to Implementation (pbr-book.org)</a><br />\r\nReal-Time Rendering Fourth Edition 第九章<br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV1YK4y1T7yY?p=10&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0\">Lecture10\r\nReal-Time Physically-based Materials (surface\r\nmodels)哔哩哔哩bilibili</a><br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV1YK4y1T7yY?p=11&amp;vd_source=1fa1b82383f6efb8a2632316da9afad0\">Lecture11\r\nReal-Time Physically-based Materials (surface models\r\ncont.)哔哩哔哩bilibili</a><br />\r\nUE4: <a\r\nhref=\"https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\">2013SiggraphPresentationsNotes-26915738.pdf\r\n(unrealengine.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/144611412\">寒霜引擎的PBR实践3.0（一）材质篇\r\n- 知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/158261389\">寒霜引擎的PBR实践3.0（二）光照篇——光照强度与精确光源\r\n- 知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/186541854\">寒霜引擎的PBR实践3.0（三）光照篇——光度学灯与区域光\r\n- 知乎 (zhihu.com)</a><br />\r\n[<a href=\"https://zhuanlan.zhihu.com/p/121719442\">译]Real Shading in\r\nUnreal Engine 4（UE4中的真实渲染)(1) - 知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://zznewclear13.github.io/posts/calculate-spherical-harmonics-using-compute-shader/\">使用Compute\r\nShader计算球谐全局光照 | ZZNEWCLEAR13</a></p>\r\n"},{"title":"春招寄语","date":"2023-03-04T07:14:23.000Z","math":true,"typora-root-url":"./..","_content":"\n图形学全忘光了，技美笔试直接寄了。  \n把面试题整理一下吧……  \n对于**多线程**和**图形API**了解不够需要继续学习\n\n<!--more-->\n\n# C++ 部分\n\n## [new 和 malloc 区别](https://www.cnblogs.com/ywliao/articles/8116622.html)\n\n### 1.申请内存所在位置\n\n* new 从 free store 动态分配内存空间，free store 能否是堆取决于 new 的实现其可以是堆，还可以是静态存储区。\n  \n* malloc 从堆上分配内存\n  \n### 2.返回类型安全性\n* new 分配内存成功时，返回对象类型的指针，符合类型安全。\n  \n* malloc 返回 void* ，需要强制类型转换。\n  \n### 3.内存分配失败时返回值\n* new 失败返回 bac_alloc 异常，不会返回 NULL；  \n* malloc 失败返回 NULL；\n  \n### 4.是否需要指定内存大小\n* new 无需指定，编译器自己计算\n  \n* malloc 需要自己显示指定。\n  \n  ```c  \n  A *ptr = (A*)malloc(sizeof(A));  \n  ```\n  \n### 5.是否调用构造函数/析构函数\n* new 会经过三步分配内存  \n  * 调用 operator new (数组是 operator new[] )，分配足够大、原始、未命名的空间。  \n  * 编译器运行对应构造函数，传入初值。  \n  * 构造完成，返回一个指向该对象的指针。  \n* 在 delete 会  \n  * 调用析构函数  \n  * 编译器调用 operator delete / operator delete[]\n  \n### 6.对数组处理\n* C++ 有 new[] 和 delete [] 处理数组\n  \n* 而 malloc 不知道你存放什么，只会给一块原始的内存，所以需要我们自己指定\n  \n  ```c  \n  int *ptr = (int*)malloc(10*sizeof(int)); // 分配10个int，作为数组  \n  ```\n  \n### 7. new 和 malloc 是否可以相互调用\n\nnew delete可以基于 malloc 实现，但是 malloc 不能调用 new！！！\n\n### 8.是否可以重载\n\n* operator new / operator delete 可以重载  \n* malloc / free 不能重载\n  \n### 9.能够直观地重新分配内存\n\nmalloc 分配的内存如果不够了可以 realloc\n\n但是 new 不行！\n\n### 10.客户处理内存分配不同\n\noperator new 抛出异常前会调用一个用户指定的错误处理函数 new-handler，指向一个错误处理函数。\n\nmalloc 异常用户只能看着他 NULL\n\n## 类和接口\n\n如果把类比作一把枪，接口就是枪的配件，比如握把，枪托等等。我们对于类重点在于描述一个对象，而对于接口重点在于描述接口能提供的功能，所以接口内没有数据成员，只有成员函数。\n\n\n\n## C++ 类\n\n* 子类和父类有同名成员数据，是通过\"::\"区分  \n  ~~~c++  \n  class A  \n  {  \n  public:  \n      int num;  \n  }  \n  class B:public A  \n  {  \n  public:  \n      int num;  \n  }  \n  ~~~\n  \n  其实这两个`num`实际的名字是`A::num`和`B::num`\n  \n* 类的成员函数调用  \n  非虚函数，根据调用对象类型决定，虚函数根据实际类型决定。\n  \n  ~~~c++  \n  class T  \n  {  \n  public:  \n      virtual void Fun1() { std::cout << \"T\" << std::endl; }  \n  };\n  \n  class A  \n  {  \n  public:  \n      int num;  \n  public:  \n      A() { num = 2; std::cout << \"A::A \" << num++<<std::endl; }  \n      virtual void Fun1() { std::cout << \"A::Fun1 \" << ++num<< std::endl; }  \n      void Fun2(){ std::cout << \"A::Fun2 \" << --num << std::endl; }  \n      void Fun3(){ std::cout << \"A::Fun3 \" << num-- << std::endl; }  \n      ~A() { std::cout << \"~A() \" << --num << std::endl; }  \n  };\n  \n  class B :public A  \n  {  \n  public:  \n      int num;  \n  public:  \n      B() { num = 100; std::cout << \"B::B \" << num++ << std::endl; }  \n      void Fun1() { std::cout << \"B::Fun1 \" << ++num << std::endl; }  \n      void Fun2() { std::cout << \"B::Fun2 \" << --num << std::endl; }  \n      virtual void Fun3() { std::cout << \"B::Fun3 \" << num-- << std::endl; }  \n      ~B() { std::cout << \"~B() \" << --num << std::endl; }  \n  };\n  \n  int main()  \n  {  \n      A* ptr = new B;  \n      ptr = dynamic_cast<A*>(ptr);  \n      ptr->Fun1();  \n      ptr->Fun2();  \n      ptr->Fun3();  \n  }  \n  ~~~\n  \n  ~~~c++  \n  A::A 2  \n  B::B 100  \n  B::Fun1 102  \n  A::Fun2 2  \n  A::Fun3 2  \n  ~B() 101  \n  ~A() 0  \n  ~~~\n  \n  `A* ptr = new B;`  \n  `ptr`类型为`A*`，但是实际指向对象类型其实为`B`  \n  那么其实在内存空间中有如下分配\n  \n  ~~~  \n  成员数据:  \n  n_ptr  \n  A::num  \n  B::num  \n  一张A的虚函数表？  \n  一张B的虚函数表  \n  函数映射：  \n  直接查找的  \n  A::Fun2  \n  A::Fun3  \n  B::Fun1  \n  B::Fun2  \n  ~~~\n\n  \n  \n## 构造函数链和析构函数链\n\n### 构造函数链\n\n一个类中有父类成员，成员变量。对于构造函数我们\n\n1. 先调用父类，  \n2. 再调用成员变量的构造函数，  \n3. 最后调用子类构造函数在构造过程中\n\n子类是继承父类的成员\n\n~~~c++\nclass A\n{\n    int a;\n}\n\nclass B : public A\n{\n\tint b;    \n}\n~~~\n\n这里B有成员b，和从父类继承的a。  \n因为 a 是父类成员，所以交由父类初始化，如果先调子类，子类成员有a，b，对a，b初始化，再调父类，a又初始化初始化两次。  \n对于成员变量，成员变量有自己的构造函数，是当前子类无需关心的，对于他们先交给他们自己初始化即可。\n\n## 析构函数链\n\n对于析构函数链，我们把子类可以看成一个套娃。  \n我们装套娃会从小到大(从父到子)\n\n## C++的public、protected、private和三种继承\n\npublic 表示大家谁都能来访问，包括类对象自己和外部。  \nprotected,外部不能访问，但是自己和子类可以访问。  \nprivate，表示只能自己访问，自己的子类都不能访问。  \npublic 继承，不改变父类成员的可见性。  \nprotected 继承，父类成员除private外，全部变为protect  \nprivate 继承全部变为private\n>假如把父类比喻一个门派，期内对象就是武功秘籍  \n>public 就像比较普通的武功，比如太祖长拳，大家都可以来学。  \n>protect 就像门派内的高深强大的武功秘籍，比如降龙十八掌，只有你是下一任掌门才能学。  \n>private 就像掌门自己偷学了邪门歪道，比如岳不群学《辟邪剑谱》，只能自己知道，外人不能晓得。除了自己谁也不让看。  \n>  \n>public 继承就像是普普通通比较开明的继承者，子承父业，原来掌门规定的哪些武功可以交给外人，哪些武功自己人学，都不变，但是掌门私底下学的歪门武功他也不知道是什么，对他而言不可见，想知道是什么得返回去用上一任掌门的去查。  \n>protect 继承就像垄断或者有点小心思的人继承，我不让所有人随便学了，现在你们想从我这学你得是我的关门弟子下一任掌门。  \n>private 继承就像断代了，诶，我谁也不教，全部变成private，只有我自己看，但是无论这三种哪一种都看不到父类的private。\n\n## static关键字\n\nstatic关键字表示静态元素，其在程序的生存周期中仅在**静态存储区**分配一次存储空间，直到程序的生存周期结束。  \nstatic常用于\n\n* 函数中的静态变量  \n* 静态类对象  \n* 类中的静态成员变量  \n* 类中的静态方法\n  \n## **static 和const分别怎么用，类里面static和const可以同时修饰成员函数吗**\n- **static**\n  \n  - static对于变量\n  \n    1. 局部变量\n  \n       在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。\n  \n       内存中的位置：静态存储区\n  \n       初始化：局部的静态变量只能被初始化一次\n  \n       作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。\n  \n       > 当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。\n  \n    2. 全局变量\n  \n       在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。\n  \n       内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）\n  \n       初始化：未经初始化的全局静态变量会被程序自动初始化为0\n  \n       作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。(只能在本文件中存在和使用)\n  \n       > 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。\n  \n- static对于函数\n  \n  修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。（和全局变量一样限制了作用域而已）\n  \n- static对于类\n  \n  1. 成员变量\n  \n     用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，**包括派生类的对象**。\n  \n     因此，static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化 。\n  \n  2. 成员函数\n  \n     用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，**不含this指针。**\n  \n     静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。\n  \n     **不可以同时用const和static修饰成员函数。**\n  \n- **const**\n  \n  1. 限定变量为不可修改。  \n  2. 限定成员函数不可以修改任何数据成员\n  \n- static和const可以同时修饰成员函数吗?\n  \n  答：不可以。C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。两者的语意是矛盾的。**static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态**，与类型的静态变量没有关系。因此不能同时用它们。\n  \n## 拷贝构造函数\n\n**只有这三种情况！！！！！**\n\n### 1.用一个对象初始化另一个对象。\n\n```c++  \nPoint p2(p1);  \nPoint p3 = p1  \n```\n\n这两种情况一样。\n\n### 2.若一个函数的形参是一个 Class 对象，当 F 被调用时，Class 拷贝构造函数调用。\n\n```c++  \nvoid Func(Point a){};\n  \nint mian()  \n{  \n    Point a;  \n    Func(a);    // 调用拷贝构造函数  \n}  \n```\n\n### 3.如果函数的返回值是 Class 对象，函数返回时，调用 Class 拷贝构造函数\n\n即返回值对象由拷贝构造函数初始化。\n\n## 模板函数\n\n### 模板函数的声明实现为什么必须在一个文件内\n\n[CSDN : 模板函数的声明和定义为何不能分开放在两个文件中?](https://blog.csdn.net/chigusakawada/article/details/78752668)\n\n##  C++ 11 特性\n\n### 左值右值\n\n[四行代码！看懂右值引用](https://www.cnblogs.com/qicosmos/p/4283455.html)\n\n#### 右值引用的特点：\n\n1. 通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。  \n   ~~~c++  \n   A GetA()  \n   {  \n       return A();  \n   }  \n   A&& a = GetA();\t// 这里只会调用一次拷贝构造函数，就是return A()，  \n   // 因为A&& 延长了 GetA的生命周期无需拷贝函数  \n   ~~~\n  \n2. 右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。\n  \n3. T&& t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。  \n   正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。\n  \n4. \n\n移动语义的实现：\n\n~~~c++\nA GetA()\n{\n    return A;\n}\n\nA(A&& a):m_ptr(a.m_ptr){}\n\nA a = GetA();\n~~~\n\n利用右值引用作为参数，因为`GetA`返回值是右值，而`A&&`类型确定不发生自动推断即确定的右值，拷贝函数会匹配到`A(A&& a)`，这样就省去了重新`new m_ptr`。\n\n##### 引用折叠\n\n- 所有的右值引用叠加到右值引用上仍然还是一个右值引用；  \n- 所有的其他引用类型之间的叠加都将变成左值引用。\n  \n#### 一个移动语义应用\n实现移动构造和移动赋值  \n为什么在 移动构造中将 f.ptr 赋值为 nullptr  \n因为我们的移动构造函数参数是一个右值，在完成初始化的任务后就应该消失，所以把他所指内存交给新对象，并指向了nullptr，移动赋值也是同理。  \n移动赋值和移动复制通常联合使用，目的是优化对象的复制和赋值操作，提高程序的性能。  \n移动赋值会在这时调用`f1=Foo()`，f1是之前声明过的，Foo()返回右值，匹配到`=(Foo&&)`函数。\n~~~c++\nclass Foo\n{\npublic:\n    int a;\n    int *ptr;\n\npublic:\n    Foo(Foo&& f):ptr(f.ptr),a(f.a)\n    {\n        f.ptr = nullptr;\n    }\n    \n    Foo& operator =(Foo&& f)\n    {\n        if(this != &f)\n        {\n            this->ptr = f.ptr;\n            f.ptr = nullptr;\n            a = f.a;\n        }\n        return *this;\n    }\n};\n~~~\n\n### 一些补充\n\n~~~c++\nvec.push(Foo());\n~~~\n\n首先，我们知道函数的返回值是右值，所以Foo() 这部分是个右值  \n当我们没有右值引用的移动构造函数时，我们会发生 右值转换的过程——把右值转化为左值，调用复制构造函数。  \n若我们有参数为右值引用的移动构造函数，右值会直接匹配到这个函数，不会发生一次转换去匹配参数为左值的复制构造函数。  \n这里的知识点是右值可以转换为左值。\n\n### 智能指针\n\n\n\n### 类型推断\n\n\n\n### lambda表达式\n\n\n\n### 类型转换\n\n[九阳神功！不会C++就看这个！](https://zhuanlan.zhihu.com/p/417640759)（1）const_cast: 把const属性去掉，即将const转换为非const（也可以反过来），const_cast只能用于指针或引用，并且只能改变对象的底层const（顶层const，本身是const，底层const，指向对象const）；\n\n（2）static_cast: 隐式类型转换，可以实现C++中内置基本数据类型之间的相互转换，enum、struct、 int、char、float等，能进行类层次间的向上类型转换和向下类型转换（向下不安全，因为没有进行动态类型检查）。它不能进行无关类型(如非基类和子类)指针之间的转换，也不能作用包含底层const的对象；\n\n（3）dynamic_cast：动态类型转换，用于将基类的指针或引用安全地转换成派生类的指针或引用（也可以向上转换），若指针转换失败返回NULL，若引用返回失败抛出bad_cast异常。dynamic_cast是在运行时进行安全性检查；使用**dynamic_cast父类一定要有虚函数，否则编译不通过；**\n\n（4）reinterpret_cast：reinterpret是重新解释的意思，此标识符的意思即为将数据的二进制形式重新解释，但是不改变其值，有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用（比较不安全）\n\n## C++ struct和class区别\n\n* 在 **C 语言** 中，**结构体** 只能存放一些 **变量** 的集合，并不能有 **函数**，但 **C++** 中的结构体对 C 语言中的结构体做了扩充，可以有函数，因此 C++ 中的结构体跟 C++ 中的类很类似。C++ 中的 struct 可以包含成员函数，也能继承，也可以实现多态。\n  \n* 但在 C++ 中，使用 class 时，类中的成员默认都是 **private** 属性的，而使用 struct 时，结构体中的成员默认都是 public 属性的。\n  \n* class 继承默认是 private 继承，而 struct 继承默认是 public 继承。\n  \n* C++ 中的 class 可以使用模板，而 struct 不能使用模板。\n  \n## C++ vector\n\nvector.clear 不释放空间\n\n- int size() const:返回向量中元素的个数  \n- int capacity() const:返回当前向量所能容纳的最大元素值  \n- int max_size() const:返回最大可允许的vector元素个数值\n  \n## C++智能指针和安全性\n\n智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(shared_ptr), 独占指针(unique_ptr)和弱指针(weak_ptr)：\n\n（1）shared_ptr ，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；\n\n（2）unique_ptr，保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr）；\n\n（3）weak_ptr，用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。\n\n- shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？shared_ptr是不是线程安全的？\n  \n\n（1）shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；\n\n（2）具体实现：\n\n1）构造函数：将指针指向该对象，引用计数置为1；\n\n2）拷贝构造函数：将指针指向该对象，引用计数++；\n\n3）赋值运算符：=号左边的shared_ptr的引用计数-1，右边的shared_ptr的引用计数+1，如果左边的引用技术降为0，还要销毁shared_ptr指向对象，释放内存空间。\n\n（3）shared_ptr的引用计数本身是安全且无锁的，但是它指向的对象的读写则不是，因此可以说shared_ptr不是线程安全的。[shared_ptr是线程安全的吗？ - 云+社区 - 腾讯云 (tencent.com)](https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1654442)\n\n- weak_ptr是为了解决shared_ptr的循环引用问题，那为什么不用raw ptr来解决这个问题？\n  \n\n答：一个weak_ptr绑定到shared_ptr之后不会增加引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使weak_ptr指向对象，也还是会释放；raw指针，当对象销毁之后会变成悬浮指针。\n\n## Shared_ptr实现原理\n\n\n\n### 智能指针如何实现\n\nC++中的智能指针（smart pointers）是一种RAII（Resource Acquisition Is Initialization）技术的实现方式，它们可以自动管理内存资源，并确保在对象离开作用域时正确地释放这些资源。智能指针的主要目的是确保资源获取与对象初始化同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。\n\nC++11中引入了三种智能指针：`std::unique_ptr`、`std::shared_ptr`和`std::weak_ptr`。其中`std::unique_ptr`是用于独占式拥有一个对象，`std::shared_ptr`是用于共享拥有一个对象，而`std::weak_ptr`则是用于弱引用一个对象。\n\n当我们需要使用RAII技术来管理动态分配的内存时，我们通常使用`std::unique_ptr`来管理指向单个对象的指针，并使用`std::shared_ptr`来管理指向共享资源的指针。如果我们需要在一个对象中存储多个指向共享资源的指针，则应使用`std::weak_ptr`来避免循环引用问题。\n\n总之，智能指针是一种非常有用的C++编程工具，可以帮助我们更安全、更简单地管理内存资源，并且对于编写高质量的C++代码来说至关重要。更多关于智能指针的资料可以参考[[3](https://zhuanlan.zhihu.com/p/150555165)][[4](https://learn.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170)]。\n\n\n\n## 为什么析构函数一定要被设置为虚函数\n\n[为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数](https://www.cnblogs.com/yuanch2019/p/11625460.html)\n\n首先类的**虚函数**调用是靠**虚函数指针**调用的，而函数成员靠的是对象类型。  \n~~~c++\nclass A\n{\npublic:\n    void func1(){};\n    virtual void func2(){};\n};\n\nint main(){\n    A a;\n    a.func1();\n    a.func2();\n}\n~~~\n\n对于`func1`是通过`a.this`调用，而`func2`是通过虚函数指针`a._vfptr->func2()`调用。(大概是这个意思，但应该是别的形式)\n\n>“Note：定义在类内部的函数是隐式的inline函数（参见6.5.2节，第214页）。” —— 《C++ Primer》 中文第五版 P230  \n>  \n>“成员函数通过一个名为**this**的额外隐式参数来访问调用它的那个对象。” —— 《C++ Primer》 中文第五版 P231\n\n**成员函数本质上可以看做全局函数，不过第一个参数固定为this。**\n\n### 菱形继承\n\nhttps://blog.csdn.net/tounaobun/article/details/8443228\n\n问题：A->B;A->C;B,C->D; B,C继承了A，D继承了A。  \n在调用D的成员函数时候就不知道是调用B的，还是C的，所以在继承中使用\n\n~~~c++\nclass Animal\n{\npublic:\n    void func() { cout << \"Animal\"; };\n};\n\nclass Lion : virtual public Animal\n{\n};\n\nclass Wolf : virtual public Animal\n{\n};\n\nclass Cat : public Wolf, public Lion\n{\n};\n~~~\n\n加上virtual保证子类只有一个父类的子对象，防止发生二义性。\n\n## C++ 深拷贝浅拷贝\n\n（1）拷贝构造函数的作用就是定义了当我们用同类型的另外一个对象初始化本对象的时候做了什么，在某些情况下，如果我们不自己定义拷贝构造函数，使用默认的拷贝构造函数，就会出错。比如一个类里面有一个指针，如果使用默认的拷贝构造函数，会将指针拷贝过去，即两个指针指向同个对象，那么其中一个类对象析构之后，这个指针也会被delete掉，那么另一个类里面的指针就会变成**野指针（悬浮指针）**；\n\n（2）这也正是深拷贝和浅拷贝的区别，浅拷贝只是简单直接地复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。\n\n## C++野指针\n\n指针指向了一块非法内存区域(悬空或者说未知区域)。\n\n## C++ 虚函数\n\n### [哪些函数不能是虚函数](https://www.cnblogs.com/NeilZhang/p/5427872.html)\n\n常见的不不能声明为虚函数的有：普通函数（非成员函数）；静态成员函数；内联成员函数；构造函数；友元函数。\n\n## C++ 内存模型\n\n### C++内存布局\n\n#### Heap 堆\n由new分配的内存块，其释放编译器不去管，由我们**程序自己控制（一个new对应一个delete）**。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”\n\n#### Stack 栈\n\n**编译器**在需要时**分配**，在不需要时自动清除。存放**局部变量**和**函数参数**。  \n存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。\n\n#### 全局/静态存储区(.bss和.data段)\n\n全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中称为zero initialization，初始化的放在.data段中，称为const initialization；在C++中二者不进行区分。  \n虚函数表就存在这里，因为是全局公用的一张表，通过虚函数指针查找。\n\n#### 常量存储区(.rodata段)\n\n存放常量，不允许修改，比如`const int a = 3`\n\n#### 代码区(.text段)\n\n存放代码，比如我们的函数和类的成员函数。不许修改但是可以执行。\n\n### C++内存区域\n\n根据生命周期不同，C++中可划分出三种不同的内存区域\n\n1.自由存储区、动态区、静态区局部非静态变量的存储区域(栈)  \n2.动态区：new，malloc分配的内存  \n3.静态区：全局变量，静态变量，字符串常量存在位置\n\nhttps://www.cnblogs.com/yunlambert/p/9876491.html  \n[深入理解计算机系统（内存管理）----内存模型](https://blog.csdn.net/JUST__Tw/article/details/118551674)  \n空类(空 class)大小是1，为了标识对象  \n[不同类型占用的字节](https://blog.csdn.net/li975242487/article/details/121395693)\n\n## C++运算符重载\n\nhttps://www.cnblogs.com/liuchenxu123/p/12538623.html\n\n## 派生类的构造函数顺序\n\nhttps://www.nowcoder.com/questionTerminal/6348a321452a4318a2da5f3757baf620?source=relative\n\n## 迭代器\n\nhttps://blog.csdn.net/QIANGWEIYUAN/article/details/89184546\n\n## 红黑树\n\nhttps://blog.csdn.net/u014454538/article/details/120120216\n\n## 小根堆，大根堆\n\n### 完全二叉堆\n\n堆又可称之为完全二叉堆。这是一个逻辑上基于完全二叉树、物理上一般基于线性数据结构（如数组、向量、链表等）的一种数据结构。\n\n#### 完全二叉树\n\n完全二叉树是由满二叉树而引出来的，若设二叉树的`深度为h`，`除第 h 层外`，`其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)`，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。\n\n### 小根堆\n\n根小于节点\n\n### 大根堆\n\n根大于节点\n\n\n\n## 对象池\n\n对象池内通常是对象实例的指针，因为对象池的原理是将对象放入池管理的某种内存连续的数据结构中，当不需要对象时，并不销毁对象，而是将对象回收到池中，下次需要的时候再次从池中拿出来。由于对象储存在内存连续的数据结构中，所以能够有效地解决内存碎片的问题。因此，对象池中保存对象的指针比直接保存对象实例更为高效，能够避免频繁分配和销毁内存，从而提高了程序的性能。\n\n\n\n## 多线程\n\n[进程间通信方式；线程间通信方式](https://zhuanlan.zhihu.com/p/430069448)\n\n### 进程间通讯的方式？\n\n管道通信，消息队列，共享内存，socket，串口都可以实现。\n\n#### 管道( pipe )：\n\n管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。\n\n#### 有名管道 (namedpipe) ：\n\n有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。\n\n#### 信号量(semophore ) ：\n\n信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\n\n#### 消息队列( messagequeue ) ：\n\n消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n\n#### 信号 (sinal ) ：\n\n信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。\n\n#### 共享内存(shared memory ) ：\n\n共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。\n\n#### 套接字(socket ) ：\n\n套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。\n\n### 线程间通讯方式。\n\n**锁机制：包括互斥锁、条件变量、读写锁**\n\n- 互斥锁提供了以排他方式防止数据结构被并发修改的方法。  \n- 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。  \n- 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。\n  \n\n**信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量**\n\n**信号机制(Signal)：类似进程间的信号处理**\n\n# 图形学部分\n\n## 叉乘\n\n两个向量的叉乘结果是一个垂直于这两个向量的向量，最后这个向量的长度等于以最初两个向量作为边的平行四边形的面积。\n\n## 光照模型\n\n* emissive  \n* specular  \n* diffuse  \n* ambient\n  \n### 环境光\n\n通常用系统定值，场景物体通用\n\n<img src=\"/imgs/SpringBoss/C_ambient.png\">\n\n### 自发光\n\n材质决定\n\n<img src=\"/imgs/SpringBoss/C_emissive.png\">\n\n### 漫反射\n\n根据 Lambert‘s law\n\n<img src=\"/imgs/SpringBoss/C_diffuse.png\">\n\n### 高光反射\n\n我们有很多变量：normal，eyeDir，lightDir，refDir\n\n#### 已知 normal，lightDir 求 refDir\n\n<img src=\"/imgs/SpringBoss/NormalLightEyeRef.png\">\n\n<img src=\"/imgs/SpringBoss/RefEqu.png\">\n\n##### Phong 模型\n\n<img src=\"/imgs/SpringBoss/PhongSpecular.png\">\n\n##### Blinn-Phong\n\n<img src=\"/imgs/SpringBoss/BlinnPhong.png\">\n\n## 复习下线性代数\n\n### 坐标系\n\n坐标系分为*左手坐标系*和*右手坐标系*\n\n<img src=\"/imgs/SpringBoss/LeftRight.png\" style=\"zoom:60%;\" >\n\n二者在 z 轴方向上有所不同。  \n在 Unity 中**模型空间**和**世界空间**为左手系，**观察空间**为右手系。\n\n### 矩阵\n\n矩阵又分为行矩阵和列矩阵。  \n***<u>矩阵的左乘/右乘，表示该矩阵在乘号的左侧/右侧。</u>***\n\n#### 行矩阵\n\n<img src=\"/imgs/SpringBoss/rowMatrix.png\" >\n\n表示 1xn 的矩阵，行矩阵**左乘**，变换矩阵乘在右侧-> `1xn dot nxn = 1xn`\n\n##### 齐次式\n\n* 矢量/点\n  \n  <img src=\"/imgs/SpringBoss/rowMatrixHC.png\">\n  \n* 变换矩阵\n  \n  <img src=\"/imgs/SpringBoss/rowMatrixHCT.png\" >\n#### 列矩阵\n\n<u>***Unity就是列矩阵！***</u>\n\n> 问题1  \n> shader中会看到法线的变换矩阵：  \n>float3x3 transform = float3x3(v.tangent.xyz, binormal, v.normal);  \n即，**float3x3类型的变量**在创建时，如果传入3个float3类型的变量。整个矩阵是按行优先填充还是按列优先填充呢？  \n答：填入的是三个列，即unity shader是**列优先**（column-major）的。  \n问题2  \n**matrix**.m12是什么意思？  \n答：m12是第一行第二列，但是构造矩阵时是**按列的**。\n\n<img src=\"/imgs/SpringBoss/columnMatrix.png\" >\n\n表示 nx1 的矩阵，列矩阵**右乘**，变换矩阵乘在其左侧 `nxn dot nx1 = nx1`\n\n##### 齐次式\n\n* 矢量/点\n  \n  <img src=\"/imgs/SpringBoss/colMHC.png\">\n  \n* 变换矩阵\n  \n\n<img src=\"/imgs/SpringBoss/colMHCT.png\">\n\n## 矩阵的几何意义变换\n\n变换优先级为：缩放>旋转>位移\n\n### 缩放\n\n<img src=\"/imgs/SpringBoss/scale.png\">\n\n### 旋转\n\n在**左手系**中，绕轴**旋转遵从左手手旋转准则**：大拇指为轴向，四指为旋转方向。  \n在**右手系**中，绕轴**旋转遵从右手旋转准则**：大拇指为轴向，四指为旋转方向。\n\n* 绕 x 轴\n  \n\n<img src=\"/imgs/SpringBoss/rotationX.png\">\n\n* 绕 y 轴\n  \n\n<img src=\"/imgs/SpringBoss/rotationY.png\">\n\n* 绕 z 轴\n  \n\n<img src=\"/imgs/SpringBoss/rotationZ.png\">\n\n#### 欧拉角旋转顺序\n\n因为不同轴旋转相乘得到变换矩阵不同。\n\n* 外旋和内旋  \n  假定一组旋转顺序 x->y->z 为内旋，则外旋为 z->x->y。  \n  一组对应的外旋内旋结果是一样的。\n  \n\n**Unity旋转顺序是ZXY**。\n\n### 位移\n\n<img src=\"/imgs/SpringBoss/translate.png\">\n\n### 变换顺序\n\n<img src=\"/imgs/SpringBoss/transform.png\">\n\n## [给定 4x4 矩阵，求缩放，旋转、平移矩阵](https://blog.csdn.net/qq_39300235/article/details/105790743)\n\n就以列矩阵为例解吧，因为大多都是列矩阵运算。  \n**M=TRS**\n\n<img src=\"/imgs/SpringBoss/4x4Matrix.png\">\n\n### T矩阵\n\n列矩阵最右侧就是 translate 变换\n\n```c++  \nT[0][3]=M[0][3]/M[3][3];  \nT[1][3]=M[1][3]/M[3][3];  \nT[2][3]=M[1][3]/M[3][3];  \n```\n\n### R矩阵\n\n之后我们对 M 矩阵剔除平移变换，得到只有缩放和旋转的矩阵*M*。  \n此时 *M*=RS；  \n我们只要算出旋转矩阵就行了，因为 R 可以用**旋转矩阵的逆矩阵**计算得到：\n\n<img src=\"/imgs/SpringBoss/4x4Rn.png\">\n\n接下来要分解出 R 矩阵，我们利用 ”Polar decomposition(极分解)“，可以证明矩阵*M*的极分解为 <u>旋转R</u> 和 <u>缩放S</u> 。该方法通过对 *M* 的逆的转置进行连续平均来计算，直到**收敛**，此时 ***M**i **= R***。\n\n<img src=\"/imgs/SpringBoss/Polar.png\">\n\n当矩阵只有旋转变换时，旋转R 的转置和R的逆相等，达到收敛状态。  \n因为旋转矩阵为**正交矩阵**。Shoemake和Duff（1992）讨论了该级数收敛的证明，所得矩阵是最接近M的正交矩阵，这是理想的特性。为了计算该序列，我们迭代应用公式，直到连续项之间的差很小或执行了固定的迭代次数为止。 实际上，该系列通常会很快收敛。\n\n```c++  \nFloat norm;  \nint count = 0;  \nMatrix4x4 R = M;  \ndo  \n{  \n    Matrix4x4 Rnext;  \n    Matrix4x4 Rit = Inverse(Transpose(R));    // 转置的逆  \n    for(int i = 0; i < 4; ++i)  \n    {  \n        for(int j = 0; j < 4; ++j)  \n        {  \n            Rnext.m[i][j] = 0.5f * (R.m[i][j]+Rit.m[i][j]);  \n        }  \n    }  \n    // compute the sub between Mi and Mi+1  \n    norm = 0;  \n    for(int i = 0; i < 3; ++i)  \n    {  \n        Float n = abs(R.m[i][0] - Rnext.m[i][0]) +  \n            abs(R.m[i][1] - Rnext.m[i][1]) +  \n            abs(R.m[i][2] - Rnext.m[i][2]);  \n        norm = max(norm,n);  \n    }  \n    R = Rnext;  \n}while(++count < 100 && norm > 0.0001) // 当迭代次数过多，或者连续项差距足够小，退出循环。  \n```\n\n### S矩阵\n\n得到 R 矩阵后 S矩阵就很简单\n\n```c++  \nS = Matrix4x4::Mul(Inverse(R),M);  \n```\n\n### 另外一种办法\n\n我们可以对3x3矩阵的每个列向量求长度，这样就知道每个坐标轴分量上的缩放，最终得到缩放矩阵，然后再根据缩放矩阵求旋转矩阵即可。\n\n## MVP矩阵\n\n### Model\n\n把顶点坐标从局部空间变换到全局空间。\n\n* 行矩阵\n  <img src=\"/imgs/SpringBoss/ModelRow.png\">\n  \n* 列矩阵\n<img src=\"/imgs/SpringBoss/ModelCol.png\">\n\n### View-Matrix 推导\n\n在图形渲染中我们要把3D的场景渲染成一张2D的图片，而这张图片是从 Camera 的视角出发，所以为了方便渲染我们做一个变换，把摄影机作为一个新的空间的原点，令摄影机观测方向为-z方向也就是我们常说的 视图变换(Viewing Transform)。  \n我们对场景中的物体都进行这样一个变换就可以得到，观察空间下的物体的坐标信息，即以 Camera 为原点，Camera 上方向为 y 轴，Camera 视线为 -z 轴，Camera 右侧为 x轴的坐标空间下物体信息。  \n**注意这里观察空间通常为右手系！而非和世界空间/模型空间所采用的左手系！**  \n**接下来推导为列矩阵运算！**\n这个变换主要分为两步一步是平移，一步是旋转。  \n设 Camera 坐标为<img src=\"/imgs/SpringBoss/posE.png\" style=\"zoom:50%;\" >  \n则平移矩阵为  \n<img src=\"/imgs/SpringBoss/viewT.png\" style=\"zoom:50%\">\n现在我们把摄影机放到了原点位置，现在我们只需要把轴向调整即可。  \n*注意这里变换推导过程是先平移后旋转，和平时计算规定的 Transform 先 scale 再 rotation最后  translate 的顺序不同。*  \n我们假设 Camera up 方向矢量为 *t*，观察方向为 *g*，则其 x 轴 *e* 为 *g*x*t*。  \n<img src=\"/imgs/SpringBoss/cameraETG.png\" style=\"zoom:50%\">  \n我们要让其轴向与 xyz 轴对齐，因为现在只是把物体进行了移动，坐标信息的基础轴还是世界坐标系而非 camera坐标系的三轴。  \n我们只需把 `t->y`,`g-> -z`,`e->x` 其中 `e = gxt`。  \n这样虽然可以进行计算，但是十分复杂。  \n我们观察到 既然TEG是坐标轴，就意味着他们三者垂直，点积为零，可以构成正交矩阵。  \n那么 `t->y`,`g-> -z`,`e->x` 的逆变换 `y->t`,`-z ->g`,`x->e` 是很好计算的。  \n而我们知道了逆矩阵，就可以知道正交矩阵的原矩阵。  \n正交矩阵性质: \n<img src=\"/imgs/SpringBoss/orthM.png\" style=\"zoom:80%\">\n\n所以\n<img src=\"/imgs/SpringBoss/Rview.png\" style=\"zoom:80%\">\n\n最后\n<img src=\"/imgs/SpringBoss/Mview.png\" style=\"zoom:80%\">\n\n### Projection Matrix\n\n我们现在已经放好了物体，也以 Camera 的角度出发了，现在我们要从 **View space( 观察空间 )** 到 **Clip Space( 裁剪空间/齐次裁剪空间 )**\n\n#### 我们这里先考虑把深度归到[0,1]的情况\n\n要把 **View 空间**的点投影到**屏幕**上，利用相似三角形原理，\n$$\n\\begin{aligned}\n\\frac{x_{screen}}{near}&=\\frac{x_{view}}{z_{view}}\\\\\nx_{screen}&=\\frac{x_{view}\\cdot near}{z_{view}}\\\\\ny_{screen}&=\\frac{y_{view}\\cdot near}{z_{view}}\\\\\n\\end{aligned}\n$$\n但是实际上我们是先把 *X,Y* 坐标变换到[-1,1]后映射到 Screen的，所以还得改成  \n将所有顶点映射到[-1,1]是为了方便 GPU 计算\n$$\n\\begin{aligned}\n&x_{screen}=\\frac{x_{view}\\cdot near}{z_{view}}&\\in[-wid,wid]\\\\\n&y_{screen}=\\frac{y_{view}\\cdot near}{z_{view}}&\\in[-height,height]\\\\\n&x_{ndc}=\\frac{x_{view}\\cdot near}{z_{view}\\cdot wid}&\\in [-1,1]\\\\\n&y_{ndc}=\\frac{y_{view}\\cdot near}{z_{view}\\cdot height}&\\in [-1,1]\\\\\n\\end{aligned}\n$$\n所以我们现在知道如何对 x,y 坐标进行变换了，Project Matrix 暂时可以写成这样，\n因为 z,w 不受 x,y 影响\n$$\n\\begin{bmatrix}\n\\frac{near}{z_p\\cdot wid}&0&0&0\\\\\n0&\\frac{near}{z_p\\cdot height}&0&0\\\\\n0&0&A&B\\\\\n0&0&C&D\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_p\\\\\ny_p\\\\\nz_p\\\\\n1\\\\\n\\end{bmatrix}\n$$\n\n而 z 值有些不一样，现在的问题是  \n\n* “我们的矩阵 *X,Y 坐标* 的变换矩阵和 <u>z值相关</u>”，  \n  这肯定不是我们希望看到的，这不利于 GPU 计算，\n* 而且为了实现深度测试我们还希望可以将深度值归化到[0,1]，  \n\n对于**第一个问题**，既然 *X,Y 坐标* 都要除 View Space 的 *Z* 坐标值，  \n那么我们不妨把这个除法操作在后面统一执行，也就是 **齐次除法**，  \n所以我们需要在做这个除法操作时能得到 *Z* 坐标值，而恰巧我们可以利用 *W 分量*  \n我们可以先把 *Z* 坐标轴存在 W 分量，即\n$$\n\\begin{bmatrix}\n\\frac{near}{wid}&0&0&0\\\\\n0&\\frac{near}{height}&0&0\\\\\n0&0&A&B\\\\\n0&0&1&0\\\\\n\\end{bmatrix}\n$$\n\n<u>因为View Space 是右手系的所以……z值不是正的</u>\n\n**第二个问题**，而对于 *Z* 值 原本范围是 [-far, -near] -> [?, ?] -> [0,1]\n$$\n[-far,-near]\\rightarrow[?,?]\\stackrel{/z}{\\rightarrow}[0,1]\n$$\n所以我们对 -near 和 -far 两个边界条件 列方程，因为是[0,1]在加上齐次除法所以near为0，far为far\n$$\n\\begin{aligned}\n\t-A\\cdot near+B=0\\\\\n\t-A\\cdot far+B=far\\\\\n\tA=\\frac{far}{near-far}\\\\\n\tB=\\frac{near\\cdot far}{near-far}\n\\end{aligned}\n$$\n\n得到\n$$\n\\begin{bmatrix}\n\\frac{near}{wid}&0&0&0\\\\\n0&\\frac{near}{height}&0&0\\\\\n0&0&\\frac{far}{near-far}&\\frac{near\\cdot far}{near-far}\\\\\n0&0&1&0\\\\\n\\end{bmatrix}\n$$\n从裁剪空间到NDC需要一次齐次除法\n\n#### think 但可能不对\n\n齐次变换(仿射变换)的 W分量 对于一个点来说，可以表示变换的“距离\", 比如用矩阵平移 点(x,y,z) 距离(1,1,1)   \n如果把W=2，再W 归一得到的是(x/2+0.5, y/2+0.5, z/2+0.5),  \n如果有若干多个点，这样做，相当于一种投影，而投影点集前后，点集之间相对当前 W 分量的点集关系不会改变，比如两个点之前相聚(a,b,c)， 除2后就是 (a/2,b/2,c/2)  \n挺有意思但没啥用好像。\n\n## TBN 矩阵\n\n[TBN矩阵不错的Blog](https://zhuanlan.zhihu.com/p/412555049)\n\n## 2D平面三角形，给出算法，生成三角形内随机一点\n\nhttps://www.cnblogs.com/TenosDoIt/p/4025221.html\n\n## 前向渲染和延迟渲染\n\nhttps://zhuanlan.zhihu.com/p/28489928\n\n## LUT 表\n\nhttps://www.jianshu.com/p/fdec2a5e889f\n\n## 描边效果\n\n边缘检测\n\n## 为什么要有光线追踪\n\n1. 传统光栅化做阴影效果不好，操作困难  \n2. 物体的模糊反射，比如毛玻璃一般的反射即 Glossy Reflection，光线打到Glossy物体在反射  \n3. 间接光照(Indirect illumination)，光线在进入人眼前弹射不止一次\n\n这种光线弹射，对于光栅化来说想要实现比较麻烦，而且也不能保证物理上的正确性。光栅化本质上是一种快速的近似质量较低。  \n光线追踪是一种比较准确的办法质量很高，但是最大的问题就是很慢。\n\n## 包围盒BVH\n\n### 如何划分BVH\n\n1.随机选取一个维度\n\n2.选Bounding box中最长的轴进行进一步划分 \n\n3.选取中间的三角形处进行划分（以保证两边三角形数量接近）。\n\n5.基于表面积的启发式评估划分方法（Surface Area Heuristic，SAH），这种方法通过对求交代价和遍历代价进行评估，给出了每一种划分的代价（Cost），寻找代价最小方式进行划分。\n\n6.基于莫顿码（Morton code）的并行化BVH构建。\n\n#### 参考学习！记得学啊！\n\n[PBRT-E4.3-层次包围体(BVH)（一） - 玉米的文章 - 知乎](https://zhuanlan.zhihu.com/p/50720158)  \n[PBRT-E4.3-层次包围体(BVH)（二） - 玉米的文章 - 知乎](https://zhuanlan.zhihu.com/p/54620381)  \n[PBRT-E4.3-层次包围体(BVH)（三） - 玉米的文章 - 知乎](https://zhuanlan.zhihu.com/p/54694041)  \n[【空间加速结构】——层次包围体BVH（Bounding Volume Hierachies） - silence394 - 博客园](https://www.cnblogs.com/silence394/p/17285231.html)  \n[Dynamic AABB Trees](https://box2d.org/files/ErinCatto_DynamicBVH_GDC2019.pdf)\n\n## 渲染管线\n\n一般就说说大概的流程 IA->VS->Hull->TS->Domain->GS->OS->RS->PS->OM\n\n### 什么是曲面细分着色器\n\n[大体介绍了一下曲面细分](https://www.cnblogs.com/chenglixue/p/17227713.html)\n\n## 透明效果\n\n\n\n# 球谐函数\n\n\n\n## 雾效\n\n\n\n\n\n# 重要性采样\n\n\n\n## 阴影\n\nLightMap\n\nShadowMapping\n\nPCF\n\nPCSS\n\nVSSM\n\n### CSM如何做的？\n\nCascaded Shadow Maps(CSM)方法根据对象到观察者的距离提供不同分辨率的深度纹理来解决上述问题。它将相机的视锥体分割成若干部分，然后为分割的每一部分生成独立的深度贴图。对于近处的场景使用较高分辨率的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用。\n\n## 两个多边形如何判断相交\n\nhttps://blog.csdn.net/StevenKyleLee/article/details/88075814\n\n### 一点是否在多边形内\n\nhttps://blog.csdn.net/StevenKyleLee/article/details/88044589\n\n一般用射线法这里说一下特殊情况：  \n<img src=\"/imgs/SpringBoss/RayPointSpe.png\" style=\"zoom:100%;\" >  \n这里的(b)因为中间那个顶点左右两条边都在该顶点的上侧，所以该顶点不识为于射线相交。  \n具体的判定过程应该可以根据多边形绕向找相邻点进行判断。\n\n[除射线法外的其他方法](https://blog.csdn.net/WilliamSun0122/article/details/77994526)\n\n## TAA(temporal anti-aliasing)\n\n[TAA in DX12](https://zhuanlan.zhihu.com/p/64993622)  \n[快速理解Tone Mapping](https://zhuanlan.zhihu.com/p/147567747)  \n[Tone Mapping](http://www.ownself.org/blog/2011/tone-mapping.html)  \n[TAA GHOSTING 的相关问题](https://www.cnblogs.com/crazii/p/7244300.html)  \nTone Mapping 是HDR算法的一部分，是用来将渲染出的场景亮度域映射到一个合理的亮度域空间。\n\n> 然后值得一提的是TAA在管线中的位置，虚幻的TAA是放在其它的后处理之前的，这么可以防止其它后处理出现的闪烁，但是因为高光很容易闪，我们又希望能在低动态范围处理，所以这里虚幻选择的是先tonemap，再算超采样，最后逆tonemap输出，去做其他的后处理。\n\n这里是说如果不做ToonMapping把HDR压倒LDR做TAA，因为HDR范围比LDR，然后TAA在混合在一起就会“亮的很花”，所以先Toon Mapping到LDR做一下TAA在 逆Toonmap输出，这样还得到了抗锯齿的输出，后处理做的更好了。这里的HDR和Toonmap我思考了很久，因为我没明白Toonmap，toonmap就是把hdr变成ldr，hdr虽然表示了更多的颜色，但是我们在屏幕空间显示还是0~1，所以要做映射，直接线性映射不行，因为人对暗部感知明显，而且自然界比LDR亮度大得多，所以我们做了很多调整。\n\n### 颜色LDR和HDR\n\n[LUT简述](https://www.jianshu.com/p/fdec2a5e889f)  \n[HDR和Tone Mapping](https://zhuanlan.zhihu.com/p/80253409)\n\n### 几何走样和着色走样\n\n* **几何走样：**几何覆盖函数采样不足，即俗称的边缘锯齿，一般发生在**光栅化阶段**。  \n* **着色走样：**渲染方程的采样不足，因为*渲染方程也是连续函数*，对某些部分在*空间变化较快（高频部分）采样不足也会造成走样*，反映在视觉上一般是图像闪烁或噪点，这类走样称之为着色走样，一般发生在**各种着色阶段**。\n  \n## Z-fighting\n\n\n\n## 景深\n\n所谓景深就是照片背景的虚化程度，规律是：光圈越大，景深越浅，背景越模糊；光圈越小，景深越深，背景越清晰。  \n[景深](http://www.ownself.org/blog/2010/jing-shen-depth-of-field.html)\n\n## 点到三角形距离\n\nhttps://zhuanlan.zhihu.com/p/148511581  \n[点到三角形面距离](https://zhuanlan.zhihu.com/p/148511581)\n\n## PBR\n\n[【基于物理的渲染（PBR）白皮书】（一） 开篇：PBR核心知识体系总结与概览](https://blog.csdn.net/poem_qianmo/article/details/85239398)\n\n## 材质系统\n\n材质系统了解、实现。\n\n\n\n# 计组部分\n\n### 大端和小端模式\n\nhttps://blog.csdn.net/wei_cheng18/article/details/79856207\n\n* **大端**（Big_endian）字数据的**高字节**存储在**低地址**中，字数据的**低字节**存储在**高地址**中。  \n* **小端**（Little_endian）字数据的**高字节**存储在**高地址**中，字数据的**低字节**存储在**低地址**中。\n  \n### Cache 命中率\n\n# 计网\n\n## TCP\n\n### [TCP三次握手](https://blog.csdn.net/jun2016425/article/details/81506353)\n\n* 第一次握手：客户端向服务器发起链接请求  \n* 第二次握手：服务器向客户端返回，发送答应客户端请求的确认信息。  \n* 第三次握手：客户端向服务器，告诉服务器已经收到第二次握手的确认信息。\n  \n#### TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？\n\n答：建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。\n\n（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。\n\n（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。\n\n（3）采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况，因此采用三次握手刚刚好，两次可能出现失效，四次甚至更多次则没必要，反而复杂了\n\n### 四次挥手\n\n* 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，**主动方：“我不会再给你数据了。”**  \n* 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1，**被动方：“我知道了！”**  \n* 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，**被动方：”我的数据也发送完了，不会再给你发数据了。“**  \n* 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，**主动方：“行了，那我知道了，一切结束”**\n  \n# 编译原理\n\n## [逆波兰式](https://blog.csdn.net/weixin_43919932/article/details/103327530)\n\nhttps://www.cnblogs.com/tangqs/archive/2012/05/18/2507708.html  \n 如果是右单目运算符，直接入存储器栈；比如 阶乘！与百分号%\n\n# OS\n\n## 进程和线程\n\n[进程和线程](https://blog.csdn.net/ThinkWon/article/details/102021274)  \n[线程调度](https://blog.csdn.net/qq_33182418/article/details/121135914)  \n[进程/作业调度](https://blog.csdn.net/qq_41784433/article/details/122194695)\n\n### 多线程比单线程慢\n\n存在上下文切换和死锁问题。  \nhttps://www.cnblogs.com/xrq730/p/5186609.html\n\n## Linux 进程通讯\n\nhttps://blog.csdn.net/qq_44443986/article/details/115065540\n\n## 死锁和银行家算法\n\nhttps://blog.csdn.net/wyf2017/article/details/80068608\n\n## 什么是内存碎片，内存碎片是在虚拟内存还是物理内存？\n\n采用分区式存储管理的系统，在储存分配过程中产生的、不能供用户作业使用的主存里的小分区称成“内存碎片”。内存碎片分为内部碎片和外部碎片。内存碎片只存在于虚拟内存上。\n\n# 概率论\n\n## 期望计算和带保底卡池期望计算\n\n\n\n\n\n\n\n\n\n\n\n# 算法\n\n## LRU手撸\n\nhttps://leetcode.cn/problems/lru-cache-lcci/\n\nLRU算法还有进化版LFU算法\n\n## 双端队列\n\n一个能用队列和栈实现的增删查改都是O(1)的数据结构，是什么  \n这个能用队列和栈实现的增删查改都是O(1)的数据结构是双端队列（deque）[[1](https://zh.wikipedia.org/wiki/队列#双端队列)]。双端队列不仅支持在队列的一端进行入队和出队操作，也支持在队列的另一端进行插入和删除操作。因此，在使用双端队列时，可以根据具体的需求选择在队列的哪一端进行操作，从而实现了增删查改都是O(1)的效率。\n\n### 双端队列定义\n\n能在队列两端进行入队、出队操作。\n\n## 统计子树中城市之间最大距离\n\nhttps://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/submissions/412418189/\n\n## A*算法\n\nhttps://zhuanlan.zhihu.com/p/54510444\n\n## 岛屿问题\n\nhttps://leetcode.cn/problems/number-of-islands/solutions/13103/dao-yu-shu-liang-by-leetcode/\n\n## Top K 问题\n\nhttps://zhuanlan.zhihu.com/p/64627590\n\n\n\n# C# 和 Unity\n\n[CSDN不错的面试总结-2022年Unity面试题分享 | 全面总结 | 建议收藏](https://blog.csdn.net/qq_21407523/article/details/108814300)  \n[知乎上五尘的Unity面试题](https://zhuanlan.zhihu.com/p/554529423)\n\n## 协程\n\n[总结：协程与线程](https://blog.csdn.net/w2009211777/article/details/125514898)\n\n## 请简述GC（垃圾回收）产生的原因，并描述如何避免？\n\nGC回收堆上的内存避免：1.减少new产生对象的次数2.使用公用的对象（静态成员）3.将String换为StringBuilder\n\n## C++指针和C#的引用\n\n[c++引用和c#引用类型的区别](https://zhuanlan.zhihu.com/p/389422617)\n\n## 反射\n\n[[整理]C#反射(Reflection)详解](https://www.cnblogs.com/wangshenhe/p/3256657.html)  \n[【Unity|C#】基础篇(12)——反射（Reflection）（核心类：Type、Assembly）](https://www.cnblogs.com/shahdza/p/12261831.html)\n\n* 反射的定义：审查元数据并收集关于它的类型信息的能力。元数据（编译以后的最基本数据单元）就是一大堆的表，当编译程序集或者模块时，编译器会创建一个类定义表，一个字段定义表，和一个方法定义表等。\n  \n* .NET的应用程序由几个部分：**程序集（Assembly）、模块（Module）、类型（class）组成**。\n  \n## 工厂模式\n\nhttps://wittykyrie.github.io/posts/Factor-Pattern/  \n[简单工厂模式、工厂方法模式优缺点](https://blog.csdn.net/cxy_zxl/article/details/116695023)  \n[C++ 深入浅出工厂模式（初识篇）](https://zhuanlan.zhihu.com/p/83535678)\n\n### 抽象工厂模式\n\nhttps://blog.csdn.net/m0_46502538/article/details/120343296\n\n## UGUI 如何实现UI物体淡入淡出?\n\n* Text，Image这些组件都有继承Graphic类，这个类提供了CrossFadeAlpha()方法，可以做透明度渐变。  \n* 但如果界面东西多了，要获取每个Graphic是挺麻烦了。其实还有一个很简便的方法，用起来跟NGUI差不多。就是CanvasGruop组件，把这个组件放到界面根节点上，对这个组件的alpha做改变就行了。看看官方文档的解释，\n  \n## ESC 框架\n\nhttps://blog.codingnow.com/2017/06/overwatch_ecs.html\n\nECS 的 E ，也就是 Entity ，可以说就是传统引擎中的 Game Object 。但是是 C 的整合其实。\n\nC 和 S 是这个框架的核心。System 系统，也就是我上面提到的模块。每个模块应该专注于干好一件事，而每件事要么是作用于游戏世界里同类的一组对象的每单个个体的，要么是关心这类对象的某种特定的交互行为。比如碰撞系统，就只关心对象的体积和位置，不关心对象的名字，连接状态，音效、敌对关系等。\n\n每个可能单独使用的对象属性归纳为一个个 Component ，比如对象的名字就是一个 Component ，对象的位置状态是另一个 Component 。\n\n## unity的委托是什么? event 关键字有什么用？\n\n委托是一个容器，可以放函数对象，并且可以触发委托面的每个函数调用。委托主要用户回调函数。如果在外部给委托变量加函数进来，那么委托要定义成public, 这样做又有一个问题，public外部的人也可以触发这个委托，如果我希望设计成外部可以加回调，但是只能是模块内部触发委托，那么我可以加一个event来修饰，这样虽然是public,但是外部无法触发委托,只能类的内部触发。\n\n# DX12\n\nDX12和\n\n# Vulkan\n\n[vulkan教程](https://geek-docs.com/vulkan/vulkan-tutorial/vulkan-tutorial-index.html)\n\n## Vulkan和DX12相比OpenGL好在哪里？\n\n\n\n# Unity\n\n[unity 八股文 实时更新](https://zhuanlan.zhihu.com/p/585164814)\n\n## UnityUpdate\n\n<img src=\"/imgs/SpringBoss/unityUpdate.jpg\">\n\n## Unity UGUI不规则区域点击问题\n\nhttps://www.cnblogs.com/msxh/p/9283266.html\n\n## 当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？\n\n碰撞检测失败，会直接穿透\n\n避免方法：  \n（1）增大细小物体的碰撞体（不建议这样做）  \n（2）使用射线检测，检测他们之间的距离  \n（3）FixedUpdate频率修改，可以physics time减小（同样不建议）  \n（4）改变物体的速度（废话）  \n（5）将检测方式改为连续检测，rigifdbody.collisionDetectionMode =CollisionDetectionMode.Continuous;  \n或者是动态连续检测（CollisionDetectionMode.ContinuousDynamic）  \n（6）代码限制，加大计算量 提前计算好下一个位置\n\n## [Canvas 有几种模式，如何配置？](https://blog.csdn.net/weixin_42352178/article/details/109034679)\n\nCanvas的三种渲染模式：\n\n* Screen Space-Overlay（屏幕空间-覆盖模式）UI元素的位置坐标是屏幕空间的坐标，Overlay模式下画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层。如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕。  \n* Screen Space-Camera（屏幕空间-摄影机模式）UI元素的位置坐标是屏幕空间的坐标，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。所不同的是，在该模式下，画布会被放置到摄影机前方。在这种渲染模式下，画布看起来绘制在一个与摄影机固定距离的平面上。所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。  \n  此时，画布上的UI组件会随视角移动。  \n* World Space即世界空间模式，此模式下UI元素的位置坐标是世界空间的坐标。画布作为场景中的一部分被固定显示在场景中，显示效果类似Plane组件。\n  \n## Unity 渲染队列\n| Name        | ID   | Description                                                  |  \n| ----------- | ---- | ------------------------------------------------------------ |  \n| Background  | 1000 | 会在任何其他队列前渲染，渲染需要绘制在背景上的物体           |  \n| Geometry    | 2000 | 默认的渲染队列，大部分物体都使用这个队列，不透明物体一般使用这个队列 |  \n| AlphaTest   | 2450 | 需要进行透明测试的物体                                       |  \n| Transparent | 3000 | 在 Geometry 和 AlphaTest 后，**从后向前**地渲染，任何使用透明混合的物体都使用此队列 |  \n| Overlay     | 4000 | 该队列用于实现叠加效果，任何需要最后渲染的物体都使用此队列。 |\n\n\n\n## 游戏动画\n\n### 关节动画\n\n### 单一网格动画\n\n### 骨骼动画\n\n## unity中UGUI如何打包成图集?\n\n[unity中UGUI如何打包成图集? - 鲨鱼辣椒的回答 - 知乎 ](https://www.zhihu.com/question/472146051/answer/2011067756)\n\n* 开启UGUI的图集模式, Editor->Project Settings 下面有sprite packer的模式。  \n* 为每个UI图片制定要打入的图集的tag名字。  \n* 打包生成图集Window ------>Sprite Packer, 点击Pack即可打包生成图集。\n  \n## Build-IN RP和SRP\n\n[Unity SRP URP HDRP 的区别](https://blog.csdn.net/weixin_41622043/article/details/107623694)\n\n## SRP\n\n[Unity官方宣传](https://unity.com/cn/srp)\n\n### SRP Batcher\n\n[SPR Batcher 官方简介](https://blog.unity.com/cn/technology/srp-batcher-speed-up-your-rendering)\n","source":"_posts/SpringBoss.md","raw":"---\ntitle: 春招寄语\ndate: 2023-03-04 15:14:23\ntags:\nmath: true\ntypora-root-url: ./..\n---\n\n图形学全忘光了，技美笔试直接寄了。  \n把面试题整理一下吧……  \n对于**多线程**和**图形API**了解不够需要继续学习\n\n<!--more-->\n\n# C++ 部分\n\n## [new 和 malloc 区别](https://www.cnblogs.com/ywliao/articles/8116622.html)\n\n### 1.申请内存所在位置\n\n* new 从 free store 动态分配内存空间，free store 能否是堆取决于 new 的实现其可以是堆，还可以是静态存储区。\n  \n* malloc 从堆上分配内存\n  \n### 2.返回类型安全性\n* new 分配内存成功时，返回对象类型的指针，符合类型安全。\n  \n* malloc 返回 void* ，需要强制类型转换。\n  \n### 3.内存分配失败时返回值\n* new 失败返回 bac_alloc 异常，不会返回 NULL；  \n* malloc 失败返回 NULL；\n  \n### 4.是否需要指定内存大小\n* new 无需指定，编译器自己计算\n  \n* malloc 需要自己显示指定。\n  \n  ```c  \n  A *ptr = (A*)malloc(sizeof(A));  \n  ```\n  \n### 5.是否调用构造函数/析构函数\n* new 会经过三步分配内存  \n  * 调用 operator new (数组是 operator new[] )，分配足够大、原始、未命名的空间。  \n  * 编译器运行对应构造函数，传入初值。  \n  * 构造完成，返回一个指向该对象的指针。  \n* 在 delete 会  \n  * 调用析构函数  \n  * 编译器调用 operator delete / operator delete[]\n  \n### 6.对数组处理\n* C++ 有 new[] 和 delete [] 处理数组\n  \n* 而 malloc 不知道你存放什么，只会给一块原始的内存，所以需要我们自己指定\n  \n  ```c  \n  int *ptr = (int*)malloc(10*sizeof(int)); // 分配10个int，作为数组  \n  ```\n  \n### 7. new 和 malloc 是否可以相互调用\n\nnew delete可以基于 malloc 实现，但是 malloc 不能调用 new！！！\n\n### 8.是否可以重载\n\n* operator new / operator delete 可以重载  \n* malloc / free 不能重载\n  \n### 9.能够直观地重新分配内存\n\nmalloc 分配的内存如果不够了可以 realloc\n\n但是 new 不行！\n\n### 10.客户处理内存分配不同\n\noperator new 抛出异常前会调用一个用户指定的错误处理函数 new-handler，指向一个错误处理函数。\n\nmalloc 异常用户只能看着他 NULL\n\n## 类和接口\n\n如果把类比作一把枪，接口就是枪的配件，比如握把，枪托等等。我们对于类重点在于描述一个对象，而对于接口重点在于描述接口能提供的功能，所以接口内没有数据成员，只有成员函数。\n\n\n\n## C++ 类\n\n* 子类和父类有同名成员数据，是通过\"::\"区分  \n  ~~~c++  \n  class A  \n  {  \n  public:  \n      int num;  \n  }  \n  class B:public A  \n  {  \n  public:  \n      int num;  \n  }  \n  ~~~\n  \n  其实这两个`num`实际的名字是`A::num`和`B::num`\n  \n* 类的成员函数调用  \n  非虚函数，根据调用对象类型决定，虚函数根据实际类型决定。\n  \n  ~~~c++  \n  class T  \n  {  \n  public:  \n      virtual void Fun1() { std::cout << \"T\" << std::endl; }  \n  };\n  \n  class A  \n  {  \n  public:  \n      int num;  \n  public:  \n      A() { num = 2; std::cout << \"A::A \" << num++<<std::endl; }  \n      virtual void Fun1() { std::cout << \"A::Fun1 \" << ++num<< std::endl; }  \n      void Fun2(){ std::cout << \"A::Fun2 \" << --num << std::endl; }  \n      void Fun3(){ std::cout << \"A::Fun3 \" << num-- << std::endl; }  \n      ~A() { std::cout << \"~A() \" << --num << std::endl; }  \n  };\n  \n  class B :public A  \n  {  \n  public:  \n      int num;  \n  public:  \n      B() { num = 100; std::cout << \"B::B \" << num++ << std::endl; }  \n      void Fun1() { std::cout << \"B::Fun1 \" << ++num << std::endl; }  \n      void Fun2() { std::cout << \"B::Fun2 \" << --num << std::endl; }  \n      virtual void Fun3() { std::cout << \"B::Fun3 \" << num-- << std::endl; }  \n      ~B() { std::cout << \"~B() \" << --num << std::endl; }  \n  };\n  \n  int main()  \n  {  \n      A* ptr = new B;  \n      ptr = dynamic_cast<A*>(ptr);  \n      ptr->Fun1();  \n      ptr->Fun2();  \n      ptr->Fun3();  \n  }  \n  ~~~\n  \n  ~~~c++  \n  A::A 2  \n  B::B 100  \n  B::Fun1 102  \n  A::Fun2 2  \n  A::Fun3 2  \n  ~B() 101  \n  ~A() 0  \n  ~~~\n  \n  `A* ptr = new B;`  \n  `ptr`类型为`A*`，但是实际指向对象类型其实为`B`  \n  那么其实在内存空间中有如下分配\n  \n  ~~~  \n  成员数据:  \n  n_ptr  \n  A::num  \n  B::num  \n  一张A的虚函数表？  \n  一张B的虚函数表  \n  函数映射：  \n  直接查找的  \n  A::Fun2  \n  A::Fun3  \n  B::Fun1  \n  B::Fun2  \n  ~~~\n\n  \n  \n## 构造函数链和析构函数链\n\n### 构造函数链\n\n一个类中有父类成员，成员变量。对于构造函数我们\n\n1. 先调用父类，  \n2. 再调用成员变量的构造函数，  \n3. 最后调用子类构造函数在构造过程中\n\n子类是继承父类的成员\n\n~~~c++\nclass A\n{\n    int a;\n}\n\nclass B : public A\n{\n\tint b;    \n}\n~~~\n\n这里B有成员b，和从父类继承的a。  \n因为 a 是父类成员，所以交由父类初始化，如果先调子类，子类成员有a，b，对a，b初始化，再调父类，a又初始化初始化两次。  \n对于成员变量，成员变量有自己的构造函数，是当前子类无需关心的，对于他们先交给他们自己初始化即可。\n\n## 析构函数链\n\n对于析构函数链，我们把子类可以看成一个套娃。  \n我们装套娃会从小到大(从父到子)\n\n## C++的public、protected、private和三种继承\n\npublic 表示大家谁都能来访问，包括类对象自己和外部。  \nprotected,外部不能访问，但是自己和子类可以访问。  \nprivate，表示只能自己访问，自己的子类都不能访问。  \npublic 继承，不改变父类成员的可见性。  \nprotected 继承，父类成员除private外，全部变为protect  \nprivate 继承全部变为private\n>假如把父类比喻一个门派，期内对象就是武功秘籍  \n>public 就像比较普通的武功，比如太祖长拳，大家都可以来学。  \n>protect 就像门派内的高深强大的武功秘籍，比如降龙十八掌，只有你是下一任掌门才能学。  \n>private 就像掌门自己偷学了邪门歪道，比如岳不群学《辟邪剑谱》，只能自己知道，外人不能晓得。除了自己谁也不让看。  \n>  \n>public 继承就像是普普通通比较开明的继承者，子承父业，原来掌门规定的哪些武功可以交给外人，哪些武功自己人学，都不变，但是掌门私底下学的歪门武功他也不知道是什么，对他而言不可见，想知道是什么得返回去用上一任掌门的去查。  \n>protect 继承就像垄断或者有点小心思的人继承，我不让所有人随便学了，现在你们想从我这学你得是我的关门弟子下一任掌门。  \n>private 继承就像断代了，诶，我谁也不教，全部变成private，只有我自己看，但是无论这三种哪一种都看不到父类的private。\n\n## static关键字\n\nstatic关键字表示静态元素，其在程序的生存周期中仅在**静态存储区**分配一次存储空间，直到程序的生存周期结束。  \nstatic常用于\n\n* 函数中的静态变量  \n* 静态类对象  \n* 类中的静态成员变量  \n* 类中的静态方法\n  \n## **static 和const分别怎么用，类里面static和const可以同时修饰成员函数吗**\n- **static**\n  \n  - static对于变量\n  \n    1. 局部变量\n  \n       在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。\n  \n       内存中的位置：静态存储区\n  \n       初始化：局部的静态变量只能被初始化一次\n  \n       作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。\n  \n       > 当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。\n  \n    2. 全局变量\n  \n       在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。\n  \n       内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）\n  \n       初始化：未经初始化的全局静态变量会被程序自动初始化为0\n  \n       作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。(只能在本文件中存在和使用)\n  \n       > 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。\n  \n- static对于函数\n  \n  修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。（和全局变量一样限制了作用域而已）\n  \n- static对于类\n  \n  1. 成员变量\n  \n     用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，**包括派生类的对象**。\n  \n     因此，static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化 。\n  \n  2. 成员函数\n  \n     用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，**不含this指针。**\n  \n     静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。\n  \n     **不可以同时用const和static修饰成员函数。**\n  \n- **const**\n  \n  1. 限定变量为不可修改。  \n  2. 限定成员函数不可以修改任何数据成员\n  \n- static和const可以同时修饰成员函数吗?\n  \n  答：不可以。C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。两者的语意是矛盾的。**static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态**，与类型的静态变量没有关系。因此不能同时用它们。\n  \n## 拷贝构造函数\n\n**只有这三种情况！！！！！**\n\n### 1.用一个对象初始化另一个对象。\n\n```c++  \nPoint p2(p1);  \nPoint p3 = p1  \n```\n\n这两种情况一样。\n\n### 2.若一个函数的形参是一个 Class 对象，当 F 被调用时，Class 拷贝构造函数调用。\n\n```c++  \nvoid Func(Point a){};\n  \nint mian()  \n{  \n    Point a;  \n    Func(a);    // 调用拷贝构造函数  \n}  \n```\n\n### 3.如果函数的返回值是 Class 对象，函数返回时，调用 Class 拷贝构造函数\n\n即返回值对象由拷贝构造函数初始化。\n\n## 模板函数\n\n### 模板函数的声明实现为什么必须在一个文件内\n\n[CSDN : 模板函数的声明和定义为何不能分开放在两个文件中?](https://blog.csdn.net/chigusakawada/article/details/78752668)\n\n##  C++ 11 特性\n\n### 左值右值\n\n[四行代码！看懂右值引用](https://www.cnblogs.com/qicosmos/p/4283455.html)\n\n#### 右值引用的特点：\n\n1. 通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。  \n   ~~~c++  \n   A GetA()  \n   {  \n       return A();  \n   }  \n   A&& a = GetA();\t// 这里只会调用一次拷贝构造函数，就是return A()，  \n   // 因为A&& 延长了 GetA的生命周期无需拷贝函数  \n   ~~~\n  \n2. 右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。\n  \n3. T&& t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。  \n   正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。\n  \n4. \n\n移动语义的实现：\n\n~~~c++\nA GetA()\n{\n    return A;\n}\n\nA(A&& a):m_ptr(a.m_ptr){}\n\nA a = GetA();\n~~~\n\n利用右值引用作为参数，因为`GetA`返回值是右值，而`A&&`类型确定不发生自动推断即确定的右值，拷贝函数会匹配到`A(A&& a)`，这样就省去了重新`new m_ptr`。\n\n##### 引用折叠\n\n- 所有的右值引用叠加到右值引用上仍然还是一个右值引用；  \n- 所有的其他引用类型之间的叠加都将变成左值引用。\n  \n#### 一个移动语义应用\n实现移动构造和移动赋值  \n为什么在 移动构造中将 f.ptr 赋值为 nullptr  \n因为我们的移动构造函数参数是一个右值，在完成初始化的任务后就应该消失，所以把他所指内存交给新对象，并指向了nullptr，移动赋值也是同理。  \n移动赋值和移动复制通常联合使用，目的是优化对象的复制和赋值操作，提高程序的性能。  \n移动赋值会在这时调用`f1=Foo()`，f1是之前声明过的，Foo()返回右值，匹配到`=(Foo&&)`函数。\n~~~c++\nclass Foo\n{\npublic:\n    int a;\n    int *ptr;\n\npublic:\n    Foo(Foo&& f):ptr(f.ptr),a(f.a)\n    {\n        f.ptr = nullptr;\n    }\n    \n    Foo& operator =(Foo&& f)\n    {\n        if(this != &f)\n        {\n            this->ptr = f.ptr;\n            f.ptr = nullptr;\n            a = f.a;\n        }\n        return *this;\n    }\n};\n~~~\n\n### 一些补充\n\n~~~c++\nvec.push(Foo());\n~~~\n\n首先，我们知道函数的返回值是右值，所以Foo() 这部分是个右值  \n当我们没有右值引用的移动构造函数时，我们会发生 右值转换的过程——把右值转化为左值，调用复制构造函数。  \n若我们有参数为右值引用的移动构造函数，右值会直接匹配到这个函数，不会发生一次转换去匹配参数为左值的复制构造函数。  \n这里的知识点是右值可以转换为左值。\n\n### 智能指针\n\n\n\n### 类型推断\n\n\n\n### lambda表达式\n\n\n\n### 类型转换\n\n[九阳神功！不会C++就看这个！](https://zhuanlan.zhihu.com/p/417640759)（1）const_cast: 把const属性去掉，即将const转换为非const（也可以反过来），const_cast只能用于指针或引用，并且只能改变对象的底层const（顶层const，本身是const，底层const，指向对象const）；\n\n（2）static_cast: 隐式类型转换，可以实现C++中内置基本数据类型之间的相互转换，enum、struct、 int、char、float等，能进行类层次间的向上类型转换和向下类型转换（向下不安全，因为没有进行动态类型检查）。它不能进行无关类型(如非基类和子类)指针之间的转换，也不能作用包含底层const的对象；\n\n（3）dynamic_cast：动态类型转换，用于将基类的指针或引用安全地转换成派生类的指针或引用（也可以向上转换），若指针转换失败返回NULL，若引用返回失败抛出bad_cast异常。dynamic_cast是在运行时进行安全性检查；使用**dynamic_cast父类一定要有虚函数，否则编译不通过；**\n\n（4）reinterpret_cast：reinterpret是重新解释的意思，此标识符的意思即为将数据的二进制形式重新解释，但是不改变其值，有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用（比较不安全）\n\n## C++ struct和class区别\n\n* 在 **C 语言** 中，**结构体** 只能存放一些 **变量** 的集合，并不能有 **函数**，但 **C++** 中的结构体对 C 语言中的结构体做了扩充，可以有函数，因此 C++ 中的结构体跟 C++ 中的类很类似。C++ 中的 struct 可以包含成员函数，也能继承，也可以实现多态。\n  \n* 但在 C++ 中，使用 class 时，类中的成员默认都是 **private** 属性的，而使用 struct 时，结构体中的成员默认都是 public 属性的。\n  \n* class 继承默认是 private 继承，而 struct 继承默认是 public 继承。\n  \n* C++ 中的 class 可以使用模板，而 struct 不能使用模板。\n  \n## C++ vector\n\nvector.clear 不释放空间\n\n- int size() const:返回向量中元素的个数  \n- int capacity() const:返回当前向量所能容纳的最大元素值  \n- int max_size() const:返回最大可允许的vector元素个数值\n  \n## C++智能指针和安全性\n\n智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(shared_ptr), 独占指针(unique_ptr)和弱指针(weak_ptr)：\n\n（1）shared_ptr ，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；\n\n（2）unique_ptr，保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr）；\n\n（3）weak_ptr，用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。\n\n- shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？shared_ptr是不是线程安全的？\n  \n\n（1）shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；\n\n（2）具体实现：\n\n1）构造函数：将指针指向该对象，引用计数置为1；\n\n2）拷贝构造函数：将指针指向该对象，引用计数++；\n\n3）赋值运算符：=号左边的shared_ptr的引用计数-1，右边的shared_ptr的引用计数+1，如果左边的引用技术降为0，还要销毁shared_ptr指向对象，释放内存空间。\n\n（3）shared_ptr的引用计数本身是安全且无锁的，但是它指向的对象的读写则不是，因此可以说shared_ptr不是线程安全的。[shared_ptr是线程安全的吗？ - 云+社区 - 腾讯云 (tencent.com)](https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1654442)\n\n- weak_ptr是为了解决shared_ptr的循环引用问题，那为什么不用raw ptr来解决这个问题？\n  \n\n答：一个weak_ptr绑定到shared_ptr之后不会增加引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使weak_ptr指向对象，也还是会释放；raw指针，当对象销毁之后会变成悬浮指针。\n\n## Shared_ptr实现原理\n\n\n\n### 智能指针如何实现\n\nC++中的智能指针（smart pointers）是一种RAII（Resource Acquisition Is Initialization）技术的实现方式，它们可以自动管理内存资源，并确保在对象离开作用域时正确地释放这些资源。智能指针的主要目的是确保资源获取与对象初始化同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。\n\nC++11中引入了三种智能指针：`std::unique_ptr`、`std::shared_ptr`和`std::weak_ptr`。其中`std::unique_ptr`是用于独占式拥有一个对象，`std::shared_ptr`是用于共享拥有一个对象，而`std::weak_ptr`则是用于弱引用一个对象。\n\n当我们需要使用RAII技术来管理动态分配的内存时，我们通常使用`std::unique_ptr`来管理指向单个对象的指针，并使用`std::shared_ptr`来管理指向共享资源的指针。如果我们需要在一个对象中存储多个指向共享资源的指针，则应使用`std::weak_ptr`来避免循环引用问题。\n\n总之，智能指针是一种非常有用的C++编程工具，可以帮助我们更安全、更简单地管理内存资源，并且对于编写高质量的C++代码来说至关重要。更多关于智能指针的资料可以参考[[3](https://zhuanlan.zhihu.com/p/150555165)][[4](https://learn.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170)]。\n\n\n\n## 为什么析构函数一定要被设置为虚函数\n\n[为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数](https://www.cnblogs.com/yuanch2019/p/11625460.html)\n\n首先类的**虚函数**调用是靠**虚函数指针**调用的，而函数成员靠的是对象类型。  \n~~~c++\nclass A\n{\npublic:\n    void func1(){};\n    virtual void func2(){};\n};\n\nint main(){\n    A a;\n    a.func1();\n    a.func2();\n}\n~~~\n\n对于`func1`是通过`a.this`调用，而`func2`是通过虚函数指针`a._vfptr->func2()`调用。(大概是这个意思，但应该是别的形式)\n\n>“Note：定义在类内部的函数是隐式的inline函数（参见6.5.2节，第214页）。” —— 《C++ Primer》 中文第五版 P230  \n>  \n>“成员函数通过一个名为**this**的额外隐式参数来访问调用它的那个对象。” —— 《C++ Primer》 中文第五版 P231\n\n**成员函数本质上可以看做全局函数，不过第一个参数固定为this。**\n\n### 菱形继承\n\nhttps://blog.csdn.net/tounaobun/article/details/8443228\n\n问题：A->B;A->C;B,C->D; B,C继承了A，D继承了A。  \n在调用D的成员函数时候就不知道是调用B的，还是C的，所以在继承中使用\n\n~~~c++\nclass Animal\n{\npublic:\n    void func() { cout << \"Animal\"; };\n};\n\nclass Lion : virtual public Animal\n{\n};\n\nclass Wolf : virtual public Animal\n{\n};\n\nclass Cat : public Wolf, public Lion\n{\n};\n~~~\n\n加上virtual保证子类只有一个父类的子对象，防止发生二义性。\n\n## C++ 深拷贝浅拷贝\n\n（1）拷贝构造函数的作用就是定义了当我们用同类型的另外一个对象初始化本对象的时候做了什么，在某些情况下，如果我们不自己定义拷贝构造函数，使用默认的拷贝构造函数，就会出错。比如一个类里面有一个指针，如果使用默认的拷贝构造函数，会将指针拷贝过去，即两个指针指向同个对象，那么其中一个类对象析构之后，这个指针也会被delete掉，那么另一个类里面的指针就会变成**野指针（悬浮指针）**；\n\n（2）这也正是深拷贝和浅拷贝的区别，浅拷贝只是简单直接地复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。\n\n## C++野指针\n\n指针指向了一块非法内存区域(悬空或者说未知区域)。\n\n## C++ 虚函数\n\n### [哪些函数不能是虚函数](https://www.cnblogs.com/NeilZhang/p/5427872.html)\n\n常见的不不能声明为虚函数的有：普通函数（非成员函数）；静态成员函数；内联成员函数；构造函数；友元函数。\n\n## C++ 内存模型\n\n### C++内存布局\n\n#### Heap 堆\n由new分配的内存块，其释放编译器不去管，由我们**程序自己控制（一个new对应一个delete）**。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”\n\n#### Stack 栈\n\n**编译器**在需要时**分配**，在不需要时自动清除。存放**局部变量**和**函数参数**。  \n存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。\n\n#### 全局/静态存储区(.bss和.data段)\n\n全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中称为zero initialization，初始化的放在.data段中，称为const initialization；在C++中二者不进行区分。  \n虚函数表就存在这里，因为是全局公用的一张表，通过虚函数指针查找。\n\n#### 常量存储区(.rodata段)\n\n存放常量，不允许修改，比如`const int a = 3`\n\n#### 代码区(.text段)\n\n存放代码，比如我们的函数和类的成员函数。不许修改但是可以执行。\n\n### C++内存区域\n\n根据生命周期不同，C++中可划分出三种不同的内存区域\n\n1.自由存储区、动态区、静态区局部非静态变量的存储区域(栈)  \n2.动态区：new，malloc分配的内存  \n3.静态区：全局变量，静态变量，字符串常量存在位置\n\nhttps://www.cnblogs.com/yunlambert/p/9876491.html  \n[深入理解计算机系统（内存管理）----内存模型](https://blog.csdn.net/JUST__Tw/article/details/118551674)  \n空类(空 class)大小是1，为了标识对象  \n[不同类型占用的字节](https://blog.csdn.net/li975242487/article/details/121395693)\n\n## C++运算符重载\n\nhttps://www.cnblogs.com/liuchenxu123/p/12538623.html\n\n## 派生类的构造函数顺序\n\nhttps://www.nowcoder.com/questionTerminal/6348a321452a4318a2da5f3757baf620?source=relative\n\n## 迭代器\n\nhttps://blog.csdn.net/QIANGWEIYUAN/article/details/89184546\n\n## 红黑树\n\nhttps://blog.csdn.net/u014454538/article/details/120120216\n\n## 小根堆，大根堆\n\n### 完全二叉堆\n\n堆又可称之为完全二叉堆。这是一个逻辑上基于完全二叉树、物理上一般基于线性数据结构（如数组、向量、链表等）的一种数据结构。\n\n#### 完全二叉树\n\n完全二叉树是由满二叉树而引出来的，若设二叉树的`深度为h`，`除第 h 层外`，`其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)`，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。\n\n### 小根堆\n\n根小于节点\n\n### 大根堆\n\n根大于节点\n\n\n\n## 对象池\n\n对象池内通常是对象实例的指针，因为对象池的原理是将对象放入池管理的某种内存连续的数据结构中，当不需要对象时，并不销毁对象，而是将对象回收到池中，下次需要的时候再次从池中拿出来。由于对象储存在内存连续的数据结构中，所以能够有效地解决内存碎片的问题。因此，对象池中保存对象的指针比直接保存对象实例更为高效，能够避免频繁分配和销毁内存，从而提高了程序的性能。\n\n\n\n## 多线程\n\n[进程间通信方式；线程间通信方式](https://zhuanlan.zhihu.com/p/430069448)\n\n### 进程间通讯的方式？\n\n管道通信，消息队列，共享内存，socket，串口都可以实现。\n\n#### 管道( pipe )：\n\n管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。\n\n#### 有名管道 (namedpipe) ：\n\n有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。\n\n#### 信号量(semophore ) ：\n\n信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\n\n#### 消息队列( messagequeue ) ：\n\n消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n\n#### 信号 (sinal ) ：\n\n信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。\n\n#### 共享内存(shared memory ) ：\n\n共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。\n\n#### 套接字(socket ) ：\n\n套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。\n\n### 线程间通讯方式。\n\n**锁机制：包括互斥锁、条件变量、读写锁**\n\n- 互斥锁提供了以排他方式防止数据结构被并发修改的方法。  \n- 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。  \n- 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。\n  \n\n**信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量**\n\n**信号机制(Signal)：类似进程间的信号处理**\n\n# 图形学部分\n\n## 叉乘\n\n两个向量的叉乘结果是一个垂直于这两个向量的向量，最后这个向量的长度等于以最初两个向量作为边的平行四边形的面积。\n\n## 光照模型\n\n* emissive  \n* specular  \n* diffuse  \n* ambient\n  \n### 环境光\n\n通常用系统定值，场景物体通用\n\n<img src=\"/imgs/SpringBoss/C_ambient.png\">\n\n### 自发光\n\n材质决定\n\n<img src=\"/imgs/SpringBoss/C_emissive.png\">\n\n### 漫反射\n\n根据 Lambert‘s law\n\n<img src=\"/imgs/SpringBoss/C_diffuse.png\">\n\n### 高光反射\n\n我们有很多变量：normal，eyeDir，lightDir，refDir\n\n#### 已知 normal，lightDir 求 refDir\n\n<img src=\"/imgs/SpringBoss/NormalLightEyeRef.png\">\n\n<img src=\"/imgs/SpringBoss/RefEqu.png\">\n\n##### Phong 模型\n\n<img src=\"/imgs/SpringBoss/PhongSpecular.png\">\n\n##### Blinn-Phong\n\n<img src=\"/imgs/SpringBoss/BlinnPhong.png\">\n\n## 复习下线性代数\n\n### 坐标系\n\n坐标系分为*左手坐标系*和*右手坐标系*\n\n<img src=\"/imgs/SpringBoss/LeftRight.png\" style=\"zoom:60%;\" >\n\n二者在 z 轴方向上有所不同。  \n在 Unity 中**模型空间**和**世界空间**为左手系，**观察空间**为右手系。\n\n### 矩阵\n\n矩阵又分为行矩阵和列矩阵。  \n***<u>矩阵的左乘/右乘，表示该矩阵在乘号的左侧/右侧。</u>***\n\n#### 行矩阵\n\n<img src=\"/imgs/SpringBoss/rowMatrix.png\" >\n\n表示 1xn 的矩阵，行矩阵**左乘**，变换矩阵乘在右侧-> `1xn dot nxn = 1xn`\n\n##### 齐次式\n\n* 矢量/点\n  \n  <img src=\"/imgs/SpringBoss/rowMatrixHC.png\">\n  \n* 变换矩阵\n  \n  <img src=\"/imgs/SpringBoss/rowMatrixHCT.png\" >\n#### 列矩阵\n\n<u>***Unity就是列矩阵！***</u>\n\n> 问题1  \n> shader中会看到法线的变换矩阵：  \n>float3x3 transform = float3x3(v.tangent.xyz, binormal, v.normal);  \n即，**float3x3类型的变量**在创建时，如果传入3个float3类型的变量。整个矩阵是按行优先填充还是按列优先填充呢？  \n答：填入的是三个列，即unity shader是**列优先**（column-major）的。  \n问题2  \n**matrix**.m12是什么意思？  \n答：m12是第一行第二列，但是构造矩阵时是**按列的**。\n\n<img src=\"/imgs/SpringBoss/columnMatrix.png\" >\n\n表示 nx1 的矩阵，列矩阵**右乘**，变换矩阵乘在其左侧 `nxn dot nx1 = nx1`\n\n##### 齐次式\n\n* 矢量/点\n  \n  <img src=\"/imgs/SpringBoss/colMHC.png\">\n  \n* 变换矩阵\n  \n\n<img src=\"/imgs/SpringBoss/colMHCT.png\">\n\n## 矩阵的几何意义变换\n\n变换优先级为：缩放>旋转>位移\n\n### 缩放\n\n<img src=\"/imgs/SpringBoss/scale.png\">\n\n### 旋转\n\n在**左手系**中，绕轴**旋转遵从左手手旋转准则**：大拇指为轴向，四指为旋转方向。  \n在**右手系**中，绕轴**旋转遵从右手旋转准则**：大拇指为轴向，四指为旋转方向。\n\n* 绕 x 轴\n  \n\n<img src=\"/imgs/SpringBoss/rotationX.png\">\n\n* 绕 y 轴\n  \n\n<img src=\"/imgs/SpringBoss/rotationY.png\">\n\n* 绕 z 轴\n  \n\n<img src=\"/imgs/SpringBoss/rotationZ.png\">\n\n#### 欧拉角旋转顺序\n\n因为不同轴旋转相乘得到变换矩阵不同。\n\n* 外旋和内旋  \n  假定一组旋转顺序 x->y->z 为内旋，则外旋为 z->x->y。  \n  一组对应的外旋内旋结果是一样的。\n  \n\n**Unity旋转顺序是ZXY**。\n\n### 位移\n\n<img src=\"/imgs/SpringBoss/translate.png\">\n\n### 变换顺序\n\n<img src=\"/imgs/SpringBoss/transform.png\">\n\n## [给定 4x4 矩阵，求缩放，旋转、平移矩阵](https://blog.csdn.net/qq_39300235/article/details/105790743)\n\n就以列矩阵为例解吧，因为大多都是列矩阵运算。  \n**M=TRS**\n\n<img src=\"/imgs/SpringBoss/4x4Matrix.png\">\n\n### T矩阵\n\n列矩阵最右侧就是 translate 变换\n\n```c++  \nT[0][3]=M[0][3]/M[3][3];  \nT[1][3]=M[1][3]/M[3][3];  \nT[2][3]=M[1][3]/M[3][3];  \n```\n\n### R矩阵\n\n之后我们对 M 矩阵剔除平移变换，得到只有缩放和旋转的矩阵*M*。  \n此时 *M*=RS；  \n我们只要算出旋转矩阵就行了，因为 R 可以用**旋转矩阵的逆矩阵**计算得到：\n\n<img src=\"/imgs/SpringBoss/4x4Rn.png\">\n\n接下来要分解出 R 矩阵，我们利用 ”Polar decomposition(极分解)“，可以证明矩阵*M*的极分解为 <u>旋转R</u> 和 <u>缩放S</u> 。该方法通过对 *M* 的逆的转置进行连续平均来计算，直到**收敛**，此时 ***M**i **= R***。\n\n<img src=\"/imgs/SpringBoss/Polar.png\">\n\n当矩阵只有旋转变换时，旋转R 的转置和R的逆相等，达到收敛状态。  \n因为旋转矩阵为**正交矩阵**。Shoemake和Duff（1992）讨论了该级数收敛的证明，所得矩阵是最接近M的正交矩阵，这是理想的特性。为了计算该序列，我们迭代应用公式，直到连续项之间的差很小或执行了固定的迭代次数为止。 实际上，该系列通常会很快收敛。\n\n```c++  \nFloat norm;  \nint count = 0;  \nMatrix4x4 R = M;  \ndo  \n{  \n    Matrix4x4 Rnext;  \n    Matrix4x4 Rit = Inverse(Transpose(R));    // 转置的逆  \n    for(int i = 0; i < 4; ++i)  \n    {  \n        for(int j = 0; j < 4; ++j)  \n        {  \n            Rnext.m[i][j] = 0.5f * (R.m[i][j]+Rit.m[i][j]);  \n        }  \n    }  \n    // compute the sub between Mi and Mi+1  \n    norm = 0;  \n    for(int i = 0; i < 3; ++i)  \n    {  \n        Float n = abs(R.m[i][0] - Rnext.m[i][0]) +  \n            abs(R.m[i][1] - Rnext.m[i][1]) +  \n            abs(R.m[i][2] - Rnext.m[i][2]);  \n        norm = max(norm,n);  \n    }  \n    R = Rnext;  \n}while(++count < 100 && norm > 0.0001) // 当迭代次数过多，或者连续项差距足够小，退出循环。  \n```\n\n### S矩阵\n\n得到 R 矩阵后 S矩阵就很简单\n\n```c++  \nS = Matrix4x4::Mul(Inverse(R),M);  \n```\n\n### 另外一种办法\n\n我们可以对3x3矩阵的每个列向量求长度，这样就知道每个坐标轴分量上的缩放，最终得到缩放矩阵，然后再根据缩放矩阵求旋转矩阵即可。\n\n## MVP矩阵\n\n### Model\n\n把顶点坐标从局部空间变换到全局空间。\n\n* 行矩阵\n  <img src=\"/imgs/SpringBoss/ModelRow.png\">\n  \n* 列矩阵\n<img src=\"/imgs/SpringBoss/ModelCol.png\">\n\n### View-Matrix 推导\n\n在图形渲染中我们要把3D的场景渲染成一张2D的图片，而这张图片是从 Camera 的视角出发，所以为了方便渲染我们做一个变换，把摄影机作为一个新的空间的原点，令摄影机观测方向为-z方向也就是我们常说的 视图变换(Viewing Transform)。  \n我们对场景中的物体都进行这样一个变换就可以得到，观察空间下的物体的坐标信息，即以 Camera 为原点，Camera 上方向为 y 轴，Camera 视线为 -z 轴，Camera 右侧为 x轴的坐标空间下物体信息。  \n**注意这里观察空间通常为右手系！而非和世界空间/模型空间所采用的左手系！**  \n**接下来推导为列矩阵运算！**\n这个变换主要分为两步一步是平移，一步是旋转。  \n设 Camera 坐标为<img src=\"/imgs/SpringBoss/posE.png\" style=\"zoom:50%;\" >  \n则平移矩阵为  \n<img src=\"/imgs/SpringBoss/viewT.png\" style=\"zoom:50%\">\n现在我们把摄影机放到了原点位置，现在我们只需要把轴向调整即可。  \n*注意这里变换推导过程是先平移后旋转，和平时计算规定的 Transform 先 scale 再 rotation最后  translate 的顺序不同。*  \n我们假设 Camera up 方向矢量为 *t*，观察方向为 *g*，则其 x 轴 *e* 为 *g*x*t*。  \n<img src=\"/imgs/SpringBoss/cameraETG.png\" style=\"zoom:50%\">  \n我们要让其轴向与 xyz 轴对齐，因为现在只是把物体进行了移动，坐标信息的基础轴还是世界坐标系而非 camera坐标系的三轴。  \n我们只需把 `t->y`,`g-> -z`,`e->x` 其中 `e = gxt`。  \n这样虽然可以进行计算，但是十分复杂。  \n我们观察到 既然TEG是坐标轴，就意味着他们三者垂直，点积为零，可以构成正交矩阵。  \n那么 `t->y`,`g-> -z`,`e->x` 的逆变换 `y->t`,`-z ->g`,`x->e` 是很好计算的。  \n而我们知道了逆矩阵，就可以知道正交矩阵的原矩阵。  \n正交矩阵性质: \n<img src=\"/imgs/SpringBoss/orthM.png\" style=\"zoom:80%\">\n\n所以\n<img src=\"/imgs/SpringBoss/Rview.png\" style=\"zoom:80%\">\n\n最后\n<img src=\"/imgs/SpringBoss/Mview.png\" style=\"zoom:80%\">\n\n### Projection Matrix\n\n我们现在已经放好了物体，也以 Camera 的角度出发了，现在我们要从 **View space( 观察空间 )** 到 **Clip Space( 裁剪空间/齐次裁剪空间 )**\n\n#### 我们这里先考虑把深度归到[0,1]的情况\n\n要把 **View 空间**的点投影到**屏幕**上，利用相似三角形原理，\n$$\n\\begin{aligned}\n\\frac{x_{screen}}{near}&=\\frac{x_{view}}{z_{view}}\\\\\nx_{screen}&=\\frac{x_{view}\\cdot near}{z_{view}}\\\\\ny_{screen}&=\\frac{y_{view}\\cdot near}{z_{view}}\\\\\n\\end{aligned}\n$$\n但是实际上我们是先把 *X,Y* 坐标变换到[-1,1]后映射到 Screen的，所以还得改成  \n将所有顶点映射到[-1,1]是为了方便 GPU 计算\n$$\n\\begin{aligned}\n&x_{screen}=\\frac{x_{view}\\cdot near}{z_{view}}&\\in[-wid,wid]\\\\\n&y_{screen}=\\frac{y_{view}\\cdot near}{z_{view}}&\\in[-height,height]\\\\\n&x_{ndc}=\\frac{x_{view}\\cdot near}{z_{view}\\cdot wid}&\\in [-1,1]\\\\\n&y_{ndc}=\\frac{y_{view}\\cdot near}{z_{view}\\cdot height}&\\in [-1,1]\\\\\n\\end{aligned}\n$$\n所以我们现在知道如何对 x,y 坐标进行变换了，Project Matrix 暂时可以写成这样，\n因为 z,w 不受 x,y 影响\n$$\n\\begin{bmatrix}\n\\frac{near}{z_p\\cdot wid}&0&0&0\\\\\n0&\\frac{near}{z_p\\cdot height}&0&0\\\\\n0&0&A&B\\\\\n0&0&C&D\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_p\\\\\ny_p\\\\\nz_p\\\\\n1\\\\\n\\end{bmatrix}\n$$\n\n而 z 值有些不一样，现在的问题是  \n\n* “我们的矩阵 *X,Y 坐标* 的变换矩阵和 <u>z值相关</u>”，  \n  这肯定不是我们希望看到的，这不利于 GPU 计算，\n* 而且为了实现深度测试我们还希望可以将深度值归化到[0,1]，  \n\n对于**第一个问题**，既然 *X,Y 坐标* 都要除 View Space 的 *Z* 坐标值，  \n那么我们不妨把这个除法操作在后面统一执行，也就是 **齐次除法**，  \n所以我们需要在做这个除法操作时能得到 *Z* 坐标值，而恰巧我们可以利用 *W 分量*  \n我们可以先把 *Z* 坐标轴存在 W 分量，即\n$$\n\\begin{bmatrix}\n\\frac{near}{wid}&0&0&0\\\\\n0&\\frac{near}{height}&0&0\\\\\n0&0&A&B\\\\\n0&0&1&0\\\\\n\\end{bmatrix}\n$$\n\n<u>因为View Space 是右手系的所以……z值不是正的</u>\n\n**第二个问题**，而对于 *Z* 值 原本范围是 [-far, -near] -> [?, ?] -> [0,1]\n$$\n[-far,-near]\\rightarrow[?,?]\\stackrel{/z}{\\rightarrow}[0,1]\n$$\n所以我们对 -near 和 -far 两个边界条件 列方程，因为是[0,1]在加上齐次除法所以near为0，far为far\n$$\n\\begin{aligned}\n\t-A\\cdot near+B=0\\\\\n\t-A\\cdot far+B=far\\\\\n\tA=\\frac{far}{near-far}\\\\\n\tB=\\frac{near\\cdot far}{near-far}\n\\end{aligned}\n$$\n\n得到\n$$\n\\begin{bmatrix}\n\\frac{near}{wid}&0&0&0\\\\\n0&\\frac{near}{height}&0&0\\\\\n0&0&\\frac{far}{near-far}&\\frac{near\\cdot far}{near-far}\\\\\n0&0&1&0\\\\\n\\end{bmatrix}\n$$\n从裁剪空间到NDC需要一次齐次除法\n\n#### think 但可能不对\n\n齐次变换(仿射变换)的 W分量 对于一个点来说，可以表示变换的“距离\", 比如用矩阵平移 点(x,y,z) 距离(1,1,1)   \n如果把W=2，再W 归一得到的是(x/2+0.5, y/2+0.5, z/2+0.5),  \n如果有若干多个点，这样做，相当于一种投影，而投影点集前后，点集之间相对当前 W 分量的点集关系不会改变，比如两个点之前相聚(a,b,c)， 除2后就是 (a/2,b/2,c/2)  \n挺有意思但没啥用好像。\n\n## TBN 矩阵\n\n[TBN矩阵不错的Blog](https://zhuanlan.zhihu.com/p/412555049)\n\n## 2D平面三角形，给出算法，生成三角形内随机一点\n\nhttps://www.cnblogs.com/TenosDoIt/p/4025221.html\n\n## 前向渲染和延迟渲染\n\nhttps://zhuanlan.zhihu.com/p/28489928\n\n## LUT 表\n\nhttps://www.jianshu.com/p/fdec2a5e889f\n\n## 描边效果\n\n边缘检测\n\n## 为什么要有光线追踪\n\n1. 传统光栅化做阴影效果不好，操作困难  \n2. 物体的模糊反射，比如毛玻璃一般的反射即 Glossy Reflection，光线打到Glossy物体在反射  \n3. 间接光照(Indirect illumination)，光线在进入人眼前弹射不止一次\n\n这种光线弹射，对于光栅化来说想要实现比较麻烦，而且也不能保证物理上的正确性。光栅化本质上是一种快速的近似质量较低。  \n光线追踪是一种比较准确的办法质量很高，但是最大的问题就是很慢。\n\n## 包围盒BVH\n\n### 如何划分BVH\n\n1.随机选取一个维度\n\n2.选Bounding box中最长的轴进行进一步划分 \n\n3.选取中间的三角形处进行划分（以保证两边三角形数量接近）。\n\n5.基于表面积的启发式评估划分方法（Surface Area Heuristic，SAH），这种方法通过对求交代价和遍历代价进行评估，给出了每一种划分的代价（Cost），寻找代价最小方式进行划分。\n\n6.基于莫顿码（Morton code）的并行化BVH构建。\n\n#### 参考学习！记得学啊！\n\n[PBRT-E4.3-层次包围体(BVH)（一） - 玉米的文章 - 知乎](https://zhuanlan.zhihu.com/p/50720158)  \n[PBRT-E4.3-层次包围体(BVH)（二） - 玉米的文章 - 知乎](https://zhuanlan.zhihu.com/p/54620381)  \n[PBRT-E4.3-层次包围体(BVH)（三） - 玉米的文章 - 知乎](https://zhuanlan.zhihu.com/p/54694041)  \n[【空间加速结构】——层次包围体BVH（Bounding Volume Hierachies） - silence394 - 博客园](https://www.cnblogs.com/silence394/p/17285231.html)  \n[Dynamic AABB Trees](https://box2d.org/files/ErinCatto_DynamicBVH_GDC2019.pdf)\n\n## 渲染管线\n\n一般就说说大概的流程 IA->VS->Hull->TS->Domain->GS->OS->RS->PS->OM\n\n### 什么是曲面细分着色器\n\n[大体介绍了一下曲面细分](https://www.cnblogs.com/chenglixue/p/17227713.html)\n\n## 透明效果\n\n\n\n# 球谐函数\n\n\n\n## 雾效\n\n\n\n\n\n# 重要性采样\n\n\n\n## 阴影\n\nLightMap\n\nShadowMapping\n\nPCF\n\nPCSS\n\nVSSM\n\n### CSM如何做的？\n\nCascaded Shadow Maps(CSM)方法根据对象到观察者的距离提供不同分辨率的深度纹理来解决上述问题。它将相机的视锥体分割成若干部分，然后为分割的每一部分生成独立的深度贴图。对于近处的场景使用较高分辨率的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用。\n\n## 两个多边形如何判断相交\n\nhttps://blog.csdn.net/StevenKyleLee/article/details/88075814\n\n### 一点是否在多边形内\n\nhttps://blog.csdn.net/StevenKyleLee/article/details/88044589\n\n一般用射线法这里说一下特殊情况：  \n<img src=\"/imgs/SpringBoss/RayPointSpe.png\" style=\"zoom:100%;\" >  \n这里的(b)因为中间那个顶点左右两条边都在该顶点的上侧，所以该顶点不识为于射线相交。  \n具体的判定过程应该可以根据多边形绕向找相邻点进行判断。\n\n[除射线法外的其他方法](https://blog.csdn.net/WilliamSun0122/article/details/77994526)\n\n## TAA(temporal anti-aliasing)\n\n[TAA in DX12](https://zhuanlan.zhihu.com/p/64993622)  \n[快速理解Tone Mapping](https://zhuanlan.zhihu.com/p/147567747)  \n[Tone Mapping](http://www.ownself.org/blog/2011/tone-mapping.html)  \n[TAA GHOSTING 的相关问题](https://www.cnblogs.com/crazii/p/7244300.html)  \nTone Mapping 是HDR算法的一部分，是用来将渲染出的场景亮度域映射到一个合理的亮度域空间。\n\n> 然后值得一提的是TAA在管线中的位置，虚幻的TAA是放在其它的后处理之前的，这么可以防止其它后处理出现的闪烁，但是因为高光很容易闪，我们又希望能在低动态范围处理，所以这里虚幻选择的是先tonemap，再算超采样，最后逆tonemap输出，去做其他的后处理。\n\n这里是说如果不做ToonMapping把HDR压倒LDR做TAA，因为HDR范围比LDR，然后TAA在混合在一起就会“亮的很花”，所以先Toon Mapping到LDR做一下TAA在 逆Toonmap输出，这样还得到了抗锯齿的输出，后处理做的更好了。这里的HDR和Toonmap我思考了很久，因为我没明白Toonmap，toonmap就是把hdr变成ldr，hdr虽然表示了更多的颜色，但是我们在屏幕空间显示还是0~1，所以要做映射，直接线性映射不行，因为人对暗部感知明显，而且自然界比LDR亮度大得多，所以我们做了很多调整。\n\n### 颜色LDR和HDR\n\n[LUT简述](https://www.jianshu.com/p/fdec2a5e889f)  \n[HDR和Tone Mapping](https://zhuanlan.zhihu.com/p/80253409)\n\n### 几何走样和着色走样\n\n* **几何走样：**几何覆盖函数采样不足，即俗称的边缘锯齿，一般发生在**光栅化阶段**。  \n* **着色走样：**渲染方程的采样不足，因为*渲染方程也是连续函数*，对某些部分在*空间变化较快（高频部分）采样不足也会造成走样*，反映在视觉上一般是图像闪烁或噪点，这类走样称之为着色走样，一般发生在**各种着色阶段**。\n  \n## Z-fighting\n\n\n\n## 景深\n\n所谓景深就是照片背景的虚化程度，规律是：光圈越大，景深越浅，背景越模糊；光圈越小，景深越深，背景越清晰。  \n[景深](http://www.ownself.org/blog/2010/jing-shen-depth-of-field.html)\n\n## 点到三角形距离\n\nhttps://zhuanlan.zhihu.com/p/148511581  \n[点到三角形面距离](https://zhuanlan.zhihu.com/p/148511581)\n\n## PBR\n\n[【基于物理的渲染（PBR）白皮书】（一） 开篇：PBR核心知识体系总结与概览](https://blog.csdn.net/poem_qianmo/article/details/85239398)\n\n## 材质系统\n\n材质系统了解、实现。\n\n\n\n# 计组部分\n\n### 大端和小端模式\n\nhttps://blog.csdn.net/wei_cheng18/article/details/79856207\n\n* **大端**（Big_endian）字数据的**高字节**存储在**低地址**中，字数据的**低字节**存储在**高地址**中。  \n* **小端**（Little_endian）字数据的**高字节**存储在**高地址**中，字数据的**低字节**存储在**低地址**中。\n  \n### Cache 命中率\n\n# 计网\n\n## TCP\n\n### [TCP三次握手](https://blog.csdn.net/jun2016425/article/details/81506353)\n\n* 第一次握手：客户端向服务器发起链接请求  \n* 第二次握手：服务器向客户端返回，发送答应客户端请求的确认信息。  \n* 第三次握手：客户端向服务器，告诉服务器已经收到第二次握手的确认信息。\n  \n#### TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？\n\n答：建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。\n\n（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。\n\n（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。\n\n（3）采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况，因此采用三次握手刚刚好，两次可能出现失效，四次甚至更多次则没必要，反而复杂了\n\n### 四次挥手\n\n* 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，**主动方：“我不会再给你数据了。”**  \n* 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1，**被动方：“我知道了！”**  \n* 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，**被动方：”我的数据也发送完了，不会再给你发数据了。“**  \n* 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，**主动方：“行了，那我知道了，一切结束”**\n  \n# 编译原理\n\n## [逆波兰式](https://blog.csdn.net/weixin_43919932/article/details/103327530)\n\nhttps://www.cnblogs.com/tangqs/archive/2012/05/18/2507708.html  \n 如果是右单目运算符，直接入存储器栈；比如 阶乘！与百分号%\n\n# OS\n\n## 进程和线程\n\n[进程和线程](https://blog.csdn.net/ThinkWon/article/details/102021274)  \n[线程调度](https://blog.csdn.net/qq_33182418/article/details/121135914)  \n[进程/作业调度](https://blog.csdn.net/qq_41784433/article/details/122194695)\n\n### 多线程比单线程慢\n\n存在上下文切换和死锁问题。  \nhttps://www.cnblogs.com/xrq730/p/5186609.html\n\n## Linux 进程通讯\n\nhttps://blog.csdn.net/qq_44443986/article/details/115065540\n\n## 死锁和银行家算法\n\nhttps://blog.csdn.net/wyf2017/article/details/80068608\n\n## 什么是内存碎片，内存碎片是在虚拟内存还是物理内存？\n\n采用分区式存储管理的系统，在储存分配过程中产生的、不能供用户作业使用的主存里的小分区称成“内存碎片”。内存碎片分为内部碎片和外部碎片。内存碎片只存在于虚拟内存上。\n\n# 概率论\n\n## 期望计算和带保底卡池期望计算\n\n\n\n\n\n\n\n\n\n\n\n# 算法\n\n## LRU手撸\n\nhttps://leetcode.cn/problems/lru-cache-lcci/\n\nLRU算法还有进化版LFU算法\n\n## 双端队列\n\n一个能用队列和栈实现的增删查改都是O(1)的数据结构，是什么  \n这个能用队列和栈实现的增删查改都是O(1)的数据结构是双端队列（deque）[[1](https://zh.wikipedia.org/wiki/队列#双端队列)]。双端队列不仅支持在队列的一端进行入队和出队操作，也支持在队列的另一端进行插入和删除操作。因此，在使用双端队列时，可以根据具体的需求选择在队列的哪一端进行操作，从而实现了增删查改都是O(1)的效率。\n\n### 双端队列定义\n\n能在队列两端进行入队、出队操作。\n\n## 统计子树中城市之间最大距离\n\nhttps://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/submissions/412418189/\n\n## A*算法\n\nhttps://zhuanlan.zhihu.com/p/54510444\n\n## 岛屿问题\n\nhttps://leetcode.cn/problems/number-of-islands/solutions/13103/dao-yu-shu-liang-by-leetcode/\n\n## Top K 问题\n\nhttps://zhuanlan.zhihu.com/p/64627590\n\n\n\n# C# 和 Unity\n\n[CSDN不错的面试总结-2022年Unity面试题分享 | 全面总结 | 建议收藏](https://blog.csdn.net/qq_21407523/article/details/108814300)  \n[知乎上五尘的Unity面试题](https://zhuanlan.zhihu.com/p/554529423)\n\n## 协程\n\n[总结：协程与线程](https://blog.csdn.net/w2009211777/article/details/125514898)\n\n## 请简述GC（垃圾回收）产生的原因，并描述如何避免？\n\nGC回收堆上的内存避免：1.减少new产生对象的次数2.使用公用的对象（静态成员）3.将String换为StringBuilder\n\n## C++指针和C#的引用\n\n[c++引用和c#引用类型的区别](https://zhuanlan.zhihu.com/p/389422617)\n\n## 反射\n\n[[整理]C#反射(Reflection)详解](https://www.cnblogs.com/wangshenhe/p/3256657.html)  \n[【Unity|C#】基础篇(12)——反射（Reflection）（核心类：Type、Assembly）](https://www.cnblogs.com/shahdza/p/12261831.html)\n\n* 反射的定义：审查元数据并收集关于它的类型信息的能力。元数据（编译以后的最基本数据单元）就是一大堆的表，当编译程序集或者模块时，编译器会创建一个类定义表，一个字段定义表，和一个方法定义表等。\n  \n* .NET的应用程序由几个部分：**程序集（Assembly）、模块（Module）、类型（class）组成**。\n  \n## 工厂模式\n\nhttps://wittykyrie.github.io/posts/Factor-Pattern/  \n[简单工厂模式、工厂方法模式优缺点](https://blog.csdn.net/cxy_zxl/article/details/116695023)  \n[C++ 深入浅出工厂模式（初识篇）](https://zhuanlan.zhihu.com/p/83535678)\n\n### 抽象工厂模式\n\nhttps://blog.csdn.net/m0_46502538/article/details/120343296\n\n## UGUI 如何实现UI物体淡入淡出?\n\n* Text，Image这些组件都有继承Graphic类，这个类提供了CrossFadeAlpha()方法，可以做透明度渐变。  \n* 但如果界面东西多了，要获取每个Graphic是挺麻烦了。其实还有一个很简便的方法，用起来跟NGUI差不多。就是CanvasGruop组件，把这个组件放到界面根节点上，对这个组件的alpha做改变就行了。看看官方文档的解释，\n  \n## ESC 框架\n\nhttps://blog.codingnow.com/2017/06/overwatch_ecs.html\n\nECS 的 E ，也就是 Entity ，可以说就是传统引擎中的 Game Object 。但是是 C 的整合其实。\n\nC 和 S 是这个框架的核心。System 系统，也就是我上面提到的模块。每个模块应该专注于干好一件事，而每件事要么是作用于游戏世界里同类的一组对象的每单个个体的，要么是关心这类对象的某种特定的交互行为。比如碰撞系统，就只关心对象的体积和位置，不关心对象的名字，连接状态，音效、敌对关系等。\n\n每个可能单独使用的对象属性归纳为一个个 Component ，比如对象的名字就是一个 Component ，对象的位置状态是另一个 Component 。\n\n## unity的委托是什么? event 关键字有什么用？\n\n委托是一个容器，可以放函数对象，并且可以触发委托面的每个函数调用。委托主要用户回调函数。如果在外部给委托变量加函数进来，那么委托要定义成public, 这样做又有一个问题，public外部的人也可以触发这个委托，如果我希望设计成外部可以加回调，但是只能是模块内部触发委托，那么我可以加一个event来修饰，这样虽然是public,但是外部无法触发委托,只能类的内部触发。\n\n# DX12\n\nDX12和\n\n# Vulkan\n\n[vulkan教程](https://geek-docs.com/vulkan/vulkan-tutorial/vulkan-tutorial-index.html)\n\n## Vulkan和DX12相比OpenGL好在哪里？\n\n\n\n# Unity\n\n[unity 八股文 实时更新](https://zhuanlan.zhihu.com/p/585164814)\n\n## UnityUpdate\n\n<img src=\"/imgs/SpringBoss/unityUpdate.jpg\">\n\n## Unity UGUI不规则区域点击问题\n\nhttps://www.cnblogs.com/msxh/p/9283266.html\n\n## 当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？\n\n碰撞检测失败，会直接穿透\n\n避免方法：  \n（1）增大细小物体的碰撞体（不建议这样做）  \n（2）使用射线检测，检测他们之间的距离  \n（3）FixedUpdate频率修改，可以physics time减小（同样不建议）  \n（4）改变物体的速度（废话）  \n（5）将检测方式改为连续检测，rigifdbody.collisionDetectionMode =CollisionDetectionMode.Continuous;  \n或者是动态连续检测（CollisionDetectionMode.ContinuousDynamic）  \n（6）代码限制，加大计算量 提前计算好下一个位置\n\n## [Canvas 有几种模式，如何配置？](https://blog.csdn.net/weixin_42352178/article/details/109034679)\n\nCanvas的三种渲染模式：\n\n* Screen Space-Overlay（屏幕空间-覆盖模式）UI元素的位置坐标是屏幕空间的坐标，Overlay模式下画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层。如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕。  \n* Screen Space-Camera（屏幕空间-摄影机模式）UI元素的位置坐标是屏幕空间的坐标，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。所不同的是，在该模式下，画布会被放置到摄影机前方。在这种渲染模式下，画布看起来绘制在一个与摄影机固定距离的平面上。所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。  \n  此时，画布上的UI组件会随视角移动。  \n* World Space即世界空间模式，此模式下UI元素的位置坐标是世界空间的坐标。画布作为场景中的一部分被固定显示在场景中，显示效果类似Plane组件。\n  \n## Unity 渲染队列\n| Name        | ID   | Description                                                  |  \n| ----------- | ---- | ------------------------------------------------------------ |  \n| Background  | 1000 | 会在任何其他队列前渲染，渲染需要绘制在背景上的物体           |  \n| Geometry    | 2000 | 默认的渲染队列，大部分物体都使用这个队列，不透明物体一般使用这个队列 |  \n| AlphaTest   | 2450 | 需要进行透明测试的物体                                       |  \n| Transparent | 3000 | 在 Geometry 和 AlphaTest 后，**从后向前**地渲染，任何使用透明混合的物体都使用此队列 |  \n| Overlay     | 4000 | 该队列用于实现叠加效果，任何需要最后渲染的物体都使用此队列。 |\n\n\n\n## 游戏动画\n\n### 关节动画\n\n### 单一网格动画\n\n### 骨骼动画\n\n## unity中UGUI如何打包成图集?\n\n[unity中UGUI如何打包成图集? - 鲨鱼辣椒的回答 - 知乎 ](https://www.zhihu.com/question/472146051/answer/2011067756)\n\n* 开启UGUI的图集模式, Editor->Project Settings 下面有sprite packer的模式。  \n* 为每个UI图片制定要打入的图集的tag名字。  \n* 打包生成图集Window ------>Sprite Packer, 点击Pack即可打包生成图集。\n  \n## Build-IN RP和SRP\n\n[Unity SRP URP HDRP 的区别](https://blog.csdn.net/weixin_41622043/article/details/107623694)\n\n## SRP\n\n[Unity官方宣传](https://unity.com/cn/srp)\n\n### SRP Batcher\n\n[SPR Batcher 官方简介](https://blog.unity.com/cn/technology/srp-batcher-speed-up-your-rendering)\n","slug":"SpringBoss","published":1,"updated":"2025-08-12T15:42:38.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti3000mbkbw46ui7vzf","content":"<p>图形学全忘光了，技美笔试直接寄了。<br />\r\n把面试题整理一下吧……<br />\r\n对于<strong>多线程</strong>和<strong>图形API</strong>了解不够需要继续学习</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"c-部分\">C++ 部分</h1>\r\n<h2 id=\"new-和-malloc-区别\"><a\r\nhref=\"https://www.cnblogs.com/ywliao/articles/8116622.html\">new 和\r\nmalloc 区别</a></h2>\r\n<h3 id=\"申请内存所在位置\">1.申请内存所在位置</h3>\r\n<ul>\r\n<li><p>new 从 free store 动态分配内存空间，free store 能否是堆取决于 new\r\n的实现其可以是堆，还可以是静态存储区。</p></li>\r\n<li><p>malloc 从堆上分配内存</p></li>\r\n</ul>\r\n<h3 id=\"返回类型安全性\">2.返回类型安全性</h3>\r\n<ul>\r\n<li><p>new 分配内存成功时，返回对象类型的指针，符合类型安全。</p></li>\r\n<li><p>malloc 返回 void* ，需要强制类型转换。</p></li>\r\n</ul>\r\n<h3 id=\"内存分配失败时返回值\">3.内存分配失败时返回值</h3>\r\n<ul>\r\n<li>new 失败返回 bac_alloc 异常，不会返回 NULL；<br />\r\n</li>\r\n<li>malloc 失败返回 NULL；</li>\r\n</ul>\r\n<h3 id=\"是否需要指定内存大小\">4.是否需要指定内存大小</h3>\r\n<ul>\r\n<li><p>new 无需指定，编译器自己计算</p></li>\r\n<li><p>malloc 需要自己显示指定。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">A *ptr = (A*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(A));  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3 id=\"是否调用构造函数析构函数\">5.是否调用构造函数/析构函数</h3>\r\n<ul>\r\n<li>new 会经过三步分配内存\r\n<ul>\r\n<li>调用 operator new (数组是 operator new[]\r\n)，分配足够大、原始、未命名的空间。<br />\r\n</li>\r\n<li>编译器运行对应构造函数，传入初值。<br />\r\n</li>\r\n<li>构造完成，返回一个指向该对象的指针。<br />\r\n</li>\r\n</ul></li>\r\n<li>在 delete 会\r\n<ul>\r\n<li>调用析构函数<br />\r\n</li>\r\n<li>编译器调用 operator delete / operator delete[]</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"对数组处理\">6.对数组处理</h3>\r\n<ul>\r\n<li><p>C++ 有 new[] 和 delete [] 处理数组</p></li>\r\n<li><p>而 malloc\r\n不知道你存放什么，只会给一块原始的内存，所以需要我们自己指定</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> *ptr = (<span class=\"hljs-type\">int</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">10</span>*<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>)); <span class=\"hljs-comment\">// 分配10个int，作为数组  </span><br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3 id=\"new-和-malloc-是否可以相互调用\">7. new 和 malloc\r\n是否可以相互调用</h3>\r\n<p>new delete可以基于 malloc 实现，但是 malloc 不能调用 new！！！</p>\r\n<h3 id=\"是否可以重载\">8.是否可以重载</h3>\r\n<ul>\r\n<li>operator new / operator delete 可以重载<br />\r\n</li>\r\n<li>malloc / free 不能重载</li>\r\n</ul>\r\n<h3 id=\"能够直观地重新分配内存\">9.能够直观地重新分配内存</h3>\r\n<p>malloc 分配的内存如果不够了可以 realloc</p>\r\n<p>但是 new 不行！</p>\r\n<h3 id=\"客户处理内存分配不同\">10.客户处理内存分配不同</h3>\r\n<p>operator new 抛出异常前会调用一个用户指定的错误处理函数\r\nnew-handler，指向一个错误处理函数。</p>\r\n<p>malloc 异常用户只能看着他 NULL</p>\r\n<h2 id=\"类和接口\">类和接口</h2>\r\n<p>如果把类比作一把枪，接口就是枪的配件，比如握把，枪托等等。我们对于类重点在于描述一个对象，而对于接口重点在于描述接口能提供的功能，所以接口内没有数据成员，只有成员函数。</p>\r\n<h2 id=\"c-类\">C++ 类</h2>\r\n<ul>\r\n<li><p>子类和父类有同名成员数据，是通过\"::\"区分<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">int</span> num;  <br>&#125;  <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span>:<span class=\"hljs-keyword\">public</span> A  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">int</span> num;  <br>&#125;  <br></code></pre></td></tr></table></figure></p>\r\n<p>其实这两个<code>num</code>实际的名字是<code>A::num</code>和<code>B::num</code></p></li>\r\n<li><p>类的成员函数调用<br />\r\n非虚函数，根据调用对象类型决定，虚函数根据实际类型决定。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T&quot;</span> &lt;&lt; std::endl; &#125;  <br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">int</span> num;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-built_in\">A</span>() &#123; num = <span class=\"hljs-number\">2</span>; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A::A &quot;</span> &lt;&lt; num++&lt;&lt;std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A::Fun1 &quot;</span> &lt;&lt; ++num&lt;&lt; std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">()</span></span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A::Fun2 &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun3</span><span class=\"hljs-params\">()</span></span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A::Fun3 &quot;</span> &lt;&lt; num-- &lt;&lt; std::endl; &#125;  <br>    ~<span class=\"hljs-built_in\">A</span>() &#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;~A() &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> :<span class=\"hljs-keyword\">public</span> A  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">int</span> num;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-built_in\">B</span>() &#123; num = <span class=\"hljs-number\">100</span>; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;B::B &quot;</span> &lt;&lt; num++ &lt;&lt; std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;B::Fun1 &quot;</span> &lt;&lt; ++num &lt;&lt; std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;B::Fun2 &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun3</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;B::Fun3 &quot;</span> &lt;&lt; num-- &lt;&lt; std::endl; &#125;  <br>    ~<span class=\"hljs-built_in\">B</span>() &#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;~B() &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    A* ptr = <span class=\"hljs-keyword\">new</span> B;  <br>    ptr = <span class=\"hljs-built_in\">dynamic_cast</span>&lt;A*&gt;(ptr);  <br>    ptr-&gt;<span class=\"hljs-built_in\">Fun1</span>();  <br>    ptr-&gt;<span class=\"hljs-built_in\">Fun2</span>();  <br>    ptr-&gt;<span class=\"hljs-built_in\">Fun3</span>();  <br>&#125;  <br></code></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">A::A <span class=\"hljs-number\">2</span>  <br>B::B <span class=\"hljs-number\">100</span>  <br>B::Fun1 <span class=\"hljs-number\">102</span>  <br>A::Fun2 <span class=\"hljs-number\">2</span>  <br>A::Fun3 <span class=\"hljs-number\">2</span>  <br>~<span class=\"hljs-built_in\">B</span>() <span class=\"hljs-number\">101</span>  <br>~<span class=\"hljs-built_in\">A</span>() <span class=\"hljs-number\">0</span>  <br></code></pre></td></tr></table></figure>\r\n<p><code>A* ptr = new B;</code><br />\r\n<code>ptr</code>类型为<code>A*</code>，但是实际指向对象类型其实为<code>B</code><br />\r\n那么其实在内存空间中有如下分配</p>\r\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\">成员数据:  <br><span class=\"hljs-selector-tag\">n_ptr</span>  <br><span class=\"hljs-selector-tag\">A</span>::<span class=\"hljs-selector-tag\">num</span>  <br><span class=\"hljs-selector-tag\">B</span>::<span class=\"hljs-selector-tag\">num</span>  <br>一张<span class=\"hljs-selector-tag\">A</span>的虚函数表？  <br>一张<span class=\"hljs-selector-tag\">B</span>的虚函数表  <br>函数映射：  <br>直接查找的  <br><span class=\"hljs-selector-tag\">A</span>::<span class=\"hljs-selector-tag\">Fun2</span>  <br><span class=\"hljs-selector-tag\">A</span>::<span class=\"hljs-selector-tag\">Fun3</span>  <br><span class=\"hljs-selector-tag\">B</span>::<span class=\"hljs-selector-tag\">Fun1</span>  <br><span class=\"hljs-selector-tag\">B</span>::<span class=\"hljs-selector-tag\">Fun2</span>  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"构造函数链和析构函数链\">构造函数链和析构函数链</h2>\r\n<h3 id=\"构造函数链\">构造函数链</h3>\r\n<p>一个类中有父类成员，成员变量。对于构造函数我们</p>\r\n<ol type=\"1\">\r\n<li>先调用父类，<br />\r\n</li>\r\n<li>再调用成员变量的构造函数，<br />\r\n</li>\r\n<li>最后调用子类构造函数在构造过程中</li>\r\n</ol>\r\n<p>子类是继承父类的成员</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> a;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br>\t<span class=\"hljs-type\">int</span> b;    <br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>这里B有成员b，和从父类继承的a。<br />\r\n因为 a\r\n是父类成员，所以交由父类初始化，如果先调子类，子类成员有a，b，对a，b初始化，再调父类，a又初始化初始化两次。<br />\r\n对于成员变量，成员变量有自己的构造函数，是当前子类无需关心的，对于他们先交给他们自己初始化即可。</p>\r\n<h2 id=\"析构函数链\">析构函数链</h2>\r\n<p>对于析构函数链，我们把子类可以看成一个套娃。<br />\r\n我们装套娃会从小到大(从父到子)</p>\r\n<h2\r\nid=\"c的publicprotectedprivate和三种继承\">C++的public、protected、private和三种继承</h2>\r\n<p>public 表示大家谁都能来访问，包括类对象自己和外部。<br />\r\nprotected,外部不能访问，但是自己和子类可以访问。<br />\r\nprivate，表示只能自己访问，自己的子类都不能访问。<br />\r\npublic 继承，不改变父类成员的可见性。<br />\r\nprotected 继承，父类成员除private外，全部变为protect<br />\r\nprivate 继承全部变为private\r\n&gt;假如把父类比喻一个门派，期内对象就是武功秘籍<br />\r\n&gt;public 就像比较普通的武功，比如太祖长拳，大家都可以来学。<br />\r\n&gt;protect\r\n就像门派内的高深强大的武功秘籍，比如降龙十八掌，只有你是下一任掌门才能学。<br />\r\n&gt;private\r\n就像掌门自己偷学了邪门歪道，比如岳不群学《辟邪剑谱》，只能自己知道，外人不能晓得。除了自己谁也不让看。<br />\r\n&gt;<br />\r\n&gt;public\r\n继承就像是普普通通比较开明的继承者，子承父业，原来掌门规定的哪些武功可以交给外人，哪些武功自己人学，都不变，但是掌门私底下学的歪门武功他也不知道是什么，对他而言不可见，想知道是什么得返回去用上一任掌门的去查。<br />\r\n&gt;protect\r\n继承就像垄断或者有点小心思的人继承，我不让所有人随便学了，现在你们想从我这学你得是我的关门弟子下一任掌门。<br />\r\n&gt;private\r\n继承就像断代了，诶，我谁也不教，全部变成private，只有我自己看，但是无论这三种哪一种都看不到父类的private。</p>\r\n<h2 id=\"static关键字\">static关键字</h2>\r\n<p>static关键字表示静态元素，其在程序的生存周期中仅在<strong>静态存储区</strong>分配一次存储空间，直到程序的生存周期结束。<br />\r\nstatic常用于</p>\r\n<ul>\r\n<li>函数中的静态变量<br />\r\n</li>\r\n<li>静态类对象<br />\r\n</li>\r\n<li>类中的静态成员变量<br />\r\n</li>\r\n<li>类中的静态方法</li>\r\n</ul>\r\n<h2\r\nid=\"static-和const分别怎么用类里面static和const可以同时修饰成员函数吗\"><strong>static\r\n和const分别怎么用，类里面static和const可以同时修饰成员函数吗</strong></h2>\r\n<ul>\r\n<li><p><strong>static</strong></p>\r\n<ul>\r\n<li><p>static对于变量</p>\r\n<ol type=\"1\">\r\n<li><p>局部变量</p>\r\n<p>在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。</p>\r\n<p>内存中的位置：静态存储区</p>\r\n<p>初始化：局部的静态变量只能被初始化一次</p>\r\n<p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。</p>\r\n<blockquote>\r\n<p>当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。</p>\r\n</blockquote></li>\r\n<li><p>全局变量</p>\r\n<p>在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。</p>\r\n<p>内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）</p>\r\n<p>初始化：未经初始化的全局静态变量会被程序自动初始化为0</p>\r\n<p>作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。(只能在本文件中存在和使用)</p>\r\n<blockquote>\r\n<p>全局变量本身就是静态存储方式，\r\n静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序，\r\n当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）。\r\n而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，\r\n在同一源程序的其它源文件中不能使用它。</p>\r\n</blockquote></li>\r\n</ol></li>\r\n</ul></li>\r\n<li><p>static对于函数</p>\r\n<p>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为\r\nstatic。（和全局变量一样限制了作用域而已）</p></li>\r\n<li><p>static对于类</p>\r\n<ol type=\"1\">\r\n<li><p>成员变量</p>\r\n<p>用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，<strong>包括派生类的对象</strong>。</p>\r\n<p>因此，static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化\r\n。</p></li>\r\n<li><p>成员函数</p>\r\n<p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，<strong>不含this指针。</strong></p>\r\n<p>静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。</p>\r\n<p><strong>不可以同时用const和static修饰成员函数。</strong></p></li>\r\n</ol></li>\r\n<li><p><strong>const</strong></p>\r\n<ol type=\"1\">\r\n<li>限定变量为不可修改。<br />\r\n</li>\r\n<li>限定成员函数不可以修改任何数据成员</li>\r\n</ol></li>\r\n<li><p>static和const可以同时修饰成员函数吗?</p>\r\n<p>答：不可以。C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const\r\nthis*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。两者的语意是矛盾的。<strong>static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态</strong>，与类型的静态变量没有关系。因此不能同时用它们。</p></li>\r\n</ul>\r\n<h2 id=\"拷贝构造函数\">拷贝构造函数</h2>\r\n<p><strong>只有这三种情况！！！！！</strong></p>\r\n<h3 id=\"用一个对象初始化另一个对象\">1.用一个对象初始化另一个对象。</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Point <span class=\"hljs-title\">p2</span><span class=\"hljs-params\">(p1)</span></span>;  <br>Point p3 = p1  <br></code></pre></td></tr></table></figure>\r\n<p>这两种情况一样。</p>\r\n<h3\r\nid=\"若一个函数的形参是一个-class-对象当-f-被调用时class-拷贝构造函数调用\">2.若一个函数的形参是一个\r\nClass 对象，当 F 被调用时，Class 拷贝构造函数调用。</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Func</span><span class=\"hljs-params\">(Point a)</span></span>&#123;&#125;;<br>  <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">mian</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    Point a;  <br>    <span class=\"hljs-built_in\">Func</span>(a);    <span class=\"hljs-comment\">// 调用拷贝构造函数  </span><br>&#125;  <br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"如果函数的返回值是-class-对象函数返回时调用-class-拷贝构造函数\">3.如果函数的返回值是\r\nClass 对象，函数返回时，调用 Class 拷贝构造函数</h3>\r\n<p>即返回值对象由拷贝构造函数初始化。</p>\r\n<h2 id=\"模板函数\">模板函数</h2>\r\n<h3\r\nid=\"模板函数的声明实现为什么必须在一个文件内\">模板函数的声明实现为什么必须在一个文件内</h3>\r\n<p><a\r\nhref=\"https://blog.csdn.net/chigusakawada/article/details/78752668\">CSDN\r\n: 模板函数的声明和定义为何不能分开放在两个文件中?</a></p>\r\n<h2 id=\"c-11-特性\">C++ 11 特性</h2>\r\n<h3 id=\"左值右值\">左值右值</h3>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/qicosmos/p/4283455.html\">四行代码！看懂右值引用</a></p>\r\n<h4 id=\"右值引用的特点\">右值引用的特点：</h4>\r\n<ol type=\"1\">\r\n<li><p>通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">A <span class=\"hljs-title\">GetA</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">A</span>();  <br>&#125;  <br>A&amp;&amp; a = <span class=\"hljs-built_in\">GetA</span>();\t<span class=\"hljs-comment\">// 这里只会调用一次拷贝构造函数，就是return A()，  </span><br><span class=\"hljs-comment\">// 因为A&amp;&amp; 延长了 GetA的生命周期无需拷贝函数  </span><br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。</p></li>\r\n<li><p>T&amp;&amp;\r\nt在发生自动类型推断的时候，它是未定的引用类型（universal\r\nreferences），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。<br />\r\n正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。</p></li>\r\n<li></li>\r\n</ol>\r\n<p>移动语义的实现：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">A <span class=\"hljs-title\">GetA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> A;<br>&#125;<br><br><span class=\"hljs-built_in\">A</span>(A&amp;&amp; a):<span class=\"hljs-built_in\">m_ptr</span>(a.m_ptr)&#123;&#125;<br><br>A a = <span class=\"hljs-built_in\">GetA</span>();<br></code></pre></td></tr></table></figure>\r\n<p>利用右值引用作为参数，因为<code>GetA</code>返回值是右值，而<code>A&amp;&amp;</code>类型确定不发生自动推断即确定的右值，拷贝函数会匹配到<code>A(A&amp;&amp; a)</code>，这样就省去了重新<code>new m_ptr</code>。</p>\r\n<h5 id=\"引用折叠\">引用折叠</h5>\r\n<ul>\r\n<li>所有的右值引用叠加到右值引用上仍然还是一个右值引用；<br />\r\n</li>\r\n<li>所有的其他引用类型之间的叠加都将变成左值引用。</li>\r\n</ul>\r\n<h4 id=\"一个移动语义应用\">一个移动语义应用</h4>\r\n<p>实现移动构造和移动赋值<br />\r\n为什么在 移动构造中将 f.ptr 赋值为 nullptr<br />\r\n因为我们的移动构造函数参数是一个右值，在完成初始化的任务后就应该消失，所以把他所指内存交给新对象，并指向了nullptr，移动赋值也是同理。<br />\r\n移动赋值和移动复制通常联合使用，目的是优化对象的复制和赋值操作，提高程序的性能。<br />\r\n移动赋值会在这时调用<code>f1=Foo()</code>，f1是之前声明过的，Foo()返回右值，匹配到<code>=(Foo&amp;&amp;)</code>函数。\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-type\">int</span> a;<br>    <span class=\"hljs-type\">int</span> *ptr;<br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Foo</span>(Foo&amp;&amp; f):<span class=\"hljs-built_in\">ptr</span>(f.ptr),<span class=\"hljs-built_in\">a</span>(f.a)<br>    &#123;<br>        f.ptr = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>    <br>    Foo&amp; <span class=\"hljs-keyword\">operator</span> =(Foo&amp;&amp; f)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span> != &amp;f)<br>        &#123;<br>            <span class=\"hljs-keyword\">this</span>-&gt;ptr = f.ptr;<br>            f.ptr = <span class=\"hljs-literal\">nullptr</span>;<br>            a = f.a;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<h3 id=\"一些补充\">一些补充</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">vec.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">Foo</span>());<br></code></pre></td></tr></table></figure>\r\n<p>首先，我们知道函数的返回值是右值，所以Foo() 这部分是个右值<br />\r\n当我们没有右值引用的移动构造函数时，我们会发生\r\n右值转换的过程——把右值转化为左值，调用复制构造函数。<br />\r\n若我们有参数为右值引用的移动构造函数，右值会直接匹配到这个函数，不会发生一次转换去匹配参数为左值的复制构造函数。<br />\r\n这里的知识点是右值可以转换为左值。</p>\r\n<h3 id=\"智能指针\">智能指针</h3>\r\n<h3 id=\"类型推断\">类型推断</h3>\r\n<h3 id=\"lambda表达式\">lambda表达式</h3>\r\n<h3 id=\"类型转换\">类型转换</h3>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/417640759\">九阳神功！不会C++就看这个！</a>（1）const_cast:\r\n把const属性去掉，即将const转换为非const（也可以反过来），const_cast只能用于指针或引用，并且只能改变对象的底层const（顶层const，本身是const，底层const，指向对象const）；</p>\r\n<p>（2）static_cast:\r\n隐式类型转换，可以实现C++中内置基本数据类型之间的相互转换，enum、struct、\r\nint、char、float等，能进行类层次间的向上类型转换和向下类型转换（向下不安全，因为没有进行动态类型检查）。它不能进行无关类型(如非基类和子类)指针之间的转换，也不能作用包含底层const的对象；</p>\r\n<p>（3）dynamic_cast：动态类型转换，用于将基类的指针或引用安全地转换成派生类的指针或引用（也可以向上转换），若指针转换失败返回NULL，若引用返回失败抛出bad_cast异常。dynamic_cast是在运行时进行安全性检查；使用<strong>dynamic_cast父类一定要有虚函数，否则编译不通过；</strong></p>\r\n<p>（4）reinterpret_cast：reinterpret是重新解释的意思，此标识符的意思即为将数据的二进制形式重新解释，但是不改变其值，有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用（比较不安全）</p>\r\n<h2 id=\"c-struct和class区别\">C++ struct和class区别</h2>\r\n<ul>\r\n<li><p>在 <strong>C 语言</strong> 中，<strong>结构体</strong>\r\n只能存放一些 <strong>变量</strong> 的集合，并不能有\r\n<strong>函数</strong>，但 <strong>C++</strong> 中的结构体对 C\r\n语言中的结构体做了扩充，可以有函数，因此 C++ 中的结构体跟 C++\r\n中的类很类似。C++ 中的 struct\r\n可以包含成员函数，也能继承，也可以实现多态。</p></li>\r\n<li><p>但在 C++ 中，使用 class 时，类中的成员默认都是\r\n<strong>private</strong> 属性的，而使用 struct\r\n时，结构体中的成员默认都是 public 属性的。</p></li>\r\n<li><p>class 继承默认是 private 继承，而 struct 继承默认是 public\r\n继承。</p></li>\r\n<li><p>C++ 中的 class 可以使用模板，而 struct 不能使用模板。</p></li>\r\n</ul>\r\n<h2 id=\"c-vector\">C++ vector</h2>\r\n<p>vector.clear 不释放空间</p>\r\n<ul>\r\n<li>int size() const:返回向量中元素的个数<br />\r\n</li>\r\n<li>int capacity() const:返回当前向量所能容纳的最大元素值<br />\r\n</li>\r\n<li>int max_size() const:返回最大可允许的vector元素个数值</li>\r\n</ul>\r\n<h2 id=\"c智能指针和安全性\">C++智能指针和安全性</h2>\r\n<p>智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(shared_ptr),\r\n独占指针(unique_ptr)和弱指针(weak_ptr)：</p>\r\n<p>（1）shared_ptr\r\n，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；</p>\r\n<p>（2）unique_ptr，保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr）；</p>\r\n<p>（3）weak_ptr，用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>\r\n<ul>\r\n<li>shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？shared_ptr是不是线程安全的？</li>\r\n</ul>\r\n<p>（1）shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；</p>\r\n<p>（2）具体实现：</p>\r\n<p>1）构造函数：将指针指向该对象，引用计数置为1；</p>\r\n<p>2）拷贝构造函数：将指针指向该对象，引用计数++；</p>\r\n<p>3）赋值运算符：=号左边的shared_ptr的引用计数-1，右边的shared_ptr的引用计数+1，如果左边的引用技术降为0，还要销毁shared_ptr指向对象，释放内存空间。</p>\r\n<p>（3）shared_ptr的引用计数本身是安全且无锁的，但是它指向的对象的读写则不是，因此可以说shared_ptr不是线程安全的。<a\r\nhref=\"https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1654442\">shared_ptr是线程安全的吗？\r\n- 云+社区 - 腾讯云 (tencent.com)</a></p>\r\n<ul>\r\n<li>weak_ptr是为了解决shared_ptr的循环引用问题，那为什么不用raw\r\nptr来解决这个问题？</li>\r\n</ul>\r\n<p>答：一个weak_ptr绑定到shared_ptr之后不会增加引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使weak_ptr指向对象，也还是会释放；raw指针，当对象销毁之后会变成悬浮指针。</p>\r\n<h2 id=\"shared_ptr实现原理\">Shared_ptr实现原理</h2>\r\n<h3 id=\"智能指针如何实现\">智能指针如何实现</h3>\r\n<p>C++中的智能指针（smart pointers）是一种RAII（Resource Acquisition Is\r\nInitialization）技术的实现方式，它们可以自动管理内存资源，并确保在对象离开作用域时正确地释放这些资源。智能指针的主要目的是确保资源获取与对象初始化同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。</p>\r\n<p>C++11中引入了三种智能指针：<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。其中<code>std::unique_ptr</code>是用于独占式拥有一个对象，<code>std::shared_ptr</code>是用于共享拥有一个对象，而<code>std::weak_ptr</code>则是用于弱引用一个对象。</p>\r\n<p>当我们需要使用RAII技术来管理动态分配的内存时，我们通常使用<code>std::unique_ptr</code>来管理指向单个对象的指针，并使用<code>std::shared_ptr</code>来管理指向共享资源的指针。如果我们需要在一个对象中存储多个指向共享资源的指针，则应使用<code>std::weak_ptr</code>来避免循环引用问题。</p>\r\n<p>总之，智能指针是一种非常有用的C++编程工具，可以帮助我们更安全、更简单地管理内存资源，并且对于编写高质量的C++代码来说至关重要。更多关于智能指针的资料可以参考[<a\r\nhref=\"https://zhuanlan.zhihu.com/p/150555165\">3</a>][<a\r\nhref=\"https://learn.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170\">4</a>]。</p>\r\n<h2\r\nid=\"为什么析构函数一定要被设置为虚函数\">为什么析构函数一定要被设置为虚函数</h2>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/yuanch2019/p/11625460.html\">为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</a></p>\r\n<p>首先类的<strong>虚函数</strong>调用是靠<strong>虚函数指针</strong>调用的，而函数成员靠的是对象类型。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span></span>&#123;&#125;;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func2</span><span class=\"hljs-params\">()</span></span>&#123;&#125;;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    A a;<br>    a.<span class=\"hljs-built_in\">func1</span>();<br>    a.<span class=\"hljs-built_in\">func2</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>对于<code>func1</code>是通过<code>a.this</code>调用，而<code>func2</code>是通过虚函数指针<code>a._vfptr-&gt;func2()</code>调用。(大概是这个意思，但应该是别的形式)</p>\r\n<blockquote>\r\n<p>“Note：定义在类内部的函数是隐式的inline函数（参见6.5.2节，第214页）。”\r\n—— 《C++ Primer》 中文第五版 P230</p>\r\n<p>“成员函数通过一个名为<strong>this</strong>的额外隐式参数来访问调用它的那个对象。”\r\n—— 《C++ Primer》 中文第五版 P231</p>\r\n</blockquote>\r\n<p><strong>成员函数本质上可以看做全局函数，不过第一个参数固定为this。</strong></p>\r\n<h3 id=\"菱形继承\">菱形继承</h3>\r\n<p>https://blog.csdn.net/tounaobun/article/details/8443228</p>\r\n<p>问题：A-&gt;B;A-&gt;C;B,C-&gt;D; B,C继承了A，D继承了A。<br />\r\n在调用D的成员函数时候就不知道是调用B的，还是C的，所以在继承中使用</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Lion</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wolf</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> : <span class=\"hljs-keyword\">public</span> Wolf, <span class=\"hljs-keyword\">public</span> Lion<br>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>加上virtual保证子类只有一个父类的子对象，防止发生二义性。</p>\r\n<h2 id=\"c-深拷贝浅拷贝\">C++ 深拷贝浅拷贝</h2>\r\n<p>（1）拷贝构造函数的作用就是定义了当我们用同类型的另外一个对象初始化本对象的时候做了什么，在某些情况下，如果我们不自己定义拷贝构造函数，使用默认的拷贝构造函数，就会出错。比如一个类里面有一个指针，如果使用默认的拷贝构造函数，会将指针拷贝过去，即两个指针指向同个对象，那么其中一个类对象析构之后，这个指针也会被delete掉，那么另一个类里面的指针就会变成<strong>野指针（悬浮指针）</strong>；</p>\r\n<p>（2）这也正是深拷贝和浅拷贝的区别，浅拷贝只是简单直接地复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。\r\n但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p>\r\n<h2 id=\"c野指针\">C++野指针</h2>\r\n<p>指针指向了一块非法内存区域(悬空或者说未知区域)。</p>\r\n<h2 id=\"c-虚函数\">C++ 虚函数</h2>\r\n<h3 id=\"哪些函数不能是虚函数\"><a\r\nhref=\"https://www.cnblogs.com/NeilZhang/p/5427872.html\">哪些函数不能是虚函数</a></h3>\r\n<p>常见的不不能声明为虚函数的有：普通函数（非成员函数）；静态成员函数；内联成员函数；构造函数；友元函数。</p>\r\n<h2 id=\"c-内存模型\">C++ 内存模型</h2>\r\n<h3 id=\"c内存布局\">C++内存布局</h3>\r\n<h4 id=\"heap-堆\">Heap 堆</h4>\r\n<p>由new分配的内存块，其释放编译器不去管，由我们<strong>程序自己控制（一个new对应一个delete）</strong>。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”</p>\r\n<h4 id=\"stack-栈\">Stack 栈</h4>\r\n<p><strong>编译器</strong>在需要时<strong>分配</strong>，在不需要时自动清除。存放<strong>局部变量</strong>和<strong>函数参数</strong>。<br />\r\n存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。</p>\r\n<h4 id=\"全局静态存储区.bss和.data段\">全局/静态存储区(.bss和.data段)</h4>\r\n<p>全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中称为zero\r\ninitialization，初始化的放在.data段中，称为const\r\ninitialization；在C++中二者不进行区分。<br />\r\n虚函数表就存在这里，因为是全局公用的一张表，通过虚函数指针查找。</p>\r\n<h4 id=\"常量存储区.rodata段\">常量存储区(.rodata段)</h4>\r\n<p>存放常量，不允许修改，比如<code>const int a = 3</code></p>\r\n<h4 id=\"代码区.text段\">代码区(.text段)</h4>\r\n<p>存放代码，比如我们的函数和类的成员函数。不许修改但是可以执行。</p>\r\n<h3 id=\"c内存区域\">C++内存区域</h3>\r\n<p>根据生命周期不同，C++中可划分出三种不同的内存区域</p>\r\n<p>1.自由存储区、动态区、静态区局部非静态变量的存储区域(栈)<br />\r\n2.动态区：new，malloc分配的内存<br />\r\n3.静态区：全局变量，静态变量，字符串常量存在位置</p>\r\n<p>https://www.cnblogs.com/yunlambert/p/9876491.html<br />\r\n<a\r\nhref=\"https://blog.csdn.net/JUST__Tw/article/details/118551674\">深入理解计算机系统（内存管理）----内存模型</a><br />\r\n空类(空 class)大小是1，为了标识对象<br />\r\n<a\r\nhref=\"https://blog.csdn.net/li975242487/article/details/121395693\">不同类型占用的字节</a></p>\r\n<h2 id=\"c运算符重载\">C++运算符重载</h2>\r\n<p>https://www.cnblogs.com/liuchenxu123/p/12538623.html</p>\r\n<h2 id=\"派生类的构造函数顺序\">派生类的构造函数顺序</h2>\r\n<p>https://www.nowcoder.com/questionTerminal/6348a321452a4318a2da5f3757baf620?source=relative</p>\r\n<h2 id=\"迭代器\">迭代器</h2>\r\n<p>https://blog.csdn.net/QIANGWEIYUAN/article/details/89184546</p>\r\n<h2 id=\"红黑树\">红黑树</h2>\r\n<p>https://blog.csdn.net/u014454538/article/details/120120216</p>\r\n<h2 id=\"小根堆大根堆\">小根堆，大根堆</h2>\r\n<h3 id=\"完全二叉堆\">完全二叉堆</h3>\r\n<p>堆又可称之为完全二叉堆。这是一个逻辑上基于完全二叉树、物理上一般基于线性数据结构（如数组、向量、链表等）的一种数据结构。</p>\r\n<h4 id=\"完全二叉树\">完全二叉树</h4>\r\n<p>完全二叉树是由满二叉树而引出来的，若设二叉树的<code>深度为h</code>，<code>除第 h 层外</code>，<code>其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)</code>，第\r\nh 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>\r\n<h3 id=\"小根堆\">小根堆</h3>\r\n<p>根小于节点</p>\r\n<h3 id=\"大根堆\">大根堆</h3>\r\n<p>根大于节点</p>\r\n<h2 id=\"对象池\">对象池</h2>\r\n<p>对象池内通常是对象实例的指针，因为对象池的原理是将对象放入池管理的某种内存连续的数据结构中，当不需要对象时，并不销毁对象，而是将对象回收到池中，下次需要的时候再次从池中拿出来。由于对象储存在内存连续的数据结构中，所以能够有效地解决内存碎片的问题。因此，对象池中保存对象的指针比直接保存对象实例更为高效，能够避免频繁分配和销毁内存，从而提高了程序的性能。</p>\r\n<h2 id=\"多线程\">多线程</h2>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/430069448\">进程间通信方式；线程间通信方式</a></p>\r\n<h3 id=\"进程间通讯的方式\">进程间通讯的方式？</h3>\r\n<p>管道通信，消息队列，共享内存，socket，串口都可以实现。</p>\r\n<h4 id=\"管道-pipe\">管道( pipe )：</h4>\r\n<p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>\r\n<h4 id=\"有名管道-namedpipe\">有名管道 (namedpipe) ：</h4>\r\n<p>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>\r\n<h4 id=\"信号量semophore\">信号量(semophore ) ：</h4>\r\n<p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>\r\n<h4 id=\"消息队列-messagequeue\">消息队列( messagequeue ) ：</h4>\r\n<p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>\r\n<h4 id=\"信号-sinal\">信号 (sinal ) ：</h4>\r\n<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>\r\n<h4 id=\"共享内存shared-memory\">共享内存(shared memory ) ：</h4>\r\n<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的\r\nIPC\r\n方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>\r\n<h4 id=\"套接字socket\">套接字(socket ) ：</h4>\r\n<p>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>\r\n<h3 id=\"线程间通讯方式\">线程间通讯方式。</h3>\r\n<p><strong>锁机制：包括互斥锁、条件变量、读写锁</strong></p>\r\n<ul>\r\n<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。<br />\r\n</li>\r\n<li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。<br />\r\n</li>\r\n<li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>\r\n</ul>\r\n<p><strong>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</strong></p>\r\n<p><strong>信号机制(Signal)：类似进程间的信号处理</strong></p>\r\n<h1 id=\"图形学部分\">图形学部分</h1>\r\n<h2 id=\"叉乘\">叉乘</h2>\r\n<p>两个向量的叉乘结果是一个垂直于这两个向量的向量，最后这个向量的长度等于以最初两个向量作为边的平行四边形的面积。</p>\r\n<h2 id=\"光照模型\">光照模型</h2>\r\n<ul>\r\n<li>emissive<br />\r\n</li>\r\n<li>specular<br />\r\n</li>\r\n<li>diffuse<br />\r\n</li>\r\n<li>ambient</li>\r\n</ul>\r\n<h3 id=\"环境光\">环境光</h3>\r\n<p>通常用系统定值，场景物体通用</p>\r\n<p><img src=\"/imgs/SpringBoss/C_ambient.png\"></p>\r\n<h3 id=\"自发光\">自发光</h3>\r\n<p>材质决定</p>\r\n<p><img src=\"/imgs/SpringBoss/C_emissive.png\"></p>\r\n<h3 id=\"漫反射\">漫反射</h3>\r\n<p>根据 Lambert‘s law</p>\r\n<p><img src=\"/imgs/SpringBoss/C_diffuse.png\"></p>\r\n<h3 id=\"高光反射\">高光反射</h3>\r\n<p>我们有很多变量：normal，eyeDir，lightDir，refDir</p>\r\n<h4 id=\"已知-normallightdir-求-refdir\">已知 normal，lightDir 求\r\nrefDir</h4>\r\n<p><img src=\"/imgs/SpringBoss/NormalLightEyeRef.png\"></p>\r\n<p><img src=\"/imgs/SpringBoss/RefEqu.png\"></p>\r\n<h5 id=\"phong-模型\">Phong 模型</h5>\r\n<p><img src=\"/imgs/SpringBoss/PhongSpecular.png\"></p>\r\n<h5 id=\"blinn-phong\">Blinn-Phong</h5>\r\n<p><img src=\"/imgs/SpringBoss/BlinnPhong.png\"></p>\r\n<h2 id=\"复习下线性代数\">复习下线性代数</h2>\r\n<h3 id=\"坐标系\">坐标系</h3>\r\n<p>坐标系分为<em>左手坐标系</em>和<em>右手坐标系</em></p>\r\n<p><img src=\"/imgs/SpringBoss/LeftRight.png\" style=\"zoom:60%;\" ></p>\r\n<p>二者在 z 轴方向上有所不同。<br />\r\n在 Unity\r\n中<strong>模型空间</strong>和<strong>世界空间</strong>为左手系，<strong>观察空间</strong>为右手系。</p>\r\n<h3 id=\"矩阵\">矩阵</h3>\r\n<p>矩阵又分为行矩阵和列矩阵。<br />\r\n<strong><em><u>矩阵的左乘/右乘，表示该矩阵在乘号的左侧/右侧。</u></em></strong></p>\r\n<h4 id=\"行矩阵\">行矩阵</h4>\r\n<p><img src=\"/imgs/SpringBoss/rowMatrix.png\" ></p>\r\n<p>表示 1xn 的矩阵，行矩阵<strong>左乘</strong>，变换矩阵乘在右侧-&gt;\r\n<code>1xn dot nxn = 1xn</code></p>\r\n<h5 id=\"齐次式\">齐次式</h5>\r\n<ul>\r\n<li><p>矢量/点</p>\r\n<p><img src=\"/imgs/SpringBoss/rowMatrixHC.png\"></p></li>\r\n<li><p>变换矩阵</p>\r\n<p><img src=\"/imgs/SpringBoss/rowMatrixHCT.png\" > #### 列矩阵</p></li>\r\n</ul>\r\n<p><u><strong><em>Unity就是列矩阵！</em></strong></u></p>\r\n<blockquote>\r\n<p>问题1<br />\r\nshader中会看到法线的变换矩阵：<br />\r\nfloat3x3 transform = float3x3(v.tangent.xyz, binormal, v.normal);<br />\r\n即，<strong>float3x3类型的变量</strong>在创建时，如果传入3个float3类型的变量。整个矩阵是按行优先填充还是按列优先填充呢？<br />\r\n答：填入的是三个列，即unity\r\nshader是<strong>列优先</strong>（column-major）的。<br />\r\n问题2<br />\r\n<strong>matrix</strong>.m12是什么意思？<br />\r\n答：m12是第一行第二列，但是构造矩阵时是<strong>按列的</strong>。</p>\r\n</blockquote>\r\n<p><img src=\"/imgs/SpringBoss/columnMatrix.png\" ></p>\r\n<p>表示 nx1 的矩阵，列矩阵<strong>右乘</strong>，变换矩阵乘在其左侧\r\n<code>nxn dot nx1 = nx1</code></p>\r\n<h5 id=\"齐次式-1\">齐次式</h5>\r\n<ul>\r\n<li><p>矢量/点</p>\r\n<p><img src=\"/imgs/SpringBoss/colMHC.png\"></p></li>\r\n<li><p>变换矩阵</p></li>\r\n</ul>\r\n<p><img src=\"/imgs/SpringBoss/colMHCT.png\"></p>\r\n<h2 id=\"矩阵的几何意义变换\">矩阵的几何意义变换</h2>\r\n<p>变换优先级为：缩放&gt;旋转&gt;位移</p>\r\n<h3 id=\"缩放\">缩放</h3>\r\n<p><img src=\"/imgs/SpringBoss/scale.png\"></p>\r\n<h3 id=\"旋转\">旋转</h3>\r\n<p>在<strong>左手系</strong>中，绕轴<strong>旋转遵从左手手旋转准则</strong>：大拇指为轴向，四指为旋转方向。<br />\r\n在<strong>右手系</strong>中，绕轴<strong>旋转遵从右手旋转准则</strong>：大拇指为轴向，四指为旋转方向。</p>\r\n<ul>\r\n<li>绕 x 轴</li>\r\n</ul>\r\n<p><img src=\"/imgs/SpringBoss/rotationX.png\"></p>\r\n<ul>\r\n<li>绕 y 轴</li>\r\n</ul>\r\n<p><img src=\"/imgs/SpringBoss/rotationY.png\"></p>\r\n<ul>\r\n<li>绕 z 轴</li>\r\n</ul>\r\n<p><img src=\"/imgs/SpringBoss/rotationZ.png\"></p>\r\n<h4 id=\"欧拉角旋转顺序\">欧拉角旋转顺序</h4>\r\n<p>因为不同轴旋转相乘得到变换矩阵不同。</p>\r\n<ul>\r\n<li>外旋和内旋<br />\r\n假定一组旋转顺序 x-&gt;y-&gt;z 为内旋，则外旋为 z-&gt;x-&gt;y。<br />\r\n一组对应的外旋内旋结果是一样的。</li>\r\n</ul>\r\n<p><strong>Unity旋转顺序是ZXY</strong>。</p>\r\n<h3 id=\"位移\">位移</h3>\r\n<p><img src=\"/imgs/SpringBoss/translate.png\"></p>\r\n<h3 id=\"变换顺序\">变换顺序</h3>\r\n<p><img src=\"/imgs/SpringBoss/transform.png\"></p>\r\n<h2 id=\"给定-4x4-矩阵求缩放旋转平移矩阵\"><a\r\nhref=\"https://blog.csdn.net/qq_39300235/article/details/105790743\">给定\r\n4x4 矩阵，求缩放，旋转、平移矩阵</a></h2>\r\n<p>就以列矩阵为例解吧，因为大多都是列矩阵运算。<br />\r\n<strong>M=TRS</strong></p>\r\n<p><img src=\"/imgs/SpringBoss/4x4Matrix.png\"></p>\r\n<h3 id=\"t矩阵\">T矩阵</h3>\r\n<p>列矩阵最右侧就是 translate 变换</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">T[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">3</span>]=M[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">3</span>]/M[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">3</span>];  <br>T[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">3</span>]=M[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">3</span>]/M[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">3</span>];  <br>T[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">3</span>]=M[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">3</span>]/M[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">3</span>];  <br></code></pre></td></tr></table></figure>\r\n<h3 id=\"r矩阵\">R矩阵</h3>\r\n<p>之后我们对 M\r\n矩阵剔除平移变换，得到只有缩放和旋转的矩阵<em>M</em>。<br />\r\n此时 <em>M</em>=RS；<br />\r\n我们只要算出旋转矩阵就行了，因为 R\r\n可以用<strong>旋转矩阵的逆矩阵</strong>计算得到：</p>\r\n<p><img src=\"/imgs/SpringBoss/4x4Rn.png\"></p>\r\n<p>接下来要分解出 R 矩阵，我们利用 ”Polar\r\ndecomposition(极分解)“，可以证明矩阵<em>M</em>的极分解为 <u>旋转R</u> 和\r\n<u>缩放S</u> 。该方法通过对 <em>M</em>\r\n的逆的转置进行连续平均来计算，直到<strong>收敛</strong>，此时\r\n<em><strong>M</strong>i <strong>= R</strong></em>。</p>\r\n<p><img src=\"/imgs/SpringBoss/Polar.png\"></p>\r\n<p>当矩阵只有旋转变换时，旋转R 的转置和R的逆相等，达到收敛状态。<br />\r\n因为旋转矩阵为<strong>正交矩阵</strong>。Shoemake和Duff（1992）讨论了该级数收敛的证明，所得矩阵是最接近M的正交矩阵，这是理想的特性。为了计算该序列，我们迭代应用公式，直到连续项之间的差很小或执行了固定的迭代次数为止。\r\n实际上，该系列通常会很快收敛。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Float norm;  <br><span class=\"hljs-type\">int</span> count = <span class=\"hljs-number\">0</span>;  <br>Matrix4x4 R = M;  <br><span class=\"hljs-keyword\">do</span>  <br>&#123;  <br>    Matrix4x4 Rnext;  <br>    Matrix4x4 Rit = <span class=\"hljs-built_in\">Inverse</span>(<span class=\"hljs-built_in\">Transpose</span>(R));    <span class=\"hljs-comment\">// 转置的逆  </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; ++i)  <br>    &#123;  <br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; ++j)  <br>        &#123;  <br>            Rnext.m[i][j] = <span class=\"hljs-number\">0.5f</span> * (R.m[i][j]+Rit.m[i][j]);  <br>        &#125;  <br>    &#125;  <br>    <span class=\"hljs-comment\">// compute the sub between Mi and Mi+1  </span><br>    norm = <span class=\"hljs-number\">0</span>;  <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; ++i)  <br>    &#123;  <br>        Float n = <span class=\"hljs-built_in\">abs</span>(R.m[i][<span class=\"hljs-number\">0</span>] - Rnext.m[i][<span class=\"hljs-number\">0</span>]) +  <br>            <span class=\"hljs-built_in\">abs</span>(R.m[i][<span class=\"hljs-number\">1</span>] - Rnext.m[i][<span class=\"hljs-number\">1</span>]) +  <br>            <span class=\"hljs-built_in\">abs</span>(R.m[i][<span class=\"hljs-number\">2</span>] - Rnext.m[i][<span class=\"hljs-number\">2</span>]);  <br>        norm = <span class=\"hljs-built_in\">max</span>(norm,n);  <br>    &#125;  <br>    R = Rnext;  <br>&#125;<span class=\"hljs-keyword\">while</span>(++count &lt; <span class=\"hljs-number\">100</span> &amp;&amp; norm &gt; <span class=\"hljs-number\">0.0001</span>) <span class=\"hljs-comment\">// 当迭代次数过多，或者连续项差距足够小，退出循环。  </span><br></code></pre></td></tr></table></figure>\r\n<h3 id=\"s矩阵\">S矩阵</h3>\r\n<p>得到 R 矩阵后 S矩阵就很简单</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">S = Matrix4x4::<span class=\"hljs-built_in\">Mul</span>(<span class=\"hljs-built_in\">Inverse</span>(R),M);  <br></code></pre></td></tr></table></figure>\r\n<h3 id=\"另外一种办法\">另外一种办法</h3>\r\n<p>我们可以对3x3矩阵的每个列向量求长度，这样就知道每个坐标轴分量上的缩放，最终得到缩放矩阵，然后再根据缩放矩阵求旋转矩阵即可。</p>\r\n<h2 id=\"mvp矩阵\">MVP矩阵</h2>\r\n<h3 id=\"model\">Model</h3>\r\n<p>把顶点坐标从局部空间变换到全局空间。</p>\r\n<ul>\r\n<li><p>行矩阵 <img src=\"/imgs/SpringBoss/ModelRow.png\"></p></li>\r\n<li><p>列矩阵 <img src=\"/imgs/SpringBoss/ModelCol.png\"></p></li>\r\n</ul>\r\n<h3 id=\"view-matrix-推导\">View-Matrix 推导</h3>\r\n<p>在图形渲染中我们要把3D的场景渲染成一张2D的图片，而这张图片是从 Camera\r\n的视角出发，所以为了方便渲染我们做一个变换，把摄影机作为一个新的空间的原点，令摄影机观测方向为-z方向也就是我们常说的\r\n视图变换(Viewing Transform)。<br />\r\n我们对场景中的物体都进行这样一个变换就可以得到，观察空间下的物体的坐标信息，即以\r\nCamera 为原点，Camera 上方向为 y 轴，Camera 视线为 -z 轴，Camera 右侧为\r\nx轴的坐标空间下物体信息。<br />\r\n<strong>注意这里观察空间通常为右手系！而非和世界空间/模型空间所采用的左手系！</strong><br />\r\n<strong>接下来推导为列矩阵运算！</strong>\r\n这个变换主要分为两步一步是平移，一步是旋转。<br />\r\n设 Camera\r\n坐标为<img src=\"/imgs/SpringBoss/posE.png\" style=\"zoom:50%;\" ><br />\r\n则平移矩阵为<br />\r\n<img src=\"/imgs/SpringBoss/viewT.png\" style=\"zoom:50%\">\r\n现在我们把摄影机放到了原点位置，现在我们只需要把轴向调整即可。<br />\r\n<em>注意这里变换推导过程是先平移后旋转，和平时计算规定的 Transform 先\r\nscale 再 rotation最后 translate 的顺序不同。</em><br />\r\n我们假设 Camera up 方向矢量为 <em>t</em>，观察方向为 <em>g</em>，则其 x\r\n轴 <em>e</em> 为 <em>g</em>x<em>t</em>。<br />\r\n<img src=\"/imgs/SpringBoss/cameraETG.png\" style=\"zoom:50%\"><br />\r\n我们要让其轴向与 xyz\r\n轴对齐，因为现在只是把物体进行了移动，坐标信息的基础轴还是世界坐标系而非\r\ncamera坐标系的三轴。<br />\r\n我们只需把\r\n<code>t-&gt;y</code>,<code>g-&gt; -z</code>,<code>e-&gt;x</code> 其中\r\n<code>e = gxt</code>。<br />\r\n这样虽然可以进行计算，但是十分复杂。<br />\r\n我们观察到\r\n既然TEG是坐标轴，就意味着他们三者垂直，点积为零，可以构成正交矩阵。<br />\r\n那么 <code>t-&gt;y</code>,<code>g-&gt; -z</code>,<code>e-&gt;x</code>\r\n的逆变换\r\n<code>y-&gt;t</code>,<code>-z -&gt;g</code>,<code>x-&gt;e</code>\r\n是很好计算的。<br />\r\n而我们知道了逆矩阵，就可以知道正交矩阵的原矩阵。<br />\r\n正交矩阵性质:\r\n<img src=\"/imgs/SpringBoss/orthM.png\" style=\"zoom:80%\"></p>\r\n<p>所以 <img src=\"/imgs/SpringBoss/Rview.png\" style=\"zoom:80%\"></p>\r\n<p>最后 <img src=\"/imgs/SpringBoss/Mview.png\" style=\"zoom:80%\"></p>\r\n<h3 id=\"projection-matrix\">Projection Matrix</h3>\r\n<p>我们现在已经放好了物体，也以 Camera 的角度出发了，现在我们要从\r\n<strong>View space( 观察空间 )</strong> 到 <strong>Clip Space(\r\n裁剪空间/齐次裁剪空间 )</strong></p>\r\n<h4\r\nid=\"我们这里先考虑把深度归到01的情况\">我们这里先考虑把深度归到[0,1]的情况</h4>\r\n<p>要把 <strong>View\r\n空间</strong>的点投影到<strong>屏幕</strong>上，利用相似三角形原理，\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\frac{x_{screen}}{near}&amp;=\\frac{x_{view}}{z_{view}}\\\\\r\nx_{screen}&amp;=\\frac{x_{view}\\cdot near}{z_{view}}\\\\\r\ny_{screen}&amp;=\\frac{y_{view}\\cdot near}{z_{view}}\\\\\r\n\\end{aligned}\r\n\\]</span> 但是实际上我们是先把 <em>X,Y</em> 坐标变换到[-1,1]后映射到\r\nScreen的，所以还得改成<br />\r\n将所有顶点映射到[-1,1]是为了方便 GPU 计算 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;x_{screen}=\\frac{x_{view}\\cdot near}{z_{view}}&amp;\\in[-wid,wid]\\\\\r\n&amp;y_{screen}=\\frac{y_{view}\\cdot\r\nnear}{z_{view}}&amp;\\in[-height,height]\\\\\r\n&amp;x_{ndc}=\\frac{x_{view}\\cdot near}{z_{view}\\cdot wid}&amp;\\in\r\n[-1,1]\\\\\r\n&amp;y_{ndc}=\\frac{y_{view}\\cdot near}{z_{view}\\cdot height}&amp;\\in\r\n[-1,1]\\\\\r\n\\end{aligned}\r\n\\]</span> 所以我们现在知道如何对 x,y 坐标进行变换了，Project Matrix\r\n暂时可以写成这样， 因为 z,w 不受 x,y 影响 <span class=\"math display\">\\[\r\n\\begin{bmatrix}\r\n\\frac{near}{z_p\\cdot wid}&amp;0&amp;0&amp;0\\\\\r\n0&amp;\\frac{near}{z_p\\cdot height}&amp;0&amp;0\\\\\r\n0&amp;0&amp;A&amp;B\\\\\r\n0&amp;0&amp;C&amp;D\\\\\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nx_p\\\\\r\ny_p\\\\\r\nz_p\\\\\r\n1\\\\\r\n\\end{bmatrix}\r\n\\]</span></p>\r\n<p>而 z 值有些不一样，现在的问题是</p>\r\n<ul>\r\n<li>“我们的矩阵 <em>X,Y 坐标</em> 的变换矩阵和 <u>z值相关</u>”，<br />\r\n这肯定不是我们希望看到的，这不利于 GPU 计算，</li>\r\n<li>而且为了实现深度测试我们还希望可以将深度值归化到[0,1]，</li>\r\n</ul>\r\n<p>对于<strong>第一个问题</strong>，既然 <em>X,Y 坐标</em> 都要除 View\r\nSpace 的 <em>Z</em> 坐标值，<br />\r\n那么我们不妨把这个除法操作在后面统一执行，也就是\r\n<strong>齐次除法</strong>，<br />\r\n所以我们需要在做这个除法操作时能得到 <em>Z</em>\r\n坐标值，而恰巧我们可以利用 <em>W 分量</em><br />\r\n我们可以先把 <em>Z</em> 坐标轴存在 W 分量，即 <span\r\nclass=\"math display\">\\[\r\n\\begin{bmatrix}\r\n\\frac{near}{wid}&amp;0&amp;0&amp;0\\\\\r\n0&amp;\\frac{near}{height}&amp;0&amp;0\\\\\r\n0&amp;0&amp;A&amp;B\\\\\r\n0&amp;0&amp;1&amp;0\\\\\r\n\\end{bmatrix}\r\n\\]</span></p>\r\n<p><u>因为View Space 是右手系的所以……z值不是正的</u></p>\r\n<p><strong>第二个问题</strong>，而对于 <em>Z</em> 值 原本范围是 [-far,\r\n-near] -&gt; [?, ?] -&gt; [0,1] <span class=\"math display\">\\[\r\n[-far,-near]\\rightarrow[?,?]\\stackrel{/z}{\\rightarrow}[0,1]\r\n\\]</span> 所以我们对 -near 和 -far 两个边界条件\r\n列方程，因为是[0,1]在加上齐次除法所以near为0，far为far <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    -A\\cdot near+B=0\\\\\r\n    -A\\cdot far+B=far\\\\\r\n    A=\\frac{far}{near-far}\\\\\r\n    B=\\frac{near\\cdot far}{near-far}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>得到 <span class=\"math display\">\\[\r\n\\begin{bmatrix}\r\n\\frac{near}{wid}&amp;0&amp;0&amp;0\\\\\r\n0&amp;\\frac{near}{height}&amp;0&amp;0\\\\\r\n0&amp;0&amp;\\frac{far}{near-far}&amp;\\frac{near\\cdot far}{near-far}\\\\\r\n0&amp;0&amp;1&amp;0\\\\\r\n\\end{bmatrix}\r\n\\]</span> 从裁剪空间到NDC需要一次齐次除法</p>\r\n<h4 id=\"think-但可能不对\">think 但可能不对</h4>\r\n<p>齐次变换(仿射变换)的 W分量 对于一个点来说，可以表示变换的“距离\",\r\n比如用矩阵平移 点(x,y,z) 距离(1,1,1)<br />\r\n如果把W=2，再W 归一得到的是(x/2+0.5, y/2+0.5, z/2+0.5),<br />\r\n如果有若干多个点，这样做，相当于一种投影，而投影点集前后，点集之间相对当前\r\nW 分量的点集关系不会改变，比如两个点之前相聚(a,b,c)， 除2后就是\r\n(a/2,b/2,c/2)<br />\r\n挺有意思但没啥用好像。</p>\r\n<h2 id=\"tbn-矩阵\">TBN 矩阵</h2>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/412555049\">TBN矩阵不错的Blog</a></p>\r\n<h2\r\nid=\"d平面三角形给出算法生成三角形内随机一点\">2D平面三角形，给出算法，生成三角形内随机一点</h2>\r\n<p>https://www.cnblogs.com/TenosDoIt/p/4025221.html</p>\r\n<h2 id=\"前向渲染和延迟渲染\">前向渲染和延迟渲染</h2>\r\n<p>https://zhuanlan.zhihu.com/p/28489928</p>\r\n<h2 id=\"lut-表\">LUT 表</h2>\r\n<p>https://www.jianshu.com/p/fdec2a5e889f</p>\r\n<h2 id=\"描边效果\">描边效果</h2>\r\n<p>边缘检测</p>\r\n<h2 id=\"为什么要有光线追踪\">为什么要有光线追踪</h2>\r\n<ol type=\"1\">\r\n<li>传统光栅化做阴影效果不好，操作困难<br />\r\n</li>\r\n<li>物体的模糊反射，比如毛玻璃一般的反射即 Glossy\r\nReflection，光线打到Glossy物体在反射<br />\r\n</li>\r\n<li>间接光照(Indirect illumination)，光线在进入人眼前弹射不止一次</li>\r\n</ol>\r\n<p>这种光线弹射，对于光栅化来说想要实现比较麻烦，而且也不能保证物理上的正确性。光栅化本质上是一种快速的近似质量较低。<br />\r\n光线追踪是一种比较准确的办法质量很高，但是最大的问题就是很慢。</p>\r\n<h2 id=\"包围盒bvh\">包围盒BVH</h2>\r\n<h3 id=\"如何划分bvh\">如何划分BVH</h3>\r\n<p>1.随机选取一个维度</p>\r\n<p>2.选Bounding box中最长的轴进行进一步划分</p>\r\n<p>3.选取中间的三角形处进行划分（以保证两边三角形数量接近）。</p>\r\n<p>5.基于表面积的启发式评估划分方法（Surface Area\r\nHeuristic，SAH），这种方法通过对求交代价和遍历代价进行评估，给出了每一种划分的代价（Cost），寻找代价最小方式进行划分。</p>\r\n<p>6.基于莫顿码（Morton code）的并行化BVH构建。</p>\r\n<h4 id=\"参考学习记得学啊\">参考学习！记得学啊！</h4>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/50720158\">PBRT-E4.3-层次包围体(BVH)（一）\r\n- 玉米的文章 - 知乎</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/54620381\">PBRT-E4.3-层次包围体(BVH)（二）\r\n- 玉米的文章 - 知乎</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/54694041\">PBRT-E4.3-层次包围体(BVH)（三）\r\n- 玉米的文章 - 知乎</a><br />\r\n<a\r\nhref=\"https://www.cnblogs.com/silence394/p/17285231.html\">【空间加速结构】——层次包围体BVH（Bounding\r\nVolume Hierachies） - silence394 - 博客园</a><br />\r\n<a\r\nhref=\"https://box2d.org/files/ErinCatto_DynamicBVH_GDC2019.pdf\">Dynamic\r\nAABB Trees</a></p>\r\n<h2 id=\"渲染管线\">渲染管线</h2>\r\n<p>一般就说说大概的流程\r\nIA-&gt;VS-&gt;Hull-&gt;TS-&gt;Domain-&gt;GS-&gt;OS-&gt;RS-&gt;PS-&gt;OM</p>\r\n<h3 id=\"什么是曲面细分着色器\">什么是曲面细分着色器</h3>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/chenglixue/p/17227713.html\">大体介绍了一下曲面细分</a></p>\r\n<h2 id=\"透明效果\">透明效果</h2>\r\n<h1 id=\"球谐函数\">球谐函数</h1>\r\n<h2 id=\"雾效\">雾效</h2>\r\n<h1 id=\"重要性采样\">重要性采样</h1>\r\n<h2 id=\"阴影\">阴影</h2>\r\n<p>LightMap</p>\r\n<p>ShadowMapping</p>\r\n<p>PCF</p>\r\n<p>PCSS</p>\r\n<p>VSSM</p>\r\n<h3 id=\"csm如何做的\">CSM如何做的？</h3>\r\n<p>Cascaded Shadow\r\nMaps(CSM)方法根据对象到观察者的距离提供不同分辨率的深度纹理来解决上述问题。它将相机的视锥体分割成若干部分，然后为分割的每一部分生成独立的深度贴图。对于近处的场景使用较高分辨率的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用。</p>\r\n<h2 id=\"两个多边形如何判断相交\">两个多边形如何判断相交</h2>\r\n<p>https://blog.csdn.net/StevenKyleLee/article/details/88075814</p>\r\n<h3 id=\"一点是否在多边形内\">一点是否在多边形内</h3>\r\n<p>https://blog.csdn.net/StevenKyleLee/article/details/88044589</p>\r\n<p>一般用射线法这里说一下特殊情况：<br />\r\n<img src=\"/imgs/SpringBoss/RayPointSpe.png\" style=\"zoom:100%;\" ><br />\r\n这里的(b)因为中间那个顶点左右两条边都在该顶点的上侧，所以该顶点不识为于射线相交。<br />\r\n具体的判定过程应该可以根据多边形绕向找相邻点进行判断。</p>\r\n<p><a\r\nhref=\"https://blog.csdn.net/WilliamSun0122/article/details/77994526\">除射线法外的其他方法</a></p>\r\n<h2 id=\"taatemporal-anti-aliasing\">TAA(temporal anti-aliasing)</h2>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/64993622\">TAA in DX12</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/147567747\">快速理解Tone\r\nMapping</a><br />\r\n<a href=\"http://www.ownself.org/blog/2011/tone-mapping.html\">Tone\r\nMapping</a><br />\r\n<a href=\"https://www.cnblogs.com/crazii/p/7244300.html\">TAA GHOSTING\r\n的相关问题</a><br />\r\nTone Mapping\r\n是HDR算法的一部分，是用来将渲染出的场景亮度域映射到一个合理的亮度域空间。</p>\r\n<blockquote>\r\n<p>然后值得一提的是TAA在管线中的位置，虚幻的TAA是放在其它的后处理之前的，这么可以防止其它后处理出现的闪烁，但是因为高光很容易闪，我们又希望能在低动态范围处理，所以这里虚幻选择的是先tonemap，再算超采样，最后逆tonemap输出，去做其他的后处理。</p>\r\n</blockquote>\r\n<p>这里是说如果不做ToonMapping把HDR压倒LDR做TAA，因为HDR范围比LDR，然后TAA在混合在一起就会“亮的很花”，所以先Toon\r\nMapping到LDR做一下TAA在\r\n逆Toonmap输出，这样还得到了抗锯齿的输出，后处理做的更好了。这里的HDR和Toonmap我思考了很久，因为我没明白Toonmap，toonmap就是把hdr变成ldr，hdr虽然表示了更多的颜色，但是我们在屏幕空间显示还是0~1，所以要做映射，直接线性映射不行，因为人对暗部感知明显，而且自然界比LDR亮度大得多，所以我们做了很多调整。</p>\r\n<h3 id=\"颜色ldr和hdr\">颜色LDR和HDR</h3>\r\n<p><a href=\"https://www.jianshu.com/p/fdec2a5e889f\">LUT简述</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/80253409\">HDR和Tone\r\nMapping</a></p>\r\n<h3 id=\"几何走样和着色走样\">几何走样和着色走样</h3>\r\n<ul>\r\n<li><strong>几何走样：</strong>几何覆盖函数采样不足，即俗称的边缘锯齿，一般发生在<strong>光栅化阶段</strong>。<br />\r\n</li>\r\n<li><strong>着色走样：</strong>渲染方程的采样不足，因为<em>渲染方程也是连续函数</em>，对某些部分在<em>空间变化较快（高频部分）采样不足也会造成走样</em>，反映在视觉上一般是图像闪烁或噪点，这类走样称之为着色走样，一般发生在<strong>各种着色阶段</strong>。</li>\r\n</ul>\r\n<h2 id=\"z-fighting\">Z-fighting</h2>\r\n<h2 id=\"景深\">景深</h2>\r\n<p>所谓景深就是照片背景的虚化程度，规律是：光圈越大，景深越浅，背景越模糊；光圈越小，景深越深，背景越清晰。<br />\r\n<a\r\nhref=\"http://www.ownself.org/blog/2010/jing-shen-depth-of-field.html\">景深</a></p>\r\n<h2 id=\"点到三角形距离\">点到三角形距离</h2>\r\n<p>https://zhuanlan.zhihu.com/p/148511581<br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/148511581\">点到三角形面距离</a></p>\r\n<h2 id=\"pbr\">PBR</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/poem_qianmo/article/details/85239398\">【基于物理的渲染（PBR）白皮书】（一）\r\n开篇：PBR核心知识体系总结与概览</a></p>\r\n<h2 id=\"材质系统\">材质系统</h2>\r\n<p>材质系统了解、实现。</p>\r\n<h1 id=\"计组部分\">计组部分</h1>\r\n<h3 id=\"大端和小端模式\">大端和小端模式</h3>\r\n<p>https://blog.csdn.net/wei_cheng18/article/details/79856207</p>\r\n<ul>\r\n<li><strong>大端</strong>（Big_endian）字数据的<strong>高字节</strong>存储在<strong>低地址</strong>中，字数据的<strong>低字节</strong>存储在<strong>高地址</strong>中。<br />\r\n</li>\r\n<li><strong>小端</strong>（Little_endian）字数据的<strong>高字节</strong>存储在<strong>高地址</strong>中，字数据的<strong>低字节</strong>存储在<strong>低地址</strong>中。</li>\r\n</ul>\r\n<h3 id=\"cache-命中率\">Cache 命中率</h3>\r\n<h1 id=\"计网\">计网</h1>\r\n<h2 id=\"tcp\">TCP</h2>\r\n<h3 id=\"tcp三次握手\"><a\r\nhref=\"https://blog.csdn.net/jun2016425/article/details/81506353\">TCP三次握手</a></h3>\r\n<ul>\r\n<li>第一次握手：客户端向服务器发起链接请求<br />\r\n</li>\r\n<li>第二次握手：服务器向客户端返回，发送答应客户端请求的确认信息。<br />\r\n</li>\r\n<li>第三次握手：客户端向服务器，告诉服务器已经收到第二次握手的确认信息。</li>\r\n</ul>\r\n<h4\r\nid=\"tcp的三次握手过程为什么会采用三次握手若采用二次握手可以吗\">TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h4>\r\n<p>答：建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。</p>\r\n<p>（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。</p>\r\n<p>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。</p>\r\n<p>（3）采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况，因此采用三次握手刚刚好，两次可能出现失效，四次甚至更多次则没必要，反而复杂了</p>\r\n<h3 id=\"四次挥手\">四次挥手</h3>\r\n<ul>\r\n<li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，<strong>主动方：“我不会再给你数据了。”</strong><br />\r\n</li>\r\n<li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1，<strong>被动方：“我知道了！”</strong><br />\r\n</li>\r\n<li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，<strong>被动方：”我的数据也发送完了，不会再给你发数据了。“</strong><br />\r\n</li>\r\n<li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，<strong>主动方：“行了，那我知道了，一切结束”</strong></li>\r\n</ul>\r\n<h1 id=\"编译原理\">编译原理</h1>\r\n<h2 id=\"逆波兰式\"><a\r\nhref=\"https://blog.csdn.net/weixin_43919932/article/details/103327530\">逆波兰式</a></h2>\r\n<p>https://www.cnblogs.com/tangqs/archive/2012/05/18/2507708.html<br />\r\n如果是右单目运算符，直接入存储器栈；比如 阶乘！与百分号%</p>\r\n<h1 id=\"os\">OS</h1>\r\n<h2 id=\"进程和线程\">进程和线程</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/ThinkWon/article/details/102021274\">进程和线程</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/qq_33182418/article/details/121135914\">线程调度</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/qq_41784433/article/details/122194695\">进程/作业调度</a></p>\r\n<h3 id=\"多线程比单线程慢\">多线程比单线程慢</h3>\r\n<p>存在上下文切换和死锁问题。<br />\r\nhttps://www.cnblogs.com/xrq730/p/5186609.html</p>\r\n<h2 id=\"linux-进程通讯\">Linux 进程通讯</h2>\r\n<p>https://blog.csdn.net/qq_44443986/article/details/115065540</p>\r\n<h2 id=\"死锁和银行家算法\">死锁和银行家算法</h2>\r\n<p>https://blog.csdn.net/wyf2017/article/details/80068608</p>\r\n<h2\r\nid=\"什么是内存碎片内存碎片是在虚拟内存还是物理内存\">什么是内存碎片，内存碎片是在虚拟内存还是物理内存？</h2>\r\n<p>采用分区式存储管理的系统，在储存分配过程中产生的、不能供用户作业使用的主存里的小分区称成“内存碎片”。内存碎片分为内部碎片和外部碎片。内存碎片只存在于虚拟内存上。</p>\r\n<h1 id=\"概率论\">概率论</h1>\r\n<h2 id=\"期望计算和带保底卡池期望计算\">期望计算和带保底卡池期望计算</h2>\r\n<h1 id=\"算法\">算法</h1>\r\n<h2 id=\"lru手撸\">LRU手撸</h2>\r\n<p>https://leetcode.cn/problems/lru-cache-lcci/</p>\r\n<p>LRU算法还有进化版LFU算法</p>\r\n<h2 id=\"双端队列\">双端队列</h2>\r\n<p>一个能用队列和栈实现的增删查改都是O(1)的数据结构，是什么<br />\r\n这个能用队列和栈实现的增删查改都是O(1)的数据结构是双端队列（deque）[<a\r\nhref=\"https://zh.wikipedia.org/wiki/队列#双端队列\">1</a>]。双端队列不仅支持在队列的一端进行入队和出队操作，也支持在队列的另一端进行插入和删除操作。因此，在使用双端队列时，可以根据具体的需求选择在队列的哪一端进行操作，从而实现了增删查改都是O(1)的效率。</p>\r\n<h3 id=\"双端队列定义\">双端队列定义</h3>\r\n<p>能在队列两端进行入队、出队操作。</p>\r\n<h2 id=\"统计子树中城市之间最大距离\">统计子树中城市之间最大距离</h2>\r\n<p>https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/submissions/412418189/</p>\r\n<h2 id=\"a算法\">A*算法</h2>\r\n<p>https://zhuanlan.zhihu.com/p/54510444</p>\r\n<h2 id=\"岛屿问题\">岛屿问题</h2>\r\n<p>https://leetcode.cn/problems/number-of-islands/solutions/13103/dao-yu-shu-liang-by-leetcode/</p>\r\n<h2 id=\"top-k-问题\">Top K 问题</h2>\r\n<p>https://zhuanlan.zhihu.com/p/64627590</p>\r\n<h1 id=\"c-和-unity\">C# 和 Unity</h1>\r\n<p><a\r\nhref=\"https://blog.csdn.net/qq_21407523/article/details/108814300\">CSDN不错的面试总结-2022年Unity面试题分享\r\n| 全面总结 | 建议收藏</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/554529423\">知乎上五尘的Unity面试题</a></p>\r\n<h2 id=\"协程\">协程</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/w2009211777/article/details/125514898\">总结：协程与线程</a></p>\r\n<h2\r\nid=\"请简述gc垃圾回收产生的原因并描述如何避免\">请简述GC（垃圾回收）产生的原因，并描述如何避免？</h2>\r\n<p>GC回收堆上的内存避免：1.减少new产生对象的次数2.使用公用的对象（静态成员）3.将String换为StringBuilder</p>\r\n<h2 id=\"c指针和c的引用\">C++指针和C#的引用</h2>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/389422617\">c++引用和c#引用类型的区别</a></p>\r\n<h2 id=\"反射\">反射</h2>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/wangshenhe/p/3256657.html\">[整理]C#反射(Reflection)详解</a><br />\r\n<a\r\nhref=\"https://www.cnblogs.com/shahdza/p/12261831.html\">【Unity|C#】基础篇(12)——反射（Reflection）（核心类：Type、Assembly）</a></p>\r\n<ul>\r\n<li><p>反射的定义：审查元数据并收集关于它的类型信息的能力。元数据（编译以后的最基本数据单元）就是一大堆的表，当编译程序集或者模块时，编译器会创建一个类定义表，一个字段定义表，和一个方法定义表等。</p></li>\r\n<li><p>.NET的应用程序由几个部分：<strong>程序集（Assembly）、模块（Module）、类型（class）组成</strong>。</p></li>\r\n</ul>\r\n<h2 id=\"工厂模式\">工厂模式</h2>\r\n<p>https://wittykyrie.github.io/posts/Factor-Pattern/<br />\r\n<a\r\nhref=\"https://blog.csdn.net/cxy_zxl/article/details/116695023\">简单工厂模式、工厂方法模式优缺点</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/83535678\">C++\r\n深入浅出工厂模式（初识篇）</a></p>\r\n<h3 id=\"抽象工厂模式\">抽象工厂模式</h3>\r\n<p>https://blog.csdn.net/m0_46502538/article/details/120343296</p>\r\n<h2 id=\"ugui-如何实现ui物体淡入淡出\">UGUI 如何实现UI物体淡入淡出?</h2>\r\n<ul>\r\n<li>Text，Image这些组件都有继承Graphic类，这个类提供了CrossFadeAlpha()方法，可以做透明度渐变。<br />\r\n</li>\r\n<li>但如果界面东西多了，要获取每个Graphic是挺麻烦了。其实还有一个很简便的方法，用起来跟NGUI差不多。就是CanvasGruop组件，把这个组件放到界面根节点上，对这个组件的alpha做改变就行了。看看官方文档的解释，</li>\r\n</ul>\r\n<h2 id=\"esc-框架\">ESC 框架</h2>\r\n<p>https://blog.codingnow.com/2017/06/overwatch_ecs.html</p>\r\n<p>ECS 的 E ，也就是 Entity ，可以说就是传统引擎中的 Game Object\r\n。但是是 C 的整合其实。</p>\r\n<p>C 和 S 是这个框架的核心。System\r\n系统，也就是我上面提到的模块。每个模块应该专注于干好一件事，而每件事要么是作用于游戏世界里同类的一组对象的每单个个体的，要么是关心这类对象的某种特定的交互行为。比如碰撞系统，就只关心对象的体积和位置，不关心对象的名字，连接状态，音效、敌对关系等。</p>\r\n<p>每个可能单独使用的对象属性归纳为一个个 Component\r\n，比如对象的名字就是一个 Component ，对象的位置状态是另一个 Component\r\n。</p>\r\n<h2 id=\"unity的委托是什么-event-关键字有什么用\">unity的委托是什么? event\r\n关键字有什么用？</h2>\r\n<p>委托是一个容器，可以放函数对象，并且可以触发委托面的每个函数调用。委托主要用户回调函数。如果在外部给委托变量加函数进来，那么委托要定义成public,\r\n这样做又有一个问题，public外部的人也可以触发这个委托，如果我希望设计成外部可以加回调，但是只能是模块内部触发委托，那么我可以加一个event来修饰，这样虽然是public,但是外部无法触发委托,只能类的内部触发。</p>\r\n<h1 id=\"dx12\">DX12</h1>\r\n<p>DX12和</p>\r\n<h1 id=\"vulkan\">Vulkan</h1>\r\n<p><a\r\nhref=\"https://geek-docs.com/vulkan/vulkan-tutorial/vulkan-tutorial-index.html\">vulkan教程</a></p>\r\n<h2\r\nid=\"vulkan和dx12相比opengl好在哪里\">Vulkan和DX12相比OpenGL好在哪里？</h2>\r\n<h1 id=\"unity\">Unity</h1>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/585164814\">unity 八股文\r\n实时更新</a></p>\r\n<h2 id=\"unityupdate\">UnityUpdate</h2>\r\n<p><img src=\"/imgs/SpringBoss/unityUpdate.jpg\"></p>\r\n<h2 id=\"unity-ugui不规则区域点击问题\">Unity UGUI不规则区域点击问题</h2>\r\n<p>https://www.cnblogs.com/msxh/p/9283266.html</p>\r\n<h2\r\nid=\"当一个细小的高速物体撞向另一个较大的物体时会出现什么情况如何避免\">当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？</h2>\r\n<p>碰撞检测失败，会直接穿透</p>\r\n<p>避免方法：<br />\r\n（1）增大细小物体的碰撞体（不建议这样做）<br />\r\n（2）使用射线检测，检测他们之间的距离<br />\r\n（3）FixedUpdate频率修改，可以physics time减小（同样不建议）<br />\r\n（4）改变物体的速度（废话）<br />\r\n（5）将检测方式改为连续检测，rigifdbody.collisionDetectionMode\r\n=CollisionDetectionMode.Continuous;<br />\r\n或者是动态连续检测（CollisionDetectionMode.ContinuousDynamic）<br />\r\n（6）代码限制，加大计算量 提前计算好下一个位置</p>\r\n<h2 id=\"canvas-有几种模式如何配置\"><a\r\nhref=\"https://blog.csdn.net/weixin_42352178/article/details/109034679\">Canvas\r\n有几种模式，如何配置？</a></h2>\r\n<p>Canvas的三种渲染模式：</p>\r\n<ul>\r\n<li>Screen\r\nSpace-Overlay（屏幕空间-覆盖模式）UI元素的位置坐标是屏幕空间的坐标，Overlay模式下画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层。如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕。<br />\r\n</li>\r\n<li>Screen\r\nSpace-Camera（屏幕空间-摄影机模式）UI元素的位置坐标是屏幕空间的坐标，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。所不同的是，在该模式下，画布会被放置到摄影机前方。在这种渲染模式下，画布看起来绘制在一个与摄影机固定距离的平面上。所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。<br />\r\n此时，画布上的UI组件会随视角移动。<br />\r\n</li>\r\n<li>World\r\nSpace即世界空间模式，此模式下UI元素的位置坐标是世界空间的坐标。画布作为场景中的一部分被固定显示在场景中，显示效果类似Plane组件。</li>\r\n</ul>\r\n<h2 id=\"unity-渲染队列\">Unity 渲染队列</h2>\r\n<table>\r\n\r\n<thead>\r\n<tr class=\"header\">\r\n<th>Name</th>\r\n<th>ID</th>\r\n<th>Description</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>Background</td>\r\n<td>1000</td>\r\n<td>会在任何其他队列前渲染，渲染需要绘制在背景上的物体</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Geometry</td>\r\n<td>2000</td>\r\n<td>默认的渲染队列，大部分物体都使用这个队列，不透明物体一般使用这个队列</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>AlphaTest</td>\r\n<td>2450</td>\r\n<td>需要进行透明测试的物体</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Transparent</td>\r\n<td>3000</td>\r\n<td>在 Geometry 和 AlphaTest\r\n后，<strong>从后向前</strong>地渲染，任何使用透明混合的物体都使用此队列</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Overlay</td>\r\n<td>4000</td>\r\n<td>该队列用于实现叠加效果，任何需要最后渲染的物体都使用此队列。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"游戏动画\">游戏动画</h2>\r\n<h3 id=\"关节动画\">关节动画</h3>\r\n<h3 id=\"单一网格动画\">单一网格动画</h3>\r\n<h3 id=\"骨骼动画\">骨骼动画</h3>\r\n<h2 id=\"unity中ugui如何打包成图集\">unity中UGUI如何打包成图集?</h2>\r\n<p><a\r\nhref=\"https://www.zhihu.com/question/472146051/answer/2011067756\">unity中UGUI如何打包成图集?\r\n- 鲨鱼辣椒的回答 - 知乎</a></p>\r\n<ul>\r\n<li>开启UGUI的图集模式, Editor-&gt;Project Settings 下面有sprite\r\npacker的模式。<br />\r\n</li>\r\n<li>为每个UI图片制定要打入的图集的tag名字。<br />\r\n</li>\r\n<li>打包生成图集Window ------&gt;Sprite Packer,\r\n点击Pack即可打包生成图集。</li>\r\n</ul>\r\n<h2 id=\"build-in-rp和srp\">Build-IN RP和SRP</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/weixin_41622043/article/details/107623694\">Unity\r\nSRP URP HDRP 的区别</a></p>\r\n<h2 id=\"srp\">SRP</h2>\r\n<p><a href=\"https://unity.com/cn/srp\">Unity官方宣传</a></p>\r\n<h3 id=\"srp-batcher\">SRP Batcher</h3>\r\n<p><a\r\nhref=\"https://blog.unity.com/cn/technology/srp-batcher-speed-up-your-rendering\">SPR\r\nBatcher 官方简介</a></p>\r\n","site":{"data":{}},"excerpt":"<p>图形学全忘光了，技美笔试直接寄了。<br />\r\n把面试题整理一下吧……<br />\r\n对于<strong>多线程</strong>和<strong>图形API</strong>了解不够需要继续学习</p>","more":"<h1 id=\"c-部分\">C++ 部分</h1>\r\n<h2 id=\"new-和-malloc-区别\"><a\r\nhref=\"https://www.cnblogs.com/ywliao/articles/8116622.html\">new 和\r\nmalloc 区别</a></h2>\r\n<h3 id=\"申请内存所在位置\">1.申请内存所在位置</h3>\r\n<ul>\r\n<li><p>new 从 free store 动态分配内存空间，free store 能否是堆取决于 new\r\n的实现其可以是堆，还可以是静态存储区。</p></li>\r\n<li><p>malloc 从堆上分配内存</p></li>\r\n</ul>\r\n<h3 id=\"返回类型安全性\">2.返回类型安全性</h3>\r\n<ul>\r\n<li><p>new 分配内存成功时，返回对象类型的指针，符合类型安全。</p></li>\r\n<li><p>malloc 返回 void* ，需要强制类型转换。</p></li>\r\n</ul>\r\n<h3 id=\"内存分配失败时返回值\">3.内存分配失败时返回值</h3>\r\n<ul>\r\n<li>new 失败返回 bac_alloc 异常，不会返回 NULL；<br />\r\n</li>\r\n<li>malloc 失败返回 NULL；</li>\r\n</ul>\r\n<h3 id=\"是否需要指定内存大小\">4.是否需要指定内存大小</h3>\r\n<ul>\r\n<li><p>new 无需指定，编译器自己计算</p></li>\r\n<li><p>malloc 需要自己显示指定。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">A *ptr = (A*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(A));  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3 id=\"是否调用构造函数析构函数\">5.是否调用构造函数/析构函数</h3>\r\n<ul>\r\n<li>new 会经过三步分配内存\r\n<ul>\r\n<li>调用 operator new (数组是 operator new[]\r\n)，分配足够大、原始、未命名的空间。<br />\r\n</li>\r\n<li>编译器运行对应构造函数，传入初值。<br />\r\n</li>\r\n<li>构造完成，返回一个指向该对象的指针。<br />\r\n</li>\r\n</ul></li>\r\n<li>在 delete 会\r\n<ul>\r\n<li>调用析构函数<br />\r\n</li>\r\n<li>编译器调用 operator delete / operator delete[]</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"对数组处理\">6.对数组处理</h3>\r\n<ul>\r\n<li><p>C++ 有 new[] 和 delete [] 处理数组</p></li>\r\n<li><p>而 malloc\r\n不知道你存放什么，只会给一块原始的内存，所以需要我们自己指定</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> *ptr = (<span class=\"hljs-type\">int</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">10</span>*<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>)); <span class=\"hljs-comment\">// 分配10个int，作为数组  </span><br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3 id=\"new-和-malloc-是否可以相互调用\">7. new 和 malloc\r\n是否可以相互调用</h3>\r\n<p>new delete可以基于 malloc 实现，但是 malloc 不能调用 new！！！</p>\r\n<h3 id=\"是否可以重载\">8.是否可以重载</h3>\r\n<ul>\r\n<li>operator new / operator delete 可以重载<br />\r\n</li>\r\n<li>malloc / free 不能重载</li>\r\n</ul>\r\n<h3 id=\"能够直观地重新分配内存\">9.能够直观地重新分配内存</h3>\r\n<p>malloc 分配的内存如果不够了可以 realloc</p>\r\n<p>但是 new 不行！</p>\r\n<h3 id=\"客户处理内存分配不同\">10.客户处理内存分配不同</h3>\r\n<p>operator new 抛出异常前会调用一个用户指定的错误处理函数\r\nnew-handler，指向一个错误处理函数。</p>\r\n<p>malloc 异常用户只能看着他 NULL</p>\r\n<h2 id=\"类和接口\">类和接口</h2>\r\n<p>如果把类比作一把枪，接口就是枪的配件，比如握把，枪托等等。我们对于类重点在于描述一个对象，而对于接口重点在于描述接口能提供的功能，所以接口内没有数据成员，只有成员函数。</p>\r\n<h2 id=\"c-类\">C++ 类</h2>\r\n<ul>\r\n<li><p>子类和父类有同名成员数据，是通过\"::\"区分<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">int</span> num;  <br>&#125;  <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span>:<span class=\"hljs-keyword\">public</span> A  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">int</span> num;  <br>&#125;  <br></code></pre></td></tr></table></figure></p>\r\n<p>其实这两个<code>num</code>实际的名字是<code>A::num</code>和<code>B::num</code></p></li>\r\n<li><p>类的成员函数调用<br />\r\n非虚函数，根据调用对象类型决定，虚函数根据实际类型决定。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;T&quot;</span> &lt;&lt; std::endl; &#125;  <br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">int</span> num;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-built_in\">A</span>() &#123; num = <span class=\"hljs-number\">2</span>; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A::A &quot;</span> &lt;&lt; num++&lt;&lt;std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A::Fun1 &quot;</span> &lt;&lt; ++num&lt;&lt; std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">()</span></span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A::Fun2 &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun3</span><span class=\"hljs-params\">()</span></span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A::Fun3 &quot;</span> &lt;&lt; num-- &lt;&lt; std::endl; &#125;  <br>    ~<span class=\"hljs-built_in\">A</span>() &#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;~A() &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> :<span class=\"hljs-keyword\">public</span> A  <br>&#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-type\">int</span> num;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-built_in\">B</span>() &#123; num = <span class=\"hljs-number\">100</span>; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;B::B &quot;</span> &lt;&lt; num++ &lt;&lt; std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun1</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;B::Fun1 &quot;</span> &lt;&lt; ++num &lt;&lt; std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun2</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;B::Fun2 &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Fun3</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;B::Fun3 &quot;</span> &lt;&lt; num-- &lt;&lt; std::endl; &#125;  <br>    ~<span class=\"hljs-built_in\">B</span>() &#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;~B() &quot;</span> &lt;&lt; --num &lt;&lt; std::endl; &#125;  <br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    A* ptr = <span class=\"hljs-keyword\">new</span> B;  <br>    ptr = <span class=\"hljs-built_in\">dynamic_cast</span>&lt;A*&gt;(ptr);  <br>    ptr-&gt;<span class=\"hljs-built_in\">Fun1</span>();  <br>    ptr-&gt;<span class=\"hljs-built_in\">Fun2</span>();  <br>    ptr-&gt;<span class=\"hljs-built_in\">Fun3</span>();  <br>&#125;  <br></code></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">A::A <span class=\"hljs-number\">2</span>  <br>B::B <span class=\"hljs-number\">100</span>  <br>B::Fun1 <span class=\"hljs-number\">102</span>  <br>A::Fun2 <span class=\"hljs-number\">2</span>  <br>A::Fun3 <span class=\"hljs-number\">2</span>  <br>~<span class=\"hljs-built_in\">B</span>() <span class=\"hljs-number\">101</span>  <br>~<span class=\"hljs-built_in\">A</span>() <span class=\"hljs-number\">0</span>  <br></code></pre></td></tr></table></figure>\r\n<p><code>A* ptr = new B;</code><br />\r\n<code>ptr</code>类型为<code>A*</code>，但是实际指向对象类型其实为<code>B</code><br />\r\n那么其实在内存空间中有如下分配</p>\r\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\">成员数据:  <br><span class=\"hljs-selector-tag\">n_ptr</span>  <br><span class=\"hljs-selector-tag\">A</span>::<span class=\"hljs-selector-tag\">num</span>  <br><span class=\"hljs-selector-tag\">B</span>::<span class=\"hljs-selector-tag\">num</span>  <br>一张<span class=\"hljs-selector-tag\">A</span>的虚函数表？  <br>一张<span class=\"hljs-selector-tag\">B</span>的虚函数表  <br>函数映射：  <br>直接查找的  <br><span class=\"hljs-selector-tag\">A</span>::<span class=\"hljs-selector-tag\">Fun2</span>  <br><span class=\"hljs-selector-tag\">A</span>::<span class=\"hljs-selector-tag\">Fun3</span>  <br><span class=\"hljs-selector-tag\">B</span>::<span class=\"hljs-selector-tag\">Fun1</span>  <br><span class=\"hljs-selector-tag\">B</span>::<span class=\"hljs-selector-tag\">Fun2</span>  <br></code></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"构造函数链和析构函数链\">构造函数链和析构函数链</h2>\r\n<h3 id=\"构造函数链\">构造函数链</h3>\r\n<p>一个类中有父类成员，成员变量。对于构造函数我们</p>\r\n<ol type=\"1\">\r\n<li>先调用父类，<br />\r\n</li>\r\n<li>再调用成员变量的构造函数，<br />\r\n</li>\r\n<li>最后调用子类构造函数在构造过程中</li>\r\n</ol>\r\n<p>子类是继承父类的成员</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> a;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br>\t<span class=\"hljs-type\">int</span> b;    <br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>这里B有成员b，和从父类继承的a。<br />\r\n因为 a\r\n是父类成员，所以交由父类初始化，如果先调子类，子类成员有a，b，对a，b初始化，再调父类，a又初始化初始化两次。<br />\r\n对于成员变量，成员变量有自己的构造函数，是当前子类无需关心的，对于他们先交给他们自己初始化即可。</p>\r\n<h2 id=\"析构函数链\">析构函数链</h2>\r\n<p>对于析构函数链，我们把子类可以看成一个套娃。<br />\r\n我们装套娃会从小到大(从父到子)</p>\r\n<h2\r\nid=\"c的publicprotectedprivate和三种继承\">C++的public、protected、private和三种继承</h2>\r\n<p>public 表示大家谁都能来访问，包括类对象自己和外部。<br />\r\nprotected,外部不能访问，但是自己和子类可以访问。<br />\r\nprivate，表示只能自己访问，自己的子类都不能访问。<br />\r\npublic 继承，不改变父类成员的可见性。<br />\r\nprotected 继承，父类成员除private外，全部变为protect<br />\r\nprivate 继承全部变为private\r\n&gt;假如把父类比喻一个门派，期内对象就是武功秘籍<br />\r\n&gt;public 就像比较普通的武功，比如太祖长拳，大家都可以来学。<br />\r\n&gt;protect\r\n就像门派内的高深强大的武功秘籍，比如降龙十八掌，只有你是下一任掌门才能学。<br />\r\n&gt;private\r\n就像掌门自己偷学了邪门歪道，比如岳不群学《辟邪剑谱》，只能自己知道，外人不能晓得。除了自己谁也不让看。<br />\r\n&gt;<br />\r\n&gt;public\r\n继承就像是普普通通比较开明的继承者，子承父业，原来掌门规定的哪些武功可以交给外人，哪些武功自己人学，都不变，但是掌门私底下学的歪门武功他也不知道是什么，对他而言不可见，想知道是什么得返回去用上一任掌门的去查。<br />\r\n&gt;protect\r\n继承就像垄断或者有点小心思的人继承，我不让所有人随便学了，现在你们想从我这学你得是我的关门弟子下一任掌门。<br />\r\n&gt;private\r\n继承就像断代了，诶，我谁也不教，全部变成private，只有我自己看，但是无论这三种哪一种都看不到父类的private。</p>\r\n<h2 id=\"static关键字\">static关键字</h2>\r\n<p>static关键字表示静态元素，其在程序的生存周期中仅在<strong>静态存储区</strong>分配一次存储空间，直到程序的生存周期结束。<br />\r\nstatic常用于</p>\r\n<ul>\r\n<li>函数中的静态变量<br />\r\n</li>\r\n<li>静态类对象<br />\r\n</li>\r\n<li>类中的静态成员变量<br />\r\n</li>\r\n<li>类中的静态方法</li>\r\n</ul>\r\n<h2\r\nid=\"static-和const分别怎么用类里面static和const可以同时修饰成员函数吗\"><strong>static\r\n和const分别怎么用，类里面static和const可以同时修饰成员函数吗</strong></h2>\r\n<ul>\r\n<li><p><strong>static</strong></p>\r\n<ul>\r\n<li><p>static对于变量</p>\r\n<ol type=\"1\">\r\n<li><p>局部变量</p>\r\n<p>在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。</p>\r\n<p>内存中的位置：静态存储区</p>\r\n<p>初始化：局部的静态变量只能被初始化一次</p>\r\n<p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。</p>\r\n<blockquote>\r\n<p>当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。</p>\r\n</blockquote></li>\r\n<li><p>全局变量</p>\r\n<p>在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。</p>\r\n<p>内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）</p>\r\n<p>初始化：未经初始化的全局静态变量会被程序自动初始化为0</p>\r\n<p>作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。(只能在本文件中存在和使用)</p>\r\n<blockquote>\r\n<p>全局变量本身就是静态存储方式，\r\n静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序，\r\n当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）。\r\n而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，\r\n在同一源程序的其它源文件中不能使用它。</p>\r\n</blockquote></li>\r\n</ol></li>\r\n</ul></li>\r\n<li><p>static对于函数</p>\r\n<p>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为\r\nstatic。（和全局变量一样限制了作用域而已）</p></li>\r\n<li><p>static对于类</p>\r\n<ol type=\"1\">\r\n<li><p>成员变量</p>\r\n<p>用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，<strong>包括派生类的对象</strong>。</p>\r\n<p>因此，static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化\r\n。</p></li>\r\n<li><p>成员函数</p>\r\n<p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，<strong>不含this指针。</strong></p>\r\n<p>静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。</p>\r\n<p><strong>不可以同时用const和static修饰成员函数。</strong></p></li>\r\n</ol></li>\r\n<li><p><strong>const</strong></p>\r\n<ol type=\"1\">\r\n<li>限定变量为不可修改。<br />\r\n</li>\r\n<li>限定成员函数不可以修改任何数据成员</li>\r\n</ol></li>\r\n<li><p>static和const可以同时修饰成员函数吗?</p>\r\n<p>答：不可以。C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const\r\nthis*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。两者的语意是矛盾的。<strong>static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态</strong>，与类型的静态变量没有关系。因此不能同时用它们。</p></li>\r\n</ul>\r\n<h2 id=\"拷贝构造函数\">拷贝构造函数</h2>\r\n<p><strong>只有这三种情况！！！！！</strong></p>\r\n<h3 id=\"用一个对象初始化另一个对象\">1.用一个对象初始化另一个对象。</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Point <span class=\"hljs-title\">p2</span><span class=\"hljs-params\">(p1)</span></span>;  <br>Point p3 = p1  <br></code></pre></td></tr></table></figure>\r\n<p>这两种情况一样。</p>\r\n<h3\r\nid=\"若一个函数的形参是一个-class-对象当-f-被调用时class-拷贝构造函数调用\">2.若一个函数的形参是一个\r\nClass 对象，当 F 被调用时，Class 拷贝构造函数调用。</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Func</span><span class=\"hljs-params\">(Point a)</span></span>&#123;&#125;;<br>  <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">mian</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    Point a;  <br>    <span class=\"hljs-built_in\">Func</span>(a);    <span class=\"hljs-comment\">// 调用拷贝构造函数  </span><br>&#125;  <br></code></pre></td></tr></table></figure>\r\n<h3\r\nid=\"如果函数的返回值是-class-对象函数返回时调用-class-拷贝构造函数\">3.如果函数的返回值是\r\nClass 对象，函数返回时，调用 Class 拷贝构造函数</h3>\r\n<p>即返回值对象由拷贝构造函数初始化。</p>\r\n<h2 id=\"模板函数\">模板函数</h2>\r\n<h3\r\nid=\"模板函数的声明实现为什么必须在一个文件内\">模板函数的声明实现为什么必须在一个文件内</h3>\r\n<p><a\r\nhref=\"https://blog.csdn.net/chigusakawada/article/details/78752668\">CSDN\r\n: 模板函数的声明和定义为何不能分开放在两个文件中?</a></p>\r\n<h2 id=\"c-11-特性\">C++ 11 特性</h2>\r\n<h3 id=\"左值右值\">左值右值</h3>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/qicosmos/p/4283455.html\">四行代码！看懂右值引用</a></p>\r\n<h4 id=\"右值引用的特点\">右值引用的特点：</h4>\r\n<ol type=\"1\">\r\n<li><p>通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">A <span class=\"hljs-title\">GetA</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">A</span>();  <br>&#125;  <br>A&amp;&amp; a = <span class=\"hljs-built_in\">GetA</span>();\t<span class=\"hljs-comment\">// 这里只会调用一次拷贝构造函数，就是return A()，  </span><br><span class=\"hljs-comment\">// 因为A&amp;&amp; 延长了 GetA的生命周期无需拷贝函数  </span><br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。</p></li>\r\n<li><p>T&amp;&amp;\r\nt在发生自动类型推断的时候，它是未定的引用类型（universal\r\nreferences），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。<br />\r\n正是因为右值引用可能是左值也可能是右值，依赖于初始化，并不是一下子就确定的特点，我们可以利用这一点做很多文章，比如后面要介绍的移动语义和完美转发。</p></li>\r\n<li></li>\r\n</ol>\r\n<p>移动语义的实现：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">A <span class=\"hljs-title\">GetA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> A;<br>&#125;<br><br><span class=\"hljs-built_in\">A</span>(A&amp;&amp; a):<span class=\"hljs-built_in\">m_ptr</span>(a.m_ptr)&#123;&#125;<br><br>A a = <span class=\"hljs-built_in\">GetA</span>();<br></code></pre></td></tr></table></figure>\r\n<p>利用右值引用作为参数，因为<code>GetA</code>返回值是右值，而<code>A&amp;&amp;</code>类型确定不发生自动推断即确定的右值，拷贝函数会匹配到<code>A(A&amp;&amp; a)</code>，这样就省去了重新<code>new m_ptr</code>。</p>\r\n<h5 id=\"引用折叠\">引用折叠</h5>\r\n<ul>\r\n<li>所有的右值引用叠加到右值引用上仍然还是一个右值引用；<br />\r\n</li>\r\n<li>所有的其他引用类型之间的叠加都将变成左值引用。</li>\r\n</ul>\r\n<h4 id=\"一个移动语义应用\">一个移动语义应用</h4>\r\n<p>实现移动构造和移动赋值<br />\r\n为什么在 移动构造中将 f.ptr 赋值为 nullptr<br />\r\n因为我们的移动构造函数参数是一个右值，在完成初始化的任务后就应该消失，所以把他所指内存交给新对象，并指向了nullptr，移动赋值也是同理。<br />\r\n移动赋值和移动复制通常联合使用，目的是优化对象的复制和赋值操作，提高程序的性能。<br />\r\n移动赋值会在这时调用<code>f1=Foo()</code>，f1是之前声明过的，Foo()返回右值，匹配到<code>=(Foo&amp;&amp;)</code>函数。\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Foo</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-type\">int</span> a;<br>    <span class=\"hljs-type\">int</span> *ptr;<br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Foo</span>(Foo&amp;&amp; f):<span class=\"hljs-built_in\">ptr</span>(f.ptr),<span class=\"hljs-built_in\">a</span>(f.a)<br>    &#123;<br>        f.ptr = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>    <br>    Foo&amp; <span class=\"hljs-keyword\">operator</span> =(Foo&amp;&amp; f)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span> != &amp;f)<br>        &#123;<br>            <span class=\"hljs-keyword\">this</span>-&gt;ptr = f.ptr;<br>            f.ptr = <span class=\"hljs-literal\">nullptr</span>;<br>            a = f.a;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<h3 id=\"一些补充\">一些补充</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">vec.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">Foo</span>());<br></code></pre></td></tr></table></figure>\r\n<p>首先，我们知道函数的返回值是右值，所以Foo() 这部分是个右值<br />\r\n当我们没有右值引用的移动构造函数时，我们会发生\r\n右值转换的过程——把右值转化为左值，调用复制构造函数。<br />\r\n若我们有参数为右值引用的移动构造函数，右值会直接匹配到这个函数，不会发生一次转换去匹配参数为左值的复制构造函数。<br />\r\n这里的知识点是右值可以转换为左值。</p>\r\n<h3 id=\"智能指针\">智能指针</h3>\r\n<h3 id=\"类型推断\">类型推断</h3>\r\n<h3 id=\"lambda表达式\">lambda表达式</h3>\r\n<h3 id=\"类型转换\">类型转换</h3>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/417640759\">九阳神功！不会C++就看这个！</a>（1）const_cast:\r\n把const属性去掉，即将const转换为非const（也可以反过来），const_cast只能用于指针或引用，并且只能改变对象的底层const（顶层const，本身是const，底层const，指向对象const）；</p>\r\n<p>（2）static_cast:\r\n隐式类型转换，可以实现C++中内置基本数据类型之间的相互转换，enum、struct、\r\nint、char、float等，能进行类层次间的向上类型转换和向下类型转换（向下不安全，因为没有进行动态类型检查）。它不能进行无关类型(如非基类和子类)指针之间的转换，也不能作用包含底层const的对象；</p>\r\n<p>（3）dynamic_cast：动态类型转换，用于将基类的指针或引用安全地转换成派生类的指针或引用（也可以向上转换），若指针转换失败返回NULL，若引用返回失败抛出bad_cast异常。dynamic_cast是在运行时进行安全性检查；使用<strong>dynamic_cast父类一定要有虚函数，否则编译不通过；</strong></p>\r\n<p>（4）reinterpret_cast：reinterpret是重新解释的意思，此标识符的意思即为将数据的二进制形式重新解释，但是不改变其值，有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用（比较不安全）</p>\r\n<h2 id=\"c-struct和class区别\">C++ struct和class区别</h2>\r\n<ul>\r\n<li><p>在 <strong>C 语言</strong> 中，<strong>结构体</strong>\r\n只能存放一些 <strong>变量</strong> 的集合，并不能有\r\n<strong>函数</strong>，但 <strong>C++</strong> 中的结构体对 C\r\n语言中的结构体做了扩充，可以有函数，因此 C++ 中的结构体跟 C++\r\n中的类很类似。C++ 中的 struct\r\n可以包含成员函数，也能继承，也可以实现多态。</p></li>\r\n<li><p>但在 C++ 中，使用 class 时，类中的成员默认都是\r\n<strong>private</strong> 属性的，而使用 struct\r\n时，结构体中的成员默认都是 public 属性的。</p></li>\r\n<li><p>class 继承默认是 private 继承，而 struct 继承默认是 public\r\n继承。</p></li>\r\n<li><p>C++ 中的 class 可以使用模板，而 struct 不能使用模板。</p></li>\r\n</ul>\r\n<h2 id=\"c-vector\">C++ vector</h2>\r\n<p>vector.clear 不释放空间</p>\r\n<ul>\r\n<li>int size() const:返回向量中元素的个数<br />\r\n</li>\r\n<li>int capacity() const:返回当前向量所能容纳的最大元素值<br />\r\n</li>\r\n<li>int max_size() const:返回最大可允许的vector元素个数值</li>\r\n</ul>\r\n<h2 id=\"c智能指针和安全性\">C++智能指针和安全性</h2>\r\n<p>智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(shared_ptr),\r\n独占指针(unique_ptr)和弱指针(weak_ptr)：</p>\r\n<p>（1）shared_ptr\r\n，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；</p>\r\n<p>（2）unique_ptr，保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr）；</p>\r\n<p>（3）weak_ptr，用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>\r\n<ul>\r\n<li>shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？shared_ptr是不是线程安全的？</li>\r\n</ul>\r\n<p>（1）shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；</p>\r\n<p>（2）具体实现：</p>\r\n<p>1）构造函数：将指针指向该对象，引用计数置为1；</p>\r\n<p>2）拷贝构造函数：将指针指向该对象，引用计数++；</p>\r\n<p>3）赋值运算符：=号左边的shared_ptr的引用计数-1，右边的shared_ptr的引用计数+1，如果左边的引用技术降为0，还要销毁shared_ptr指向对象，释放内存空间。</p>\r\n<p>（3）shared_ptr的引用计数本身是安全且无锁的，但是它指向的对象的读写则不是，因此可以说shared_ptr不是线程安全的。<a\r\nhref=\"https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1654442\">shared_ptr是线程安全的吗？\r\n- 云+社区 - 腾讯云 (tencent.com)</a></p>\r\n<ul>\r\n<li>weak_ptr是为了解决shared_ptr的循环引用问题，那为什么不用raw\r\nptr来解决这个问题？</li>\r\n</ul>\r\n<p>答：一个weak_ptr绑定到shared_ptr之后不会增加引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使weak_ptr指向对象，也还是会释放；raw指针，当对象销毁之后会变成悬浮指针。</p>\r\n<h2 id=\"shared_ptr实现原理\">Shared_ptr实现原理</h2>\r\n<h3 id=\"智能指针如何实现\">智能指针如何实现</h3>\r\n<p>C++中的智能指针（smart pointers）是一种RAII（Resource Acquisition Is\r\nInitialization）技术的实现方式，它们可以自动管理内存资源，并确保在对象离开作用域时正确地释放这些资源。智能指针的主要目的是确保资源获取与对象初始化同时发生，从而能够创建该对象的所有资源并在某行代码中准备就绪。</p>\r\n<p>C++11中引入了三种智能指针：<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。其中<code>std::unique_ptr</code>是用于独占式拥有一个对象，<code>std::shared_ptr</code>是用于共享拥有一个对象，而<code>std::weak_ptr</code>则是用于弱引用一个对象。</p>\r\n<p>当我们需要使用RAII技术来管理动态分配的内存时，我们通常使用<code>std::unique_ptr</code>来管理指向单个对象的指针，并使用<code>std::shared_ptr</code>来管理指向共享资源的指针。如果我们需要在一个对象中存储多个指向共享资源的指针，则应使用<code>std::weak_ptr</code>来避免循环引用问题。</p>\r\n<p>总之，智能指针是一种非常有用的C++编程工具，可以帮助我们更安全、更简单地管理内存资源，并且对于编写高质量的C++代码来说至关重要。更多关于智能指针的资料可以参考[<a\r\nhref=\"https://zhuanlan.zhihu.com/p/150555165\">3</a>][<a\r\nhref=\"https://learn.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170\">4</a>]。</p>\r\n<h2\r\nid=\"为什么析构函数一定要被设置为虚函数\">为什么析构函数一定要被设置为虚函数</h2>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/yuanch2019/p/11625460.html\">为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</a></p>\r\n<p>首先类的<strong>虚函数</strong>调用是靠<strong>虚函数指针</strong>调用的，而函数成员靠的是对象类型。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span></span>&#123;&#125;;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func2</span><span class=\"hljs-params\">()</span></span>&#123;&#125;;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    A a;<br>    a.<span class=\"hljs-built_in\">func1</span>();<br>    a.<span class=\"hljs-built_in\">func2</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>对于<code>func1</code>是通过<code>a.this</code>调用，而<code>func2</code>是通过虚函数指针<code>a._vfptr-&gt;func2()</code>调用。(大概是这个意思，但应该是别的形式)</p>\r\n<blockquote>\r\n<p>“Note：定义在类内部的函数是隐式的inline函数（参见6.5.2节，第214页）。”\r\n—— 《C++ Primer》 中文第五版 P230</p>\r\n<p>“成员函数通过一个名为<strong>this</strong>的额外隐式参数来访问调用它的那个对象。”\r\n—— 《C++ Primer》 中文第五版 P231</p>\r\n</blockquote>\r\n<p><strong>成员函数本质上可以看做全局函数，不过第一个参数固定为this。</strong></p>\r\n<h3 id=\"菱形继承\">菱形继承</h3>\r\n<p>https://blog.csdn.net/tounaobun/article/details/8443228</p>\r\n<p>问题：A-&gt;B;A-&gt;C;B,C-&gt;D; B,C继承了A，D继承了A。<br />\r\n在调用D的成员函数时候就不知道是调用B的，还是C的，所以在继承中使用</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Lion</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Wolf</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> Animal<br>&#123;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> : <span class=\"hljs-keyword\">public</span> Wolf, <span class=\"hljs-keyword\">public</span> Lion<br>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>加上virtual保证子类只有一个父类的子对象，防止发生二义性。</p>\r\n<h2 id=\"c-深拷贝浅拷贝\">C++ 深拷贝浅拷贝</h2>\r\n<p>（1）拷贝构造函数的作用就是定义了当我们用同类型的另外一个对象初始化本对象的时候做了什么，在某些情况下，如果我们不自己定义拷贝构造函数，使用默认的拷贝构造函数，就会出错。比如一个类里面有一个指针，如果使用默认的拷贝构造函数，会将指针拷贝过去，即两个指针指向同个对象，那么其中一个类对象析构之后，这个指针也会被delete掉，那么另一个类里面的指针就会变成<strong>野指针（悬浮指针）</strong>；</p>\r\n<p>（2）这也正是深拷贝和浅拷贝的区别，浅拷贝只是简单直接地复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。\r\n但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p>\r\n<h2 id=\"c野指针\">C++野指针</h2>\r\n<p>指针指向了一块非法内存区域(悬空或者说未知区域)。</p>\r\n<h2 id=\"c-虚函数\">C++ 虚函数</h2>\r\n<h3 id=\"哪些函数不能是虚函数\"><a\r\nhref=\"https://www.cnblogs.com/NeilZhang/p/5427872.html\">哪些函数不能是虚函数</a></h3>\r\n<p>常见的不不能声明为虚函数的有：普通函数（非成员函数）；静态成员函数；内联成员函数；构造函数；友元函数。</p>\r\n<h2 id=\"c-内存模型\">C++ 内存模型</h2>\r\n<h3 id=\"c内存布局\">C++内存布局</h3>\r\n<h4 id=\"heap-堆\">Heap 堆</h4>\r\n<p>由new分配的内存块，其释放编译器不去管，由我们<strong>程序自己控制（一个new对应一个delete）</strong>。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”</p>\r\n<h4 id=\"stack-栈\">Stack 栈</h4>\r\n<p><strong>编译器</strong>在需要时<strong>分配</strong>，在不需要时自动清除。存放<strong>局部变量</strong>和<strong>函数参数</strong>。<br />\r\n存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。</p>\r\n<h4 id=\"全局静态存储区.bss和.data段\">全局/静态存储区(.bss和.data段)</h4>\r\n<p>全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中称为zero\r\ninitialization，初始化的放在.data段中，称为const\r\ninitialization；在C++中二者不进行区分。<br />\r\n虚函数表就存在这里，因为是全局公用的一张表，通过虚函数指针查找。</p>\r\n<h4 id=\"常量存储区.rodata段\">常量存储区(.rodata段)</h4>\r\n<p>存放常量，不允许修改，比如<code>const int a = 3</code></p>\r\n<h4 id=\"代码区.text段\">代码区(.text段)</h4>\r\n<p>存放代码，比如我们的函数和类的成员函数。不许修改但是可以执行。</p>\r\n<h3 id=\"c内存区域\">C++内存区域</h3>\r\n<p>根据生命周期不同，C++中可划分出三种不同的内存区域</p>\r\n<p>1.自由存储区、动态区、静态区局部非静态变量的存储区域(栈)<br />\r\n2.动态区：new，malloc分配的内存<br />\r\n3.静态区：全局变量，静态变量，字符串常量存在位置</p>\r\n<p>https://www.cnblogs.com/yunlambert/p/9876491.html<br />\r\n<a\r\nhref=\"https://blog.csdn.net/JUST__Tw/article/details/118551674\">深入理解计算机系统（内存管理）----内存模型</a><br />\r\n空类(空 class)大小是1，为了标识对象<br />\r\n<a\r\nhref=\"https://blog.csdn.net/li975242487/article/details/121395693\">不同类型占用的字节</a></p>\r\n<h2 id=\"c运算符重载\">C++运算符重载</h2>\r\n<p>https://www.cnblogs.com/liuchenxu123/p/12538623.html</p>\r\n<h2 id=\"派生类的构造函数顺序\">派生类的构造函数顺序</h2>\r\n<p>https://www.nowcoder.com/questionTerminal/6348a321452a4318a2da5f3757baf620?source=relative</p>\r\n<h2 id=\"迭代器\">迭代器</h2>\r\n<p>https://blog.csdn.net/QIANGWEIYUAN/article/details/89184546</p>\r\n<h2 id=\"红黑树\">红黑树</h2>\r\n<p>https://blog.csdn.net/u014454538/article/details/120120216</p>\r\n<h2 id=\"小根堆大根堆\">小根堆，大根堆</h2>\r\n<h3 id=\"完全二叉堆\">完全二叉堆</h3>\r\n<p>堆又可称之为完全二叉堆。这是一个逻辑上基于完全二叉树、物理上一般基于线性数据结构（如数组、向量、链表等）的一种数据结构。</p>\r\n<h4 id=\"完全二叉树\">完全二叉树</h4>\r\n<p>完全二叉树是由满二叉树而引出来的，若设二叉树的<code>深度为h</code>，<code>除第 h 层外</code>，<code>其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)</code>，第\r\nh 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>\r\n<h3 id=\"小根堆\">小根堆</h3>\r\n<p>根小于节点</p>\r\n<h3 id=\"大根堆\">大根堆</h3>\r\n<p>根大于节点</p>\r\n<h2 id=\"对象池\">对象池</h2>\r\n<p>对象池内通常是对象实例的指针，因为对象池的原理是将对象放入池管理的某种内存连续的数据结构中，当不需要对象时，并不销毁对象，而是将对象回收到池中，下次需要的时候再次从池中拿出来。由于对象储存在内存连续的数据结构中，所以能够有效地解决内存碎片的问题。因此，对象池中保存对象的指针比直接保存对象实例更为高效，能够避免频繁分配和销毁内存，从而提高了程序的性能。</p>\r\n<h2 id=\"多线程\">多线程</h2>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/430069448\">进程间通信方式；线程间通信方式</a></p>\r\n<h3 id=\"进程间通讯的方式\">进程间通讯的方式？</h3>\r\n<p>管道通信，消息队列，共享内存，socket，串口都可以实现。</p>\r\n<h4 id=\"管道-pipe\">管道( pipe )：</h4>\r\n<p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>\r\n<h4 id=\"有名管道-namedpipe\">有名管道 (namedpipe) ：</h4>\r\n<p>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>\r\n<h4 id=\"信号量semophore\">信号量(semophore ) ：</h4>\r\n<p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>\r\n<h4 id=\"消息队列-messagequeue\">消息队列( messagequeue ) ：</h4>\r\n<p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>\r\n<h4 id=\"信号-sinal\">信号 (sinal ) ：</h4>\r\n<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>\r\n<h4 id=\"共享内存shared-memory\">共享内存(shared memory ) ：</h4>\r\n<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的\r\nIPC\r\n方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>\r\n<h4 id=\"套接字socket\">套接字(socket ) ：</h4>\r\n<p>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>\r\n<h3 id=\"线程间通讯方式\">线程间通讯方式。</h3>\r\n<p><strong>锁机制：包括互斥锁、条件变量、读写锁</strong></p>\r\n<ul>\r\n<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。<br />\r\n</li>\r\n<li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。<br />\r\n</li>\r\n<li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>\r\n</ul>\r\n<p><strong>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</strong></p>\r\n<p><strong>信号机制(Signal)：类似进程间的信号处理</strong></p>\r\n<h1 id=\"图形学部分\">图形学部分</h1>\r\n<h2 id=\"叉乘\">叉乘</h2>\r\n<p>两个向量的叉乘结果是一个垂直于这两个向量的向量，最后这个向量的长度等于以最初两个向量作为边的平行四边形的面积。</p>\r\n<h2 id=\"光照模型\">光照模型</h2>\r\n<ul>\r\n<li>emissive<br />\r\n</li>\r\n<li>specular<br />\r\n</li>\r\n<li>diffuse<br />\r\n</li>\r\n<li>ambient</li>\r\n</ul>\r\n<h3 id=\"环境光\">环境光</h3>\r\n<p>通常用系统定值，场景物体通用</p>\r\n<p><img src=\"/imgs/SpringBoss/C_ambient.png\"></p>\r\n<h3 id=\"自发光\">自发光</h3>\r\n<p>材质决定</p>\r\n<p><img src=\"/imgs/SpringBoss/C_emissive.png\"></p>\r\n<h3 id=\"漫反射\">漫反射</h3>\r\n<p>根据 Lambert‘s law</p>\r\n<p><img src=\"/imgs/SpringBoss/C_diffuse.png\"></p>\r\n<h3 id=\"高光反射\">高光反射</h3>\r\n<p>我们有很多变量：normal，eyeDir，lightDir，refDir</p>\r\n<h4 id=\"已知-normallightdir-求-refdir\">已知 normal，lightDir 求\r\nrefDir</h4>\r\n<p><img src=\"/imgs/SpringBoss/NormalLightEyeRef.png\"></p>\r\n<p><img src=\"/imgs/SpringBoss/RefEqu.png\"></p>\r\n<h5 id=\"phong-模型\">Phong 模型</h5>\r\n<p><img src=\"/imgs/SpringBoss/PhongSpecular.png\"></p>\r\n<h5 id=\"blinn-phong\">Blinn-Phong</h5>\r\n<p><img src=\"/imgs/SpringBoss/BlinnPhong.png\"></p>\r\n<h2 id=\"复习下线性代数\">复习下线性代数</h2>\r\n<h3 id=\"坐标系\">坐标系</h3>\r\n<p>坐标系分为<em>左手坐标系</em>和<em>右手坐标系</em></p>\r\n<p><img src=\"/imgs/SpringBoss/LeftRight.png\" style=\"zoom:60%;\" ></p>\r\n<p>二者在 z 轴方向上有所不同。<br />\r\n在 Unity\r\n中<strong>模型空间</strong>和<strong>世界空间</strong>为左手系，<strong>观察空间</strong>为右手系。</p>\r\n<h3 id=\"矩阵\">矩阵</h3>\r\n<p>矩阵又分为行矩阵和列矩阵。<br />\r\n<strong><em><u>矩阵的左乘/右乘，表示该矩阵在乘号的左侧/右侧。</u></em></strong></p>\r\n<h4 id=\"行矩阵\">行矩阵</h4>\r\n<p><img src=\"/imgs/SpringBoss/rowMatrix.png\" ></p>\r\n<p>表示 1xn 的矩阵，行矩阵<strong>左乘</strong>，变换矩阵乘在右侧-&gt;\r\n<code>1xn dot nxn = 1xn</code></p>\r\n<h5 id=\"齐次式\">齐次式</h5>\r\n<ul>\r\n<li><p>矢量/点</p>\r\n<p><img src=\"/imgs/SpringBoss/rowMatrixHC.png\"></p></li>\r\n<li><p>变换矩阵</p>\r\n<p><img src=\"/imgs/SpringBoss/rowMatrixHCT.png\" > #### 列矩阵</p></li>\r\n</ul>\r\n<p><u><strong><em>Unity就是列矩阵！</em></strong></u></p>\r\n<blockquote>\r\n<p>问题1<br />\r\nshader中会看到法线的变换矩阵：<br />\r\nfloat3x3 transform = float3x3(v.tangent.xyz, binormal, v.normal);<br />\r\n即，<strong>float3x3类型的变量</strong>在创建时，如果传入3个float3类型的变量。整个矩阵是按行优先填充还是按列优先填充呢？<br />\r\n答：填入的是三个列，即unity\r\nshader是<strong>列优先</strong>（column-major）的。<br />\r\n问题2<br />\r\n<strong>matrix</strong>.m12是什么意思？<br />\r\n答：m12是第一行第二列，但是构造矩阵时是<strong>按列的</strong>。</p>\r\n</blockquote>\r\n<p><img src=\"/imgs/SpringBoss/columnMatrix.png\" ></p>\r\n<p>表示 nx1 的矩阵，列矩阵<strong>右乘</strong>，变换矩阵乘在其左侧\r\n<code>nxn dot nx1 = nx1</code></p>\r\n<h5 id=\"齐次式-1\">齐次式</h5>\r\n<ul>\r\n<li><p>矢量/点</p>\r\n<p><img src=\"/imgs/SpringBoss/colMHC.png\"></p></li>\r\n<li><p>变换矩阵</p></li>\r\n</ul>\r\n<p><img src=\"/imgs/SpringBoss/colMHCT.png\"></p>\r\n<h2 id=\"矩阵的几何意义变换\">矩阵的几何意义变换</h2>\r\n<p>变换优先级为：缩放&gt;旋转&gt;位移</p>\r\n<h3 id=\"缩放\">缩放</h3>\r\n<p><img src=\"/imgs/SpringBoss/scale.png\"></p>\r\n<h3 id=\"旋转\">旋转</h3>\r\n<p>在<strong>左手系</strong>中，绕轴<strong>旋转遵从左手手旋转准则</strong>：大拇指为轴向，四指为旋转方向。<br />\r\n在<strong>右手系</strong>中，绕轴<strong>旋转遵从右手旋转准则</strong>：大拇指为轴向，四指为旋转方向。</p>\r\n<ul>\r\n<li>绕 x 轴</li>\r\n</ul>\r\n<p><img src=\"/imgs/SpringBoss/rotationX.png\"></p>\r\n<ul>\r\n<li>绕 y 轴</li>\r\n</ul>\r\n<p><img src=\"/imgs/SpringBoss/rotationY.png\"></p>\r\n<ul>\r\n<li>绕 z 轴</li>\r\n</ul>\r\n<p><img src=\"/imgs/SpringBoss/rotationZ.png\"></p>\r\n<h4 id=\"欧拉角旋转顺序\">欧拉角旋转顺序</h4>\r\n<p>因为不同轴旋转相乘得到变换矩阵不同。</p>\r\n<ul>\r\n<li>外旋和内旋<br />\r\n假定一组旋转顺序 x-&gt;y-&gt;z 为内旋，则外旋为 z-&gt;x-&gt;y。<br />\r\n一组对应的外旋内旋结果是一样的。</li>\r\n</ul>\r\n<p><strong>Unity旋转顺序是ZXY</strong>。</p>\r\n<h3 id=\"位移\">位移</h3>\r\n<p><img src=\"/imgs/SpringBoss/translate.png\"></p>\r\n<h3 id=\"变换顺序\">变换顺序</h3>\r\n<p><img src=\"/imgs/SpringBoss/transform.png\"></p>\r\n<h2 id=\"给定-4x4-矩阵求缩放旋转平移矩阵\"><a\r\nhref=\"https://blog.csdn.net/qq_39300235/article/details/105790743\">给定\r\n4x4 矩阵，求缩放，旋转、平移矩阵</a></h2>\r\n<p>就以列矩阵为例解吧，因为大多都是列矩阵运算。<br />\r\n<strong>M=TRS</strong></p>\r\n<p><img src=\"/imgs/SpringBoss/4x4Matrix.png\"></p>\r\n<h3 id=\"t矩阵\">T矩阵</h3>\r\n<p>列矩阵最右侧就是 translate 变换</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">T[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">3</span>]=M[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">3</span>]/M[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">3</span>];  <br>T[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">3</span>]=M[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">3</span>]/M[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">3</span>];  <br>T[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">3</span>]=M[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">3</span>]/M[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">3</span>];  <br></code></pre></td></tr></table></figure>\r\n<h3 id=\"r矩阵\">R矩阵</h3>\r\n<p>之后我们对 M\r\n矩阵剔除平移变换，得到只有缩放和旋转的矩阵<em>M</em>。<br />\r\n此时 <em>M</em>=RS；<br />\r\n我们只要算出旋转矩阵就行了，因为 R\r\n可以用<strong>旋转矩阵的逆矩阵</strong>计算得到：</p>\r\n<p><img src=\"/imgs/SpringBoss/4x4Rn.png\"></p>\r\n<p>接下来要分解出 R 矩阵，我们利用 ”Polar\r\ndecomposition(极分解)“，可以证明矩阵<em>M</em>的极分解为 <u>旋转R</u> 和\r\n<u>缩放S</u> 。该方法通过对 <em>M</em>\r\n的逆的转置进行连续平均来计算，直到<strong>收敛</strong>，此时\r\n<em><strong>M</strong>i <strong>= R</strong></em>。</p>\r\n<p><img src=\"/imgs/SpringBoss/Polar.png\"></p>\r\n<p>当矩阵只有旋转变换时，旋转R 的转置和R的逆相等，达到收敛状态。<br />\r\n因为旋转矩阵为<strong>正交矩阵</strong>。Shoemake和Duff（1992）讨论了该级数收敛的证明，所得矩阵是最接近M的正交矩阵，这是理想的特性。为了计算该序列，我们迭代应用公式，直到连续项之间的差很小或执行了固定的迭代次数为止。\r\n实际上，该系列通常会很快收敛。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Float norm;  <br><span class=\"hljs-type\">int</span> count = <span class=\"hljs-number\">0</span>;  <br>Matrix4x4 R = M;  <br><span class=\"hljs-keyword\">do</span>  <br>&#123;  <br>    Matrix4x4 Rnext;  <br>    Matrix4x4 Rit = <span class=\"hljs-built_in\">Inverse</span>(<span class=\"hljs-built_in\">Transpose</span>(R));    <span class=\"hljs-comment\">// 转置的逆  </span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; ++i)  <br>    &#123;  <br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; ++j)  <br>        &#123;  <br>            Rnext.m[i][j] = <span class=\"hljs-number\">0.5f</span> * (R.m[i][j]+Rit.m[i][j]);  <br>        &#125;  <br>    &#125;  <br>    <span class=\"hljs-comment\">// compute the sub between Mi and Mi+1  </span><br>    norm = <span class=\"hljs-number\">0</span>;  <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; ++i)  <br>    &#123;  <br>        Float n = <span class=\"hljs-built_in\">abs</span>(R.m[i][<span class=\"hljs-number\">0</span>] - Rnext.m[i][<span class=\"hljs-number\">0</span>]) +  <br>            <span class=\"hljs-built_in\">abs</span>(R.m[i][<span class=\"hljs-number\">1</span>] - Rnext.m[i][<span class=\"hljs-number\">1</span>]) +  <br>            <span class=\"hljs-built_in\">abs</span>(R.m[i][<span class=\"hljs-number\">2</span>] - Rnext.m[i][<span class=\"hljs-number\">2</span>]);  <br>        norm = <span class=\"hljs-built_in\">max</span>(norm,n);  <br>    &#125;  <br>    R = Rnext;  <br>&#125;<span class=\"hljs-keyword\">while</span>(++count &lt; <span class=\"hljs-number\">100</span> &amp;&amp; norm &gt; <span class=\"hljs-number\">0.0001</span>) <span class=\"hljs-comment\">// 当迭代次数过多，或者连续项差距足够小，退出循环。  </span><br></code></pre></td></tr></table></figure>\r\n<h3 id=\"s矩阵\">S矩阵</h3>\r\n<p>得到 R 矩阵后 S矩阵就很简单</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">S = Matrix4x4::<span class=\"hljs-built_in\">Mul</span>(<span class=\"hljs-built_in\">Inverse</span>(R),M);  <br></code></pre></td></tr></table></figure>\r\n<h3 id=\"另外一种办法\">另外一种办法</h3>\r\n<p>我们可以对3x3矩阵的每个列向量求长度，这样就知道每个坐标轴分量上的缩放，最终得到缩放矩阵，然后再根据缩放矩阵求旋转矩阵即可。</p>\r\n<h2 id=\"mvp矩阵\">MVP矩阵</h2>\r\n<h3 id=\"model\">Model</h3>\r\n<p>把顶点坐标从局部空间变换到全局空间。</p>\r\n<ul>\r\n<li><p>行矩阵 <img src=\"/imgs/SpringBoss/ModelRow.png\"></p></li>\r\n<li><p>列矩阵 <img src=\"/imgs/SpringBoss/ModelCol.png\"></p></li>\r\n</ul>\r\n<h3 id=\"view-matrix-推导\">View-Matrix 推导</h3>\r\n<p>在图形渲染中我们要把3D的场景渲染成一张2D的图片，而这张图片是从 Camera\r\n的视角出发，所以为了方便渲染我们做一个变换，把摄影机作为一个新的空间的原点，令摄影机观测方向为-z方向也就是我们常说的\r\n视图变换(Viewing Transform)。<br />\r\n我们对场景中的物体都进行这样一个变换就可以得到，观察空间下的物体的坐标信息，即以\r\nCamera 为原点，Camera 上方向为 y 轴，Camera 视线为 -z 轴，Camera 右侧为\r\nx轴的坐标空间下物体信息。<br />\r\n<strong>注意这里观察空间通常为右手系！而非和世界空间/模型空间所采用的左手系！</strong><br />\r\n<strong>接下来推导为列矩阵运算！</strong>\r\n这个变换主要分为两步一步是平移，一步是旋转。<br />\r\n设 Camera\r\n坐标为<img src=\"/imgs/SpringBoss/posE.png\" style=\"zoom:50%;\" ><br />\r\n则平移矩阵为<br />\r\n<img src=\"/imgs/SpringBoss/viewT.png\" style=\"zoom:50%\">\r\n现在我们把摄影机放到了原点位置，现在我们只需要把轴向调整即可。<br />\r\n<em>注意这里变换推导过程是先平移后旋转，和平时计算规定的 Transform 先\r\nscale 再 rotation最后 translate 的顺序不同。</em><br />\r\n我们假设 Camera up 方向矢量为 <em>t</em>，观察方向为 <em>g</em>，则其 x\r\n轴 <em>e</em> 为 <em>g</em>x<em>t</em>。<br />\r\n<img src=\"/imgs/SpringBoss/cameraETG.png\" style=\"zoom:50%\"><br />\r\n我们要让其轴向与 xyz\r\n轴对齐，因为现在只是把物体进行了移动，坐标信息的基础轴还是世界坐标系而非\r\ncamera坐标系的三轴。<br />\r\n我们只需把\r\n<code>t-&gt;y</code>,<code>g-&gt; -z</code>,<code>e-&gt;x</code> 其中\r\n<code>e = gxt</code>。<br />\r\n这样虽然可以进行计算，但是十分复杂。<br />\r\n我们观察到\r\n既然TEG是坐标轴，就意味着他们三者垂直，点积为零，可以构成正交矩阵。<br />\r\n那么 <code>t-&gt;y</code>,<code>g-&gt; -z</code>,<code>e-&gt;x</code>\r\n的逆变换\r\n<code>y-&gt;t</code>,<code>-z -&gt;g</code>,<code>x-&gt;e</code>\r\n是很好计算的。<br />\r\n而我们知道了逆矩阵，就可以知道正交矩阵的原矩阵。<br />\r\n正交矩阵性质:\r\n<img src=\"/imgs/SpringBoss/orthM.png\" style=\"zoom:80%\"></p>\r\n<p>所以 <img src=\"/imgs/SpringBoss/Rview.png\" style=\"zoom:80%\"></p>\r\n<p>最后 <img src=\"/imgs/SpringBoss/Mview.png\" style=\"zoom:80%\"></p>\r\n<h3 id=\"projection-matrix\">Projection Matrix</h3>\r\n<p>我们现在已经放好了物体，也以 Camera 的角度出发了，现在我们要从\r\n<strong>View space( 观察空间 )</strong> 到 <strong>Clip Space(\r\n裁剪空间/齐次裁剪空间 )</strong></p>\r\n<h4\r\nid=\"我们这里先考虑把深度归到01的情况\">我们这里先考虑把深度归到[0,1]的情况</h4>\r\n<p>要把 <strong>View\r\n空间</strong>的点投影到<strong>屏幕</strong>上，利用相似三角形原理，\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\frac{x_{screen}}{near}&amp;=\\frac{x_{view}}{z_{view}}\\\\\r\nx_{screen}&amp;=\\frac{x_{view}\\cdot near}{z_{view}}\\\\\r\ny_{screen}&amp;=\\frac{y_{view}\\cdot near}{z_{view}}\\\\\r\n\\end{aligned}\r\n\\]</span> 但是实际上我们是先把 <em>X,Y</em> 坐标变换到[-1,1]后映射到\r\nScreen的，所以还得改成<br />\r\n将所有顶点映射到[-1,1]是为了方便 GPU 计算 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;x_{screen}=\\frac{x_{view}\\cdot near}{z_{view}}&amp;\\in[-wid,wid]\\\\\r\n&amp;y_{screen}=\\frac{y_{view}\\cdot\r\nnear}{z_{view}}&amp;\\in[-height,height]\\\\\r\n&amp;x_{ndc}=\\frac{x_{view}\\cdot near}{z_{view}\\cdot wid}&amp;\\in\r\n[-1,1]\\\\\r\n&amp;y_{ndc}=\\frac{y_{view}\\cdot near}{z_{view}\\cdot height}&amp;\\in\r\n[-1,1]\\\\\r\n\\end{aligned}\r\n\\]</span> 所以我们现在知道如何对 x,y 坐标进行变换了，Project Matrix\r\n暂时可以写成这样， 因为 z,w 不受 x,y 影响 <span class=\"math display\">\\[\r\n\\begin{bmatrix}\r\n\\frac{near}{z_p\\cdot wid}&amp;0&amp;0&amp;0\\\\\r\n0&amp;\\frac{near}{z_p\\cdot height}&amp;0&amp;0\\\\\r\n0&amp;0&amp;A&amp;B\\\\\r\n0&amp;0&amp;C&amp;D\\\\\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nx_p\\\\\r\ny_p\\\\\r\nz_p\\\\\r\n1\\\\\r\n\\end{bmatrix}\r\n\\]</span></p>\r\n<p>而 z 值有些不一样，现在的问题是</p>\r\n<ul>\r\n<li>“我们的矩阵 <em>X,Y 坐标</em> 的变换矩阵和 <u>z值相关</u>”，<br />\r\n这肯定不是我们希望看到的，这不利于 GPU 计算，</li>\r\n<li>而且为了实现深度测试我们还希望可以将深度值归化到[0,1]，</li>\r\n</ul>\r\n<p>对于<strong>第一个问题</strong>，既然 <em>X,Y 坐标</em> 都要除 View\r\nSpace 的 <em>Z</em> 坐标值，<br />\r\n那么我们不妨把这个除法操作在后面统一执行，也就是\r\n<strong>齐次除法</strong>，<br />\r\n所以我们需要在做这个除法操作时能得到 <em>Z</em>\r\n坐标值，而恰巧我们可以利用 <em>W 分量</em><br />\r\n我们可以先把 <em>Z</em> 坐标轴存在 W 分量，即 <span\r\nclass=\"math display\">\\[\r\n\\begin{bmatrix}\r\n\\frac{near}{wid}&amp;0&amp;0&amp;0\\\\\r\n0&amp;\\frac{near}{height}&amp;0&amp;0\\\\\r\n0&amp;0&amp;A&amp;B\\\\\r\n0&amp;0&amp;1&amp;0\\\\\r\n\\end{bmatrix}\r\n\\]</span></p>\r\n<p><u>因为View Space 是右手系的所以……z值不是正的</u></p>\r\n<p><strong>第二个问题</strong>，而对于 <em>Z</em> 值 原本范围是 [-far,\r\n-near] -&gt; [?, ?] -&gt; [0,1] <span class=\"math display\">\\[\r\n[-far,-near]\\rightarrow[?,?]\\stackrel{/z}{\\rightarrow}[0,1]\r\n\\]</span> 所以我们对 -near 和 -far 两个边界条件\r\n列方程，因为是[0,1]在加上齐次除法所以near为0，far为far <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    -A\\cdot near+B=0\\\\\r\n    -A\\cdot far+B=far\\\\\r\n    A=\\frac{far}{near-far}\\\\\r\n    B=\\frac{near\\cdot far}{near-far}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>得到 <span class=\"math display\">\\[\r\n\\begin{bmatrix}\r\n\\frac{near}{wid}&amp;0&amp;0&amp;0\\\\\r\n0&amp;\\frac{near}{height}&amp;0&amp;0\\\\\r\n0&amp;0&amp;\\frac{far}{near-far}&amp;\\frac{near\\cdot far}{near-far}\\\\\r\n0&amp;0&amp;1&amp;0\\\\\r\n\\end{bmatrix}\r\n\\]</span> 从裁剪空间到NDC需要一次齐次除法</p>\r\n<h4 id=\"think-但可能不对\">think 但可能不对</h4>\r\n<p>齐次变换(仿射变换)的 W分量 对于一个点来说，可以表示变换的“距离\",\r\n比如用矩阵平移 点(x,y,z) 距离(1,1,1)<br />\r\n如果把W=2，再W 归一得到的是(x/2+0.5, y/2+0.5, z/2+0.5),<br />\r\n如果有若干多个点，这样做，相当于一种投影，而投影点集前后，点集之间相对当前\r\nW 分量的点集关系不会改变，比如两个点之前相聚(a,b,c)， 除2后就是\r\n(a/2,b/2,c/2)<br />\r\n挺有意思但没啥用好像。</p>\r\n<h2 id=\"tbn-矩阵\">TBN 矩阵</h2>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/412555049\">TBN矩阵不错的Blog</a></p>\r\n<h2\r\nid=\"d平面三角形给出算法生成三角形内随机一点\">2D平面三角形，给出算法，生成三角形内随机一点</h2>\r\n<p>https://www.cnblogs.com/TenosDoIt/p/4025221.html</p>\r\n<h2 id=\"前向渲染和延迟渲染\">前向渲染和延迟渲染</h2>\r\n<p>https://zhuanlan.zhihu.com/p/28489928</p>\r\n<h2 id=\"lut-表\">LUT 表</h2>\r\n<p>https://www.jianshu.com/p/fdec2a5e889f</p>\r\n<h2 id=\"描边效果\">描边效果</h2>\r\n<p>边缘检测</p>\r\n<h2 id=\"为什么要有光线追踪\">为什么要有光线追踪</h2>\r\n<ol type=\"1\">\r\n<li>传统光栅化做阴影效果不好，操作困难<br />\r\n</li>\r\n<li>物体的模糊反射，比如毛玻璃一般的反射即 Glossy\r\nReflection，光线打到Glossy物体在反射<br />\r\n</li>\r\n<li>间接光照(Indirect illumination)，光线在进入人眼前弹射不止一次</li>\r\n</ol>\r\n<p>这种光线弹射，对于光栅化来说想要实现比较麻烦，而且也不能保证物理上的正确性。光栅化本质上是一种快速的近似质量较低。<br />\r\n光线追踪是一种比较准确的办法质量很高，但是最大的问题就是很慢。</p>\r\n<h2 id=\"包围盒bvh\">包围盒BVH</h2>\r\n<h3 id=\"如何划分bvh\">如何划分BVH</h3>\r\n<p>1.随机选取一个维度</p>\r\n<p>2.选Bounding box中最长的轴进行进一步划分</p>\r\n<p>3.选取中间的三角形处进行划分（以保证两边三角形数量接近）。</p>\r\n<p>5.基于表面积的启发式评估划分方法（Surface Area\r\nHeuristic，SAH），这种方法通过对求交代价和遍历代价进行评估，给出了每一种划分的代价（Cost），寻找代价最小方式进行划分。</p>\r\n<p>6.基于莫顿码（Morton code）的并行化BVH构建。</p>\r\n<h4 id=\"参考学习记得学啊\">参考学习！记得学啊！</h4>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/50720158\">PBRT-E4.3-层次包围体(BVH)（一）\r\n- 玉米的文章 - 知乎</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/54620381\">PBRT-E4.3-层次包围体(BVH)（二）\r\n- 玉米的文章 - 知乎</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/54694041\">PBRT-E4.3-层次包围体(BVH)（三）\r\n- 玉米的文章 - 知乎</a><br />\r\n<a\r\nhref=\"https://www.cnblogs.com/silence394/p/17285231.html\">【空间加速结构】——层次包围体BVH（Bounding\r\nVolume Hierachies） - silence394 - 博客园</a><br />\r\n<a\r\nhref=\"https://box2d.org/files/ErinCatto_DynamicBVH_GDC2019.pdf\">Dynamic\r\nAABB Trees</a></p>\r\n<h2 id=\"渲染管线\">渲染管线</h2>\r\n<p>一般就说说大概的流程\r\nIA-&gt;VS-&gt;Hull-&gt;TS-&gt;Domain-&gt;GS-&gt;OS-&gt;RS-&gt;PS-&gt;OM</p>\r\n<h3 id=\"什么是曲面细分着色器\">什么是曲面细分着色器</h3>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/chenglixue/p/17227713.html\">大体介绍了一下曲面细分</a></p>\r\n<h2 id=\"透明效果\">透明效果</h2>\r\n<h1 id=\"球谐函数\">球谐函数</h1>\r\n<h2 id=\"雾效\">雾效</h2>\r\n<h1 id=\"重要性采样\">重要性采样</h1>\r\n<h2 id=\"阴影\">阴影</h2>\r\n<p>LightMap</p>\r\n<p>ShadowMapping</p>\r\n<p>PCF</p>\r\n<p>PCSS</p>\r\n<p>VSSM</p>\r\n<h3 id=\"csm如何做的\">CSM如何做的？</h3>\r\n<p>Cascaded Shadow\r\nMaps(CSM)方法根据对象到观察者的距离提供不同分辨率的深度纹理来解决上述问题。它将相机的视锥体分割成若干部分，然后为分割的每一部分生成独立的深度贴图。对于近处的场景使用较高分辨率的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用。</p>\r\n<h2 id=\"两个多边形如何判断相交\">两个多边形如何判断相交</h2>\r\n<p>https://blog.csdn.net/StevenKyleLee/article/details/88075814</p>\r\n<h3 id=\"一点是否在多边形内\">一点是否在多边形内</h3>\r\n<p>https://blog.csdn.net/StevenKyleLee/article/details/88044589</p>\r\n<p>一般用射线法这里说一下特殊情况：<br />\r\n<img src=\"/imgs/SpringBoss/RayPointSpe.png\" style=\"zoom:100%;\" ><br />\r\n这里的(b)因为中间那个顶点左右两条边都在该顶点的上侧，所以该顶点不识为于射线相交。<br />\r\n具体的判定过程应该可以根据多边形绕向找相邻点进行判断。</p>\r\n<p><a\r\nhref=\"https://blog.csdn.net/WilliamSun0122/article/details/77994526\">除射线法外的其他方法</a></p>\r\n<h2 id=\"taatemporal-anti-aliasing\">TAA(temporal anti-aliasing)</h2>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/64993622\">TAA in DX12</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/147567747\">快速理解Tone\r\nMapping</a><br />\r\n<a href=\"http://www.ownself.org/blog/2011/tone-mapping.html\">Tone\r\nMapping</a><br />\r\n<a href=\"https://www.cnblogs.com/crazii/p/7244300.html\">TAA GHOSTING\r\n的相关问题</a><br />\r\nTone Mapping\r\n是HDR算法的一部分，是用来将渲染出的场景亮度域映射到一个合理的亮度域空间。</p>\r\n<blockquote>\r\n<p>然后值得一提的是TAA在管线中的位置，虚幻的TAA是放在其它的后处理之前的，这么可以防止其它后处理出现的闪烁，但是因为高光很容易闪，我们又希望能在低动态范围处理，所以这里虚幻选择的是先tonemap，再算超采样，最后逆tonemap输出，去做其他的后处理。</p>\r\n</blockquote>\r\n<p>这里是说如果不做ToonMapping把HDR压倒LDR做TAA，因为HDR范围比LDR，然后TAA在混合在一起就会“亮的很花”，所以先Toon\r\nMapping到LDR做一下TAA在\r\n逆Toonmap输出，这样还得到了抗锯齿的输出，后处理做的更好了。这里的HDR和Toonmap我思考了很久，因为我没明白Toonmap，toonmap就是把hdr变成ldr，hdr虽然表示了更多的颜色，但是我们在屏幕空间显示还是0~1，所以要做映射，直接线性映射不行，因为人对暗部感知明显，而且自然界比LDR亮度大得多，所以我们做了很多调整。</p>\r\n<h3 id=\"颜色ldr和hdr\">颜色LDR和HDR</h3>\r\n<p><a href=\"https://www.jianshu.com/p/fdec2a5e889f\">LUT简述</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/80253409\">HDR和Tone\r\nMapping</a></p>\r\n<h3 id=\"几何走样和着色走样\">几何走样和着色走样</h3>\r\n<ul>\r\n<li><strong>几何走样：</strong>几何覆盖函数采样不足，即俗称的边缘锯齿，一般发生在<strong>光栅化阶段</strong>。<br />\r\n</li>\r\n<li><strong>着色走样：</strong>渲染方程的采样不足，因为<em>渲染方程也是连续函数</em>，对某些部分在<em>空间变化较快（高频部分）采样不足也会造成走样</em>，反映在视觉上一般是图像闪烁或噪点，这类走样称之为着色走样，一般发生在<strong>各种着色阶段</strong>。</li>\r\n</ul>\r\n<h2 id=\"z-fighting\">Z-fighting</h2>\r\n<h2 id=\"景深\">景深</h2>\r\n<p>所谓景深就是照片背景的虚化程度，规律是：光圈越大，景深越浅，背景越模糊；光圈越小，景深越深，背景越清晰。<br />\r\n<a\r\nhref=\"http://www.ownself.org/blog/2010/jing-shen-depth-of-field.html\">景深</a></p>\r\n<h2 id=\"点到三角形距离\">点到三角形距离</h2>\r\n<p>https://zhuanlan.zhihu.com/p/148511581<br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/148511581\">点到三角形面距离</a></p>\r\n<h2 id=\"pbr\">PBR</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/poem_qianmo/article/details/85239398\">【基于物理的渲染（PBR）白皮书】（一）\r\n开篇：PBR核心知识体系总结与概览</a></p>\r\n<h2 id=\"材质系统\">材质系统</h2>\r\n<p>材质系统了解、实现。</p>\r\n<h1 id=\"计组部分\">计组部分</h1>\r\n<h3 id=\"大端和小端模式\">大端和小端模式</h3>\r\n<p>https://blog.csdn.net/wei_cheng18/article/details/79856207</p>\r\n<ul>\r\n<li><strong>大端</strong>（Big_endian）字数据的<strong>高字节</strong>存储在<strong>低地址</strong>中，字数据的<strong>低字节</strong>存储在<strong>高地址</strong>中。<br />\r\n</li>\r\n<li><strong>小端</strong>（Little_endian）字数据的<strong>高字节</strong>存储在<strong>高地址</strong>中，字数据的<strong>低字节</strong>存储在<strong>低地址</strong>中。</li>\r\n</ul>\r\n<h3 id=\"cache-命中率\">Cache 命中率</h3>\r\n<h1 id=\"计网\">计网</h1>\r\n<h2 id=\"tcp\">TCP</h2>\r\n<h3 id=\"tcp三次握手\"><a\r\nhref=\"https://blog.csdn.net/jun2016425/article/details/81506353\">TCP三次握手</a></h3>\r\n<ul>\r\n<li>第一次握手：客户端向服务器发起链接请求<br />\r\n</li>\r\n<li>第二次握手：服务器向客户端返回，发送答应客户端请求的确认信息。<br />\r\n</li>\r\n<li>第三次握手：客户端向服务器，告诉服务器已经收到第二次握手的确认信息。</li>\r\n</ul>\r\n<h4\r\nid=\"tcp的三次握手过程为什么会采用三次握手若采用二次握手可以吗\">TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h4>\r\n<p>答：建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。</p>\r\n<p>（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。</p>\r\n<p>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。</p>\r\n<p>（3）采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况，因此采用三次握手刚刚好，两次可能出现失效，四次甚至更多次则没必要，反而复杂了</p>\r\n<h3 id=\"四次挥手\">四次挥手</h3>\r\n<ul>\r\n<li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，<strong>主动方：“我不会再给你数据了。”</strong><br />\r\n</li>\r\n<li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1，<strong>被动方：“我知道了！”</strong><br />\r\n</li>\r\n<li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，<strong>被动方：”我的数据也发送完了，不会再给你发数据了。“</strong><br />\r\n</li>\r\n<li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，<strong>主动方：“行了，那我知道了，一切结束”</strong></li>\r\n</ul>\r\n<h1 id=\"编译原理\">编译原理</h1>\r\n<h2 id=\"逆波兰式\"><a\r\nhref=\"https://blog.csdn.net/weixin_43919932/article/details/103327530\">逆波兰式</a></h2>\r\n<p>https://www.cnblogs.com/tangqs/archive/2012/05/18/2507708.html<br />\r\n如果是右单目运算符，直接入存储器栈；比如 阶乘！与百分号%</p>\r\n<h1 id=\"os\">OS</h1>\r\n<h2 id=\"进程和线程\">进程和线程</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/ThinkWon/article/details/102021274\">进程和线程</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/qq_33182418/article/details/121135914\">线程调度</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/qq_41784433/article/details/122194695\">进程/作业调度</a></p>\r\n<h3 id=\"多线程比单线程慢\">多线程比单线程慢</h3>\r\n<p>存在上下文切换和死锁问题。<br />\r\nhttps://www.cnblogs.com/xrq730/p/5186609.html</p>\r\n<h2 id=\"linux-进程通讯\">Linux 进程通讯</h2>\r\n<p>https://blog.csdn.net/qq_44443986/article/details/115065540</p>\r\n<h2 id=\"死锁和银行家算法\">死锁和银行家算法</h2>\r\n<p>https://blog.csdn.net/wyf2017/article/details/80068608</p>\r\n<h2\r\nid=\"什么是内存碎片内存碎片是在虚拟内存还是物理内存\">什么是内存碎片，内存碎片是在虚拟内存还是物理内存？</h2>\r\n<p>采用分区式存储管理的系统，在储存分配过程中产生的、不能供用户作业使用的主存里的小分区称成“内存碎片”。内存碎片分为内部碎片和外部碎片。内存碎片只存在于虚拟内存上。</p>\r\n<h1 id=\"概率论\">概率论</h1>\r\n<h2 id=\"期望计算和带保底卡池期望计算\">期望计算和带保底卡池期望计算</h2>\r\n<h1 id=\"算法\">算法</h1>\r\n<h2 id=\"lru手撸\">LRU手撸</h2>\r\n<p>https://leetcode.cn/problems/lru-cache-lcci/</p>\r\n<p>LRU算法还有进化版LFU算法</p>\r\n<h2 id=\"双端队列\">双端队列</h2>\r\n<p>一个能用队列和栈实现的增删查改都是O(1)的数据结构，是什么<br />\r\n这个能用队列和栈实现的增删查改都是O(1)的数据结构是双端队列（deque）[<a\r\nhref=\"https://zh.wikipedia.org/wiki/队列#双端队列\">1</a>]。双端队列不仅支持在队列的一端进行入队和出队操作，也支持在队列的另一端进行插入和删除操作。因此，在使用双端队列时，可以根据具体的需求选择在队列的哪一端进行操作，从而实现了增删查改都是O(1)的效率。</p>\r\n<h3 id=\"双端队列定义\">双端队列定义</h3>\r\n<p>能在队列两端进行入队、出队操作。</p>\r\n<h2 id=\"统计子树中城市之间最大距离\">统计子树中城市之间最大距离</h2>\r\n<p>https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/submissions/412418189/</p>\r\n<h2 id=\"a算法\">A*算法</h2>\r\n<p>https://zhuanlan.zhihu.com/p/54510444</p>\r\n<h2 id=\"岛屿问题\">岛屿问题</h2>\r\n<p>https://leetcode.cn/problems/number-of-islands/solutions/13103/dao-yu-shu-liang-by-leetcode/</p>\r\n<h2 id=\"top-k-问题\">Top K 问题</h2>\r\n<p>https://zhuanlan.zhihu.com/p/64627590</p>\r\n<h1 id=\"c-和-unity\">C# 和 Unity</h1>\r\n<p><a\r\nhref=\"https://blog.csdn.net/qq_21407523/article/details/108814300\">CSDN不错的面试总结-2022年Unity面试题分享\r\n| 全面总结 | 建议收藏</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/554529423\">知乎上五尘的Unity面试题</a></p>\r\n<h2 id=\"协程\">协程</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/w2009211777/article/details/125514898\">总结：协程与线程</a></p>\r\n<h2\r\nid=\"请简述gc垃圾回收产生的原因并描述如何避免\">请简述GC（垃圾回收）产生的原因，并描述如何避免？</h2>\r\n<p>GC回收堆上的内存避免：1.减少new产生对象的次数2.使用公用的对象（静态成员）3.将String换为StringBuilder</p>\r\n<h2 id=\"c指针和c的引用\">C++指针和C#的引用</h2>\r\n<p><a\r\nhref=\"https://zhuanlan.zhihu.com/p/389422617\">c++引用和c#引用类型的区别</a></p>\r\n<h2 id=\"反射\">反射</h2>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/wangshenhe/p/3256657.html\">[整理]C#反射(Reflection)详解</a><br />\r\n<a\r\nhref=\"https://www.cnblogs.com/shahdza/p/12261831.html\">【Unity|C#】基础篇(12)——反射（Reflection）（核心类：Type、Assembly）</a></p>\r\n<ul>\r\n<li><p>反射的定义：审查元数据并收集关于它的类型信息的能力。元数据（编译以后的最基本数据单元）就是一大堆的表，当编译程序集或者模块时，编译器会创建一个类定义表，一个字段定义表，和一个方法定义表等。</p></li>\r\n<li><p>.NET的应用程序由几个部分：<strong>程序集（Assembly）、模块（Module）、类型（class）组成</strong>。</p></li>\r\n</ul>\r\n<h2 id=\"工厂模式\">工厂模式</h2>\r\n<p>https://wittykyrie.github.io/posts/Factor-Pattern/<br />\r\n<a\r\nhref=\"https://blog.csdn.net/cxy_zxl/article/details/116695023\">简单工厂模式、工厂方法模式优缺点</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/83535678\">C++\r\n深入浅出工厂模式（初识篇）</a></p>\r\n<h3 id=\"抽象工厂模式\">抽象工厂模式</h3>\r\n<p>https://blog.csdn.net/m0_46502538/article/details/120343296</p>\r\n<h2 id=\"ugui-如何实现ui物体淡入淡出\">UGUI 如何实现UI物体淡入淡出?</h2>\r\n<ul>\r\n<li>Text，Image这些组件都有继承Graphic类，这个类提供了CrossFadeAlpha()方法，可以做透明度渐变。<br />\r\n</li>\r\n<li>但如果界面东西多了，要获取每个Graphic是挺麻烦了。其实还有一个很简便的方法，用起来跟NGUI差不多。就是CanvasGruop组件，把这个组件放到界面根节点上，对这个组件的alpha做改变就行了。看看官方文档的解释，</li>\r\n</ul>\r\n<h2 id=\"esc-框架\">ESC 框架</h2>\r\n<p>https://blog.codingnow.com/2017/06/overwatch_ecs.html</p>\r\n<p>ECS 的 E ，也就是 Entity ，可以说就是传统引擎中的 Game Object\r\n。但是是 C 的整合其实。</p>\r\n<p>C 和 S 是这个框架的核心。System\r\n系统，也就是我上面提到的模块。每个模块应该专注于干好一件事，而每件事要么是作用于游戏世界里同类的一组对象的每单个个体的，要么是关心这类对象的某种特定的交互行为。比如碰撞系统，就只关心对象的体积和位置，不关心对象的名字，连接状态，音效、敌对关系等。</p>\r\n<p>每个可能单独使用的对象属性归纳为一个个 Component\r\n，比如对象的名字就是一个 Component ，对象的位置状态是另一个 Component\r\n。</p>\r\n<h2 id=\"unity的委托是什么-event-关键字有什么用\">unity的委托是什么? event\r\n关键字有什么用？</h2>\r\n<p>委托是一个容器，可以放函数对象，并且可以触发委托面的每个函数调用。委托主要用户回调函数。如果在外部给委托变量加函数进来，那么委托要定义成public,\r\n这样做又有一个问题，public外部的人也可以触发这个委托，如果我希望设计成外部可以加回调，但是只能是模块内部触发委托，那么我可以加一个event来修饰，这样虽然是public,但是外部无法触发委托,只能类的内部触发。</p>\r\n<h1 id=\"dx12\">DX12</h1>\r\n<p>DX12和</p>\r\n<h1 id=\"vulkan\">Vulkan</h1>\r\n<p><a\r\nhref=\"https://geek-docs.com/vulkan/vulkan-tutorial/vulkan-tutorial-index.html\">vulkan教程</a></p>\r\n<h2\r\nid=\"vulkan和dx12相比opengl好在哪里\">Vulkan和DX12相比OpenGL好在哪里？</h2>\r\n<h1 id=\"unity\">Unity</h1>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/585164814\">unity 八股文\r\n实时更新</a></p>\r\n<h2 id=\"unityupdate\">UnityUpdate</h2>\r\n<p><img src=\"/imgs/SpringBoss/unityUpdate.jpg\"></p>\r\n<h2 id=\"unity-ugui不规则区域点击问题\">Unity UGUI不规则区域点击问题</h2>\r\n<p>https://www.cnblogs.com/msxh/p/9283266.html</p>\r\n<h2\r\nid=\"当一个细小的高速物体撞向另一个较大的物体时会出现什么情况如何避免\">当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？</h2>\r\n<p>碰撞检测失败，会直接穿透</p>\r\n<p>避免方法：<br />\r\n（1）增大细小物体的碰撞体（不建议这样做）<br />\r\n（2）使用射线检测，检测他们之间的距离<br />\r\n（3）FixedUpdate频率修改，可以physics time减小（同样不建议）<br />\r\n（4）改变物体的速度（废话）<br />\r\n（5）将检测方式改为连续检测，rigifdbody.collisionDetectionMode\r\n=CollisionDetectionMode.Continuous;<br />\r\n或者是动态连续检测（CollisionDetectionMode.ContinuousDynamic）<br />\r\n（6）代码限制，加大计算量 提前计算好下一个位置</p>\r\n<h2 id=\"canvas-有几种模式如何配置\"><a\r\nhref=\"https://blog.csdn.net/weixin_42352178/article/details/109034679\">Canvas\r\n有几种模式，如何配置？</a></h2>\r\n<p>Canvas的三种渲染模式：</p>\r\n<ul>\r\n<li>Screen\r\nSpace-Overlay（屏幕空间-覆盖模式）UI元素的位置坐标是屏幕空间的坐标，Overlay模式下画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层。如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕。<br />\r\n</li>\r\n<li>Screen\r\nSpace-Camera（屏幕空间-摄影机模式）UI元素的位置坐标是屏幕空间的坐标，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。所不同的是，在该模式下，画布会被放置到摄影机前方。在这种渲染模式下，画布看起来绘制在一个与摄影机固定距离的平面上。所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。<br />\r\n此时，画布上的UI组件会随视角移动。<br />\r\n</li>\r\n<li>World\r\nSpace即世界空间模式，此模式下UI元素的位置坐标是世界空间的坐标。画布作为场景中的一部分被固定显示在场景中，显示效果类似Plane组件。</li>\r\n</ul>\r\n<h2 id=\"unity-渲染队列\">Unity 渲染队列</h2>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 5%\" />\r\n<col style=\"width: 80%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>Name</th>\r\n<th>ID</th>\r\n<th>Description</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>Background</td>\r\n<td>1000</td>\r\n<td>会在任何其他队列前渲染，渲染需要绘制在背景上的物体</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Geometry</td>\r\n<td>2000</td>\r\n<td>默认的渲染队列，大部分物体都使用这个队列，不透明物体一般使用这个队列</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>AlphaTest</td>\r\n<td>2450</td>\r\n<td>需要进行透明测试的物体</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>Transparent</td>\r\n<td>3000</td>\r\n<td>在 Geometry 和 AlphaTest\r\n后，<strong>从后向前</strong>地渲染，任何使用透明混合的物体都使用此队列</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>Overlay</td>\r\n<td>4000</td>\r\n<td>该队列用于实现叠加效果，任何需要最后渲染的物体都使用此队列。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"游戏动画\">游戏动画</h2>\r\n<h3 id=\"关节动画\">关节动画</h3>\r\n<h3 id=\"单一网格动画\">单一网格动画</h3>\r\n<h3 id=\"骨骼动画\">骨骼动画</h3>\r\n<h2 id=\"unity中ugui如何打包成图集\">unity中UGUI如何打包成图集?</h2>\r\n<p><a\r\nhref=\"https://www.zhihu.com/question/472146051/answer/2011067756\">unity中UGUI如何打包成图集?\r\n- 鲨鱼辣椒的回答 - 知乎</a></p>\r\n<ul>\r\n<li>开启UGUI的图集模式, Editor-&gt;Project Settings 下面有sprite\r\npacker的模式。<br />\r\n</li>\r\n<li>为每个UI图片制定要打入的图集的tag名字。<br />\r\n</li>\r\n<li>打包生成图集Window ------&gt;Sprite Packer,\r\n点击Pack即可打包生成图集。</li>\r\n</ul>\r\n<h2 id=\"build-in-rp和srp\">Build-IN RP和SRP</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/weixin_41622043/article/details/107623694\">Unity\r\nSRP URP HDRP 的区别</a></p>\r\n<h2 id=\"srp\">SRP</h2>\r\n<p><a href=\"https://unity.com/cn/srp\">Unity官方宣传</a></p>\r\n<h3 id=\"srp-batcher\">SRP Batcher</h3>\r\n<p><a\r\nhref=\"https://blog.unity.com/cn/technology/srp-batcher-speed-up-your-rendering\">SPR\r\nBatcher 官方简介</a></p>"},{"title":"关于 SRP Batcher","math":true,"index_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","banner_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","date":"2025-02-22T06:05:36.000Z","typora-root-url":"../","_content":"\n关于 SRP Batcher 的理解和内容\n\n# 关于 SRP Batcher\n\n## Shader 和 Material\n\n首先我们得对 Shader 和 Material 以及渲染过程有一个基础的了解。\n\n* Shader：运行在 **GPU** 上的一段程序，\n  将输入的 Mesh 和 Texture 以及 其他 Properties 进行计算，然后输出结果。\n  <font color= #999999>当然也有利用 GPU 并行能力计算的 Computer Shader 主要是做数据计算和处理，比如计算 LUT，或者滤波、图像处理等等，这个不是本文重点。</font>\n* Material：描述(存储) 模型/物体 表面细节信息的资源。\n  定义外观属性 Color，Tex，Smoothness……可以看作是对 Shader的实例。\n\n材质可以看作是一个配置Shader属性数值的面板。通过修改材质球里的属性数值，实际上就是在修改Shader的属性数值。\n当我们创建一个材质时，我们实际上是在创建一个Shader的实例。这个实例包含了Shader的所有属性，并且我们可以为这些属性提供具体的值。\n在Unity中，每个材质都关联了一个Shader。当我们将材质应用到一个物体上时，实际上是在告诉Unity使用这个材质所关联的Shader来渲染这个物体。\n\n## 简单的渲染过程\n\n就现在的设计，简单来讲渲染物体主要分为四个步骤：\n暂时用 DX 举例吧，我记不得太多了……\n\n1. **初始化**：\n\n   * **创建设备** (ID3D11Device) 和 **设备上下文**(ID3D11DeviceContext)，以及交换链管理 Front Buffer 和 Back Buffer\n\n     创建渲染视图并绑定到输出合并阶段。\n\n2. **设置渲染状态**：\n\n   * **定义顶点格式和输入布局**：根据需要渲染的几何体定义顶点结构，并创建相应的输入布局（`ID3D11InputLayout`）描述顶点数据的格式和语义。\n   * **创建顶点和索引缓冲区**：将几何体的顶点数据存储在顶点缓冲区（`ID3D11Buffer`）中，如果有重复顶点，可以使用索引缓冲区（`ID3D11Buffer`）来优化内存使用和渲染效率。\n   * **创建着色器**：编写顶点着色器（Vertex Shader）和像素着色器（Pixel Shader），并使用`D3DCompile`函数编译成字节码，然后创建着色器对象（`ID3D11VertexShader`和`ID3D11PixelShader`）\n\n3. **绘制调用**：\n\n   - **绑定着色器和常量缓冲区**：将顶点着色器、像素着色器和常量缓冲区绑定到渲染管线的相应阶段。\n   - **设置图元拓扑**：指定要渲染的图元类型，如三角形列表、线列表等。\n   - **设置混合状态、深度/模板状态等**：根据需要设置渲染管线的其他状态，如混合模式、深度测试和模板测试等。\n   - (可选)进行ClearRenderTargetView\n   - **绘制几何体**：使用`DrawIndexed`或`Draw`函数绘制几何体，根据索引缓冲区（如果有）或顶点缓冲区中的数据生成图元，\n   - 重复渲染过程。\n\n4. **结果展示**：\n\n   前后帧交替显示渲染结果\n\n###  一点关于dx的概念，不是很重要……\n\n* `ID3D11Device`接口，它用于创建资源和枚举显示适配器的功能，用以应用程序直接与图形硬件进行交互。\n\n* 设备上下文[^设备上下文]是设备的一个接口，用于设置管道状态、将资源绑定到图形管线和生成渲染命令。\n  设备上下文在`ID3D11DeviceContext`接口中实现，它提供了对图形管线的直接控制，允许应用程序执行各种渲染操作。\n  * **即时上下文（Immediate Context）**：即时上下文直接与图形硬件进行交互，它允许应用程序立即执行渲染命令。每个设备都有一个且只有一个即时上下文。\n  * **延迟上下文（Deferred Context）**：延迟上下文将渲染命令记录到命令列表中，它主要用于多线程渲染。延迟上下文可以由工作线程使用，而即时上下文通常由主线程使用\n\n### Draw Call\n\n**Draw Call** 是 CPU 调用图形 API（如 OpenGL 或 DirectX）命令 GPU 进行渲染的操作。具体来说，Draw Call 是 CPU 向 GPU 发送的绘制命令，告诉 GPU 如何渲染场景的一部分，包括使用哪些顶点、纹理、着色器等。\n\n### Draw Call 的工作原理\n\n1. **命令缓冲区**：为了实现 CPU 和 GPU 的并行工作，需要一个命令缓冲区（Command Buffer），它包含一个命令队列。CPU 向其中添加命令，GPU 从中读取命令并执行。\n2. **Draw Call 命令**：Draw Call 是 **Command Buffer 的一种命令**，用于告诉 GPU 进行绘制操作。除了 Draw Call，Command Buffer 中还有其他命令，如改变渲染状态等。\n3. **CPU 和 GPU 的交互**：CPU 通过图形 API 向命令缓冲区添加命令，GPU 从中读取命令并执行。当 CPU 需要渲染一个对象时，它会向命令缓冲区添加一个 Draw Call 命令，GPU 完成上一个渲染任务后，会从命令缓冲区中取出这个命令并执行。\n\n### 为什么 Draw Call 多了会影响帧率？\n\n1. **CPU 的准备工作**：在每次调用 Draw Call 之前，CPU 需要向 GPU 发送很多内容，包括数据、状态和命令等。CPU 需要完成很多准备工作，如数据准备，资源绑定，命令提交，检查渲染状态等。\n2. **GPU 的渲染能力**：GPU 的渲染能力很强，渲染速度往往快于 CPU 提交命令的速度。如果 Draw Call 的数量太多，CPU 就会把大量时间花费在提交 Draw Call 命令上，造成 CPU 的过载。\n   可以粗浅地理解为 DrawIndexed 或Draw函数就是一次 Draw Call\n3. **性能瓶颈**：由于 CPU 的准备工作和 GPU 的渲染能力不匹配，过多的 Draw Call 会导致 CPU 成为性能瓶颈，影响帧率。\n\n### 如何减少 Draw Call？\n\n1. **批处理（Batching）**：将多个小的 Draw Call 合并成一个大的 Draw Call，减少 CPU 提交 Draw Call 的次数和时间。\n   - **静态批处理**：适合静态物体，如不会移动的大地、石头等。将这些物体标记为静态，引擎会自动合并网格，减少 Draw Call。\n   - **动态批处理**：适合动态物体，引擎每帧都会重新合并网格，但限制较多，如顶点数和着色器复杂度等。\n2. **减少材质使用**：相同的材质会方便合并网格，减少 Draw Call。\n3. **GPU 实例化（GPU Instancing）**：将 mesh 信息存储在 GPU 内存缓冲区中，并进行渲染而无需额外的 Draw Call。\n4. **减少渲染状态切换**：改变渲染状态比渲染模型更耗时，尽量减少渲染状态切换。\n\n#### 渲染状态\n\n**改变渲染状态**是指在图形渲染过程中，通过设置或修改渲染器（如Direct3D或OpenGL）的各种参数，来控制渲染行为和效果的过程。这些参数通常被称为渲染状态，它们定义了渲染器在处理图形数据时的行为方式。\n\n##### 渲染状态的类型\n\n渲染状态有很多种，常见的包括：\n\n1. **填充模式（Fill Mode）**：决定多边形是被填充还是只绘制轮廓。例如，线框模式（Wireframe）只绘制多边形的边框，而实心模式（Solid）会填充整个多边形。\n2. **剔除模式（Cull Mode）**：决定是否剔除（不渲染）某些面。例如，可以设置为剔除背面（Backface Culling），只渲染正面的三角形。\n3. **深度测试（Depth Test）**：决定是否根据深度值（Z值）来决定是否更新像素的颜色。如果开启深度测试，只有当新像素的深度值小于当前像素的深度值时，才会更新像素的颜色。\n4. **混合模式（Blend Mode）**：决定如何将新像素的颜色与现有像素的颜色进行混合。例如，可以设置为Alpha混合，根据新像素的Alpha值来决定如何混合颜色。\n5. **模板测试（Stencil Test）**：决定是否根据模板缓冲区中的值来决定是否更新像素的颜色。模板缓冲区可以用于实现各种高级渲染效果，如阴影、轮廓等。\n6. **光照模式（Lighting Mode）**：决定是否使用光照计算，以及如何计算光照。\n7. **纹理过滤器（Texture Filter）**：决定如何对纹理进行采样和过滤，以获得更好的图像质量。例如，可以设置为线性过滤（Linear Filtering）或各向异性过滤（Anisotropic Filtering）\n\n## Unity And Material\n\n<img src=\"/imgs/关于SRP Batcher/OldMaterial.jpg\">\nCPU 收集 Material 信息，设置 CBUFFER\n\n## SRP Batcher\n\n<img src=\"/imgs/关于SRP Batcher/SRPPipeline.jpg\">\n在渲染循环里把材质信息保留在 GPU 内存中，只有材质内容改变才会重新 setup material data。\n在此流程中，CPU 仅负责处理内置引擎属性（如*对象矩阵变换*）。所有材质的 CBUFFER 均以持久化形式驻留在 GPU 内存中，随时可供调用。\n\n1. **材质数据持久化存储于 GPU 内存**，若材质内容未发生变更，则无需重复配置和上传缓冲区至 GPU，显著减少数据传输开销。\n2. **专用代码管理全局「按对象」GPU 常量缓冲区**，通过独立优化的代码路径，高效更新 GPU 中存储大规模对象相关数据（如内置属性）的 CBUFFER，进一步降低 CPU-GPU 通信负载。\n\n<img src=\"/imgs/关于SRP Batcher/SRPPipeline2.jpg\">\n左图为标准的 SRP（可编程渲染管线）渲染循环，右图为 SRP Batcher 的渲染循环。在 SRP Batcher 的机制中，一个“批次”仅由连续的 `Bind`（绑定资源）、`Draw`（绘制）、`Bind`、`Draw`... 等 GPU 命令序列构成。\n\n**SRP Batcher 的核心优化逻辑**：\n\n- **不减少 DrawCall 数量** SRP Batcher 并不会直接降低 DrawCall 的总数，其优化重点在于 **减少 DrawCall 之间的 GPU 资源设置开销**。\n- **通过持久化与批次合并降低开销** 借助材质数据在 GPU 内存中的持久化存储，以及针对同着色器变体的批次合并机制，大幅减少重复的资源绑定与状态切换操作，从而提升整体渲染效率。\n\n### 补充\n\n#### “Per Object” 变量\n\n<img src=\"/imgs/关于SRP Batcher/SRPPerObject.jpg\">\n\n## 关于\n\n* [^设备上下文]: [Direct3D 11 中的设备简介 - Win32 apps | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/overviews-direct3d-11-devices-intro)\n","source":"_posts/关于SRP Batcher.md","raw":"---\ntitle: 关于 SRP Batcher\nmath: true\ntags: [Unity,渲染]\nindex_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\nbanner_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\ndate: 2025-02-22 14:05:36\ntypora-root-url: ../\n---\n\n关于 SRP Batcher 的理解和内容\n\n# 关于 SRP Batcher\n\n## Shader 和 Material\n\n首先我们得对 Shader 和 Material 以及渲染过程有一个基础的了解。\n\n* Shader：运行在 **GPU** 上的一段程序，\n  将输入的 Mesh 和 Texture 以及 其他 Properties 进行计算，然后输出结果。\n  <font color= #999999>当然也有利用 GPU 并行能力计算的 Computer Shader 主要是做数据计算和处理，比如计算 LUT，或者滤波、图像处理等等，这个不是本文重点。</font>\n* Material：描述(存储) 模型/物体 表面细节信息的资源。\n  定义外观属性 Color，Tex，Smoothness……可以看作是对 Shader的实例。\n\n材质可以看作是一个配置Shader属性数值的面板。通过修改材质球里的属性数值，实际上就是在修改Shader的属性数值。\n当我们创建一个材质时，我们实际上是在创建一个Shader的实例。这个实例包含了Shader的所有属性，并且我们可以为这些属性提供具体的值。\n在Unity中，每个材质都关联了一个Shader。当我们将材质应用到一个物体上时，实际上是在告诉Unity使用这个材质所关联的Shader来渲染这个物体。\n\n## 简单的渲染过程\n\n就现在的设计，简单来讲渲染物体主要分为四个步骤：\n暂时用 DX 举例吧，我记不得太多了……\n\n1. **初始化**：\n\n   * **创建设备** (ID3D11Device) 和 **设备上下文**(ID3D11DeviceContext)，以及交换链管理 Front Buffer 和 Back Buffer\n\n     创建渲染视图并绑定到输出合并阶段。\n\n2. **设置渲染状态**：\n\n   * **定义顶点格式和输入布局**：根据需要渲染的几何体定义顶点结构，并创建相应的输入布局（`ID3D11InputLayout`）描述顶点数据的格式和语义。\n   * **创建顶点和索引缓冲区**：将几何体的顶点数据存储在顶点缓冲区（`ID3D11Buffer`）中，如果有重复顶点，可以使用索引缓冲区（`ID3D11Buffer`）来优化内存使用和渲染效率。\n   * **创建着色器**：编写顶点着色器（Vertex Shader）和像素着色器（Pixel Shader），并使用`D3DCompile`函数编译成字节码，然后创建着色器对象（`ID3D11VertexShader`和`ID3D11PixelShader`）\n\n3. **绘制调用**：\n\n   - **绑定着色器和常量缓冲区**：将顶点着色器、像素着色器和常量缓冲区绑定到渲染管线的相应阶段。\n   - **设置图元拓扑**：指定要渲染的图元类型，如三角形列表、线列表等。\n   - **设置混合状态、深度/模板状态等**：根据需要设置渲染管线的其他状态，如混合模式、深度测试和模板测试等。\n   - (可选)进行ClearRenderTargetView\n   - **绘制几何体**：使用`DrawIndexed`或`Draw`函数绘制几何体，根据索引缓冲区（如果有）或顶点缓冲区中的数据生成图元，\n   - 重复渲染过程。\n\n4. **结果展示**：\n\n   前后帧交替显示渲染结果\n\n###  一点关于dx的概念，不是很重要……\n\n* `ID3D11Device`接口，它用于创建资源和枚举显示适配器的功能，用以应用程序直接与图形硬件进行交互。\n\n* 设备上下文[^设备上下文]是设备的一个接口，用于设置管道状态、将资源绑定到图形管线和生成渲染命令。\n  设备上下文在`ID3D11DeviceContext`接口中实现，它提供了对图形管线的直接控制，允许应用程序执行各种渲染操作。\n  * **即时上下文（Immediate Context）**：即时上下文直接与图形硬件进行交互，它允许应用程序立即执行渲染命令。每个设备都有一个且只有一个即时上下文。\n  * **延迟上下文（Deferred Context）**：延迟上下文将渲染命令记录到命令列表中，它主要用于多线程渲染。延迟上下文可以由工作线程使用，而即时上下文通常由主线程使用\n\n### Draw Call\n\n**Draw Call** 是 CPU 调用图形 API（如 OpenGL 或 DirectX）命令 GPU 进行渲染的操作。具体来说，Draw Call 是 CPU 向 GPU 发送的绘制命令，告诉 GPU 如何渲染场景的一部分，包括使用哪些顶点、纹理、着色器等。\n\n### Draw Call 的工作原理\n\n1. **命令缓冲区**：为了实现 CPU 和 GPU 的并行工作，需要一个命令缓冲区（Command Buffer），它包含一个命令队列。CPU 向其中添加命令，GPU 从中读取命令并执行。\n2. **Draw Call 命令**：Draw Call 是 **Command Buffer 的一种命令**，用于告诉 GPU 进行绘制操作。除了 Draw Call，Command Buffer 中还有其他命令，如改变渲染状态等。\n3. **CPU 和 GPU 的交互**：CPU 通过图形 API 向命令缓冲区添加命令，GPU 从中读取命令并执行。当 CPU 需要渲染一个对象时，它会向命令缓冲区添加一个 Draw Call 命令，GPU 完成上一个渲染任务后，会从命令缓冲区中取出这个命令并执行。\n\n### 为什么 Draw Call 多了会影响帧率？\n\n1. **CPU 的准备工作**：在每次调用 Draw Call 之前，CPU 需要向 GPU 发送很多内容，包括数据、状态和命令等。CPU 需要完成很多准备工作，如数据准备，资源绑定，命令提交，检查渲染状态等。\n2. **GPU 的渲染能力**：GPU 的渲染能力很强，渲染速度往往快于 CPU 提交命令的速度。如果 Draw Call 的数量太多，CPU 就会把大量时间花费在提交 Draw Call 命令上，造成 CPU 的过载。\n   可以粗浅地理解为 DrawIndexed 或Draw函数就是一次 Draw Call\n3. **性能瓶颈**：由于 CPU 的准备工作和 GPU 的渲染能力不匹配，过多的 Draw Call 会导致 CPU 成为性能瓶颈，影响帧率。\n\n### 如何减少 Draw Call？\n\n1. **批处理（Batching）**：将多个小的 Draw Call 合并成一个大的 Draw Call，减少 CPU 提交 Draw Call 的次数和时间。\n   - **静态批处理**：适合静态物体，如不会移动的大地、石头等。将这些物体标记为静态，引擎会自动合并网格，减少 Draw Call。\n   - **动态批处理**：适合动态物体，引擎每帧都会重新合并网格，但限制较多，如顶点数和着色器复杂度等。\n2. **减少材质使用**：相同的材质会方便合并网格，减少 Draw Call。\n3. **GPU 实例化（GPU Instancing）**：将 mesh 信息存储在 GPU 内存缓冲区中，并进行渲染而无需额外的 Draw Call。\n4. **减少渲染状态切换**：改变渲染状态比渲染模型更耗时，尽量减少渲染状态切换。\n\n#### 渲染状态\n\n**改变渲染状态**是指在图形渲染过程中，通过设置或修改渲染器（如Direct3D或OpenGL）的各种参数，来控制渲染行为和效果的过程。这些参数通常被称为渲染状态，它们定义了渲染器在处理图形数据时的行为方式。\n\n##### 渲染状态的类型\n\n渲染状态有很多种，常见的包括：\n\n1. **填充模式（Fill Mode）**：决定多边形是被填充还是只绘制轮廓。例如，线框模式（Wireframe）只绘制多边形的边框，而实心模式（Solid）会填充整个多边形。\n2. **剔除模式（Cull Mode）**：决定是否剔除（不渲染）某些面。例如，可以设置为剔除背面（Backface Culling），只渲染正面的三角形。\n3. **深度测试（Depth Test）**：决定是否根据深度值（Z值）来决定是否更新像素的颜色。如果开启深度测试，只有当新像素的深度值小于当前像素的深度值时，才会更新像素的颜色。\n4. **混合模式（Blend Mode）**：决定如何将新像素的颜色与现有像素的颜色进行混合。例如，可以设置为Alpha混合，根据新像素的Alpha值来决定如何混合颜色。\n5. **模板测试（Stencil Test）**：决定是否根据模板缓冲区中的值来决定是否更新像素的颜色。模板缓冲区可以用于实现各种高级渲染效果，如阴影、轮廓等。\n6. **光照模式（Lighting Mode）**：决定是否使用光照计算，以及如何计算光照。\n7. **纹理过滤器（Texture Filter）**：决定如何对纹理进行采样和过滤，以获得更好的图像质量。例如，可以设置为线性过滤（Linear Filtering）或各向异性过滤（Anisotropic Filtering）\n\n## Unity And Material\n\n<img src=\"/imgs/关于SRP Batcher/OldMaterial.jpg\">\nCPU 收集 Material 信息，设置 CBUFFER\n\n## SRP Batcher\n\n<img src=\"/imgs/关于SRP Batcher/SRPPipeline.jpg\">\n在渲染循环里把材质信息保留在 GPU 内存中，只有材质内容改变才会重新 setup material data。\n在此流程中，CPU 仅负责处理内置引擎属性（如*对象矩阵变换*）。所有材质的 CBUFFER 均以持久化形式驻留在 GPU 内存中，随时可供调用。\n\n1. **材质数据持久化存储于 GPU 内存**，若材质内容未发生变更，则无需重复配置和上传缓冲区至 GPU，显著减少数据传输开销。\n2. **专用代码管理全局「按对象」GPU 常量缓冲区**，通过独立优化的代码路径，高效更新 GPU 中存储大规模对象相关数据（如内置属性）的 CBUFFER，进一步降低 CPU-GPU 通信负载。\n\n<img src=\"/imgs/关于SRP Batcher/SRPPipeline2.jpg\">\n左图为标准的 SRP（可编程渲染管线）渲染循环，右图为 SRP Batcher 的渲染循环。在 SRP Batcher 的机制中，一个“批次”仅由连续的 `Bind`（绑定资源）、`Draw`（绘制）、`Bind`、`Draw`... 等 GPU 命令序列构成。\n\n**SRP Batcher 的核心优化逻辑**：\n\n- **不减少 DrawCall 数量** SRP Batcher 并不会直接降低 DrawCall 的总数，其优化重点在于 **减少 DrawCall 之间的 GPU 资源设置开销**。\n- **通过持久化与批次合并降低开销** 借助材质数据在 GPU 内存中的持久化存储，以及针对同着色器变体的批次合并机制，大幅减少重复的资源绑定与状态切换操作，从而提升整体渲染效率。\n\n### 补充\n\n#### “Per Object” 变量\n\n<img src=\"/imgs/关于SRP Batcher/SRPPerObject.jpg\">\n\n## 关于\n\n* [^设备上下文]: [Direct3D 11 中的设备简介 - Win32 apps | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/overviews-direct3d-11-devices-intro)\n","slug":"关于SRP Batcher","published":1,"updated":"2025-02-23T16:52:56.986Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti3000obkbw0gbbfhvp","content":"<p>关于 SRP Batcher 的理解和内容</p>\r\n<h1 id=\"关于-srp-batcher\">关于 SRP Batcher</h1>\r\n<h2 id=\"shader-和-material\">Shader 和 Material</h2>\r\n<p>首先我们得对 Shader 和 Material 以及渲染过程有一个基础的了解。</p>\r\n<ul>\r\n<li>Shader：运行在 <strong>GPU</strong> 上的一段程序， 将输入的 Mesh 和\r\nTexture 以及 其他 Properties 进行计算，然后输出结果。\r\n<font color= #999999>当然也有利用 GPU 并行能力计算的 Computer Shader\r\n主要是做数据计算和处理，比如计算\r\nLUT，或者滤波、图像处理等等，这个不是本文重点。</font></li>\r\n<li>Material：描述(存储) 模型/物体 表面细节信息的资源。 定义外观属性\r\nColor，Tex，Smoothness……可以看作是对 Shader的实例。</li>\r\n</ul>\r\n<p>材质可以看作是一个配置Shader属性数值的面板。通过修改材质球里的属性数值，实际上就是在修改Shader的属性数值。\r\n当我们创建一个材质时，我们实际上是在创建一个Shader的实例。这个实例包含了Shader的所有属性，并且我们可以为这些属性提供具体的值。\r\n在Unity中，每个材质都关联了一个Shader。当我们将材质应用到一个物体上时，实际上是在告诉Unity使用这个材质所关联的Shader来渲染这个物体。</p>\r\n<h2 id=\"简单的渲染过程\">简单的渲染过程</h2>\r\n<p>就现在的设计，简单来讲渲染物体主要分为四个步骤： 暂时用 DX\r\n举例吧，我记不得太多了……</p>\r\n<ol type=\"1\">\r\n<li><p><strong>初始化</strong>：</p>\r\n<ul>\r\n<li><p><strong>创建设备</strong> (ID3D11Device) 和\r\n<strong>设备上下文</strong>(ID3D11DeviceContext)，以及交换链管理 Front\r\nBuffer 和 Back Buffer</p>\r\n<p>创建渲染视图并绑定到输出合并阶段。</p></li>\r\n</ul></li>\r\n<li><p><strong>设置渲染状态</strong>：</p>\r\n<ul>\r\n<li><strong>定义顶点格式和输入布局</strong>：根据需要渲染的几何体定义顶点结构，并创建相应的输入布局（<code>ID3D11InputLayout</code>）描述顶点数据的格式和语义。</li>\r\n<li><strong>创建顶点和索引缓冲区</strong>：将几何体的顶点数据存储在顶点缓冲区（<code>ID3D11Buffer</code>）中，如果有重复顶点，可以使用索引缓冲区（<code>ID3D11Buffer</code>）来优化内存使用和渲染效率。</li>\r\n<li><strong>创建着色器</strong>：编写顶点着色器（Vertex\r\nShader）和像素着色器（Pixel\r\nShader），并使用<code>D3DCompile</code>函数编译成字节码，然后创建着色器对象（<code>ID3D11VertexShader</code>和<code>ID3D11PixelShader</code>）</li>\r\n</ul></li>\r\n<li><p><strong>绘制调用</strong>：</p>\r\n<ul>\r\n<li><strong>绑定着色器和常量缓冲区</strong>：将顶点着色器、像素着色器和常量缓冲区绑定到渲染管线的相应阶段。</li>\r\n<li><strong>设置图元拓扑</strong>：指定要渲染的图元类型，如三角形列表、线列表等。</li>\r\n<li><strong>设置混合状态、深度/模板状态等</strong>：根据需要设置渲染管线的其他状态，如混合模式、深度测试和模板测试等。</li>\r\n<li>(可选)进行ClearRenderTargetView</li>\r\n<li><strong>绘制几何体</strong>：使用<code>DrawIndexed</code>或<code>Draw</code>函数绘制几何体，根据索引缓冲区（如果有）或顶点缓冲区中的数据生成图元，</li>\r\n<li>重复渲染过程。</li>\r\n</ul></li>\r\n<li><p><strong>结果展示</strong>：</p>\r\n<p>前后帧交替显示渲染结果</p></li>\r\n</ol>\r\n<h3 id=\"一点关于dx的概念不是很重要\">一点关于dx的概念，不是很重要……</h3>\r\n<ul>\r\n<li><p><code>ID3D11Device</code>接口，它用于创建资源和枚举显示适配器的功能，用以应用程序直接与图形硬件进行交互。</p></li>\r\n<li><p>设备上下文<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\"\r\nrole=\"doc-noteref\"><sup>1</sup></a>是设备的一个接口，用于设置管道状态、将资源绑定到图形管线和生成渲染命令。\r\n设备上下文在<code>ID3D11DeviceContext</code>接口中实现，它提供了对图形管线的直接控制，允许应用程序执行各种渲染操作。</p>\r\n<ul>\r\n<li><strong>即时上下文（Immediate\r\nContext）</strong>：即时上下文直接与图形硬件进行交互，它允许应用程序立即执行渲染命令。每个设备都有一个且只有一个即时上下文。</li>\r\n<li><strong>延迟上下文（Deferred\r\nContext）</strong>：延迟上下文将渲染命令记录到命令列表中，它主要用于多线程渲染。延迟上下文可以由工作线程使用，而即时上下文通常由主线程使用</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"draw-call\">Draw Call</h3>\r\n<p><strong>Draw Call</strong> 是 CPU 调用图形 API（如 OpenGL 或\r\nDirectX）命令 GPU 进行渲染的操作。具体来说，Draw Call 是 CPU 向 GPU\r\n发送的绘制命令，告诉 GPU\r\n如何渲染场景的一部分，包括使用哪些顶点、纹理、着色器等。</p>\r\n<h3 id=\"draw-call-的工作原理\">Draw Call 的工作原理</h3>\r\n<ol type=\"1\">\r\n<li><strong>命令缓冲区</strong>：为了实现 CPU 和 GPU\r\n的并行工作，需要一个命令缓冲区（Command\r\nBuffer），它包含一个命令队列。CPU 向其中添加命令，GPU\r\n从中读取命令并执行。</li>\r\n<li><strong>Draw Call 命令</strong>：Draw Call 是 <strong>Command Buffer\r\n的一种命令</strong>，用于告诉 GPU 进行绘制操作。除了 Draw Call，Command\r\nBuffer 中还有其他命令，如改变渲染状态等。</li>\r\n<li><strong>CPU 和 GPU 的交互</strong>：CPU 通过图形 API\r\n向命令缓冲区添加命令，GPU 从中读取命令并执行。当 CPU\r\n需要渲染一个对象时，它会向命令缓冲区添加一个 Draw Call 命令，GPU\r\n完成上一个渲染任务后，会从命令缓冲区中取出这个命令并执行。</li>\r\n</ol>\r\n<h3 id=\"为什么-draw-call-多了会影响帧率\">为什么 Draw Call\r\n多了会影响帧率？</h3>\r\n<ol type=\"1\">\r\n<li><strong>CPU 的准备工作</strong>：在每次调用 Draw Call 之前，CPU\r\n需要向 GPU 发送很多内容，包括数据、状态和命令等。CPU\r\n需要完成很多准备工作，如数据准备，资源绑定，命令提交，检查渲染状态等。</li>\r\n<li><strong>GPU 的渲染能力</strong>：GPU\r\n的渲染能力很强，渲染速度往往快于 CPU 提交命令的速度。如果 Draw Call\r\n的数量太多，CPU 就会把大量时间花费在提交 Draw Call 命令上，造成 CPU\r\n的过载。 可以粗浅地理解为 DrawIndexed 或Draw函数就是一次 Draw Call</li>\r\n<li><strong>性能瓶颈</strong>：由于 CPU 的准备工作和 GPU\r\n的渲染能力不匹配，过多的 Draw Call 会导致 CPU\r\n成为性能瓶颈，影响帧率。</li>\r\n</ol>\r\n<h3 id=\"如何减少-draw-call\">如何减少 Draw Call？</h3>\r\n<ol type=\"1\">\r\n<li><strong>批处理（Batching）</strong>：将多个小的 Draw Call\r\n合并成一个大的 Draw Call，减少 CPU 提交 Draw Call 的次数和时间。\r\n<ul>\r\n<li><strong>静态批处理</strong>：适合静态物体，如不会移动的大地、石头等。将这些物体标记为静态，引擎会自动合并网格，减少\r\nDraw Call。</li>\r\n<li><strong>动态批处理</strong>：适合动态物体，引擎每帧都会重新合并网格，但限制较多，如顶点数和着色器复杂度等。</li>\r\n</ul></li>\r\n<li><strong>减少材质使用</strong>：相同的材质会方便合并网格，减少 Draw\r\nCall。</li>\r\n<li><strong>GPU 实例化（GPU Instancing）</strong>：将 mesh 信息存储在\r\nGPU 内存缓冲区中，并进行渲染而无需额外的 Draw Call。</li>\r\n<li><strong>减少渲染状态切换</strong>：改变渲染状态比渲染模型更耗时，尽量减少渲染状态切换。</li>\r\n</ol>\r\n<h4 id=\"渲染状态\">渲染状态</h4>\r\n<p><strong>改变渲染状态</strong>是指在图形渲染过程中，通过设置或修改渲染器（如Direct3D或OpenGL）的各种参数，来控制渲染行为和效果的过程。这些参数通常被称为渲染状态，它们定义了渲染器在处理图形数据时的行为方式。</p>\r\n<h5 id=\"渲染状态的类型\">渲染状态的类型</h5>\r\n<p>渲染状态有很多种，常见的包括：</p>\r\n<ol type=\"1\">\r\n<li><strong>填充模式（Fill\r\nMode）</strong>：决定多边形是被填充还是只绘制轮廓。例如，线框模式（Wireframe）只绘制多边形的边框，而实心模式（Solid）会填充整个多边形。</li>\r\n<li><strong>剔除模式（Cull\r\nMode）</strong>：决定是否剔除（不渲染）某些面。例如，可以设置为剔除背面（Backface\r\nCulling），只渲染正面的三角形。</li>\r\n<li><strong>深度测试（Depth\r\nTest）</strong>：决定是否根据深度值（Z值）来决定是否更新像素的颜色。如果开启深度测试，只有当新像素的深度值小于当前像素的深度值时，才会更新像素的颜色。</li>\r\n<li><strong>混合模式（Blend\r\nMode）</strong>：决定如何将新像素的颜色与现有像素的颜色进行混合。例如，可以设置为Alpha混合，根据新像素的Alpha值来决定如何混合颜色。</li>\r\n<li><strong>模板测试（Stencil\r\nTest）</strong>：决定是否根据模板缓冲区中的值来决定是否更新像素的颜色。模板缓冲区可以用于实现各种高级渲染效果，如阴影、轮廓等。</li>\r\n<li><strong>光照模式（Lighting\r\nMode）</strong>：决定是否使用光照计算，以及如何计算光照。</li>\r\n<li><strong>纹理过滤器（Texture\r\nFilter）</strong>：决定如何对纹理进行采样和过滤，以获得更好的图像质量。例如，可以设置为线性过滤（Linear\r\nFiltering）或各向异性过滤（Anisotropic Filtering）</li>\r\n</ol>\r\n<h2 id=\"unity-and-material\">Unity And Material</h2>\r\n<p><img src=\"/imgs/关于SRP Batcher/OldMaterial.jpg\"> CPU 收集 Material\r\n信息，设置 CBUFFER</p>\r\n<h2 id=\"srp-batcher\">SRP Batcher</h2>\r\n<p><img src=\"/imgs/关于SRP Batcher/SRPPipeline.jpg\">\r\n在渲染循环里把材质信息保留在 GPU 内存中，只有材质内容改变才会重新 setup\r\nmaterial data。 在此流程中，CPU\r\n仅负责处理内置引擎属性（如<em>对象矩阵变换</em>）。所有材质的 CBUFFER\r\n均以持久化形式驻留在 GPU 内存中，随时可供调用。</p>\r\n<ol type=\"1\">\r\n<li><strong>材质数据持久化存储于 GPU\r\n内存</strong>，若材质内容未发生变更，则无需重复配置和上传缓冲区至\r\nGPU，显著减少数据传输开销。</li>\r\n<li><strong>专用代码管理全局「按对象」GPU\r\n常量缓冲区</strong>，通过独立优化的代码路径，高效更新 GPU\r\n中存储大规模对象相关数据（如内置属性）的 CBUFFER，进一步降低 CPU-GPU\r\n通信负载。</li>\r\n</ol>\r\n<p><img src=\"/imgs/关于SRP Batcher/SRPPipeline2.jpg\"> 左图为标准的\r\nSRP（可编程渲染管线）渲染循环，右图为 SRP Batcher 的渲染循环。在 SRP\r\nBatcher 的机制中，一个“批次”仅由连续的\r\n<code>Bind</code>（绑定资源）、<code>Draw</code>（绘制）、<code>Bind</code>、<code>Draw</code>...\r\n等 GPU 命令序列构成。</p>\r\n<p><strong>SRP Batcher 的核心优化逻辑</strong>：</p>\r\n<ul>\r\n<li><strong>不减少 DrawCall 数量</strong> SRP Batcher 并不会直接降低\r\nDrawCall 的总数，其优化重点在于 <strong>减少 DrawCall 之间的 GPU\r\n资源设置开销</strong>。</li>\r\n<li><strong>通过持久化与批次合并降低开销</strong> 借助材质数据在 GPU\r\n内存中的持久化存储，以及针对同着色器变体的批次合并机制，大幅减少重复的资源绑定与状态切换操作，从而提升整体渲染效率。</li>\r\n</ul>\r\n<h3 id=\"补充\">补充</h3>\r\n<h4 id=\"per-object-变量\">“Per Object” 变量</h4>\r\n<p><img src=\"/imgs/关于SRP Batcher/SRPPerObject.jpg\"></p>\r\n<h2 id=\"关于\">关于</h2>\r\n<ul>\r\n<li></li>\r\n</ul>\r\n<section id=\"footnotes\" class=\"footnotes footnotes-end-of-document\"\r\nrole=\"doc-endnotes\">\r\n<hr />\r\n<ol>\r\n<li id=\"fn1\"><p><a\r\nhref=\"https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/overviews-direct3d-11-devices-intro\">Direct3D\r\n11 中的设备简介 - Win32 apps | Microsoft Learn</a><a href=\"#fnref1\"\r\nclass=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n","site":{"data":{}},"excerpt":"","more":"<p>关于 SRP Batcher 的理解和内容</p>\r\n<h1 id=\"关于-srp-batcher\">关于 SRP Batcher</h1>\r\n<h2 id=\"shader-和-material\">Shader 和 Material</h2>\r\n<p>首先我们得对 Shader 和 Material 以及渲染过程有一个基础的了解。</p>\r\n<ul>\r\n<li>Shader：运行在 <strong>GPU</strong> 上的一段程序， 将输入的 Mesh 和\r\nTexture 以及 其他 Properties 进行计算，然后输出结果。\r\n<font color= #999999>当然也有利用 GPU 并行能力计算的 Computer Shader\r\n主要是做数据计算和处理，比如计算\r\nLUT，或者滤波、图像处理等等，这个不是本文重点。</font></li>\r\n<li>Material：描述(存储) 模型/物体 表面细节信息的资源。 定义外观属性\r\nColor，Tex，Smoothness……可以看作是对 Shader的实例。</li>\r\n</ul>\r\n<p>材质可以看作是一个配置Shader属性数值的面板。通过修改材质球里的属性数值，实际上就是在修改Shader的属性数值。\r\n当我们创建一个材质时，我们实际上是在创建一个Shader的实例。这个实例包含了Shader的所有属性，并且我们可以为这些属性提供具体的值。\r\n在Unity中，每个材质都关联了一个Shader。当我们将材质应用到一个物体上时，实际上是在告诉Unity使用这个材质所关联的Shader来渲染这个物体。</p>\r\n<h2 id=\"简单的渲染过程\">简单的渲染过程</h2>\r\n<p>就现在的设计，简单来讲渲染物体主要分为四个步骤： 暂时用 DX\r\n举例吧，我记不得太多了……</p>\r\n<ol type=\"1\">\r\n<li><p><strong>初始化</strong>：</p>\r\n<ul>\r\n<li><p><strong>创建设备</strong> (ID3D11Device) 和\r\n<strong>设备上下文</strong>(ID3D11DeviceContext)，以及交换链管理 Front\r\nBuffer 和 Back Buffer</p>\r\n<p>创建渲染视图并绑定到输出合并阶段。</p></li>\r\n</ul></li>\r\n<li><p><strong>设置渲染状态</strong>：</p>\r\n<ul>\r\n<li><strong>定义顶点格式和输入布局</strong>：根据需要渲染的几何体定义顶点结构，并创建相应的输入布局（<code>ID3D11InputLayout</code>）描述顶点数据的格式和语义。</li>\r\n<li><strong>创建顶点和索引缓冲区</strong>：将几何体的顶点数据存储在顶点缓冲区（<code>ID3D11Buffer</code>）中，如果有重复顶点，可以使用索引缓冲区（<code>ID3D11Buffer</code>）来优化内存使用和渲染效率。</li>\r\n<li><strong>创建着色器</strong>：编写顶点着色器（Vertex\r\nShader）和像素着色器（Pixel\r\nShader），并使用<code>D3DCompile</code>函数编译成字节码，然后创建着色器对象（<code>ID3D11VertexShader</code>和<code>ID3D11PixelShader</code>）</li>\r\n</ul></li>\r\n<li><p><strong>绘制调用</strong>：</p>\r\n<ul>\r\n<li><strong>绑定着色器和常量缓冲区</strong>：将顶点着色器、像素着色器和常量缓冲区绑定到渲染管线的相应阶段。</li>\r\n<li><strong>设置图元拓扑</strong>：指定要渲染的图元类型，如三角形列表、线列表等。</li>\r\n<li><strong>设置混合状态、深度/模板状态等</strong>：根据需要设置渲染管线的其他状态，如混合模式、深度测试和模板测试等。</li>\r\n<li>(可选)进行ClearRenderTargetView</li>\r\n<li><strong>绘制几何体</strong>：使用<code>DrawIndexed</code>或<code>Draw</code>函数绘制几何体，根据索引缓冲区（如果有）或顶点缓冲区中的数据生成图元，</li>\r\n<li>重复渲染过程。</li>\r\n</ul></li>\r\n<li><p><strong>结果展示</strong>：</p>\r\n<p>前后帧交替显示渲染结果</p></li>\r\n</ol>\r\n<h3 id=\"一点关于dx的概念不是很重要\">一点关于dx的概念，不是很重要……</h3>\r\n<ul>\r\n<li><p><code>ID3D11Device</code>接口，它用于创建资源和枚举显示适配器的功能，用以应用程序直接与图形硬件进行交互。</p></li>\r\n<li><p>设备上下文<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\"\r\nrole=\"doc-noteref\"><sup>1</sup></a>是设备的一个接口，用于设置管道状态、将资源绑定到图形管线和生成渲染命令。\r\n设备上下文在<code>ID3D11DeviceContext</code>接口中实现，它提供了对图形管线的直接控制，允许应用程序执行各种渲染操作。</p>\r\n<ul>\r\n<li><strong>即时上下文（Immediate\r\nContext）</strong>：即时上下文直接与图形硬件进行交互，它允许应用程序立即执行渲染命令。每个设备都有一个且只有一个即时上下文。</li>\r\n<li><strong>延迟上下文（Deferred\r\nContext）</strong>：延迟上下文将渲染命令记录到命令列表中，它主要用于多线程渲染。延迟上下文可以由工作线程使用，而即时上下文通常由主线程使用</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"draw-call\">Draw Call</h3>\r\n<p><strong>Draw Call</strong> 是 CPU 调用图形 API（如 OpenGL 或\r\nDirectX）命令 GPU 进行渲染的操作。具体来说，Draw Call 是 CPU 向 GPU\r\n发送的绘制命令，告诉 GPU\r\n如何渲染场景的一部分，包括使用哪些顶点、纹理、着色器等。</p>\r\n<h3 id=\"draw-call-的工作原理\">Draw Call 的工作原理</h3>\r\n<ol type=\"1\">\r\n<li><strong>命令缓冲区</strong>：为了实现 CPU 和 GPU\r\n的并行工作，需要一个命令缓冲区（Command\r\nBuffer），它包含一个命令队列。CPU 向其中添加命令，GPU\r\n从中读取命令并执行。</li>\r\n<li><strong>Draw Call 命令</strong>：Draw Call 是 <strong>Command Buffer\r\n的一种命令</strong>，用于告诉 GPU 进行绘制操作。除了 Draw Call，Command\r\nBuffer 中还有其他命令，如改变渲染状态等。</li>\r\n<li><strong>CPU 和 GPU 的交互</strong>：CPU 通过图形 API\r\n向命令缓冲区添加命令，GPU 从中读取命令并执行。当 CPU\r\n需要渲染一个对象时，它会向命令缓冲区添加一个 Draw Call 命令，GPU\r\n完成上一个渲染任务后，会从命令缓冲区中取出这个命令并执行。</li>\r\n</ol>\r\n<h3 id=\"为什么-draw-call-多了会影响帧率\">为什么 Draw Call\r\n多了会影响帧率？</h3>\r\n<ol type=\"1\">\r\n<li><strong>CPU 的准备工作</strong>：在每次调用 Draw Call 之前，CPU\r\n需要向 GPU 发送很多内容，包括数据、状态和命令等。CPU\r\n需要完成很多准备工作，如数据准备，资源绑定，命令提交，检查渲染状态等。</li>\r\n<li><strong>GPU 的渲染能力</strong>：GPU\r\n的渲染能力很强，渲染速度往往快于 CPU 提交命令的速度。如果 Draw Call\r\n的数量太多，CPU 就会把大量时间花费在提交 Draw Call 命令上，造成 CPU\r\n的过载。 可以粗浅地理解为 DrawIndexed 或Draw函数就是一次 Draw Call</li>\r\n<li><strong>性能瓶颈</strong>：由于 CPU 的准备工作和 GPU\r\n的渲染能力不匹配，过多的 Draw Call 会导致 CPU\r\n成为性能瓶颈，影响帧率。</li>\r\n</ol>\r\n<h3 id=\"如何减少-draw-call\">如何减少 Draw Call？</h3>\r\n<ol type=\"1\">\r\n<li><strong>批处理（Batching）</strong>：将多个小的 Draw Call\r\n合并成一个大的 Draw Call，减少 CPU 提交 Draw Call 的次数和时间。\r\n<ul>\r\n<li><strong>静态批处理</strong>：适合静态物体，如不会移动的大地、石头等。将这些物体标记为静态，引擎会自动合并网格，减少\r\nDraw Call。</li>\r\n<li><strong>动态批处理</strong>：适合动态物体，引擎每帧都会重新合并网格，但限制较多，如顶点数和着色器复杂度等。</li>\r\n</ul></li>\r\n<li><strong>减少材质使用</strong>：相同的材质会方便合并网格，减少 Draw\r\nCall。</li>\r\n<li><strong>GPU 实例化（GPU Instancing）</strong>：将 mesh 信息存储在\r\nGPU 内存缓冲区中，并进行渲染而无需额外的 Draw Call。</li>\r\n<li><strong>减少渲染状态切换</strong>：改变渲染状态比渲染模型更耗时，尽量减少渲染状态切换。</li>\r\n</ol>\r\n<h4 id=\"渲染状态\">渲染状态</h4>\r\n<p><strong>改变渲染状态</strong>是指在图形渲染过程中，通过设置或修改渲染器（如Direct3D或OpenGL）的各种参数，来控制渲染行为和效果的过程。这些参数通常被称为渲染状态，它们定义了渲染器在处理图形数据时的行为方式。</p>\r\n<h5 id=\"渲染状态的类型\">渲染状态的类型</h5>\r\n<p>渲染状态有很多种，常见的包括：</p>\r\n<ol type=\"1\">\r\n<li><strong>填充模式（Fill\r\nMode）</strong>：决定多边形是被填充还是只绘制轮廓。例如，线框模式（Wireframe）只绘制多边形的边框，而实心模式（Solid）会填充整个多边形。</li>\r\n<li><strong>剔除模式（Cull\r\nMode）</strong>：决定是否剔除（不渲染）某些面。例如，可以设置为剔除背面（Backface\r\nCulling），只渲染正面的三角形。</li>\r\n<li><strong>深度测试（Depth\r\nTest）</strong>：决定是否根据深度值（Z值）来决定是否更新像素的颜色。如果开启深度测试，只有当新像素的深度值小于当前像素的深度值时，才会更新像素的颜色。</li>\r\n<li><strong>混合模式（Blend\r\nMode）</strong>：决定如何将新像素的颜色与现有像素的颜色进行混合。例如，可以设置为Alpha混合，根据新像素的Alpha值来决定如何混合颜色。</li>\r\n<li><strong>模板测试（Stencil\r\nTest）</strong>：决定是否根据模板缓冲区中的值来决定是否更新像素的颜色。模板缓冲区可以用于实现各种高级渲染效果，如阴影、轮廓等。</li>\r\n<li><strong>光照模式（Lighting\r\nMode）</strong>：决定是否使用光照计算，以及如何计算光照。</li>\r\n<li><strong>纹理过滤器（Texture\r\nFilter）</strong>：决定如何对纹理进行采样和过滤，以获得更好的图像质量。例如，可以设置为线性过滤（Linear\r\nFiltering）或各向异性过滤（Anisotropic Filtering）</li>\r\n</ol>\r\n<h2 id=\"unity-and-material\">Unity And Material</h2>\r\n<p><img src=\"/imgs/关于SRP Batcher/OldMaterial.jpg\"> CPU 收集 Material\r\n信息，设置 CBUFFER</p>\r\n<h2 id=\"srp-batcher\">SRP Batcher</h2>\r\n<p><img src=\"/imgs/关于SRP Batcher/SRPPipeline.jpg\">\r\n在渲染循环里把材质信息保留在 GPU 内存中，只有材质内容改变才会重新 setup\r\nmaterial data。 在此流程中，CPU\r\n仅负责处理内置引擎属性（如<em>对象矩阵变换</em>）。所有材质的 CBUFFER\r\n均以持久化形式驻留在 GPU 内存中，随时可供调用。</p>\r\n<ol type=\"1\">\r\n<li><strong>材质数据持久化存储于 GPU\r\n内存</strong>，若材质内容未发生变更，则无需重复配置和上传缓冲区至\r\nGPU，显著减少数据传输开销。</li>\r\n<li><strong>专用代码管理全局「按对象」GPU\r\n常量缓冲区</strong>，通过独立优化的代码路径，高效更新 GPU\r\n中存储大规模对象相关数据（如内置属性）的 CBUFFER，进一步降低 CPU-GPU\r\n通信负载。</li>\r\n</ol>\r\n<p><img src=\"/imgs/关于SRP Batcher/SRPPipeline2.jpg\"> 左图为标准的\r\nSRP（可编程渲染管线）渲染循环，右图为 SRP Batcher 的渲染循环。在 SRP\r\nBatcher 的机制中，一个“批次”仅由连续的\r\n<code>Bind</code>（绑定资源）、<code>Draw</code>（绘制）、<code>Bind</code>、<code>Draw</code>...\r\n等 GPU 命令序列构成。</p>\r\n<p><strong>SRP Batcher 的核心优化逻辑</strong>：</p>\r\n<ul>\r\n<li><strong>不减少 DrawCall 数量</strong> SRP Batcher 并不会直接降低\r\nDrawCall 的总数，其优化重点在于 <strong>减少 DrawCall 之间的 GPU\r\n资源设置开销</strong>。</li>\r\n<li><strong>通过持久化与批次合并降低开销</strong> 借助材质数据在 GPU\r\n内存中的持久化存储，以及针对同着色器变体的批次合并机制，大幅减少重复的资源绑定与状态切换操作，从而提升整体渲染效率。</li>\r\n</ul>\r\n<h3 id=\"补充\">补充</h3>\r\n<h4 id=\"per-object-变量\">“Per Object” 变量</h4>\r\n<p><img src=\"/imgs/关于SRP Batcher/SRPPerObject.jpg\"></p>\r\n<h2 id=\"关于\">关于</h2>\r\n<ul>\r\n<li></li>\r\n</ul>\r\n<section id=\"footnotes\" class=\"footnotes footnotes-end-of-document\"\r\nrole=\"doc-endnotes\">\r\n<hr />\r\n<ol>\r\n<li id=\"fn1\"><p><a\r\nhref=\"https://learn.microsoft.com/zh-cn/windows/win32/direct3d11/overviews-direct3d-11-devices-intro\">Direct3D\r\n11 中的设备简介 - Win32 apps | Microsoft Learn</a><a href=\"#fnref1\"\r\nclass=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n"},{"title":"刀光特效果","math":true,"index_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","banner_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","date":"2024-05-01T06:26:11.454Z","typora-root-url":"../","_content":"\nUnity 下实现的 刀光特效，但是主要是 shader，所以可以用于其他引擎。\n\n<!--more-->\n\n# 刀光特效\n\n## shader\n\n~~~hlsl\nShader \"MyShader/Dao Guang\"\n{\n    Properties\n    {\n        //_CopyColorRT (\"Main Texture\", 2D) = \"white\" {}\n        _MainTex(\"Main Tex\", 2D) = \"white\" {}\n        [HDR]_MainColor(\"Main Color\", Color) = (1,1,1,1)\n        _Alpha(\"Alpha Val\", Range(0,1)) = 0.1\n        _FlowVal(\"Flow Val\", Range(0.0,1)) = 0\n        _FadeInTime(\"Fade In Time\", Range(0,0.5)) = 0\n        _FadeOutKey(\"Fade Out Key\", Range(0.0,1)) = 1\n        _FadeOutTime(\"Fade Out Time\", Range(0,1)) = 0.1\n        [HDR]_FlowSpecularColor(\"Flow Specular Color\", Color) = (1,1,1,1)\n        [HDR]_NoiseColor(\"Noise Color\", Color) = (1,1,1,1)\n        [Toggle]_ReverseDir(\"Reverse Dir\", Int) = 0\n        \n        [Header(Option)]\n        [Enum(UnityEngine.Rendering.BlendOp)]  _BlendOp  (\"BlendOp\", Float) = 0\n        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (\"SrcBlend\", Float) = 1\n        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (\"DstBlend\", Float) = 0\n        [Enum(Off, 0, On, 1)]_ZWriteMode (\"ZWriteMode\", float) = 1\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode (\"CullMode\", float) = 2\n        [Enum(UnityEngine.Rendering.CompareFunction)]_ZTestMode (\"ZTestMode\", Float) = 4\n        //[Enum(UnityEngine.Rendering.ColorWriteMask)]_ColorMask (\"ColorMask\", Float) = 15\n\n        //[Header(Stencil)]\n        //[Enum(UnityEngine.Rendering.CompareFunction)]_StencilComp (\"Stencil Comparison\", Float) = 8\n        //[IntRange]_StencilWriteMask (\"Stencil Write Mask\", Range(0,255)) = 255\n        //[IntRange]_StencilReadMask (\"Stencil Read Mask\", Range(0,255)) = 255\n        //[IntRange]_Stencil (\"Stencil ID\", Range(0,255)) = 0\n        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilPass (\"Stencil Pass\", Float) = 0\n        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilFail (\"Stencil Fail\", Float) = 0\n        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilZFail (\"Stencil ZFail\", Float) = 0\n    }\n    SubShader\n    {\n        Tags\n        { \n            \"RenderType\"=\"Transparent\"\n            \"Queue\" = \"Transparent\"\n        }\n        \n        ZWrite [_ZWriteMode]\n        ZTest [_ZTestMode]\n        BlendOp [_BlendOp]\n        Blend [_SrcBlend] [_DstBlend]\n        Pass\n        {\n            Name \"Alpha Clip\"\n            Tags \n            { \n                //\"LightMode\" = \"UniversalForward\"\n                \"LightMode\" = \"UniversalForward\"\n            }\n\n            HLSLPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            };\n\n            //SAMPLER(sampler_ScreenOffRT);\n            //TEXTURE2D(_ScreenOffRT);\n            //float4 _ScreenOffRT_ST;\n\n            CBUFFER_START(UnityPerMaterial)\n                SAMPLER(sampler_MainTex);\n                TEXTURE2D(_MainTex);\n                float4 _MainTex_ST, _MainColor;\n                float4 _FlowSpecularColor, _NoiseColor;\n                float _Alpha, _FlowVal, _FadeInTime;\n                float _FadeOutKey, _FadeOutTime;\n                int _ReverseDir;\n            CBUFFER_END\n\n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex = mul(UNITY_MATRIX_MVP,v.vertex);\n                o.uv = TRANSFORM_TEX(v.uv,_MainTex);\n                return o;\n            }\n\n            half4 frag (v2f i) : SV_Target\n            {\n                // sample the texture\n                float flowUV = i.uv.x;\n                if(_ReverseDir != 0)\n                    flowUV = 1 - flowUV;\n                //float val = i.uv.x;\n                flowUV = flowUV + _FlowVal;\n                float alphaFade = clamp((_FlowVal / _FadeInTime), 0 ,1);\n                //flowUV *= _FlowVal;\n\n                half4 mainCol = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, float2(flowUV,i.uv.y));\n                float alpha = alphaFade * mainCol.a;\n                alpha *= 1 - clamp( (_FlowVal - _FadeOutKey) / _FadeOutTime, 0, 1);\n                clip(_Alpha - mainCol.a);\n                \n                float3 col = _FlowSpecularColor * mainCol.g;\n                col += mainCol.r * _MainColor;\n                col += _NoiseColor * mainCol.b;\n                return half4(col, alpha);\n                //return col * flowUV * alphaValByFlow;// * _FlowSpecularColor;\n            }\n\n            ENDHLSL\n        }\n    }\n}\n\n~~~\n\n主要思路就根据 uv.x 做渐入渐出和透明度的调整。\n","source":"_posts/刀光特效.md","raw":"---\ntitle: 刀光特效果\nmath: true\ntags: 特效\nindex_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\nbanner_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\ndate: 2024-05-01 --\ntypora-root-url: ../\n---\n\nUnity 下实现的 刀光特效，但是主要是 shader，所以可以用于其他引擎。\n\n<!--more-->\n\n# 刀光特效\n\n## shader\n\n~~~hlsl\nShader \"MyShader/Dao Guang\"\n{\n    Properties\n    {\n        //_CopyColorRT (\"Main Texture\", 2D) = \"white\" {}\n        _MainTex(\"Main Tex\", 2D) = \"white\" {}\n        [HDR]_MainColor(\"Main Color\", Color) = (1,1,1,1)\n        _Alpha(\"Alpha Val\", Range(0,1)) = 0.1\n        _FlowVal(\"Flow Val\", Range(0.0,1)) = 0\n        _FadeInTime(\"Fade In Time\", Range(0,0.5)) = 0\n        _FadeOutKey(\"Fade Out Key\", Range(0.0,1)) = 1\n        _FadeOutTime(\"Fade Out Time\", Range(0,1)) = 0.1\n        [HDR]_FlowSpecularColor(\"Flow Specular Color\", Color) = (1,1,1,1)\n        [HDR]_NoiseColor(\"Noise Color\", Color) = (1,1,1,1)\n        [Toggle]_ReverseDir(\"Reverse Dir\", Int) = 0\n        \n        [Header(Option)]\n        [Enum(UnityEngine.Rendering.BlendOp)]  _BlendOp  (\"BlendOp\", Float) = 0\n        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (\"SrcBlend\", Float) = 1\n        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (\"DstBlend\", Float) = 0\n        [Enum(Off, 0, On, 1)]_ZWriteMode (\"ZWriteMode\", float) = 1\n        [Enum(UnityEngine.Rendering.CullMode)]_CullMode (\"CullMode\", float) = 2\n        [Enum(UnityEngine.Rendering.CompareFunction)]_ZTestMode (\"ZTestMode\", Float) = 4\n        //[Enum(UnityEngine.Rendering.ColorWriteMask)]_ColorMask (\"ColorMask\", Float) = 15\n\n        //[Header(Stencil)]\n        //[Enum(UnityEngine.Rendering.CompareFunction)]_StencilComp (\"Stencil Comparison\", Float) = 8\n        //[IntRange]_StencilWriteMask (\"Stencil Write Mask\", Range(0,255)) = 255\n        //[IntRange]_StencilReadMask (\"Stencil Read Mask\", Range(0,255)) = 255\n        //[IntRange]_Stencil (\"Stencil ID\", Range(0,255)) = 0\n        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilPass (\"Stencil Pass\", Float) = 0\n        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilFail (\"Stencil Fail\", Float) = 0\n        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilZFail (\"Stencil ZFail\", Float) = 0\n    }\n    SubShader\n    {\n        Tags\n        { \n            \"RenderType\"=\"Transparent\"\n            \"Queue\" = \"Transparent\"\n        }\n        \n        ZWrite [_ZWriteMode]\n        ZTest [_ZTestMode]\n        BlendOp [_BlendOp]\n        Blend [_SrcBlend] [_DstBlend]\n        Pass\n        {\n            Name \"Alpha Clip\"\n            Tags \n            { \n                //\"LightMode\" = \"UniversalForward\"\n                \"LightMode\" = \"UniversalForward\"\n            }\n\n            HLSLPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n\n            struct appdata\n            {\n                float4 vertex : POSITION;\n                float2 uv : TEXCOORD0;\n            };\n\n            struct v2f\n            {\n                float2 uv : TEXCOORD0;\n                float4 vertex : SV_POSITION;\n            };\n\n            //SAMPLER(sampler_ScreenOffRT);\n            //TEXTURE2D(_ScreenOffRT);\n            //float4 _ScreenOffRT_ST;\n\n            CBUFFER_START(UnityPerMaterial)\n                SAMPLER(sampler_MainTex);\n                TEXTURE2D(_MainTex);\n                float4 _MainTex_ST, _MainColor;\n                float4 _FlowSpecularColor, _NoiseColor;\n                float _Alpha, _FlowVal, _FadeInTime;\n                float _FadeOutKey, _FadeOutTime;\n                int _ReverseDir;\n            CBUFFER_END\n\n            v2f vert (appdata v)\n            {\n                v2f o;\n                o.vertex = mul(UNITY_MATRIX_MVP,v.vertex);\n                o.uv = TRANSFORM_TEX(v.uv,_MainTex);\n                return o;\n            }\n\n            half4 frag (v2f i) : SV_Target\n            {\n                // sample the texture\n                float flowUV = i.uv.x;\n                if(_ReverseDir != 0)\n                    flowUV = 1 - flowUV;\n                //float val = i.uv.x;\n                flowUV = flowUV + _FlowVal;\n                float alphaFade = clamp((_FlowVal / _FadeInTime), 0 ,1);\n                //flowUV *= _FlowVal;\n\n                half4 mainCol = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, float2(flowUV,i.uv.y));\n                float alpha = alphaFade * mainCol.a;\n                alpha *= 1 - clamp( (_FlowVal - _FadeOutKey) / _FadeOutTime, 0, 1);\n                clip(_Alpha - mainCol.a);\n                \n                float3 col = _FlowSpecularColor * mainCol.g;\n                col += mainCol.r * _MainColor;\n                col += _NoiseColor * mainCol.b;\n                return half4(col, alpha);\n                //return col * flowUV * alphaValByFlow;// * _FlowSpecularColor;\n            }\n\n            ENDHLSL\n        }\n    }\n}\n\n~~~\n\n主要思路就根据 uv.x 做渐入渐出和透明度的调整。\n","slug":"刀光特效","published":1,"updated":"2025-08-15T18:14:28.576Z","_id":"cme8ppti4000qbkbw5spvcs3l","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Unity 下实现的 刀光特效，但是主要是\r\nshader，所以可以用于其他引擎。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"刀光特效\">刀光特效</h1>\r\n<h2 id=\"shader\">shader</h2>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs hlsl\">Shader &quot;MyShader/Dao Guang&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        //_CopyColorRT (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _MainTex(&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        [HDR]_MainColor(&quot;Main Color&quot;, Color) = (1,1,1,1)<br>        _Alpha(&quot;Alpha Val&quot;, Range(0,1)) = 0.1<br>        _FlowVal(&quot;Flow Val&quot;, Range(0.0,1)) = 0<br>        _FadeInTime(&quot;Fade In Time&quot;, Range(0,0.5)) = 0<br>        _FadeOutKey(&quot;Fade Out Key&quot;, Range(0.0,1)) = 1<br>        _FadeOutTime(&quot;Fade Out Time&quot;, Range(0,1)) = 0.1<br>        [HDR]_FlowSpecularColor(&quot;Flow Specular Color&quot;, Color) = (1,1,1,1)<br>        [HDR]_NoiseColor(&quot;Noise Color&quot;, Color) = (1,1,1,1)<br>        [Toggle]_ReverseDir(&quot;Reverse Dir&quot;, Int) = 0<br>        <br>        [Header(Option)]<br>        [Enum(UnityEngine.Rendering.BlendOp)]  _BlendOp  (&quot;BlendOp&quot;, Float) = 0<br>        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (&quot;SrcBlend&quot;, Float) = 1<br>        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (&quot;DstBlend&quot;, Float) = 0<br>        [Enum(Off, 0, On, 1)]_ZWriteMode (&quot;ZWriteMode&quot;, float) = 1<br>        [Enum(UnityEngine.Rendering.CullMode)]_CullMode (&quot;CullMode&quot;, float) = 2<br>        [Enum(UnityEngine.Rendering.CompareFunction)]_ZTestMode (&quot;ZTestMode&quot;, Float) = 4<br>        //[Enum(UnityEngine.Rendering.ColorWriteMask)]_ColorMask (&quot;ColorMask&quot;, Float) = 15<br><br>        //[Header(Stencil)]<br>        //[Enum(UnityEngine.Rendering.CompareFunction)]_StencilComp (&quot;Stencil Comparison&quot;, Float) = 8<br>        //[IntRange]_StencilWriteMask (&quot;Stencil Write Mask&quot;, Range(0,255)) = 255<br>        //[IntRange]_StencilReadMask (&quot;Stencil Read Mask&quot;, Range(0,255)) = 255<br>        //[IntRange]_Stencil (&quot;Stencil ID&quot;, Range(0,255)) = 0<br>        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilPass (&quot;Stencil Pass&quot;, Float) = 0<br>        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilFail (&quot;Stencil Fail&quot;, Float) = 0<br>        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilZFail (&quot;Stencil ZFail&quot;, Float) = 0<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags<br>        &#123; <br>            &quot;RenderType&quot;=&quot;Transparent&quot;<br>            &quot;Queue&quot; = &quot;Transparent&quot;<br>        &#125;<br>        <br>        ZWrite [_ZWriteMode]<br>        ZTest [_ZTestMode]<br>        BlendOp [_BlendOp]<br>        Blend [_SrcBlend] [_DstBlend]<br>        Pass<br>        &#123;<br>            Name &quot;Alpha Clip&quot;<br>            Tags <br>            &#123; <br>                //&quot;LightMode&quot; = &quot;UniversalForward&quot;<br>                &quot;LightMode&quot; = &quot;UniversalForward&quot;<br>            &#125;<br><br>            HLSLPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;<br><br>            struct appdata<br>            &#123;<br>                float4 vertex : POSITION;<br>                float2 uv : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f<br>            &#123;<br>                float2 uv : TEXCOORD0;<br>                float4 vertex : SV_POSITION;<br>            &#125;;<br><br>            //SAMPLER(sampler_ScreenOffRT);<br>            //TEXTURE2D(_ScreenOffRT);<br>            //float4 _ScreenOffRT_ST;<br><br>            CBUFFER_START(UnityPerMaterial)<br>                SAMPLER(sampler_MainTex);<br>                TEXTURE2D(_MainTex);<br>                float4 _MainTex_ST, _MainColor;<br>                float4 _FlowSpecularColor, _NoiseColor;<br>                float _Alpha, _FlowVal, _FadeInTime;<br>                float _FadeOutKey, _FadeOutTime;<br>                int _ReverseDir;<br>            CBUFFER_END<br><br>            v2f vert (appdata v)<br>            &#123;<br>                v2f o;<br>                o.vertex = mul(UNITY_MATRIX_MVP,v.vertex);<br>                o.uv = TRANSFORM_TEX(v.uv,_MainTex);<br>                return o;<br>            &#125;<br><br>            half4 frag (v2f i) : SV_Target<br>            &#123;<br>                // sample the texture<br>                float flowUV = i.uv.x;<br>                if(_ReverseDir != 0)<br>                    flowUV = 1 - flowUV;<br>                //float val = i.uv.x;<br>                flowUV = flowUV + _FlowVal;<br>                float alphaFade = clamp((_FlowVal / _FadeInTime), 0 ,1);<br>                //flowUV *= _FlowVal;<br><br>                half4 mainCol = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, float2(flowUV,i.uv.y));<br>                float alpha = alphaFade * mainCol.a;<br>                alpha *= 1 - clamp( (_FlowVal - _FadeOutKey) / _FadeOutTime, 0, 1);<br>                clip(_Alpha - mainCol.a);<br>                <br>                float3 col = _FlowSpecularColor * mainCol.g;<br>                col += mainCol.r * _MainColor;<br>                col += _NoiseColor * mainCol.b;<br>                return half4(col, alpha);<br>                //return col * flowUV * alphaValByFlow;// * _FlowSpecularColor;<br>            &#125;<br><br>            ENDHLSL<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\r\n<p>主要思路就根据 uv.x 做渐入渐出和透明度的调整。</p>\r\n","site":{"data":{}},"excerpt":"<p>Unity 下实现的 刀光特效，但是主要是\r\nshader，所以可以用于其他引擎。</p>","more":"<h1 id=\"刀光特效\">刀光特效</h1>\r\n<h2 id=\"shader\">shader</h2>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs hlsl\">Shader &quot;MyShader/Dao Guang&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        //_CopyColorRT (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _MainTex(&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        [HDR]_MainColor(&quot;Main Color&quot;, Color) = (1,1,1,1)<br>        _Alpha(&quot;Alpha Val&quot;, Range(0,1)) = 0.1<br>        _FlowVal(&quot;Flow Val&quot;, Range(0.0,1)) = 0<br>        _FadeInTime(&quot;Fade In Time&quot;, Range(0,0.5)) = 0<br>        _FadeOutKey(&quot;Fade Out Key&quot;, Range(0.0,1)) = 1<br>        _FadeOutTime(&quot;Fade Out Time&quot;, Range(0,1)) = 0.1<br>        [HDR]_FlowSpecularColor(&quot;Flow Specular Color&quot;, Color) = (1,1,1,1)<br>        [HDR]_NoiseColor(&quot;Noise Color&quot;, Color) = (1,1,1,1)<br>        [Toggle]_ReverseDir(&quot;Reverse Dir&quot;, Int) = 0<br>        <br>        [Header(Option)]<br>        [Enum(UnityEngine.Rendering.BlendOp)]  _BlendOp  (&quot;BlendOp&quot;, Float) = 0<br>        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (&quot;SrcBlend&quot;, Float) = 1<br>        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (&quot;DstBlend&quot;, Float) = 0<br>        [Enum(Off, 0, On, 1)]_ZWriteMode (&quot;ZWriteMode&quot;, float) = 1<br>        [Enum(UnityEngine.Rendering.CullMode)]_CullMode (&quot;CullMode&quot;, float) = 2<br>        [Enum(UnityEngine.Rendering.CompareFunction)]_ZTestMode (&quot;ZTestMode&quot;, Float) = 4<br>        //[Enum(UnityEngine.Rendering.ColorWriteMask)]_ColorMask (&quot;ColorMask&quot;, Float) = 15<br><br>        //[Header(Stencil)]<br>        //[Enum(UnityEngine.Rendering.CompareFunction)]_StencilComp (&quot;Stencil Comparison&quot;, Float) = 8<br>        //[IntRange]_StencilWriteMask (&quot;Stencil Write Mask&quot;, Range(0,255)) = 255<br>        //[IntRange]_StencilReadMask (&quot;Stencil Read Mask&quot;, Range(0,255)) = 255<br>        //[IntRange]_Stencil (&quot;Stencil ID&quot;, Range(0,255)) = 0<br>        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilPass (&quot;Stencil Pass&quot;, Float) = 0<br>        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilFail (&quot;Stencil Fail&quot;, Float) = 0<br>        //[Enum(UnityEngine.Rendering.StencilOp)]_StencilZFail (&quot;Stencil ZFail&quot;, Float) = 0<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags<br>        &#123; <br>            &quot;RenderType&quot;=&quot;Transparent&quot;<br>            &quot;Queue&quot; = &quot;Transparent&quot;<br>        &#125;<br>        <br>        ZWrite [_ZWriteMode]<br>        ZTest [_ZTestMode]<br>        BlendOp [_BlendOp]<br>        Blend [_SrcBlend] [_DstBlend]<br>        Pass<br>        &#123;<br>            Name &quot;Alpha Clip&quot;<br>            Tags <br>            &#123; <br>                //&quot;LightMode&quot; = &quot;UniversalForward&quot;<br>                &quot;LightMode&quot; = &quot;UniversalForward&quot;<br>            &#125;<br><br>            HLSLPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;<br><br>            struct appdata<br>            &#123;<br>                float4 vertex : POSITION;<br>                float2 uv : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f<br>            &#123;<br>                float2 uv : TEXCOORD0;<br>                float4 vertex : SV_POSITION;<br>            &#125;;<br><br>            //SAMPLER(sampler_ScreenOffRT);<br>            //TEXTURE2D(_ScreenOffRT);<br>            //float4 _ScreenOffRT_ST;<br><br>            CBUFFER_START(UnityPerMaterial)<br>                SAMPLER(sampler_MainTex);<br>                TEXTURE2D(_MainTex);<br>                float4 _MainTex_ST, _MainColor;<br>                float4 _FlowSpecularColor, _NoiseColor;<br>                float _Alpha, _FlowVal, _FadeInTime;<br>                float _FadeOutKey, _FadeOutTime;<br>                int _ReverseDir;<br>            CBUFFER_END<br><br>            v2f vert (appdata v)<br>            &#123;<br>                v2f o;<br>                o.vertex = mul(UNITY_MATRIX_MVP,v.vertex);<br>                o.uv = TRANSFORM_TEX(v.uv,_MainTex);<br>                return o;<br>            &#125;<br><br>            half4 frag (v2f i) : SV_Target<br>            &#123;<br>                // sample the texture<br>                float flowUV = i.uv.x;<br>                if(_ReverseDir != 0)<br>                    flowUV = 1 - flowUV;<br>                //float val = i.uv.x;<br>                flowUV = flowUV + _FlowVal;<br>                float alphaFade = clamp((_FlowVal / _FadeInTime), 0 ,1);<br>                //flowUV *= _FlowVal;<br><br>                half4 mainCol = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, float2(flowUV,i.uv.y));<br>                float alpha = alphaFade * mainCol.a;<br>                alpha *= 1 - clamp( (_FlowVal - _FadeOutKey) / _FadeOutTime, 0, 1);<br>                clip(_Alpha - mainCol.a);<br>                <br>                float3 col = _FlowSpecularColor * mainCol.g;<br>                col += mainCol.r * _MainColor;<br>                col += _NoiseColor * mainCol.b;<br>                return half4(col, alpha);<br>                //return col * flowUV * alphaValByFlow;// * _FlowSpecularColor;<br>            &#125;<br><br>            ENDHLSL<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\r\n<p>主要思路就根据 uv.x 做渐入渐出和透明度的调整。</p>"},{"title":"关于透视矫正插值","math":true,"index_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","banner_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","date":"2024-04-14T13:28:59.442Z","typora-root-url":"../","_content":"\n把之前推导计算的透视矫正插值记录一下\n\n<!--more-->\n\n# 透视矫正插值\n\n首先我们要知道从 “**顶点着色器**” 到 “**片元着色器**” 需要经过 “**光栅化(Rasterization)**”\n而光栅化做的就是把三角形离散为一个一个片元，\n如果是对于一个三角形而言，我们能够通过重心坐标表示其中任意一点。\n\n## 重心坐标\n\n设有三角形 ABC，及内一点P\n\n所谓重心坐标就是，三角形内一点可以写作\n$$\nP=\\alpha A+\\beta B+\\gamma C\n$$\n如果 $(\\alpha + \\beta+\\gamma)==1$ 则点 **P** 在三角形内。\n\n* 为什么能用重心坐标表示一个点?\n\n* 因为假设一个点P在一条直线上，取直线上两点 AB，\n  P点的位置一定能由 $P=\\alpha A+\\beta B$ 表示，并且$\\alpha+\\beta==1$则 P 在 AB 之间。\n  而 三角形重心坐标 可以看作 先在 AB上寻找一点 $D=\\alpha_1 A+\\beta_1 B$, 而 点P 在线 CD 上，有 $P = \\alpha_2D+\\gamma C$.\n\n### 屏幕坐标和NDC空间坐标\n\n如何从 MVP 的 Vertex 到 ScreenPos\n\nNDC 是GPU为了方便图像处理的空间，x->[0,1] y->[0,1] z->[-1,1]/[0,1]\nxy是线性变化，其实还好，问题关键在于z\n\n### MVP 变换\n\nM 是 Object 自己的变化\n\nV 是 camra forwardVec 和 UpVec，推导 rightVec，根据正交矩阵性质，转置就是其逆\n\nP 是 View 到 ClipSpace， ClipSpace 后再经过齐次除法到 NDC 空间。\n\n再NDC空间后再进行光栅化。\n\n#### Projection Matrix\n\n$$\n\\begin{bmatrix}\n\\frac{near}{wid}&0&0&0\\\\\n0&\\frac{near}{height}&0&0\\\\\n0&0&\\frac{far}{near-far}&\\frac{near\\cdot far}{near-far}\\\\\n0&0&1&0\\\\\n\\end{bmatrix}\n$$\n\n其实矩阵变换是线性的，问题在于后面的齐次除法\n\n## Screen 插值\n\n我们首先要保证的是 Screen 上的点插值是正确的  \n因为我们只会对顶点进行齐次除法，而我们对于点P进行重心坐标插值时，三角形ABC都是经过齐次除法的，这没有问题，但是顶点中其他数据比如UV这种是没有经过齐次除法的。  \n所以根据屏幕点P的重心坐标，求经过矫正的插值：\n\n$$\n\\begin{aligned}\n\t&设屏幕上三角形点A_s、B_s、C_s\\\\\n\t&屏幕上三角形内一点P_s\\\\\n\t&对于点XY坐标而言有：\\\\\n\t&P_s = \\alpha A_s+\\beta B_s+\\gamma C_s\\\\\n\t&因为屏幕空间的点都是经过齐次除法的，且 Z 值是能够从[0,1]反向计算得到的\\\\\n\t&\\frac{P_p}{z_P}= \\alpha \\frac{A_p}{z_A}+\\beta \\frac{B_p}{z_B}+\\gamma \\frac{C_p}{z_C}\\\\\\\\\n\t& \\textbf{我们已知} A_s、B_s、C_s和点P_s;\\\\\\\\\n\t&也就是说P_s是Clip\\;Space的P_p投影变换得到\\\\\n\t&P_p =z_p( \\alpha \\frac{A_p}{z_A}+\\beta \\frac{B_p}{z_B}+\\gamma \\frac{C_p}{z_C})\n\t\\\\\n\t&且P_p,P_s \\;都在\\; \\triangle ABC内\\\\\n\t& \\alpha+\\beta+\\gamma=1\\\\\n\t&z_p( \\frac{\\alpha}{z_A}+\\frac{\\beta}{z_B}+\\frac{\\gamma }{z_C})=1\\\\\n\\end{aligned}\n$$\n\n所以能得到根据矫正插值和屏幕XY坐标计算的插值关系\n\n$$\n\\begin{aligned}\n\t&\\frac{z_p\\alpha}{z_A}=\\alpha_p,\\;\\frac{z_p\\beta}{z_B}=\\beta_p,\n\t\\frac{z_p\\gamma}{z_C}=\\gamma_p\\\\\n\t&P_p=\\alpha_pA_p+\\beta_pB_p+\\gamma_pC_p\\\\\n\t&但是z_p是未知的\\\\\n\t&\\frac{\\alpha_p}{\\beta_p}=\\frac{\\alpha z_B}{\\beta z_A}\\\\\n\t&得\\;\\;\\alpha_p=\\frac{\\alpha z_B}{\\beta z_A}\\beta_p\\\\\n\t&所以\\;\\;\\gamma_p=\\frac{\\gamma z_B}{\\beta z_C}\\beta_p\\\\\n\t&(\\frac{\\alpha z_B}{\\beta z_A}+\\frac{\\gamma z_B}{\\beta z_C}+1)\\beta_p=1\\\\\n\\end{aligned}\n$$\n\n能够得到透视矫正插值\n\n$$\n\\begin{aligned}\n(\\frac{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta z_Az_C}{\\beta z_Az_C})\\beta_p=1\\\\\n\\beta_p=\\frac{\\beta z_Az_C}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta z_Az_C}\\\\\n\\alpha_p=\\frac{\\alpha z_Bz_C}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta z_Az_C}\\\\\n\\gamma_p=\\frac{\\gamma z_Az_B}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta z_Az_C}\\\\\n\\end{aligned}\n$$\n\n对于 屏幕点P，我们知道其 XY 坐标，但是不知道该点在 Clip Space的实际位置，所以对于 顶点内数据都要进行透视矫正插值。\n\n## 参考\n\n[Latex 多行公式](https://matnoble.github.io/tech/latex/multi-line-equations/)\n","source":"_posts/关于透视矫正插值.md","raw":"---\ntitle: 关于透视矫正插值\ntags: 图形学\nmath: true\nindex_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\nbanner_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\ndate: 2024-04-14 --\ntypora-root-url: ../\n---\n\n把之前推导计算的透视矫正插值记录一下\n\n<!--more-->\n\n# 透视矫正插值\n\n首先我们要知道从 “**顶点着色器**” 到 “**片元着色器**” 需要经过 “**光栅化(Rasterization)**”\n而光栅化做的就是把三角形离散为一个一个片元，\n如果是对于一个三角形而言，我们能够通过重心坐标表示其中任意一点。\n\n## 重心坐标\n\n设有三角形 ABC，及内一点P\n\n所谓重心坐标就是，三角形内一点可以写作\n$$\nP=\\alpha A+\\beta B+\\gamma C\n$$\n如果 $(\\alpha + \\beta+\\gamma)==1$ 则点 **P** 在三角形内。\n\n* 为什么能用重心坐标表示一个点?\n\n* 因为假设一个点P在一条直线上，取直线上两点 AB，\n  P点的位置一定能由 $P=\\alpha A+\\beta B$ 表示，并且$\\alpha+\\beta==1$则 P 在 AB 之间。\n  而 三角形重心坐标 可以看作 先在 AB上寻找一点 $D=\\alpha_1 A+\\beta_1 B$, 而 点P 在线 CD 上，有 $P = \\alpha_2D+\\gamma C$.\n\n### 屏幕坐标和NDC空间坐标\n\n如何从 MVP 的 Vertex 到 ScreenPos\n\nNDC 是GPU为了方便图像处理的空间，x->[0,1] y->[0,1] z->[-1,1]/[0,1]\nxy是线性变化，其实还好，问题关键在于z\n\n### MVP 变换\n\nM 是 Object 自己的变化\n\nV 是 camra forwardVec 和 UpVec，推导 rightVec，根据正交矩阵性质，转置就是其逆\n\nP 是 View 到 ClipSpace， ClipSpace 后再经过齐次除法到 NDC 空间。\n\n再NDC空间后再进行光栅化。\n\n#### Projection Matrix\n\n$$\n\\begin{bmatrix}\n\\frac{near}{wid}&0&0&0\\\\\n0&\\frac{near}{height}&0&0\\\\\n0&0&\\frac{far}{near-far}&\\frac{near\\cdot far}{near-far}\\\\\n0&0&1&0\\\\\n\\end{bmatrix}\n$$\n\n其实矩阵变换是线性的，问题在于后面的齐次除法\n\n## Screen 插值\n\n我们首先要保证的是 Screen 上的点插值是正确的  \n因为我们只会对顶点进行齐次除法，而我们对于点P进行重心坐标插值时，三角形ABC都是经过齐次除法的，这没有问题，但是顶点中其他数据比如UV这种是没有经过齐次除法的。  \n所以根据屏幕点P的重心坐标，求经过矫正的插值：\n\n$$\n\\begin{aligned}\n\t&设屏幕上三角形点A_s、B_s、C_s\\\\\n\t&屏幕上三角形内一点P_s\\\\\n\t&对于点XY坐标而言有：\\\\\n\t&P_s = \\alpha A_s+\\beta B_s+\\gamma C_s\\\\\n\t&因为屏幕空间的点都是经过齐次除法的，且 Z 值是能够从[0,1]反向计算得到的\\\\\n\t&\\frac{P_p}{z_P}= \\alpha \\frac{A_p}{z_A}+\\beta \\frac{B_p}{z_B}+\\gamma \\frac{C_p}{z_C}\\\\\\\\\n\t& \\textbf{我们已知} A_s、B_s、C_s和点P_s;\\\\\\\\\n\t&也就是说P_s是Clip\\;Space的P_p投影变换得到\\\\\n\t&P_p =z_p( \\alpha \\frac{A_p}{z_A}+\\beta \\frac{B_p}{z_B}+\\gamma \\frac{C_p}{z_C})\n\t\\\\\n\t&且P_p,P_s \\;都在\\; \\triangle ABC内\\\\\n\t& \\alpha+\\beta+\\gamma=1\\\\\n\t&z_p( \\frac{\\alpha}{z_A}+\\frac{\\beta}{z_B}+\\frac{\\gamma }{z_C})=1\\\\\n\\end{aligned}\n$$\n\n所以能得到根据矫正插值和屏幕XY坐标计算的插值关系\n\n$$\n\\begin{aligned}\n\t&\\frac{z_p\\alpha}{z_A}=\\alpha_p,\\;\\frac{z_p\\beta}{z_B}=\\beta_p,\n\t\\frac{z_p\\gamma}{z_C}=\\gamma_p\\\\\n\t&P_p=\\alpha_pA_p+\\beta_pB_p+\\gamma_pC_p\\\\\n\t&但是z_p是未知的\\\\\n\t&\\frac{\\alpha_p}{\\beta_p}=\\frac{\\alpha z_B}{\\beta z_A}\\\\\n\t&得\\;\\;\\alpha_p=\\frac{\\alpha z_B}{\\beta z_A}\\beta_p\\\\\n\t&所以\\;\\;\\gamma_p=\\frac{\\gamma z_B}{\\beta z_C}\\beta_p\\\\\n\t&(\\frac{\\alpha z_B}{\\beta z_A}+\\frac{\\gamma z_B}{\\beta z_C}+1)\\beta_p=1\\\\\n\\end{aligned}\n$$\n\n能够得到透视矫正插值\n\n$$\n\\begin{aligned}\n(\\frac{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta z_Az_C}{\\beta z_Az_C})\\beta_p=1\\\\\n\\beta_p=\\frac{\\beta z_Az_C}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta z_Az_C}\\\\\n\\alpha_p=\\frac{\\alpha z_Bz_C}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta z_Az_C}\\\\\n\\gamma_p=\\frac{\\gamma z_Az_B}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta z_Az_C}\\\\\n\\end{aligned}\n$$\n\n对于 屏幕点P，我们知道其 XY 坐标，但是不知道该点在 Clip Space的实际位置，所以对于 顶点内数据都要进行透视矫正插值。\n\n## 参考\n\n[Latex 多行公式](https://matnoble.github.io/tech/latex/multi-line-equations/)\n","slug":"关于透视矫正插值","published":1,"updated":"2025-08-15T18:14:35.274Z","_id":"cme8ppti4000tbkbw8t92ge5a","comments":1,"layout":"post","photos":[],"link":"","content":"<p>把之前推导计算的透视矫正插值记录一下</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"透视矫正插值\">透视矫正插值</h1>\r\n<p>首先我们要知道从 “<strong>顶点着色器</strong>” 到\r\n“<strong>片元着色器</strong>” 需要经过\r\n“<strong>光栅化(Rasterization)</strong>”\r\n而光栅化做的就是把三角形离散为一个一个片元，\r\n如果是对于一个三角形而言，我们能够通过重心坐标表示其中任意一点。</p>\r\n<h2 id=\"重心坐标\">重心坐标</h2>\r\n<p>设有三角形 ABC，及内一点P</p>\r\n<p>所谓重心坐标就是，三角形内一点可以写作 <span class=\"math display\">\\[\r\nP=\\alpha A+\\beta B+\\gamma C\r\n\\]</span> 如果 <span class=\"math inline\">\\((\\alpha +\r\n\\beta+\\gamma)==1\\)</span> 则点 <strong>P</strong> 在三角形内。</p>\r\n<ul>\r\n<li><p>为什么能用重心坐标表示一个点?</p></li>\r\n<li><p>因为假设一个点P在一条直线上，取直线上两点 AB， P点的位置一定能由\r\n<span class=\"math inline\">\\(P=\\alpha A+\\beta B\\)</span> 表示，并且<span\r\nclass=\"math inline\">\\(\\alpha+\\beta==1\\)</span>则 P 在 AB 之间。 而\r\n三角形重心坐标 可以看作 先在 AB上寻找一点 <span\r\nclass=\"math inline\">\\(D=\\alpha_1 A+\\beta_1 B\\)</span>, 而 点P 在线 CD\r\n上，有 <span class=\"math inline\">\\(P = \\alpha_2D+\\gamma\r\nC\\)</span>.</p></li>\r\n</ul>\r\n<h3 id=\"屏幕坐标和ndc空间坐标\">屏幕坐标和NDC空间坐标</h3>\r\n<p>如何从 MVP 的 Vertex 到 ScreenPos</p>\r\n<p>NDC 是GPU为了方便图像处理的空间，x-&gt;[0,1] y-&gt;[0,1]\r\nz-&gt;[-1,1]/[0,1] xy是线性变化，其实还好，问题关键在于z</p>\r\n<h3 id=\"mvp-变换\">MVP 变换</h3>\r\n<p>M 是 Object 自己的变化</p>\r\n<p>V 是 camra forwardVec 和 UpVec，推导\r\nrightVec，根据正交矩阵性质，转置就是其逆</p>\r\n<p>P 是 View 到 ClipSpace， ClipSpace 后再经过齐次除法到 NDC 空间。</p>\r\n<p>再NDC空间后再进行光栅化。</p>\r\n<h4 id=\"projection-matrix\">Projection Matrix</h4>\r\n<p><span class=\"math display\">\\[\r\n\\begin{bmatrix}\r\n\\frac{near}{wid}&amp;0&amp;0&amp;0\\\\\r\n0&amp;\\frac{near}{height}&amp;0&amp;0\\\\\r\n0&amp;0&amp;\\frac{far}{near-far}&amp;\\frac{near\\cdot far}{near-far}\\\\\r\n0&amp;0&amp;1&amp;0\\\\\r\n\\end{bmatrix}\r\n\\]</span></p>\r\n<p>其实矩阵变换是线性的，问题在于后面的齐次除法</p>\r\n<h2 id=\"screen-插值\">Screen 插值</h2>\r\n<p>我们首先要保证的是 Screen 上的点插值是正确的<br />\r\n因为我们只会对顶点进行齐次除法，而我们对于点P进行重心坐标插值时，三角形ABC都是经过齐次除法的，这没有问题，但是顶点中其他数据比如UV这种是没有经过齐次除法的。<br />\r\n所以根据屏幕点P的重心坐标，求经过矫正的插值：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    &amp;设屏幕上三角形点A_s、B_s、C_s\\\\\r\n    &amp;屏幕上三角形内一点P_s\\\\\r\n    &amp;对于点XY坐标而言有：\\\\\r\n    &amp;P_s = \\alpha A_s+\\beta B_s+\\gamma C_s\\\\\r\n    &amp;因为屏幕空间的点都是经过齐次除法的，且 Z\r\n值是能够从[0,1]反向计算得到的\\\\\r\n    &amp;\\frac{P_p}{z_P}= \\alpha \\frac{A_p}{z_A}+\\beta\r\n\\frac{B_p}{z_B}+\\gamma \\frac{C_p}{z_C}\\\\\\\\\r\n    &amp; \\textbf{我们已知} A_s、B_s、C_s和点P_s;\\\\\\\\\r\n    &amp;也就是说P_s是Clip\\;Space的P_p投影变换得到\\\\\r\n    &amp;P_p =z_p( \\alpha \\frac{A_p}{z_A}+\\beta \\frac{B_p}{z_B}+\\gamma\r\n\\frac{C_p}{z_C})\r\n    \\\\\r\n    &amp;且P_p,P_s \\;都在\\; \\triangle ABC内\\\\\r\n    &amp; \\alpha+\\beta+\\gamma=1\\\\\r\n    &amp;z_p( \\frac{\\alpha}{z_A}+\\frac{\\beta}{z_B}+\\frac{\\gamma\r\n}{z_C})=1\\\\\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>所以能得到根据矫正插值和屏幕XY坐标计算的插值关系</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    &amp;\\frac{z_p\\alpha}{z_A}=\\alpha_p,\\;\\frac{z_p\\beta}{z_B}=\\beta_p,\r\n    \\frac{z_p\\gamma}{z_C}=\\gamma_p\\\\\r\n    &amp;P_p=\\alpha_pA_p+\\beta_pB_p+\\gamma_pC_p\\\\\r\n    &amp;但是z_p是未知的\\\\\r\n    &amp;\\frac{\\alpha_p}{\\beta_p}=\\frac{\\alpha z_B}{\\beta z_A}\\\\\r\n    &amp;得\\;\\;\\alpha_p=\\frac{\\alpha z_B}{\\beta z_A}\\beta_p\\\\\r\n    &amp;所以\\;\\;\\gamma_p=\\frac{\\gamma z_B}{\\beta z_C}\\beta_p\\\\\r\n    &amp;(\\frac{\\alpha z_B}{\\beta z_A}+\\frac{\\gamma z_B}{\\beta\r\nz_C}+1)\\beta_p=1\\\\\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>能够得到透视矫正插值</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n(\\frac{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta z_Az_C}{\\beta\r\nz_Az_C})\\beta_p=1\\\\\r\n\\beta_p=\\frac{\\beta z_Az_C}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta\r\nz_Az_C}\\\\\r\n\\alpha_p=\\frac{\\alpha z_Bz_C}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta\r\nz_Az_C}\\\\\r\n\\gamma_p=\\frac{\\gamma z_Az_B}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta\r\nz_Az_C}\\\\\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>对于 屏幕点P，我们知道其 XY 坐标，但是不知道该点在 Clip\r\nSpace的实际位置，所以对于 顶点内数据都要进行透视矫正插值。</p>\r\n<h2 id=\"参考\">参考</h2>\r\n<p><a\r\nhref=\"https://matnoble.github.io/tech/latex/multi-line-equations/\">Latex\r\n多行公式</a></p>\r\n","site":{"data":{}},"excerpt":"<p>把之前推导计算的透视矫正插值记录一下</p>","more":"<h1 id=\"透视矫正插值\">透视矫正插值</h1>\r\n<p>首先我们要知道从 “<strong>顶点着色器</strong>” 到\r\n“<strong>片元着色器</strong>” 需要经过\r\n“<strong>光栅化(Rasterization)</strong>”\r\n而光栅化做的就是把三角形离散为一个一个片元，\r\n如果是对于一个三角形而言，我们能够通过重心坐标表示其中任意一点。</p>\r\n<h2 id=\"重心坐标\">重心坐标</h2>\r\n<p>设有三角形 ABC，及内一点P</p>\r\n<p>所谓重心坐标就是，三角形内一点可以写作 <span class=\"math display\">\\[\r\nP=\\alpha A+\\beta B+\\gamma C\r\n\\]</span> 如果 <span class=\"math inline\">\\((\\alpha +\r\n\\beta+\\gamma)==1\\)</span> 则点 <strong>P</strong> 在三角形内。</p>\r\n<ul>\r\n<li><p>为什么能用重心坐标表示一个点?</p></li>\r\n<li><p>因为假设一个点P在一条直线上，取直线上两点 AB， P点的位置一定能由\r\n<span class=\"math inline\">\\(P=\\alpha A+\\beta B\\)</span> 表示，并且<span\r\nclass=\"math inline\">\\(\\alpha+\\beta==1\\)</span>则 P 在 AB 之间。 而\r\n三角形重心坐标 可以看作 先在 AB上寻找一点 <span\r\nclass=\"math inline\">\\(D=\\alpha_1 A+\\beta_1 B\\)</span>, 而 点P 在线 CD\r\n上，有 <span class=\"math inline\">\\(P = \\alpha_2D+\\gamma\r\nC\\)</span>.</p></li>\r\n</ul>\r\n<h3 id=\"屏幕坐标和ndc空间坐标\">屏幕坐标和NDC空间坐标</h3>\r\n<p>如何从 MVP 的 Vertex 到 ScreenPos</p>\r\n<p>NDC 是GPU为了方便图像处理的空间，x-&gt;[0,1] y-&gt;[0,1]\r\nz-&gt;[-1,1]/[0,1] xy是线性变化，其实还好，问题关键在于z</p>\r\n<h3 id=\"mvp-变换\">MVP 变换</h3>\r\n<p>M 是 Object 自己的变化</p>\r\n<p>V 是 camra forwardVec 和 UpVec，推导\r\nrightVec，根据正交矩阵性质，转置就是其逆</p>\r\n<p>P 是 View 到 ClipSpace， ClipSpace 后再经过齐次除法到 NDC 空间。</p>\r\n<p>再NDC空间后再进行光栅化。</p>\r\n<h4 id=\"projection-matrix\">Projection Matrix</h4>\r\n<p><span class=\"math display\">\\[\r\n\\begin{bmatrix}\r\n\\frac{near}{wid}&amp;0&amp;0&amp;0\\\\\r\n0&amp;\\frac{near}{height}&amp;0&amp;0\\\\\r\n0&amp;0&amp;\\frac{far}{near-far}&amp;\\frac{near\\cdot far}{near-far}\\\\\r\n0&amp;0&amp;1&amp;0\\\\\r\n\\end{bmatrix}\r\n\\]</span></p>\r\n<p>其实矩阵变换是线性的，问题在于后面的齐次除法</p>\r\n<h2 id=\"screen-插值\">Screen 插值</h2>\r\n<p>我们首先要保证的是 Screen 上的点插值是正确的<br />\r\n因为我们只会对顶点进行齐次除法，而我们对于点P进行重心坐标插值时，三角形ABC都是经过齐次除法的，这没有问题，但是顶点中其他数据比如UV这种是没有经过齐次除法的。<br />\r\n所以根据屏幕点P的重心坐标，求经过矫正的插值：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    &amp;设屏幕上三角形点A_s、B_s、C_s\\\\\r\n    &amp;屏幕上三角形内一点P_s\\\\\r\n    &amp;对于点XY坐标而言有：\\\\\r\n    &amp;P_s = \\alpha A_s+\\beta B_s+\\gamma C_s\\\\\r\n    &amp;因为屏幕空间的点都是经过齐次除法的，且 Z\r\n值是能够从[0,1]反向计算得到的\\\\\r\n    &amp;\\frac{P_p}{z_P}= \\alpha \\frac{A_p}{z_A}+\\beta\r\n\\frac{B_p}{z_B}+\\gamma \\frac{C_p}{z_C}\\\\\\\\\r\n    &amp; \\textbf{我们已知} A_s、B_s、C_s和点P_s;\\\\\\\\\r\n    &amp;也就是说P_s是Clip\\;Space的P_p投影变换得到\\\\\r\n    &amp;P_p =z_p( \\alpha \\frac{A_p}{z_A}+\\beta \\frac{B_p}{z_B}+\\gamma\r\n\\frac{C_p}{z_C})\r\n    \\\\\r\n    &amp;且P_p,P_s \\;都在\\; \\triangle ABC内\\\\\r\n    &amp; \\alpha+\\beta+\\gamma=1\\\\\r\n    &amp;z_p( \\frac{\\alpha}{z_A}+\\frac{\\beta}{z_B}+\\frac{\\gamma\r\n}{z_C})=1\\\\\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>所以能得到根据矫正插值和屏幕XY坐标计算的插值关系</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    &amp;\\frac{z_p\\alpha}{z_A}=\\alpha_p,\\;\\frac{z_p\\beta}{z_B}=\\beta_p,\r\n    \\frac{z_p\\gamma}{z_C}=\\gamma_p\\\\\r\n    &amp;P_p=\\alpha_pA_p+\\beta_pB_p+\\gamma_pC_p\\\\\r\n    &amp;但是z_p是未知的\\\\\r\n    &amp;\\frac{\\alpha_p}{\\beta_p}=\\frac{\\alpha z_B}{\\beta z_A}\\\\\r\n    &amp;得\\;\\;\\alpha_p=\\frac{\\alpha z_B}{\\beta z_A}\\beta_p\\\\\r\n    &amp;所以\\;\\;\\gamma_p=\\frac{\\gamma z_B}{\\beta z_C}\\beta_p\\\\\r\n    &amp;(\\frac{\\alpha z_B}{\\beta z_A}+\\frac{\\gamma z_B}{\\beta\r\nz_C}+1)\\beta_p=1\\\\\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>能够得到透视矫正插值</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n(\\frac{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta z_Az_C}{\\beta\r\nz_Az_C})\\beta_p=1\\\\\r\n\\beta_p=\\frac{\\beta z_Az_C}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta\r\nz_Az_C}\\\\\r\n\\alpha_p=\\frac{\\alpha z_Bz_C}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta\r\nz_Az_C}\\\\\r\n\\gamma_p=\\frac{\\gamma z_Az_B}{\\alpha z_Bz_C+\\gamma z_Az_B + \\beta\r\nz_Az_C}\\\\\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>对于 屏幕点P，我们知道其 XY 坐标，但是不知道该点在 Clip\r\nSpace的实际位置，所以对于 顶点内数据都要进行透视矫正插值。</p>\r\n<h2 id=\"参考\">参考</h2>\r\n<p><a\r\nhref=\"https://matnoble.github.io/tech/latex/multi-line-equations/\">Latex\r\n多行公式</a></p>"},{"title":"大气散射","date":"2023-11-04T16:00:00.000Z","math":true,"index_img":"/imgs/大气散射/Res01.png","banner_img":"/imgs/大气散射/Res02.png","typora-root-url":"../","_content":"\n\n\n# RayMarching:Atmospheric Scattering-RayleighScattering\n\n## Rayleigh Scattering\n\n一般的渲染都是在物体的一个表面上进行计算，而诸如半透明物体是光线和其内部结构相互作用造成的，还有比如皮肤的渲染，可以用 次表面散射去模拟这种效果。但是大气散射不是在表面上计算，是模拟光线透过大气会发生什么，也就是体积渲染。这里是学习 **体积单散射**，渲染实体半透明物体。\n## Single Scattering\n大多数游戏引擎的光线都是在真空传播，散射需要做的就是模拟光在空气介质中传播。\n## Out Scattering & In Scattering\n光和粒子最显著的现象就是粒子偏转光的方向，当一束光偏离 Camera 也就是外散射，偏离到 Camera 方向就是 **内散射**。\n\n<img src=\"/imgs/大气散射/OutScattering.png\">\n\n## **Volumetric Signle Scattering**\n\n实际上光可以反射/散射很多次，但是这需要大量计算，这里只是计算 **光的单次散射事件**。\n\n关键在于如何模拟光线穿过大气。 即从 A 到 B 的光如何受到散射的影响，因为 AB 上任一点 P 都可能会发生散射。\n\n![SingleScattering](/imgs/大气散射/SingleScattering.PNG)\n\n所以在计算每个点 P 有多少 Out Scattering时，第一步要先知道 P点 有多少光。假设所有光都来自太阳，一些会发生 in-Scattering，转向摄像机:\n\n![InScattering](/imgs/大气散射/InScattering.PNG)\n\n内散射到 P，从 P 到 A 散射，能够描述大部分散射情况，但实际上 P 点接收的光，是太阳射向P并经过 CP 路径的 out-scattering后的。\n\n![OutScattering2](/imgs/大气散射/OutScattering2.PNG)\n\n## **[需要做的]可公开的情报**\n\n- 摄像机的视线，从 A 出发，进入大气，并从 B 点离开。\n- 我们需要考虑每个点 P∈AB 的 in-scattering 和 out-scattering 贡献/影响。\n- P 点从太阳接收的光线\n- P 点经路径CP接受光，收到 out-scattering 的影响\n- P 点发生多少 in-scattering，使光线向相机方向。\n- 从 P 射向摄像机的光受到 out-scattering 影响偏离相机的视线。\n\n## **Transmittance Function**\n\n要计算传播到 Camera 的有多少光，那么所有的计算应该在光线从太阳出发开始；\n\n上图中光经过真空到达C点，其路径上没有其他物体影响，C点的光还没有散射； 设 C点的光量为 Ic，全部从太阳接收，从太阳真空传播过来，无散射影响。 经过路径CP，光线进入大气，和大气中的粒子发生散射，到达P的光量为 Ip(肯定小于Ic) 则 Ip和Ic的比率为 **transmittance**:\n\n$$ T(\\overline{CP})=\\frac{I_P}{I_C} $$\n\n![Trasmittance](/imgs/大气散射/Trasmittance.png)\n\n 可以用 transmittance 表示在 CP 路径上为散射的光量百分比，也就是经过 CP 后能到得到的光量。这个函数我们后面会进行更详细的推导。\n\n$$ I_P=I_CT(\\overline{CP}) $$\n\n## **Scattering Function**\n\n假设我们先不考虑 **Transmittance Function** *T*，然后我们得到了 P点的光量，我们现在需要考虑的就是在P点有多少光因为 scattering 偏转到 camera 方向。 也就是 **Scattering Function** *S*，目的是描述某点处，有多少光沿某个角度发生偏转。\n\n这里光的偏转角度为 θ，*S*(λ,θ,h) 的值表示沿theta偏转的光量比率。 受到波长，角度，高度的影响，高度是因为大气密度会随高度而改变。\n\n$$ I_{PA}=I_P*S(\\lambda,\\theta,h)*T(\\overline{PA})\\\\ I_{PA}=I_C*T(\\overline{CP})*S(\\lambda,\\theta,h)*T(\\overline{PA})\\\\ =\\underbrace{ I_C*S(\\lambda,\\theta,h)}_{in-scattering}*\\underbrace{T(\\overline{CP})*T(\\overline{PA})}_{out-scattering}\\\\ $$\n\n![ScatteringFunc](/imgs/大气散射/ScatteringFunc.png)\n\nS 计算折射到视线，T算的沿路径的损失，就是in-scattering 和 out-scattering\n\n## **Numerical Integration**\n\n看起来挺好，但可能你已经意识到了，这不太对吧，用 Ipa 表示 点P 传输到 A 的光量，但是刚才的公式并不能描述 A 所有接受到的光。 A接收的光应该是 P∈AB 所有点的累加贡献，我们应该计算 AB 上所有的点，这需要用到积分的思想，将AB划分为无数的微小段——ds，再进行累加，就是数值积分。\n\n$$ I_A=\\sum_{P\\in\\overline{AB}}I_{PA}ds $$\n\n![NumericalIntegration](/imgs/大气散射/NumericalIntegration.png)\n\n- 为什么要乘 ds 因为用 ds 中一个点 P0 代表所有这段上所有点的光线如何散射\n\n> 假设不划分，以 E 为 AB 每个点的光照散射结果，那么 IA = E * dis_AB\n\n## **Direcation Light**\n\n如果离太阳近可以建模点光源解决，不过通常我们都离太阳很远，而且这里最终目的是做山麓之间的那种大气散射，所有还是以 direction light 建模。 因此每个点接收相同数量的光，且方向保持不变。\n\n现在可以对 IC 进行简化。\n\n$$ I_A=\\sum_{P\\in\\overline{AB}}I_{PA}ds\\\\\\ =\\sum_{P\\in\\overline{AB}}I_C*S(\\lambda,\\theta,h)*T(\\overline{CP})*T(\\overline{PA})ds\\\\ =I_S\\sum_{P\\in\\overline{AB}}S(\\lambda,\\theta,h)*T(\\overline{CP})*T(\\overline{PA})ds\\\\ $$\n\n![DirectionLight](/imgs/大气散射/DirectionLight.png)\n\n> 如果这里阳光和camera 都不动，theta 固定，甚至还可以优化\n\n## **Absorption Coefficient**\n\n> 在描述光和空气分子之间相互作用的可能结果时，我们只介绍了两个。直接通过，或偏转。还有第三种可能。一些化合物吸收光。地球上的大气中有很多具有这种特性的化学物质。例如，臭氧存在于高等大气中，并且已知对紫外线有强烈反应。然而，它的存在对天空的颜色几乎没有影响，因为它吸收了可见光谱之外的光。在地球上，吸光化学物质的贡献往往被忽视。 在地球上，吸光化学物质的贡献往往被忽视。其他行星不能这样做。例如，海王星和天王星的典型颜色是由大气中大量存在的甲烷引起的。甲烷以吸收红光而闻名，导致蓝色色调。在本教程的其余部分，我们将忽略吸收系数，尽管我们将添加一种为大气着色的方法。\n\n## **Scattering Model**\n\n模拟大气散射现象是十分复杂的，几乎没有一个完美的模型去描述。 通常使用两种模型 : **Rayleigh scattering** 和 **Mie scattering**. Rayleigh Scattering 描述光和微小粒子的散射，比如空气，氧、氮分子。 Mie Scattering 描述的是光的波长和粒子大小相近的散射情况，比如用 Mie scattering 画太阳，花粉、粉尘、污染物。\n\nRayleigh Scattering 导致天空是蓝的，日落是红的，Mie Scattering 导致云是白的。\n\n## **Rayleigh Scattering**\n\n需要明确的一点是 Rayleigh Scattering 只能描述粒子小于光的波长。 当光子撞击到粒子后，因为粒子足够小，主要有两部分光，一部分不受影响继续传播，一部分以相反方向反射回来，其他可能沿其他方向传播，不过因为光的方向导致其不太可能沿 90° 。\n\n> 可以想象一个胖人去撞一个比较瘦的人，或者撞一根很细的柱子\n\n![RayleighScattering](/imgs/大气散射/RayleighScattering.png)\n\n其 **Rayleigh scattering equation**\n\n$$ I=I_0S(\\lambda,\\theta,h)\\\\ S(\\lambda,\\theta,h)=\\frac{\\pi^2(n^2-1)^2}{2}\\underbrace{\\frac{\\rho(h)}{N}}_{density}\\overbrace{\\frac{1}{\\lambda^4}}^{wavelength}\\underbrace{(1+\\cos^2\\theta)}_{geometry} $$\n\n- λ: the **wavelength** of the incoming light;\n- θ : the **scattering angle**;\n- h : the **altitude** of the point;\n- n=1.00029 : the **refractive index** of air;(空气的**折射率**)\n- : the **molecular number density** of the standard atmosphere. This is the number of molecules per cubic metre;(标准大气的**分子数密度**。这是每立方米的分子数;)\n- : the **density ratio**. This number is equal to \n-  at sea level, and decreases exponentially with \n- . There is a lot to say about this function, and we will do it in a future post of this series.(**密度比**。 此数字等于海平面1时的数字，后面细嗦)\n\n该方程来自：[nishitalab.org/user/nis/cdrom/sig93_nis.pdf](http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf)\n\n![chart](/imgs/大气散射/chart.png)\n\n- 某些方向比其他方向接收更多光\n- 散射的光量多少受光波长的影响，波长越长越少，红少蓝多(所以天是蓝的)\n\n## **Rayleigh Scattering Coefficient**\n\n前面的Rayleigh 只描述了散射的方向，但是没有描述某一点散射现象的能量衰减。要考虑能量的损失，我们得考虑各个方向上的光能的散射。 很简单对相位函数做积分即可，不过记得这是一个三维空间，不是二维的可别在 [0,2pi] 积分。\n\n$$ \\beta(\\lambda,h)=\\int_0^{2\\pi}\\int_0^\\pi S(\\lambda,\\theta,h)\\sin\\theta d\\theta d\\phi\\\\ =\\int_0^{2\\pi}\\int_0^\\pi\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\sin\\theta d\\theta d\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\int_0^\\pi(1+\\cos^2\\theta)\\sin\\theta d\\theta d\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\int_0^\\pi(\\sin\\theta+\\sin\\theta\\cos^2\\theta) d\\theta d\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}(\\cos0+\\frac{\\cos0}{3}-\\cos\\pi-\\frac{\\cos^3\\pi}{3})d\\phi\\\\ =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\frac{8\\pi}{3}d\\phi\\\\ =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\frac{16\\pi}{3}\\\\ =\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\ \\\\  \\beta(\\lambda,h)  =\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\$$\n\n所以能量的散射受波长和海拔高度的影响。\n\n![chart2](/imgs/大气散射/chart2.png)\n\n所以地球大气分子会更多反射蓝光，所以当傍晚时，光线要经过更多大气，传播时间更长，所有的蓝光基本都被散射，我们观察到的就是红色的天空。 而白天天空为什么是蓝色的，首先，白天我们观察时日光方向基本固定，因为蓝色更容易发生散射，在空中蓝色光波被散射到四面八方，我们观察天空接收到的自然也就是蓝光。\n\n## **Rayleigh Phase Function**\n\n关于 Rayleigh Scattering Equation 可以分解为两个部分，一部分是 Rayleig Scattering Coefficient，也就是刚刚推导的；另一部分是 Geometry of Scattering，并控制其反射方向。 \n\n$$ S(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta)\\\\ \\gamma(\\theta)=\\frac{S(\\lambda,\\theta,h)}{\\beta(\\lambda,h)}=\\\\ \\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\frac{3}{8\\pi^3(n^2-1)^2}\\frac{N}{\\rho(h)}\\lambda^4=\\\\ \\frac{3}{16\\pi}(1+\\cos^2\\theta) $$\n\n## **[可公开的情报]**\n\n- **Rayleigh Scattering Equation** 描述在某方向的光偏转比率\n\n$$ S(\\lambda,\\theta,h)=\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\\\ S(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta) $$\n\n- **Rayleigh Scattering Coefficient** 在某点发生散射后，多少比例的能量损失情况\n\n$$ \\beta(\\lambda,h)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\ $$\n\n- **Rayleigh Scattering Coefficient in Sea level**\n- $$ \\beta(\\lambda,0)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{1}{N}\\frac{1}{\\lambda^4}\\\\ $$\n\n- **Rayleigh Scattering Phase Function** 描述散射的形状，在特定方向光的损失相对比率。\n- $$ \\gamma(\\theta)=\\frac{3}{16\\pi}(1+\\cos^2\\theta) $$\n\n- **Density ratio** 模拟大气密度的函数\n- $$ \\rho(h)=\\exp(\\frac{h}{H}) $$\n\nH = 8500 是 scale heigh\n\n## **Atmospheric Density Ratio**\n\n当大气密度越大时大气中粒子越多，会有更多的散射现象发生。 大气密度和高度示意图：\n\n![height](/imgs/大气散射/height.png)\n\nH 为 Scale Height，通常取 8500\n\n## **Exponential Decay**\n\n我们前面的得到了 **scattering coefficient** *β*，我们有能求得解析解的 close form 函数\n\n$$ \\beta(\\lambda,h)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\ $$\n\n上式描述了**光和粒子单次散射后**光量损失的比例。\n\n现在假设如果初始光量为 I0，然后以衰减系数为β，经过大气中粒子的一次散射后所剩的光量会是：**(这里的β不是*****β(λ,h)*****,而是鉴定穿过一部分大气后的衰减系数)**\n\n$$ I_1=\\underbrace{I_0}_{initial\\;energy}-\\underbrace{I_0\\beta}_{energy\\;lost}=(1-\\beta)I_0 $$\n\n但这只适用于一次散射/单次散射碰撞，我们希望求得**在一均匀介质中**，传播一定距离后光的衰减： 假设我们将这个过程分为两次散射看待，考虑两次散射：**(这里的β不是*****β(λ,h)*****,而是鉴定穿过一部分大气后的衰减系数)**\n\n$$ First\\;Scattering\\;:\\;I_1=I_0(1-\\beta\\frac{S}{2})\\\\ Second\\;Scattering\\;:\\;I_2=I_1(1-\\beta\\frac{S}{2})=I_0(1-\\beta\\frac{S}{2})^2\\\\ About\\;N\\;Scattering\\;:\\;I=\\lim_{n\\rightarrow\\infty}I_0(1-\\beta\\frac{S}{n})^n=\\exp\\{-\\beta S\\} $$\n\n## **Uniform Transmittance**\n\n**transmittance** T 描述了光量穿越大气时经过散射所剩余的光量比例。\n\n![OutScattering2](/imgs/大气散射/OutScattering2.PNG)\n\n根据刚才的欧拉数推导我们能写出一个 P位置光量\n\n$$ I_P=I_S\\exp\\{-\\beta\\overline{CP}\\}\\\\ \\overline{CP}:\\;distance \\; of \\; CP $$\n\n但实际上CP中的散射系数β不是一个均匀值 我们延续前面类似的思路，将CP分为两段CQ，QP\n\n![Trasmittance2](/imgs/大气散射/Trasmittance2.png)\n\n$$ I_Q=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}\\}\\\\ I_P=I_Q\\exp\\{-\\beta(\\lambda,h_1)\\overline{QP}\\}\\\\ I_P=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}\\}\\exp\\{-\\beta(\\lambda,h_1)\\overline{QP}\\}\\\\ I_P=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}-\\beta(\\lambda,h_1)\\overline{QP}\\} $$\n\n如果CQ和QP长度相同还可以再次简化，那不妨设其相同且为 ***ds*** (方便后面采用积分思想推导)\n\n$$ I_P=I_S\\exp\\{-(\\beta(\\lambda,h_0)+\\beta(\\lambda,h_1))ds\\} $$\n\n延续该思路我们可以将 CP 段化为无数等长的小段，累加这个过程,也就是数值积分\n\n$$ I_P=I_S\\exp\\{-\\sum_{Q\\in\\overline{CP}}\\beta(\\lambda,h_Q)ds\\} $$\n\n将 Rayleigh Scattering 带入\n\n$$ T(\\overline{CP})=I_S\\exp\\{-\\sum_{Q\\in\\overline{CP}}\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h_Q)}{N}\\frac{1}{\\lambda^4}ds\\}\\\\ =\\underbrace{-\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{1}{N}\\frac{1}{\\lambda^4}}_{constant\\;\\beta(\\lambda)}\\overbrace{\\sum_{Q\\in\\overline{CP}}\\rho(h_Q)ds}^{optical\\;depth\\;D(\\overline{CP})}\\\\ $$\n\n求和部分为 Optical Depth ，需要我们在 shader 中计算，其他都是常数。\n\n$$ T(\\overline{CP})=\\exp\\{-\\beta(\\lambda)D(\\overline{CP})\\} $$\n\n## **Intersecting the Atmosphere**\n\n> 这个教程是渲染星球的\n\n所以其要求 AB 的 optical depth，其中 O 点是大气层表面一点也就是我们的 fragment\n\n![math](/imgs/大气散射/math.png)\n\nD 是 camera 的视线方向，L外壳半径，R大气半径\n\n$$ A=O+D\\overline{OA}\\\\ B=O+D\\overline{OB}\\\\ \\overline{OA}=\\overline{OT}-\\overline{AT}\\\\ \\overline{OB}=\\overline{OT}+\\overline{TB}\\\\ \\overline{AT}=\\overline{TB}\\\\ \\overline{OT}=(C-O)\\cdot D=L\\cdot D\\\\ R^2=(\\overline{CT})^2+(\\overline{AT})^2\\\\ (\\overline{CT})^2=L^2-(\\overline{OT})^2\\\\ (\\overline{AT})^2=R^2-(\\overline{CT})^2 $$\n\n如果 CT 大于 R 则无解\n\n### **Colliding with the Planet**\n\n和 plant 相交 只需要按和大气球求交点再求一次和plant球的交点即可 如果有解则 大气的 B点要改为 plant 的A点\n\n![math2](/imgs/大气散射/math2.png)\n\n## **Sampling the View Ray**\n\n$$ I=I_S\\sum_{P\\in AB}S(\\lambda,\\theta,h)T(\\overline{CP})T(\\overline{PA})ds\\\\\\\\ Decompose \\;S(\\lambda,\\theta,h):\\\\ S(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta)=\\beta(\\lambda)\\rho(h)\\gamma(\\theta)\\\\ \\beta(\\lambda)=\\frac{8\\pi^3(n^2-1)^2}{3N\\lambda^4}\\\\ \\rho(h)=\\exp\\{-\\frac{h}{H}\\}\\\\ \\gamma(\\theta)=\\frac{3}{16\\pi}(1+\\cos^2(\\theta))\\\\ We\\;get:I=I_S\\beta(\\lambda)\\gamma(\\theta)\\sum_{P\\in AB}\\underbrace{T(\\overline{CP})T(\\overline{PA})\\rho(h_P)ds}_{light\\;contribution\\;of\\;L(P)}\\\\ $$\n\n$$ For\\;T(\\overline{Dis}):\\\\ T(\\overline{CP})T(\\overline{PA})=\\exp\\{-\\beta(\\lambda)D(\\overline{CP})\\}\\exp\\{-\\beta(\\lambda)D(\\overline{PA})\\}\\\\ =\\exp\\{-\\beta(\\lambda)(D(\\overline{CP})+D(\\overline{PA}))\\}\\\\ D(\\overline{CP})=\\sum_{Q\\in CP}\\exp\\{-\\frac{h_Q}{H}\\}dt\\\\ D(\\overline{PA})=\\sum_{Q\\in AP}\\exp\\{-\\frac{h_P}{H}\\}dx\\\\\\\\ I=I_S\\beta(\\lambda)\\gamma(\\theta)\\sum_{P\\in AB}\\underbrace{T(\\overline{CP})T(\\overline{PA})\\rho(h)ds}_{light\\;contribution\\;of\\;L(P)}\\\\ $$\n\n$$ \\sum_{P\\in AB}T(\\overline{CP})T(\\overline{PA})\\rho(h_P)ds=\\sum_{P\\in AB}\\rho(h_P)\\exp\\{-\\beta(\\lambda)(D(\\overline{CP})+D(\\overline{PA}))\\}ds\\\\ 实际上 D(\\overline{PA}) 可以在最外层循环\\sum_{P\\in AB}做累加,\\\\ 不必每次在里面的循环做，即不必每次从A开始累加 $$\n\n## **[To Do]Mie Scattering**\n\n和波长无关，只和粒子大小相干\n\n$$ phase\\;function:\\\\ S(\\theta)= \\frac{1}{4\\pi}\\frac{3(1-g^2)}{(1-2g\\cos\\theta+g^2)^{\\frac{3}{2}}}\\\\ or:S(\\theta)=\\frac{3}{8\\pi}\\frac{1-g^2}{2+g^2}\\frac{1+\\cos^2\\theta}{(1-2g\\cos\\theta+g^2)^{\\frac{3}{2}}} $$\n\n# 待更新\n\n我们知道了基本的计算思路，但是实际实现还有所不同，后面陆续更新","source":"_posts/大气散射.md","raw":"---\ntitle: 大气散射\ndate: 2023-11-05\ntags: 图形学\nmath: true\nindex_img: /imgs/大气散射/Res01.png\nbanner_img: /imgs/大气散射/Res02.png\ntypora-root-url: ../\n---\n\n\n\n# RayMarching:Atmospheric Scattering-RayleighScattering\n\n## Rayleigh Scattering\n\n一般的渲染都是在物体的一个表面上进行计算，而诸如半透明物体是光线和其内部结构相互作用造成的，还有比如皮肤的渲染，可以用 次表面散射去模拟这种效果。但是大气散射不是在表面上计算，是模拟光线透过大气会发生什么，也就是体积渲染。这里是学习 **体积单散射**，渲染实体半透明物体。\n## Single Scattering\n大多数游戏引擎的光线都是在真空传播，散射需要做的就是模拟光在空气介质中传播。\n## Out Scattering & In Scattering\n光和粒子最显著的现象就是粒子偏转光的方向，当一束光偏离 Camera 也就是外散射，偏离到 Camera 方向就是 **内散射**。\n\n<img src=\"/imgs/大气散射/OutScattering.png\">\n\n## **Volumetric Signle Scattering**\n\n实际上光可以反射/散射很多次，但是这需要大量计算，这里只是计算 **光的单次散射事件**。\n\n关键在于如何模拟光线穿过大气。 即从 A 到 B 的光如何受到散射的影响，因为 AB 上任一点 P 都可能会发生散射。\n\n![SingleScattering](/imgs/大气散射/SingleScattering.PNG)\n\n所以在计算每个点 P 有多少 Out Scattering时，第一步要先知道 P点 有多少光。假设所有光都来自太阳，一些会发生 in-Scattering，转向摄像机:\n\n![InScattering](/imgs/大气散射/InScattering.PNG)\n\n内散射到 P，从 P 到 A 散射，能够描述大部分散射情况，但实际上 P 点接收的光，是太阳射向P并经过 CP 路径的 out-scattering后的。\n\n![OutScattering2](/imgs/大气散射/OutScattering2.PNG)\n\n## **[需要做的]可公开的情报**\n\n- 摄像机的视线，从 A 出发，进入大气，并从 B 点离开。\n- 我们需要考虑每个点 P∈AB 的 in-scattering 和 out-scattering 贡献/影响。\n- P 点从太阳接收的光线\n- P 点经路径CP接受光，收到 out-scattering 的影响\n- P 点发生多少 in-scattering，使光线向相机方向。\n- 从 P 射向摄像机的光受到 out-scattering 影响偏离相机的视线。\n\n## **Transmittance Function**\n\n要计算传播到 Camera 的有多少光，那么所有的计算应该在光线从太阳出发开始；\n\n上图中光经过真空到达C点，其路径上没有其他物体影响，C点的光还没有散射； 设 C点的光量为 Ic，全部从太阳接收，从太阳真空传播过来，无散射影响。 经过路径CP，光线进入大气，和大气中的粒子发生散射，到达P的光量为 Ip(肯定小于Ic) 则 Ip和Ic的比率为 **transmittance**:\n\n$$ T(\\overline{CP})=\\frac{I_P}{I_C} $$\n\n![Trasmittance](/imgs/大气散射/Trasmittance.png)\n\n 可以用 transmittance 表示在 CP 路径上为散射的光量百分比，也就是经过 CP 后能到得到的光量。这个函数我们后面会进行更详细的推导。\n\n$$ I_P=I_CT(\\overline{CP}) $$\n\n## **Scattering Function**\n\n假设我们先不考虑 **Transmittance Function** *T*，然后我们得到了 P点的光量，我们现在需要考虑的就是在P点有多少光因为 scattering 偏转到 camera 方向。 也就是 **Scattering Function** *S*，目的是描述某点处，有多少光沿某个角度发生偏转。\n\n这里光的偏转角度为 θ，*S*(λ,θ,h) 的值表示沿theta偏转的光量比率。 受到波长，角度，高度的影响，高度是因为大气密度会随高度而改变。\n\n$$ I_{PA}=I_P*S(\\lambda,\\theta,h)*T(\\overline{PA})\\\\ I_{PA}=I_C*T(\\overline{CP})*S(\\lambda,\\theta,h)*T(\\overline{PA})\\\\ =\\underbrace{ I_C*S(\\lambda,\\theta,h)}_{in-scattering}*\\underbrace{T(\\overline{CP})*T(\\overline{PA})}_{out-scattering}\\\\ $$\n\n![ScatteringFunc](/imgs/大气散射/ScatteringFunc.png)\n\nS 计算折射到视线，T算的沿路径的损失，就是in-scattering 和 out-scattering\n\n## **Numerical Integration**\n\n看起来挺好，但可能你已经意识到了，这不太对吧，用 Ipa 表示 点P 传输到 A 的光量，但是刚才的公式并不能描述 A 所有接受到的光。 A接收的光应该是 P∈AB 所有点的累加贡献，我们应该计算 AB 上所有的点，这需要用到积分的思想，将AB划分为无数的微小段——ds，再进行累加，就是数值积分。\n\n$$ I_A=\\sum_{P\\in\\overline{AB}}I_{PA}ds $$\n\n![NumericalIntegration](/imgs/大气散射/NumericalIntegration.png)\n\n- 为什么要乘 ds 因为用 ds 中一个点 P0 代表所有这段上所有点的光线如何散射\n\n> 假设不划分，以 E 为 AB 每个点的光照散射结果，那么 IA = E * dis_AB\n\n## **Direcation Light**\n\n如果离太阳近可以建模点光源解决，不过通常我们都离太阳很远，而且这里最终目的是做山麓之间的那种大气散射，所有还是以 direction light 建模。 因此每个点接收相同数量的光，且方向保持不变。\n\n现在可以对 IC 进行简化。\n\n$$ I_A=\\sum_{P\\in\\overline{AB}}I_{PA}ds\\\\\\ =\\sum_{P\\in\\overline{AB}}I_C*S(\\lambda,\\theta,h)*T(\\overline{CP})*T(\\overline{PA})ds\\\\ =I_S\\sum_{P\\in\\overline{AB}}S(\\lambda,\\theta,h)*T(\\overline{CP})*T(\\overline{PA})ds\\\\ $$\n\n![DirectionLight](/imgs/大气散射/DirectionLight.png)\n\n> 如果这里阳光和camera 都不动，theta 固定，甚至还可以优化\n\n## **Absorption Coefficient**\n\n> 在描述光和空气分子之间相互作用的可能结果时，我们只介绍了两个。直接通过，或偏转。还有第三种可能。一些化合物吸收光。地球上的大气中有很多具有这种特性的化学物质。例如，臭氧存在于高等大气中，并且已知对紫外线有强烈反应。然而，它的存在对天空的颜色几乎没有影响，因为它吸收了可见光谱之外的光。在地球上，吸光化学物质的贡献往往被忽视。 在地球上，吸光化学物质的贡献往往被忽视。其他行星不能这样做。例如，海王星和天王星的典型颜色是由大气中大量存在的甲烷引起的。甲烷以吸收红光而闻名，导致蓝色色调。在本教程的其余部分，我们将忽略吸收系数，尽管我们将添加一种为大气着色的方法。\n\n## **Scattering Model**\n\n模拟大气散射现象是十分复杂的，几乎没有一个完美的模型去描述。 通常使用两种模型 : **Rayleigh scattering** 和 **Mie scattering**. Rayleigh Scattering 描述光和微小粒子的散射，比如空气，氧、氮分子。 Mie Scattering 描述的是光的波长和粒子大小相近的散射情况，比如用 Mie scattering 画太阳，花粉、粉尘、污染物。\n\nRayleigh Scattering 导致天空是蓝的，日落是红的，Mie Scattering 导致云是白的。\n\n## **Rayleigh Scattering**\n\n需要明确的一点是 Rayleigh Scattering 只能描述粒子小于光的波长。 当光子撞击到粒子后，因为粒子足够小，主要有两部分光，一部分不受影响继续传播，一部分以相反方向反射回来，其他可能沿其他方向传播，不过因为光的方向导致其不太可能沿 90° 。\n\n> 可以想象一个胖人去撞一个比较瘦的人，或者撞一根很细的柱子\n\n![RayleighScattering](/imgs/大气散射/RayleighScattering.png)\n\n其 **Rayleigh scattering equation**\n\n$$ I=I_0S(\\lambda,\\theta,h)\\\\ S(\\lambda,\\theta,h)=\\frac{\\pi^2(n^2-1)^2}{2}\\underbrace{\\frac{\\rho(h)}{N}}_{density}\\overbrace{\\frac{1}{\\lambda^4}}^{wavelength}\\underbrace{(1+\\cos^2\\theta)}_{geometry} $$\n\n- λ: the **wavelength** of the incoming light;\n- θ : the **scattering angle**;\n- h : the **altitude** of the point;\n- n=1.00029 : the **refractive index** of air;(空气的**折射率**)\n- : the **molecular number density** of the standard atmosphere. This is the number of molecules per cubic metre;(标准大气的**分子数密度**。这是每立方米的分子数;)\n- : the **density ratio**. This number is equal to \n-  at sea level, and decreases exponentially with \n- . There is a lot to say about this function, and we will do it in a future post of this series.(**密度比**。 此数字等于海平面1时的数字，后面细嗦)\n\n该方程来自：[nishitalab.org/user/nis/cdrom/sig93_nis.pdf](http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf)\n\n![chart](/imgs/大气散射/chart.png)\n\n- 某些方向比其他方向接收更多光\n- 散射的光量多少受光波长的影响，波长越长越少，红少蓝多(所以天是蓝的)\n\n## **Rayleigh Scattering Coefficient**\n\n前面的Rayleigh 只描述了散射的方向，但是没有描述某一点散射现象的能量衰减。要考虑能量的损失，我们得考虑各个方向上的光能的散射。 很简单对相位函数做积分即可，不过记得这是一个三维空间，不是二维的可别在 [0,2pi] 积分。\n\n$$ \\beta(\\lambda,h)=\\int_0^{2\\pi}\\int_0^\\pi S(\\lambda,\\theta,h)\\sin\\theta d\\theta d\\phi\\\\ =\\int_0^{2\\pi}\\int_0^\\pi\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\sin\\theta d\\theta d\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\int_0^\\pi(1+\\cos^2\\theta)\\sin\\theta d\\theta d\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\int_0^\\pi(\\sin\\theta+\\sin\\theta\\cos^2\\theta) d\\theta d\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}(\\cos0+\\frac{\\cos0}{3}-\\cos\\pi-\\frac{\\cos^3\\pi}{3})d\\phi\\\\ =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\frac{8\\pi}{3}d\\phi\\\\ =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\frac{16\\pi}{3}\\\\ =\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\ \\\\  \\beta(\\lambda,h)  =\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\$$\n\n所以能量的散射受波长和海拔高度的影响。\n\n![chart2](/imgs/大气散射/chart2.png)\n\n所以地球大气分子会更多反射蓝光，所以当傍晚时，光线要经过更多大气，传播时间更长，所有的蓝光基本都被散射，我们观察到的就是红色的天空。 而白天天空为什么是蓝色的，首先，白天我们观察时日光方向基本固定，因为蓝色更容易发生散射，在空中蓝色光波被散射到四面八方，我们观察天空接收到的自然也就是蓝光。\n\n## **Rayleigh Phase Function**\n\n关于 Rayleigh Scattering Equation 可以分解为两个部分，一部分是 Rayleig Scattering Coefficient，也就是刚刚推导的；另一部分是 Geometry of Scattering，并控制其反射方向。 \n\n$$ S(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta)\\\\ \\gamma(\\theta)=\\frac{S(\\lambda,\\theta,h)}{\\beta(\\lambda,h)}=\\\\ \\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\frac{3}{8\\pi^3(n^2-1)^2}\\frac{N}{\\rho(h)}\\lambda^4=\\\\ \\frac{3}{16\\pi}(1+\\cos^2\\theta) $$\n\n## **[可公开的情报]**\n\n- **Rayleigh Scattering Equation** 描述在某方向的光偏转比率\n\n$$ S(\\lambda,\\theta,h)=\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\\\ S(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta) $$\n\n- **Rayleigh Scattering Coefficient** 在某点发生散射后，多少比例的能量损失情况\n\n$$ \\beta(\\lambda,h)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\ $$\n\n- **Rayleigh Scattering Coefficient in Sea level**\n- $$ \\beta(\\lambda,0)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{1}{N}\\frac{1}{\\lambda^4}\\\\ $$\n\n- **Rayleigh Scattering Phase Function** 描述散射的形状，在特定方向光的损失相对比率。\n- $$ \\gamma(\\theta)=\\frac{3}{16\\pi}(1+\\cos^2\\theta) $$\n\n- **Density ratio** 模拟大气密度的函数\n- $$ \\rho(h)=\\exp(\\frac{h}{H}) $$\n\nH = 8500 是 scale heigh\n\n## **Atmospheric Density Ratio**\n\n当大气密度越大时大气中粒子越多，会有更多的散射现象发生。 大气密度和高度示意图：\n\n![height](/imgs/大气散射/height.png)\n\nH 为 Scale Height，通常取 8500\n\n## **Exponential Decay**\n\n我们前面的得到了 **scattering coefficient** *β*，我们有能求得解析解的 close form 函数\n\n$$ \\beta(\\lambda,h)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\ $$\n\n上式描述了**光和粒子单次散射后**光量损失的比例。\n\n现在假设如果初始光量为 I0，然后以衰减系数为β，经过大气中粒子的一次散射后所剩的光量会是：**(这里的β不是*****β(λ,h)*****,而是鉴定穿过一部分大气后的衰减系数)**\n\n$$ I_1=\\underbrace{I_0}_{initial\\;energy}-\\underbrace{I_0\\beta}_{energy\\;lost}=(1-\\beta)I_0 $$\n\n但这只适用于一次散射/单次散射碰撞，我们希望求得**在一均匀介质中**，传播一定距离后光的衰减： 假设我们将这个过程分为两次散射看待，考虑两次散射：**(这里的β不是*****β(λ,h)*****,而是鉴定穿过一部分大气后的衰减系数)**\n\n$$ First\\;Scattering\\;:\\;I_1=I_0(1-\\beta\\frac{S}{2})\\\\ Second\\;Scattering\\;:\\;I_2=I_1(1-\\beta\\frac{S}{2})=I_0(1-\\beta\\frac{S}{2})^2\\\\ About\\;N\\;Scattering\\;:\\;I=\\lim_{n\\rightarrow\\infty}I_0(1-\\beta\\frac{S}{n})^n=\\exp\\{-\\beta S\\} $$\n\n## **Uniform Transmittance**\n\n**transmittance** T 描述了光量穿越大气时经过散射所剩余的光量比例。\n\n![OutScattering2](/imgs/大气散射/OutScattering2.PNG)\n\n根据刚才的欧拉数推导我们能写出一个 P位置光量\n\n$$ I_P=I_S\\exp\\{-\\beta\\overline{CP}\\}\\\\ \\overline{CP}:\\;distance \\; of \\; CP $$\n\n但实际上CP中的散射系数β不是一个均匀值 我们延续前面类似的思路，将CP分为两段CQ，QP\n\n![Trasmittance2](/imgs/大气散射/Trasmittance2.png)\n\n$$ I_Q=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}\\}\\\\ I_P=I_Q\\exp\\{-\\beta(\\lambda,h_1)\\overline{QP}\\}\\\\ I_P=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}\\}\\exp\\{-\\beta(\\lambda,h_1)\\overline{QP}\\}\\\\ I_P=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}-\\beta(\\lambda,h_1)\\overline{QP}\\} $$\n\n如果CQ和QP长度相同还可以再次简化，那不妨设其相同且为 ***ds*** (方便后面采用积分思想推导)\n\n$$ I_P=I_S\\exp\\{-(\\beta(\\lambda,h_0)+\\beta(\\lambda,h_1))ds\\} $$\n\n延续该思路我们可以将 CP 段化为无数等长的小段，累加这个过程,也就是数值积分\n\n$$ I_P=I_S\\exp\\{-\\sum_{Q\\in\\overline{CP}}\\beta(\\lambda,h_Q)ds\\} $$\n\n将 Rayleigh Scattering 带入\n\n$$ T(\\overline{CP})=I_S\\exp\\{-\\sum_{Q\\in\\overline{CP}}\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h_Q)}{N}\\frac{1}{\\lambda^4}ds\\}\\\\ =\\underbrace{-\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{1}{N}\\frac{1}{\\lambda^4}}_{constant\\;\\beta(\\lambda)}\\overbrace{\\sum_{Q\\in\\overline{CP}}\\rho(h_Q)ds}^{optical\\;depth\\;D(\\overline{CP})}\\\\ $$\n\n求和部分为 Optical Depth ，需要我们在 shader 中计算，其他都是常数。\n\n$$ T(\\overline{CP})=\\exp\\{-\\beta(\\lambda)D(\\overline{CP})\\} $$\n\n## **Intersecting the Atmosphere**\n\n> 这个教程是渲染星球的\n\n所以其要求 AB 的 optical depth，其中 O 点是大气层表面一点也就是我们的 fragment\n\n![math](/imgs/大气散射/math.png)\n\nD 是 camera 的视线方向，L外壳半径，R大气半径\n\n$$ A=O+D\\overline{OA}\\\\ B=O+D\\overline{OB}\\\\ \\overline{OA}=\\overline{OT}-\\overline{AT}\\\\ \\overline{OB}=\\overline{OT}+\\overline{TB}\\\\ \\overline{AT}=\\overline{TB}\\\\ \\overline{OT}=(C-O)\\cdot D=L\\cdot D\\\\ R^2=(\\overline{CT})^2+(\\overline{AT})^2\\\\ (\\overline{CT})^2=L^2-(\\overline{OT})^2\\\\ (\\overline{AT})^2=R^2-(\\overline{CT})^2 $$\n\n如果 CT 大于 R 则无解\n\n### **Colliding with the Planet**\n\n和 plant 相交 只需要按和大气球求交点再求一次和plant球的交点即可 如果有解则 大气的 B点要改为 plant 的A点\n\n![math2](/imgs/大气散射/math2.png)\n\n## **Sampling the View Ray**\n\n$$ I=I_S\\sum_{P\\in AB}S(\\lambda,\\theta,h)T(\\overline{CP})T(\\overline{PA})ds\\\\\\\\ Decompose \\;S(\\lambda,\\theta,h):\\\\ S(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta)=\\beta(\\lambda)\\rho(h)\\gamma(\\theta)\\\\ \\beta(\\lambda)=\\frac{8\\pi^3(n^2-1)^2}{3N\\lambda^4}\\\\ \\rho(h)=\\exp\\{-\\frac{h}{H}\\}\\\\ \\gamma(\\theta)=\\frac{3}{16\\pi}(1+\\cos^2(\\theta))\\\\ We\\;get:I=I_S\\beta(\\lambda)\\gamma(\\theta)\\sum_{P\\in AB}\\underbrace{T(\\overline{CP})T(\\overline{PA})\\rho(h_P)ds}_{light\\;contribution\\;of\\;L(P)}\\\\ $$\n\n$$ For\\;T(\\overline{Dis}):\\\\ T(\\overline{CP})T(\\overline{PA})=\\exp\\{-\\beta(\\lambda)D(\\overline{CP})\\}\\exp\\{-\\beta(\\lambda)D(\\overline{PA})\\}\\\\ =\\exp\\{-\\beta(\\lambda)(D(\\overline{CP})+D(\\overline{PA}))\\}\\\\ D(\\overline{CP})=\\sum_{Q\\in CP}\\exp\\{-\\frac{h_Q}{H}\\}dt\\\\ D(\\overline{PA})=\\sum_{Q\\in AP}\\exp\\{-\\frac{h_P}{H}\\}dx\\\\\\\\ I=I_S\\beta(\\lambda)\\gamma(\\theta)\\sum_{P\\in AB}\\underbrace{T(\\overline{CP})T(\\overline{PA})\\rho(h)ds}_{light\\;contribution\\;of\\;L(P)}\\\\ $$\n\n$$ \\sum_{P\\in AB}T(\\overline{CP})T(\\overline{PA})\\rho(h_P)ds=\\sum_{P\\in AB}\\rho(h_P)\\exp\\{-\\beta(\\lambda)(D(\\overline{CP})+D(\\overline{PA}))\\}ds\\\\ 实际上 D(\\overline{PA}) 可以在最外层循环\\sum_{P\\in AB}做累加,\\\\ 不必每次在里面的循环做，即不必每次从A开始累加 $$\n\n## **[To Do]Mie Scattering**\n\n和波长无关，只和粒子大小相干\n\n$$ phase\\;function:\\\\ S(\\theta)= \\frac{1}{4\\pi}\\frac{3(1-g^2)}{(1-2g\\cos\\theta+g^2)^{\\frac{3}{2}}}\\\\ or:S(\\theta)=\\frac{3}{8\\pi}\\frac{1-g^2}{2+g^2}\\frac{1+\\cos^2\\theta}{(1-2g\\cos\\theta+g^2)^{\\frac{3}{2}}} $$\n\n# 待更新\n\n我们知道了基本的计算思路，但是实际实现还有所不同，后面陆续更新","slug":"大气散射","published":1,"updated":"2024-04-27T04:13:10.762Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti4000ubkbw623g8kvp","content":"<h1\r\nid=\"raymarchingatmospheric-scattering-rayleighscattering\">RayMarching:Atmospheric\r\nScattering-RayleighScattering</h1>\r\n<h2 id=\"rayleigh-scattering\">Rayleigh Scattering</h2>\r\n<p>一般的渲染都是在物体的一个表面上进行计算，而诸如半透明物体是光线和其内部结构相互作用造成的，还有比如皮肤的渲染，可以用\r\n次表面散射去模拟这种效果。但是大气散射不是在表面上计算，是模拟光线透过大气会发生什么，也就是体积渲染。这里是学习\r\n<strong>体积单散射</strong>，渲染实体半透明物体。 ## Single Scattering\r\n大多数游戏引擎的光线都是在真空传播，散射需要做的就是模拟光在空气介质中传播。\r\n## Out Scattering &amp; In Scattering\r\n光和粒子最显著的现象就是粒子偏转光的方向，当一束光偏离 Camera\r\n也就是外散射，偏离到 Camera 方向就是 <strong>内散射</strong>。</p>\r\n<p><img src=\"/imgs/大气散射/OutScattering.png\"></p>\r\n<h2 id=\"volumetric-signle-scattering\"><strong>Volumetric Signle\r\nScattering</strong></h2>\r\n<p>实际上光可以反射/散射很多次，但是这需要大量计算，这里只是计算\r\n<strong>光的单次散射事件</strong>。</p>\r\n<p>关键在于如何模拟光线穿过大气。 即从 A 到 B\r\n的光如何受到散射的影响，因为 AB 上任一点 P 都可能会发生散射。</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/SingleScattering.PNG\" alt=\"SingleScattering\" />\r\n<figcaption aria-hidden=\"true\">SingleScattering</figcaption>\r\n</figure>\r\n<p>所以在计算每个点 P 有多少 Out Scattering时，第一步要先知道 P点\r\n有多少光。假设所有光都来自太阳，一些会发生\r\nin-Scattering，转向摄像机:</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/InScattering.PNG\" alt=\"InScattering\" />\r\n<figcaption aria-hidden=\"true\">InScattering</figcaption>\r\n</figure>\r\n<p>内散射到 P，从 P 到 A 散射，能够描述大部分散射情况，但实际上 P\r\n点接收的光，是太阳射向P并经过 CP 路径的 out-scattering后的。</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/OutScattering2.PNG\" alt=\"OutScattering2\" />\r\n<figcaption aria-hidden=\"true\">OutScattering2</figcaption>\r\n</figure>\r\n<h2\r\nid=\"需要做的可公开的情报\"><strong>[需要做的]可公开的情报</strong></h2>\r\n<ul>\r\n<li>摄像机的视线，从 A 出发，进入大气，并从 B 点离开。</li>\r\n<li>我们需要考虑每个点 P∈AB 的 in-scattering 和 out-scattering\r\n贡献/影响。</li>\r\n<li>P 点从太阳接收的光线</li>\r\n<li>P 点经路径CP接受光，收到 out-scattering 的影响</li>\r\n<li>P 点发生多少 in-scattering，使光线向相机方向。</li>\r\n<li>从 P 射向摄像机的光受到 out-scattering 影响偏离相机的视线。</li>\r\n</ul>\r\n<h2 id=\"transmittance-function\"><strong>Transmittance\r\nFunction</strong></h2>\r\n<p>要计算传播到 Camera\r\n的有多少光，那么所有的计算应该在光线从太阳出发开始；</p>\r\n<p>上图中光经过真空到达C点，其路径上没有其他物体影响，C点的光还没有散射；\r\n设 C点的光量为 Ic，全部从太阳接收，从太阳真空传播过来，无散射影响。\r\n经过路径CP，光线进入大气，和大气中的粒子发生散射，到达P的光量为\r\nIp(肯定小于Ic) 则 Ip和Ic的比率为 <strong>transmittance</strong>:</p>\r\n<p><span class=\"math display\">\\[ T(\\overline{CP})=\\frac{I_P}{I_C}\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/Trasmittance.png\" alt=\"Trasmittance\" />\r\n<figcaption aria-hidden=\"true\">Trasmittance</figcaption>\r\n</figure>\r\n<p>可以用 transmittance 表示在 CP 路径上为散射的光量百分比，也就是经过\r\nCP 后能到得到的光量。这个函数我们后面会进行更详细的推导。</p>\r\n<p><span class=\"math display\">\\[ I_P=I_CT(\\overline{CP}) \\]</span></p>\r\n<h2 id=\"scattering-function\"><strong>Scattering Function</strong></h2>\r\n<p>假设我们先不考虑 <strong>Transmittance Function</strong>\r\n<em>T</em>，然后我们得到了\r\nP点的光量，我们现在需要考虑的就是在P点有多少光因为 scattering 偏转到\r\ncamera 方向。 也就是 <strong>Scattering Function</strong>\r\n<em>S</em>，目的是描述某点处，有多少光沿某个角度发生偏转。</p>\r\n<p>这里光的偏转角度为 θ，<em>S</em>(λ,θ,h)\r\n的值表示沿theta偏转的光量比率。\r\n受到波长，角度，高度的影响，高度是因为大气密度会随高度而改变。</p>\r\n<p><span class=\"math display\">\\[\r\nI_{PA}=I_P*S(\\lambda,\\theta,h)*T(\\overline{PA})\\\\\r\nI_{PA}=I_C*T(\\overline{CP})*S(\\lambda,\\theta,h)*T(\\overline{PA})\\\\\r\n=\\underbrace{\r\nI_C*S(\\lambda,\\theta,h)}_{in-scattering}*\\underbrace{T(\\overline{CP})*T(\\overline{PA})}_{out-scattering}\\\\\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/ScatteringFunc.png\" alt=\"ScatteringFunc\" />\r\n<figcaption aria-hidden=\"true\">ScatteringFunc</figcaption>\r\n</figure>\r\n<p>S 计算折射到视线，T算的沿路径的损失，就是in-scattering 和\r\nout-scattering</p>\r\n<h2 id=\"numerical-integration\"><strong>Numerical\r\nIntegration</strong></h2>\r\n<p>看起来挺好，但可能你已经意识到了，这不太对吧，用 Ipa 表示 点P 传输到\r\nA 的光量，但是刚才的公式并不能描述 A 所有接受到的光。 A接收的光应该是\r\nP∈AB 所有点的累加贡献，我们应该计算 AB\r\n上所有的点，这需要用到积分的思想，将AB划分为无数的微小段——ds，再进行累加，就是数值积分。</p>\r\n<p><span class=\"math display\">\\[ I_A=\\sum_{P\\in\\overline{AB}}I_{PA}ds\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/NumericalIntegration.png\"\r\nalt=\"NumericalIntegration\" />\r\n<figcaption aria-hidden=\"true\">NumericalIntegration</figcaption>\r\n</figure>\r\n<ul>\r\n<li>为什么要乘 ds 因为用 ds 中一个点 P0\r\n代表所有这段上所有点的光线如何散射</li>\r\n</ul>\r\n<blockquote>\r\n<p>假设不划分，以 E 为 AB 每个点的光照散射结果，那么 IA = E * dis_AB</p>\r\n</blockquote>\r\n<h2 id=\"direcation-light\"><strong>Direcation Light</strong></h2>\r\n<p>如果离太阳近可以建模点光源解决，不过通常我们都离太阳很远，而且这里最终目的是做山麓之间的那种大气散射，所有还是以\r\ndirection light 建模。 因此每个点接收相同数量的光，且方向保持不变。</p>\r\n<p>现在可以对 IC 进行简化。</p>\r\n<p><span class=\"math display\">\\[ I_A=\\sum_{P\\in\\overline{AB}}I_{PA}ds\\\\\\\r\n=\\sum_{P\\in\\overline{AB}}I_C*S(\\lambda,\\theta,h)*T(\\overline{CP})*T(\\overline{PA})ds\\\\\r\n=I_S\\sum_{P\\in\\overline{AB}}S(\\lambda,\\theta,h)*T(\\overline{CP})*T(\\overline{PA})ds\\\\\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/DirectionLight.png\" alt=\"DirectionLight\" />\r\n<figcaption aria-hidden=\"true\">DirectionLight</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>如果这里阳光和camera 都不动，theta 固定，甚至还可以优化</p>\r\n</blockquote>\r\n<h2 id=\"absorption-coefficient\"><strong>Absorption\r\nCoefficient</strong></h2>\r\n<blockquote>\r\n<p>在描述光和空气分子之间相互作用的可能结果时，我们只介绍了两个。直接通过，或偏转。还有第三种可能。一些化合物吸收光。地球上的大气中有很多具有这种特性的化学物质。例如，臭氧存在于高等大气中，并且已知对紫外线有强烈反应。然而，它的存在对天空的颜色几乎没有影响，因为它吸收了可见光谱之外的光。在地球上，吸光化学物质的贡献往往被忽视。\r\n在地球上，吸光化学物质的贡献往往被忽视。其他行星不能这样做。例如，海王星和天王星的典型颜色是由大气中大量存在的甲烷引起的。甲烷以吸收红光而闻名，导致蓝色色调。在本教程的其余部分，我们将忽略吸收系数，尽管我们将添加一种为大气着色的方法。</p>\r\n</blockquote>\r\n<h2 id=\"scattering-model\"><strong>Scattering Model</strong></h2>\r\n<p>模拟大气散射现象是十分复杂的，几乎没有一个完美的模型去描述。\r\n通常使用两种模型 : <strong>Rayleigh scattering</strong> 和 <strong>Mie\r\nscattering</strong>. Rayleigh Scattering\r\n描述光和微小粒子的散射，比如空气，氧、氮分子。 Mie Scattering\r\n描述的是光的波长和粒子大小相近的散射情况，比如用 Mie scattering\r\n画太阳，花粉、粉尘、污染物。</p>\r\n<p>Rayleigh Scattering 导致天空是蓝的，日落是红的，Mie Scattering\r\n导致云是白的。</p>\r\n<h2 id=\"rayleigh-scattering-1\"><strong>Rayleigh Scattering</strong></h2>\r\n<p>需要明确的一点是 Rayleigh Scattering 只能描述粒子小于光的波长。\r\n当光子撞击到粒子后，因为粒子足够小，主要有两部分光，一部分不受影响继续传播，一部分以相反方向反射回来，其他可能沿其他方向传播，不过因为光的方向导致其不太可能沿\r\n90° 。</p>\r\n<blockquote>\r\n<p>可以想象一个胖人去撞一个比较瘦的人，或者撞一根很细的柱子</p>\r\n</blockquote>\r\n<figure>\r\n<img src=\"/imgs/大气散射/RayleighScattering.png\"\r\nalt=\"RayleighScattering\" />\r\n<figcaption aria-hidden=\"true\">RayleighScattering</figcaption>\r\n</figure>\r\n<p>其 <strong>Rayleigh scattering equation</strong></p>\r\n<p><span class=\"math display\">\\[ I=I_0S(\\lambda,\\theta,h)\\\\\r\nS(\\lambda,\\theta,h)=\\frac{\\pi^2(n^2-1)^2}{2}\\underbrace{\\frac{\\rho(h)}{N}}_{density}\\overbrace{\\frac{1}{\\lambda^4}}^{wavelength}\\underbrace{(1+\\cos^2\\theta)}_{geometry}\r\n\\]</span></p>\r\n<ul>\r\n<li>λ: the <strong>wavelength</strong> of the incoming light;</li>\r\n<li>θ : the <strong>scattering angle</strong>;</li>\r\n<li>h : the <strong>altitude</strong> of the point;</li>\r\n<li>n=1.00029 : the <strong>refractive index</strong> of\r\nair;(空气的<strong>折射率</strong>)</li>\r\n<li>: the <strong>molecular number density</strong> of the standard\r\natmosphere. This is the number of molecules per cubic\r\nmetre;(标准大气的<strong>分子数密度</strong>。这是每立方米的分子数;)</li>\r\n<li>: the <strong>density ratio</strong>. This number is equal to</li>\r\n<li>at sea level, and decreases exponentially with</li>\r\n<li>. There is a lot to say about this function, and we will do it in a\r\nfuture post of this series.(<strong>密度比</strong>。\r\n此数字等于海平面1时的数字，后面细嗦)</li>\r\n</ul>\r\n<p>该方程来自：<a\r\nhref=\"http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\">nishitalab.org/user/nis/cdrom/sig93_nis.pdf</a></p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/chart.png\" alt=\"chart\" />\r\n<figcaption aria-hidden=\"true\">chart</figcaption>\r\n</figure>\r\n<ul>\r\n<li>某些方向比其他方向接收更多光</li>\r\n<li>散射的光量多少受光波长的影响，波长越长越少，红少蓝多(所以天是蓝的)</li>\r\n</ul>\r\n<h2 id=\"rayleigh-scattering-coefficient\"><strong>Rayleigh Scattering\r\nCoefficient</strong></h2>\r\n<p>前面的Rayleigh\r\n只描述了散射的方向，但是没有描述某一点散射现象的能量衰减。要考虑能量的损失，我们得考虑各个方向上的光能的散射。\r\n很简单对相位函数做积分即可，不过记得这是一个三维空间，不是二维的可别在\r\n[0,2pi] 积分。</p>\r\n<p><span class=\"math display\">\\[\r\n\\beta(\\lambda,h)=\\int_0^{2\\pi}\\int_0^\\pi S(\\lambda,\\theta,h)\\sin\\theta\r\nd\\theta d\\phi\\\\\r\n=\\int_0^{2\\pi}\\int_0^\\pi\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\sin\\theta\r\nd\\theta\r\nd\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\int_0^\\pi(1+\\cos^2\\theta)\\sin\\theta\r\nd\\theta\r\nd\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\int_0^\\pi(\\sin\\theta+\\sin\\theta\\cos^2\\theta)\r\nd\\theta\r\nd\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}(\\cos0+\\frac{\\cos0}{3}-\\cos\\pi-\\frac{\\cos^3\\pi}{3})d\\phi\\\\\r\n=\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\frac{8\\pi}{3}d\\phi\\\\\r\n=\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\frac{16\\pi}{3}\\\\\r\n=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\\r\n\\\\  \\beta(\\lambda,h)  =\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\\\]</span></p>\r\n<p>所以能量的散射受波长和海拔高度的影响。</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/chart2.png\" alt=\"chart2\" />\r\n<figcaption aria-hidden=\"true\">chart2</figcaption>\r\n</figure>\r\n<p>所以地球大气分子会更多反射蓝光，所以当傍晚时，光线要经过更多大气，传播时间更长，所有的蓝光基本都被散射，我们观察到的就是红色的天空。\r\n而白天天空为什么是蓝色的，首先，白天我们观察时日光方向基本固定，因为蓝色更容易发生散射，在空中蓝色光波被散射到四面八方，我们观察天空接收到的自然也就是蓝光。</p>\r\n<h2 id=\"rayleigh-phase-function\"><strong>Rayleigh Phase\r\nFunction</strong></h2>\r\n<p>关于 Rayleigh Scattering Equation 可以分解为两个部分，一部分是\r\nRayleig Scattering Coefficient，也就是刚刚推导的；另一部分是 Geometry of\r\nScattering，并控制其反射方向。</p>\r\n<p><span class=\"math display\">\\[\r\nS(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta)\\\\\r\n\\gamma(\\theta)=\\frac{S(\\lambda,\\theta,h)}{\\beta(\\lambda,h)}=\\\\\r\n\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\frac{3}{8\\pi^3(n^2-1)^2}\\frac{N}{\\rho(h)}\\lambda^4=\\\\\r\n\\frac{3}{16\\pi}(1+\\cos^2\\theta) \\]</span></p>\r\n<h2 id=\"可公开的情报\"><strong>[可公开的情报]</strong></h2>\r\n<ul>\r\n<li><strong>Rayleigh Scattering Equation</strong>\r\n描述在某方向的光偏转比率</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nS(\\lambda,\\theta,h)=\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\\\\r\nS(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta) \\]</span></p>\r\n<ul>\r\n<li><strong>Rayleigh Scattering Coefficient</strong>\r\n在某点发生散射后，多少比例的能量损失情况</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\beta(\\lambda,h)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\\r\n\\]</span></p>\r\n<ul>\r\n<li><p><strong>Rayleigh Scattering Coefficient in Sea\r\nlevel</strong></p></li>\r\n<li><p><span class=\"math display\">\\[\r\n\\beta(\\lambda,0)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{1}{N}\\frac{1}{\\lambda^4}\\\\\r\n\\]</span></p></li>\r\n<li><p><strong>Rayleigh Scattering Phase Function</strong>\r\n描述散射的形状，在特定方向光的损失相对比率。</p></li>\r\n<li><p><span class=\"math display\">\\[\r\n\\gamma(\\theta)=\\frac{3}{16\\pi}(1+\\cos^2\\theta) \\]</span></p></li>\r\n<li><p><strong>Density ratio</strong> 模拟大气密度的函数</p></li>\r\n<li><p><span class=\"math display\">\\[ \\rho(h)=\\exp(\\frac{h}{H})\r\n\\]</span></p></li>\r\n</ul>\r\n<p>H = 8500 是 scale heigh</p>\r\n<h2 id=\"atmospheric-density-ratio\"><strong>Atmospheric Density\r\nRatio</strong></h2>\r\n<p>当大气密度越大时大气中粒子越多，会有更多的散射现象发生。\r\n大气密度和高度示意图：</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/height.png\" alt=\"height\" />\r\n<figcaption aria-hidden=\"true\">height</figcaption>\r\n</figure>\r\n<p>H 为 Scale Height，通常取 8500</p>\r\n<h2 id=\"exponential-decay\"><strong>Exponential Decay</strong></h2>\r\n<p>我们前面的得到了 <strong>scattering coefficient</strong>\r\n<em>β</em>，我们有能求得解析解的 close form 函数</p>\r\n<p><span class=\"math display\">\\[\r\n\\beta(\\lambda,h)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\\r\n\\]</span></p>\r\n<p>上式描述了<strong>光和粒子单次散射后</strong>光量损失的比例。</p>\r\n<p>现在假设如果初始光量为\r\nI0，然后以衰减系数为β，经过大气中粒子的一次散射后所剩的光量会是：<strong>(这里的β不是<em>β(λ,h)</em>,而是鉴定穿过一部分大气后的衰减系数)</strong></p>\r\n<p><span class=\"math display\">\\[\r\nI_1=\\underbrace{I_0}_{initial\\;energy}-\\underbrace{I_0\\beta}_{energy\\;lost}=(1-\\beta)I_0\r\n\\]</span></p>\r\n<p>但这只适用于一次散射/单次散射碰撞，我们希望求得<strong>在一均匀介质中</strong>，传播一定距离后光的衰减：\r\n假设我们将这个过程分为两次散射看待，考虑两次散射：<strong>(这里的β不是<em>β(λ,h)</em>,而是鉴定穿过一部分大气后的衰减系数)</strong></p>\r\n<p><span class=\"math display\">\\[\r\nFirst\\;Scattering\\;:\\;I_1=I_0(1-\\beta\\frac{S}{2})\\\\\r\nSecond\\;Scattering\\;:\\;I_2=I_1(1-\\beta\\frac{S}{2})=I_0(1-\\beta\\frac{S}{2})^2\\\\\r\nAbout\\;N\\;Scattering\\;:\\;I=\\lim_{n\\rightarrow\\infty}I_0(1-\\beta\\frac{S}{n})^n=\\exp\\{-\\beta\r\nS\\} \\]</span></p>\r\n<h2 id=\"uniform-transmittance\"><strong>Uniform\r\nTransmittance</strong></h2>\r\n<p><strong>transmittance</strong> T\r\n描述了光量穿越大气时经过散射所剩余的光量比例。</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/OutScattering2.PNG\" alt=\"OutScattering2\" />\r\n<figcaption aria-hidden=\"true\">OutScattering2</figcaption>\r\n</figure>\r\n<p>根据刚才的欧拉数推导我们能写出一个 P位置光量</p>\r\n<p><span class=\"math display\">\\[ I_P=I_S\\exp\\{-\\beta\\overline{CP}\\}\\\\\r\n\\overline{CP}:\\;distance \\; of \\; CP \\]</span></p>\r\n<p>但实际上CP中的散射系数β不是一个均匀值\r\n我们延续前面类似的思路，将CP分为两段CQ，QP</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/Trasmittance2.png\" alt=\"Trasmittance2\" />\r\n<figcaption aria-hidden=\"true\">Trasmittance2</figcaption>\r\n</figure>\r\n<p><span class=\"math display\">\\[\r\nI_Q=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}\\}\\\\\r\nI_P=I_Q\\exp\\{-\\beta(\\lambda,h_1)\\overline{QP}\\}\\\\\r\nI_P=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}\\}\\exp\\{-\\beta(\\lambda,h_1)\\overline{QP}\\}\\\\\r\nI_P=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}-\\beta(\\lambda,h_1)\\overline{QP}\\}\r\n\\]</span></p>\r\n<p>如果CQ和QP长度相同还可以再次简化，那不妨设其相同且为\r\n<strong><em>ds</em></strong> (方便后面采用积分思想推导)</p>\r\n<p><span class=\"math display\">\\[\r\nI_P=I_S\\exp\\{-(\\beta(\\lambda,h_0)+\\beta(\\lambda,h_1))ds\\} \\]</span></p>\r\n<p>延续该思路我们可以将 CP\r\n段化为无数等长的小段，累加这个过程,也就是数值积分</p>\r\n<p><span class=\"math display\">\\[\r\nI_P=I_S\\exp\\{-\\sum_{Q\\in\\overline{CP}}\\beta(\\lambda,h_Q)ds\\}\r\n\\]</span></p>\r\n<p>将 Rayleigh Scattering 带入</p>\r\n<p><span class=\"math display\">\\[\r\nT(\\overline{CP})=I_S\\exp\\{-\\sum_{Q\\in\\overline{CP}}\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h_Q)}{N}\\frac{1}{\\lambda^4}ds\\}\\\\\r\n=\\underbrace{-\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{1}{N}\\frac{1}{\\lambda^4}}_{constant\\;\\beta(\\lambda)}\\overbrace{\\sum_{Q\\in\\overline{CP}}\\rho(h_Q)ds}^{optical\\;depth\\;D(\\overline{CP})}\\\\\r\n\\]</span></p>\r\n<p>求和部分为 Optical Depth ，需要我们在 shader\r\n中计算，其他都是常数。</p>\r\n<p><span class=\"math display\">\\[\r\nT(\\overline{CP})=\\exp\\{-\\beta(\\lambda)D(\\overline{CP})\\} \\]</span></p>\r\n<h2 id=\"intersecting-the-atmosphere\"><strong>Intersecting the\r\nAtmosphere</strong></h2>\r\n<blockquote>\r\n<p>这个教程是渲染星球的</p>\r\n</blockquote>\r\n<p>所以其要求 AB 的 optical depth，其中 O 点是大气层表面一点也就是我们的\r\nfragment</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/math.png\" alt=\"math\" />\r\n<figcaption aria-hidden=\"true\">math</figcaption>\r\n</figure>\r\n<p>D 是 camera 的视线方向，L外壳半径，R大气半径</p>\r\n<p><span class=\"math display\">\\[ A=O+D\\overline{OA}\\\\\r\nB=O+D\\overline{OB}\\\\ \\overline{OA}=\\overline{OT}-\\overline{AT}\\\\\r\n\\overline{OB}=\\overline{OT}+\\overline{TB}\\\\\r\n\\overline{AT}=\\overline{TB}\\\\ \\overline{OT}=(C-O)\\cdot D=L\\cdot D\\\\\r\nR^2=(\\overline{CT})^2+(\\overline{AT})^2\\\\\r\n(\\overline{CT})^2=L^2-(\\overline{OT})^2\\\\\r\n(\\overline{AT})^2=R^2-(\\overline{CT})^2 \\]</span></p>\r\n<p>如果 CT 大于 R 则无解</p>\r\n<h3 id=\"colliding-with-the-planet\"><strong>Colliding with the\r\nPlanet</strong></h3>\r\n<p>和 plant 相交 只需要按和大气球求交点再求一次和plant球的交点即可\r\n如果有解则 大气的 B点要改为 plant 的A点</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/math2.png\" alt=\"math2\" />\r\n<figcaption aria-hidden=\"true\">math2</figcaption>\r\n</figure>\r\n<h2 id=\"sampling-the-view-ray\"><strong>Sampling the View\r\nRay</strong></h2>\r\n<p><span class=\"math display\">\\[ I=I_S\\sum_{P\\in\r\nAB}S(\\lambda,\\theta,h)T(\\overline{CP})T(\\overline{PA})ds\\\\\\\\ Decompose\r\n\\;S(\\lambda,\\theta,h):\\\\\r\nS(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta)=\\beta(\\lambda)\\rho(h)\\gamma(\\theta)\\\\\r\n\\beta(\\lambda)=\\frac{8\\pi^3(n^2-1)^2}{3N\\lambda^4}\\\\\r\n\\rho(h)=\\exp\\{-\\frac{h}{H}\\}\\\\\r\n\\gamma(\\theta)=\\frac{3}{16\\pi}(1+\\cos^2(\\theta))\\\\\r\nWe\\;get:I=I_S\\beta(\\lambda)\\gamma(\\theta)\\sum_{P\\in\r\nAB}\\underbrace{T(\\overline{CP})T(\\overline{PA})\\rho(h_P)ds}_{light\\;contribution\\;of\\;L(P)}\\\\\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[ For\\;T(\\overline{Dis}):\\\\\r\nT(\\overline{CP})T(\\overline{PA})=\\exp\\{-\\beta(\\lambda)D(\\overline{CP})\\}\\exp\\{-\\beta(\\lambda)D(\\overline{PA})\\}\\\\\r\n=\\exp\\{-\\beta(\\lambda)(D(\\overline{CP})+D(\\overline{PA}))\\}\\\\\r\nD(\\overline{CP})=\\sum_{Q\\in CP}\\exp\\{-\\frac{h_Q}{H}\\}dt\\\\\r\nD(\\overline{PA})=\\sum_{Q\\in AP}\\exp\\{-\\frac{h_P}{H}\\}dx\\\\\\\\\r\nI=I_S\\beta(\\lambda)\\gamma(\\theta)\\sum_{P\\in\r\nAB}\\underbrace{T(\\overline{CP})T(\\overline{PA})\\rho(h)ds}_{light\\;contribution\\;of\\;L(P)}\\\\\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[ \\sum_{P\\in\r\nAB}T(\\overline{CP})T(\\overline{PA})\\rho(h_P)ds=\\sum_{P\\in\r\nAB}\\rho(h_P)\\exp\\{-\\beta(\\lambda)(D(\\overline{CP})+D(\\overline{PA}))\\}ds\\\\\r\n实际上 D(\\overline{PA}) 可以在最外层循环\\sum_{P\\in AB}做累加,\\\\\r\n不必每次在里面的循环做，即不必每次从A开始累加 \\]</span></p>\r\n<h2 id=\"to-domie-scattering\"><strong>[To Do]Mie Scattering</strong></h2>\r\n<p>和波长无关，只和粒子大小相干</p>\r\n<p><span class=\"math display\">\\[ phase\\;function:\\\\ S(\\theta)=\r\n\\frac{1}{4\\pi}\\frac{3(1-g^2)}{(1-2g\\cos\\theta+g^2)^{\\frac{3}{2}}}\\\\\r\nor:S(\\theta)=\\frac{3}{8\\pi}\\frac{1-g^2}{2+g^2}\\frac{1+\\cos^2\\theta}{(1-2g\\cos\\theta+g^2)^{\\frac{3}{2}}}\r\n\\]</span></p>\r\n<h1 id=\"待更新\">待更新</h1>\r\n<p>我们知道了基本的计算思路，但是实际实现还有所不同，后面陆续更新</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1\r\nid=\"raymarchingatmospheric-scattering-rayleighscattering\">RayMarching:Atmospheric\r\nScattering-RayleighScattering</h1>\r\n<h2 id=\"rayleigh-scattering\">Rayleigh Scattering</h2>\r\n<p>一般的渲染都是在物体的一个表面上进行计算，而诸如半透明物体是光线和其内部结构相互作用造成的，还有比如皮肤的渲染，可以用\r\n次表面散射去模拟这种效果。但是大气散射不是在表面上计算，是模拟光线透过大气会发生什么，也就是体积渲染。这里是学习\r\n<strong>体积单散射</strong>，渲染实体半透明物体。 ## Single Scattering\r\n大多数游戏引擎的光线都是在真空传播，散射需要做的就是模拟光在空气介质中传播。\r\n## Out Scattering &amp; In Scattering\r\n光和粒子最显著的现象就是粒子偏转光的方向，当一束光偏离 Camera\r\n也就是外散射，偏离到 Camera 方向就是 <strong>内散射</strong>。</p>\r\n<p><img src=\"/imgs/大气散射/OutScattering.png\"></p>\r\n<h2 id=\"volumetric-signle-scattering\"><strong>Volumetric Signle\r\nScattering</strong></h2>\r\n<p>实际上光可以反射/散射很多次，但是这需要大量计算，这里只是计算\r\n<strong>光的单次散射事件</strong>。</p>\r\n<p>关键在于如何模拟光线穿过大气。 即从 A 到 B\r\n的光如何受到散射的影响，因为 AB 上任一点 P 都可能会发生散射。</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/SingleScattering.PNG\" alt=\"SingleScattering\" />\r\n<figcaption aria-hidden=\"true\">SingleScattering</figcaption>\r\n</figure>\r\n<p>所以在计算每个点 P 有多少 Out Scattering时，第一步要先知道 P点\r\n有多少光。假设所有光都来自太阳，一些会发生\r\nin-Scattering，转向摄像机:</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/InScattering.PNG\" alt=\"InScattering\" />\r\n<figcaption aria-hidden=\"true\">InScattering</figcaption>\r\n</figure>\r\n<p>内散射到 P，从 P 到 A 散射，能够描述大部分散射情况，但实际上 P\r\n点接收的光，是太阳射向P并经过 CP 路径的 out-scattering后的。</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/OutScattering2.PNG\" alt=\"OutScattering2\" />\r\n<figcaption aria-hidden=\"true\">OutScattering2</figcaption>\r\n</figure>\r\n<h2\r\nid=\"需要做的可公开的情报\"><strong>[需要做的]可公开的情报</strong></h2>\r\n<ul>\r\n<li>摄像机的视线，从 A 出发，进入大气，并从 B 点离开。</li>\r\n<li>我们需要考虑每个点 P∈AB 的 in-scattering 和 out-scattering\r\n贡献/影响。</li>\r\n<li>P 点从太阳接收的光线</li>\r\n<li>P 点经路径CP接受光，收到 out-scattering 的影响</li>\r\n<li>P 点发生多少 in-scattering，使光线向相机方向。</li>\r\n<li>从 P 射向摄像机的光受到 out-scattering 影响偏离相机的视线。</li>\r\n</ul>\r\n<h2 id=\"transmittance-function\"><strong>Transmittance\r\nFunction</strong></h2>\r\n<p>要计算传播到 Camera\r\n的有多少光，那么所有的计算应该在光线从太阳出发开始；</p>\r\n<p>上图中光经过真空到达C点，其路径上没有其他物体影响，C点的光还没有散射；\r\n设 C点的光量为 Ic，全部从太阳接收，从太阳真空传播过来，无散射影响。\r\n经过路径CP，光线进入大气，和大气中的粒子发生散射，到达P的光量为\r\nIp(肯定小于Ic) 则 Ip和Ic的比率为 <strong>transmittance</strong>:</p>\r\n<p><span class=\"math display\">\\[ T(\\overline{CP})=\\frac{I_P}{I_C}\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/Trasmittance.png\" alt=\"Trasmittance\" />\r\n<figcaption aria-hidden=\"true\">Trasmittance</figcaption>\r\n</figure>\r\n<p>可以用 transmittance 表示在 CP 路径上为散射的光量百分比，也就是经过\r\nCP 后能到得到的光量。这个函数我们后面会进行更详细的推导。</p>\r\n<p><span class=\"math display\">\\[ I_P=I_CT(\\overline{CP}) \\]</span></p>\r\n<h2 id=\"scattering-function\"><strong>Scattering Function</strong></h2>\r\n<p>假设我们先不考虑 <strong>Transmittance Function</strong>\r\n<em>T</em>，然后我们得到了\r\nP点的光量，我们现在需要考虑的就是在P点有多少光因为 scattering 偏转到\r\ncamera 方向。 也就是 <strong>Scattering Function</strong>\r\n<em>S</em>，目的是描述某点处，有多少光沿某个角度发生偏转。</p>\r\n<p>这里光的偏转角度为 θ，<em>S</em>(λ,θ,h)\r\n的值表示沿theta偏转的光量比率。\r\n受到波长，角度，高度的影响，高度是因为大气密度会随高度而改变。</p>\r\n<p><span class=\"math display\">\\[\r\nI_{PA}=I_P*S(\\lambda,\\theta,h)*T(\\overline{PA})\\\\\r\nI_{PA}=I_C*T(\\overline{CP})*S(\\lambda,\\theta,h)*T(\\overline{PA})\\\\\r\n=\\underbrace{\r\nI_C*S(\\lambda,\\theta,h)}_{in-scattering}*\\underbrace{T(\\overline{CP})*T(\\overline{PA})}_{out-scattering}\\\\\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/ScatteringFunc.png\" alt=\"ScatteringFunc\" />\r\n<figcaption aria-hidden=\"true\">ScatteringFunc</figcaption>\r\n</figure>\r\n<p>S 计算折射到视线，T算的沿路径的损失，就是in-scattering 和\r\nout-scattering</p>\r\n<h2 id=\"numerical-integration\"><strong>Numerical\r\nIntegration</strong></h2>\r\n<p>看起来挺好，但可能你已经意识到了，这不太对吧，用 Ipa 表示 点P 传输到\r\nA 的光量，但是刚才的公式并不能描述 A 所有接受到的光。 A接收的光应该是\r\nP∈AB 所有点的累加贡献，我们应该计算 AB\r\n上所有的点，这需要用到积分的思想，将AB划分为无数的微小段——ds，再进行累加，就是数值积分。</p>\r\n<p><span class=\"math display\">\\[ I_A=\\sum_{P\\in\\overline{AB}}I_{PA}ds\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/NumericalIntegration.png\"\r\nalt=\"NumericalIntegration\" />\r\n<figcaption aria-hidden=\"true\">NumericalIntegration</figcaption>\r\n</figure>\r\n<ul>\r\n<li>为什么要乘 ds 因为用 ds 中一个点 P0\r\n代表所有这段上所有点的光线如何散射</li>\r\n</ul>\r\n<blockquote>\r\n<p>假设不划分，以 E 为 AB 每个点的光照散射结果，那么 IA = E * dis_AB</p>\r\n</blockquote>\r\n<h2 id=\"direcation-light\"><strong>Direcation Light</strong></h2>\r\n<p>如果离太阳近可以建模点光源解决，不过通常我们都离太阳很远，而且这里最终目的是做山麓之间的那种大气散射，所有还是以\r\ndirection light 建模。 因此每个点接收相同数量的光，且方向保持不变。</p>\r\n<p>现在可以对 IC 进行简化。</p>\r\n<p><span class=\"math display\">\\[ I_A=\\sum_{P\\in\\overline{AB}}I_{PA}ds\\\\\\\r\n=\\sum_{P\\in\\overline{AB}}I_C*S(\\lambda,\\theta,h)*T(\\overline{CP})*T(\\overline{PA})ds\\\\\r\n=I_S\\sum_{P\\in\\overline{AB}}S(\\lambda,\\theta,h)*T(\\overline{CP})*T(\\overline{PA})ds\\\\\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/DirectionLight.png\" alt=\"DirectionLight\" />\r\n<figcaption aria-hidden=\"true\">DirectionLight</figcaption>\r\n</figure>\r\n<blockquote>\r\n<p>如果这里阳光和camera 都不动，theta 固定，甚至还可以优化</p>\r\n</blockquote>\r\n<h2 id=\"absorption-coefficient\"><strong>Absorption\r\nCoefficient</strong></h2>\r\n<blockquote>\r\n<p>在描述光和空气分子之间相互作用的可能结果时，我们只介绍了两个。直接通过，或偏转。还有第三种可能。一些化合物吸收光。地球上的大气中有很多具有这种特性的化学物质。例如，臭氧存在于高等大气中，并且已知对紫外线有强烈反应。然而，它的存在对天空的颜色几乎没有影响，因为它吸收了可见光谱之外的光。在地球上，吸光化学物质的贡献往往被忽视。\r\n在地球上，吸光化学物质的贡献往往被忽视。其他行星不能这样做。例如，海王星和天王星的典型颜色是由大气中大量存在的甲烷引起的。甲烷以吸收红光而闻名，导致蓝色色调。在本教程的其余部分，我们将忽略吸收系数，尽管我们将添加一种为大气着色的方法。</p>\r\n</blockquote>\r\n<h2 id=\"scattering-model\"><strong>Scattering Model</strong></h2>\r\n<p>模拟大气散射现象是十分复杂的，几乎没有一个完美的模型去描述。\r\n通常使用两种模型 : <strong>Rayleigh scattering</strong> 和 <strong>Mie\r\nscattering</strong>. Rayleigh Scattering\r\n描述光和微小粒子的散射，比如空气，氧、氮分子。 Mie Scattering\r\n描述的是光的波长和粒子大小相近的散射情况，比如用 Mie scattering\r\n画太阳，花粉、粉尘、污染物。</p>\r\n<p>Rayleigh Scattering 导致天空是蓝的，日落是红的，Mie Scattering\r\n导致云是白的。</p>\r\n<h2 id=\"rayleigh-scattering-1\"><strong>Rayleigh Scattering</strong></h2>\r\n<p>需要明确的一点是 Rayleigh Scattering 只能描述粒子小于光的波长。\r\n当光子撞击到粒子后，因为粒子足够小，主要有两部分光，一部分不受影响继续传播，一部分以相反方向反射回来，其他可能沿其他方向传播，不过因为光的方向导致其不太可能沿\r\n90° 。</p>\r\n<blockquote>\r\n<p>可以想象一个胖人去撞一个比较瘦的人，或者撞一根很细的柱子</p>\r\n</blockquote>\r\n<figure>\r\n<img src=\"/imgs/大气散射/RayleighScattering.png\"\r\nalt=\"RayleighScattering\" />\r\n<figcaption aria-hidden=\"true\">RayleighScattering</figcaption>\r\n</figure>\r\n<p>其 <strong>Rayleigh scattering equation</strong></p>\r\n<p><span class=\"math display\">\\[ I=I_0S(\\lambda,\\theta,h)\\\\\r\nS(\\lambda,\\theta,h)=\\frac{\\pi^2(n^2-1)^2}{2}\\underbrace{\\frac{\\rho(h)}{N}}_{density}\\overbrace{\\frac{1}{\\lambda^4}}^{wavelength}\\underbrace{(1+\\cos^2\\theta)}_{geometry}\r\n\\]</span></p>\r\n<ul>\r\n<li>λ: the <strong>wavelength</strong> of the incoming light;</li>\r\n<li>θ : the <strong>scattering angle</strong>;</li>\r\n<li>h : the <strong>altitude</strong> of the point;</li>\r\n<li>n=1.00029 : the <strong>refractive index</strong> of\r\nair;(空气的<strong>折射率</strong>)</li>\r\n<li>: the <strong>molecular number density</strong> of the standard\r\natmosphere. This is the number of molecules per cubic\r\nmetre;(标准大气的<strong>分子数密度</strong>。这是每立方米的分子数;)</li>\r\n<li>: the <strong>density ratio</strong>. This number is equal to</li>\r\n<li>at sea level, and decreases exponentially with</li>\r\n<li>. There is a lot to say about this function, and we will do it in a\r\nfuture post of this series.(<strong>密度比</strong>。\r\n此数字等于海平面1时的数字，后面细嗦)</li>\r\n</ul>\r\n<p>该方程来自：<a\r\nhref=\"http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\">nishitalab.org/user/nis/cdrom/sig93_nis.pdf</a></p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/chart.png\" alt=\"chart\" />\r\n<figcaption aria-hidden=\"true\">chart</figcaption>\r\n</figure>\r\n<ul>\r\n<li>某些方向比其他方向接收更多光</li>\r\n<li>散射的光量多少受光波长的影响，波长越长越少，红少蓝多(所以天是蓝的)</li>\r\n</ul>\r\n<h2 id=\"rayleigh-scattering-coefficient\"><strong>Rayleigh Scattering\r\nCoefficient</strong></h2>\r\n<p>前面的Rayleigh\r\n只描述了散射的方向，但是没有描述某一点散射现象的能量衰减。要考虑能量的损失，我们得考虑各个方向上的光能的散射。\r\n很简单对相位函数做积分即可，不过记得这是一个三维空间，不是二维的可别在\r\n[0,2pi] 积分。</p>\r\n<p><span class=\"math display\">\\[\r\n\\beta(\\lambda,h)=\\int_0^{2\\pi}\\int_0^\\pi S(\\lambda,\\theta,h)\\sin\\theta\r\nd\\theta d\\phi\\\\\r\n=\\int_0^{2\\pi}\\int_0^\\pi\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\sin\\theta\r\nd\\theta\r\nd\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\int_0^\\pi(1+\\cos^2\\theta)\\sin\\theta\r\nd\\theta\r\nd\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\int_0^\\pi(\\sin\\theta+\\sin\\theta\\cos^2\\theta)\r\nd\\theta\r\nd\\phi\\\\  =\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}(\\cos0+\\frac{\\cos0}{3}-\\cos\\pi-\\frac{\\cos^3\\pi}{3})d\\phi\\\\\r\n=\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\int_0^{2\\pi}\\frac{8\\pi}{3}d\\phi\\\\\r\n=\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\frac{16\\pi}{3}\\\\\r\n=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\\r\n\\\\  \\beta(\\lambda,h)  =\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\\\]</span></p>\r\n<p>所以能量的散射受波长和海拔高度的影响。</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/chart2.png\" alt=\"chart2\" />\r\n<figcaption aria-hidden=\"true\">chart2</figcaption>\r\n</figure>\r\n<p>所以地球大气分子会更多反射蓝光，所以当傍晚时，光线要经过更多大气，传播时间更长，所有的蓝光基本都被散射，我们观察到的就是红色的天空。\r\n而白天天空为什么是蓝色的，首先，白天我们观察时日光方向基本固定，因为蓝色更容易发生散射，在空中蓝色光波被散射到四面八方，我们观察天空接收到的自然也就是蓝光。</p>\r\n<h2 id=\"rayleigh-phase-function\"><strong>Rayleigh Phase\r\nFunction</strong></h2>\r\n<p>关于 Rayleigh Scattering Equation 可以分解为两个部分，一部分是\r\nRayleig Scattering Coefficient，也就是刚刚推导的；另一部分是 Geometry of\r\nScattering，并控制其反射方向。</p>\r\n<p><span class=\"math display\">\\[\r\nS(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta)\\\\\r\n\\gamma(\\theta)=\\frac{S(\\lambda,\\theta,h)}{\\beta(\\lambda,h)}=\\\\\r\n\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\frac{3}{8\\pi^3(n^2-1)^2}\\frac{N}{\\rho(h)}\\lambda^4=\\\\\r\n\\frac{3}{16\\pi}(1+\\cos^2\\theta) \\]</span></p>\r\n<h2 id=\"可公开的情报\"><strong>[可公开的情报]</strong></h2>\r\n<ul>\r\n<li><strong>Rayleigh Scattering Equation</strong>\r\n描述在某方向的光偏转比率</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nS(\\lambda,\\theta,h)=\\frac{\\pi^2(n^2-1)^2}{2}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}(1+\\cos^2\\theta)\\\\\r\nS(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta) \\]</span></p>\r\n<ul>\r\n<li><strong>Rayleigh Scattering Coefficient</strong>\r\n在某点发生散射后，多少比例的能量损失情况</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\beta(\\lambda,h)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\\r\n\\]</span></p>\r\n<ul>\r\n<li><p><strong>Rayleigh Scattering Coefficient in Sea\r\nlevel</strong></p></li>\r\n<li><p><span class=\"math display\">\\[\r\n\\beta(\\lambda,0)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{1}{N}\\frac{1}{\\lambda^4}\\\\\r\n\\]</span></p></li>\r\n<li><p><strong>Rayleigh Scattering Phase Function</strong>\r\n描述散射的形状，在特定方向光的损失相对比率。</p></li>\r\n<li><p><span class=\"math display\">\\[\r\n\\gamma(\\theta)=\\frac{3}{16\\pi}(1+\\cos^2\\theta) \\]</span></p></li>\r\n<li><p><strong>Density ratio</strong> 模拟大气密度的函数</p></li>\r\n<li><p><span class=\"math display\">\\[ \\rho(h)=\\exp(\\frac{h}{H})\r\n\\]</span></p></li>\r\n</ul>\r\n<p>H = 8500 是 scale heigh</p>\r\n<h2 id=\"atmospheric-density-ratio\"><strong>Atmospheric Density\r\nRatio</strong></h2>\r\n<p>当大气密度越大时大气中粒子越多，会有更多的散射现象发生。\r\n大气密度和高度示意图：</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/height.png\" alt=\"height\" />\r\n<figcaption aria-hidden=\"true\">height</figcaption>\r\n</figure>\r\n<p>H 为 Scale Height，通常取 8500</p>\r\n<h2 id=\"exponential-decay\"><strong>Exponential Decay</strong></h2>\r\n<p>我们前面的得到了 <strong>scattering coefficient</strong>\r\n<em>β</em>，我们有能求得解析解的 close form 函数</p>\r\n<p><span class=\"math display\">\\[\r\n\\beta(\\lambda,h)=\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h)}{N}\\frac{1}{\\lambda^4}\\\\\r\n\\]</span></p>\r\n<p>上式描述了<strong>光和粒子单次散射后</strong>光量损失的比例。</p>\r\n<p>现在假设如果初始光量为\r\nI0，然后以衰减系数为β，经过大气中粒子的一次散射后所剩的光量会是：<strong>(这里的β不是<em>β(λ,h)</em>,而是鉴定穿过一部分大气后的衰减系数)</strong></p>\r\n<p><span class=\"math display\">\\[\r\nI_1=\\underbrace{I_0}_{initial\\;energy}-\\underbrace{I_0\\beta}_{energy\\;lost}=(1-\\beta)I_0\r\n\\]</span></p>\r\n<p>但这只适用于一次散射/单次散射碰撞，我们希望求得<strong>在一均匀介质中</strong>，传播一定距离后光的衰减：\r\n假设我们将这个过程分为两次散射看待，考虑两次散射：<strong>(这里的β不是<em>β(λ,h)</em>,而是鉴定穿过一部分大气后的衰减系数)</strong></p>\r\n<p><span class=\"math display\">\\[\r\nFirst\\;Scattering\\;:\\;I_1=I_0(1-\\beta\\frac{S}{2})\\\\\r\nSecond\\;Scattering\\;:\\;I_2=I_1(1-\\beta\\frac{S}{2})=I_0(1-\\beta\\frac{S}{2})^2\\\\\r\nAbout\\;N\\;Scattering\\;:\\;I=\\lim_{n\\rightarrow\\infty}I_0(1-\\beta\\frac{S}{n})^n=\\exp\\{-\\beta\r\nS\\} \\]</span></p>\r\n<h2 id=\"uniform-transmittance\"><strong>Uniform\r\nTransmittance</strong></h2>\r\n<p><strong>transmittance</strong> T\r\n描述了光量穿越大气时经过散射所剩余的光量比例。</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/OutScattering2.PNG\" alt=\"OutScattering2\" />\r\n<figcaption aria-hidden=\"true\">OutScattering2</figcaption>\r\n</figure>\r\n<p>根据刚才的欧拉数推导我们能写出一个 P位置光量</p>\r\n<p><span class=\"math display\">\\[ I_P=I_S\\exp\\{-\\beta\\overline{CP}\\}\\\\\r\n\\overline{CP}:\\;distance \\; of \\; CP \\]</span></p>\r\n<p>但实际上CP中的散射系数β不是一个均匀值\r\n我们延续前面类似的思路，将CP分为两段CQ，QP</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/Trasmittance2.png\" alt=\"Trasmittance2\" />\r\n<figcaption aria-hidden=\"true\">Trasmittance2</figcaption>\r\n</figure>\r\n<p><span class=\"math display\">\\[\r\nI_Q=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}\\}\\\\\r\nI_P=I_Q\\exp\\{-\\beta(\\lambda,h_1)\\overline{QP}\\}\\\\\r\nI_P=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}\\}\\exp\\{-\\beta(\\lambda,h_1)\\overline{QP}\\}\\\\\r\nI_P=I_S\\exp\\{-\\beta(\\lambda,h_0)\\overline{CQ}-\\beta(\\lambda,h_1)\\overline{QP}\\}\r\n\\]</span></p>\r\n<p>如果CQ和QP长度相同还可以再次简化，那不妨设其相同且为\r\n<strong><em>ds</em></strong> (方便后面采用积分思想推导)</p>\r\n<p><span class=\"math display\">\\[\r\nI_P=I_S\\exp\\{-(\\beta(\\lambda,h_0)+\\beta(\\lambda,h_1))ds\\} \\]</span></p>\r\n<p>延续该思路我们可以将 CP\r\n段化为无数等长的小段，累加这个过程,也就是数值积分</p>\r\n<p><span class=\"math display\">\\[\r\nI_P=I_S\\exp\\{-\\sum_{Q\\in\\overline{CP}}\\beta(\\lambda,h_Q)ds\\}\r\n\\]</span></p>\r\n<p>将 Rayleigh Scattering 带入</p>\r\n<p><span class=\"math display\">\\[\r\nT(\\overline{CP})=I_S\\exp\\{-\\sum_{Q\\in\\overline{CP}}\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{\\rho(h_Q)}{N}\\frac{1}{\\lambda^4}ds\\}\\\\\r\n=\\underbrace{-\\frac{8\\pi^3(n^2-1)^2}{3}\\frac{1}{N}\\frac{1}{\\lambda^4}}_{constant\\;\\beta(\\lambda)}\\overbrace{\\sum_{Q\\in\\overline{CP}}\\rho(h_Q)ds}^{optical\\;depth\\;D(\\overline{CP})}\\\\\r\n\\]</span></p>\r\n<p>求和部分为 Optical Depth ，需要我们在 shader\r\n中计算，其他都是常数。</p>\r\n<p><span class=\"math display\">\\[\r\nT(\\overline{CP})=\\exp\\{-\\beta(\\lambda)D(\\overline{CP})\\} \\]</span></p>\r\n<h2 id=\"intersecting-the-atmosphere\"><strong>Intersecting the\r\nAtmosphere</strong></h2>\r\n<blockquote>\r\n<p>这个教程是渲染星球的</p>\r\n</blockquote>\r\n<p>所以其要求 AB 的 optical depth，其中 O 点是大气层表面一点也就是我们的\r\nfragment</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/math.png\" alt=\"math\" />\r\n<figcaption aria-hidden=\"true\">math</figcaption>\r\n</figure>\r\n<p>D 是 camera 的视线方向，L外壳半径，R大气半径</p>\r\n<p><span class=\"math display\">\\[ A=O+D\\overline{OA}\\\\\r\nB=O+D\\overline{OB}\\\\ \\overline{OA}=\\overline{OT}-\\overline{AT}\\\\\r\n\\overline{OB}=\\overline{OT}+\\overline{TB}\\\\\r\n\\overline{AT}=\\overline{TB}\\\\ \\overline{OT}=(C-O)\\cdot D=L\\cdot D\\\\\r\nR^2=(\\overline{CT})^2+(\\overline{AT})^2\\\\\r\n(\\overline{CT})^2=L^2-(\\overline{OT})^2\\\\\r\n(\\overline{AT})^2=R^2-(\\overline{CT})^2 \\]</span></p>\r\n<p>如果 CT 大于 R 则无解</p>\r\n<h3 id=\"colliding-with-the-planet\"><strong>Colliding with the\r\nPlanet</strong></h3>\r\n<p>和 plant 相交 只需要按和大气球求交点再求一次和plant球的交点即可\r\n如果有解则 大气的 B点要改为 plant 的A点</p>\r\n<figure>\r\n<img src=\"/imgs/大气散射/math2.png\" alt=\"math2\" />\r\n<figcaption aria-hidden=\"true\">math2</figcaption>\r\n</figure>\r\n<h2 id=\"sampling-the-view-ray\"><strong>Sampling the View\r\nRay</strong></h2>\r\n<p><span class=\"math display\">\\[ I=I_S\\sum_{P\\in\r\nAB}S(\\lambda,\\theta,h)T(\\overline{CP})T(\\overline{PA})ds\\\\\\\\ Decompose\r\n\\;S(\\lambda,\\theta,h):\\\\\r\nS(\\lambda,\\theta,h)=\\beta(\\lambda,h)\\gamma(\\theta)=\\beta(\\lambda)\\rho(h)\\gamma(\\theta)\\\\\r\n\\beta(\\lambda)=\\frac{8\\pi^3(n^2-1)^2}{3N\\lambda^4}\\\\\r\n\\rho(h)=\\exp\\{-\\frac{h}{H}\\}\\\\\r\n\\gamma(\\theta)=\\frac{3}{16\\pi}(1+\\cos^2(\\theta))\\\\\r\nWe\\;get:I=I_S\\beta(\\lambda)\\gamma(\\theta)\\sum_{P\\in\r\nAB}\\underbrace{T(\\overline{CP})T(\\overline{PA})\\rho(h_P)ds}_{light\\;contribution\\;of\\;L(P)}\\\\\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[ For\\;T(\\overline{Dis}):\\\\\r\nT(\\overline{CP})T(\\overline{PA})=\\exp\\{-\\beta(\\lambda)D(\\overline{CP})\\}\\exp\\{-\\beta(\\lambda)D(\\overline{PA})\\}\\\\\r\n=\\exp\\{-\\beta(\\lambda)(D(\\overline{CP})+D(\\overline{PA}))\\}\\\\\r\nD(\\overline{CP})=\\sum_{Q\\in CP}\\exp\\{-\\frac{h_Q}{H}\\}dt\\\\\r\nD(\\overline{PA})=\\sum_{Q\\in AP}\\exp\\{-\\frac{h_P}{H}\\}dx\\\\\\\\\r\nI=I_S\\beta(\\lambda)\\gamma(\\theta)\\sum_{P\\in\r\nAB}\\underbrace{T(\\overline{CP})T(\\overline{PA})\\rho(h)ds}_{light\\;contribution\\;of\\;L(P)}\\\\\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[ \\sum_{P\\in\r\nAB}T(\\overline{CP})T(\\overline{PA})\\rho(h_P)ds=\\sum_{P\\in\r\nAB}\\rho(h_P)\\exp\\{-\\beta(\\lambda)(D(\\overline{CP})+D(\\overline{PA}))\\}ds\\\\\r\n实际上 D(\\overline{PA}) 可以在最外层循环\\sum_{P\\in AB}做累加,\\\\\r\n不必每次在里面的循环做，即不必每次从A开始累加 \\]</span></p>\r\n<h2 id=\"to-domie-scattering\"><strong>[To Do]Mie Scattering</strong></h2>\r\n<p>和波长无关，只和粒子大小相干</p>\r\n<p><span class=\"math display\">\\[ phase\\;function:\\\\ S(\\theta)=\r\n\\frac{1}{4\\pi}\\frac{3(1-g^2)}{(1-2g\\cos\\theta+g^2)^{\\frac{3}{2}}}\\\\\r\nor:S(\\theta)=\\frac{3}{8\\pi}\\frac{1-g^2}{2+g^2}\\frac{1+\\cos^2\\theta}{(1-2g\\cos\\theta+g^2)^{\\frac{3}{2}}}\r\n\\]</span></p>\r\n<h1 id=\"待更新\">待更新</h1>\r\n<p>我们知道了基本的计算思路，但是实际实现还有所不同，后面陆续更新</p>\r\n"},{"title":"设计模式学习","date":"2023-04-10T04:23:38.000Z","typora-root-url":"./..\\imgs\\常见设计模式","_content":"  \n对常见设计模式的学习，从C++角度学习的，但是部分资料没找到好C++版本，所以可能会有不正确的地方。  \n<!--more-->\n  \n# [常见设计模式](https://zhuanlan.zhihu.com/p/231526884)\n  \n## 工厂模式\n  \n### 简单工厂\n  \n#### 含义\n  \n* **简单工厂模式**又叫**静态方法模式**，因为**工厂类**定义了一个**静态方法**。  \n* 简单工厂的工厂类是负责生产一个对象的类。\n  \n#### 解决的问题\n  \n“类实例化的操作”和“使用对象的操作”分开，可以做到不知道具体参数就可以实例化出所需要的“产品类”。\n  \n#### 模式原理\n  \n##### 模式组成\n  \n* 抽象产品：产品的父类；是一个描述产品的公共接口  \n* 具体产品：抽象产品的子类、工厂创建的目标类；描述生产的具体产品。  \n* 工厂：被外界调用；根据传入不同参数创建不同产品。\n  \n#### 代码实例\n  \n一个小摊位可以产出“烤冷面”、“手抓饼”、“煎饼果子”等。\n  \n```cpp  \n// 抽象的食物  \nclass Food {  \npublic: virtual void Cook() { std::cout << \"A Food\"; }  \n};\n  \n// 具体食物类  \nclass KaoLengMian :public Food {  \npublic:  \n    void Cook()  \n    {  \n        std::cout << \"烤冷面\";  \n    }  \n};\n  \nclass ShouZhuaBing :public Food {  \npublic:  \n    void Cook() {  \n        std::cout << \"手抓饼\";  \n    }  \n};\n  \nclass JianBingGuoZi :public Food {  \npublic:  \n    void Cook()  \n    {  \n        std::cout << \"煎饼果子\";  \n    }  \n};\n  \n// 创建工厂  \nclass LiuJiu {  \npublic:  \n    static Food* CookFood(const char* foodName)  \n    {  \n        if (!strcmp(foodName,\"烤冷面\"))  \n        {  \n            return new KaoLengMian();  \n        }  \n        else if (!strcmp(foodName,\"手抓饼\"))  \n        {  \n            return new ShouZhuaBing();  \n        }  \n        else if (!strcmp(foodName, \"煎饼果子\"))  \n        {  \n            return new JianBingGuoZi();  \n        }  \n        else  \n        {  \n            std::cout << \"没有这种商品\";  \n        }  \n        return new Food();  \n    }  \n};\n\n  \nint main()  \n{  \n    LiuJiu myCar=LiuJiu();  \n    std::string f;  \n    std::cin >> f;  \n    Food* myfood;  \n    myfood = myCar.CookFood(f.c_str());  \n    myfood->Cook();  \n    return 0;  \n}  \n```\n  \n#### 优缺点\n  \n* 优点  \n  * <u>把创建产品实例的操作</u> 和 <u>使用实例的工作分开</u> ，类似于消费者不需要知道怎么做煎饼果子就能吃到，不关心产品如何制造，只关心如何使用，实现了解耦。  \n  * 把初始化产品的工作全集中在工厂内进行，方便维护，更符合面向对象的原则，而不是面向过程。  \n* 缺点  \n  * 所有实例创建都在工厂内，工厂不能工作后，整个系统都会被影响。  \n  * 违背开闭原则，添加新产品，不得不修改工厂类的逻辑，会造成工厂类的逻辑复杂。  \n  * 使用了静态方法，静态方法无法被继承、重写，工厂无法基于继承形成等级结构。\n  \n#### 适用场景\n  \n产品少；只知道传入参数，对构造逻辑不关心。\n  \n### 工厂方法\n  \n#### 简介\n  \n通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。解决普通工厂一旦生产新产品就要修改工厂类的方法逻辑，造成工厂逻辑混乱复杂的问题。\n  \n#### 模式组成\n  \n* 抽象产品  \n* 具体产品  \n* 抽象工厂，具体工厂的父类，描述具体工厂的接口  \n* 具体工厂，被外界调用，实现工厂方法创建产品实例。\n  \n#### 直接上代码\n  \n~~~c++\n// 抽象的食物\nclass Food {\npublic: virtual void Cook() { std::cout << \"A Food\"; }\n};\n\n// 抽象工厂类\nclass Factory {\npublic:\n    virtual Food FactoryMeth() { std::cout << \"Can`t find Factory\"; }\n};\n\n// 具体食物类\nclass KaoLengMian :public Food {\npublic:\n    void Cook()\n    {\n        std::cout << \"烤冷面\";\n    }\npublic:\n    int a = 0;\n};\n\nclass ShouZhuaBing :public Food {\npublic:\n    void Cook() {\n        std::cout << \"手抓饼\";\n    }\n};\n\nclass JianBingGuoZi :public Food {\npublic:\n    void Cook()\n    {\n        std::cout << \"煎饼果子\";\n    }\n};\n\n// 创建工厂\nclass KLMFactory : public Factory {\npublic:\n    Food* FactoryMeth() {\n        return new KaoLengMian();\n    }\n};\n\nclass SZBFactory : public Factory {\npublic:\n    Food* FactoryMeth()\n    {\n        return new ShouZhuaBing();\n    }\n};\n\nclass JBGZFactory : public Factory {\npublic:\n    Food* FactoryMeth() {\n        return new JianBingGuoZi();\n    }\n};\n\n\nint main()\n{\n    KLMFactory klmCar = KLMFactory();\n    SZBFactory szbCar = SZBFactory();\n    JBGZFactory jbgzCar = JBGZFactory();\n    KaoLengMian* klm = (KaoLengMian*)klmCar.FactoryMeth();\n    klm->Cook();\n    std::cout << klm->a;\n    return 0;\n}\n~~~\n  \n#### 优缺点\n  \n* 优点  \n  * 更符合开闭原则  \n    新增产品时只需要新增相应的工厂即可。  \n    无需像简单工厂那样修改工厂逻辑。  \n  * 更符合单一职责原则  \n    每个工厂只负责一种产品  \n  * 不用静态方法，可以进行继承，可以实现多态。  \n* 缺点  \n  * 新增产品，还要新增工厂，系统内类的个数成对增加，一定程度上增加了系统的复杂度，编译运行时会带来一定的开销。  \n  * 抽象类多不方便理解代码  \n  * 对于使用这种工厂方法的类而言，若要更换别的商品，需要修改工厂类的实例。  \n  * 一个工厂只能生产一种产品。\n  \n#### 适用场景\n  \n不需要知道产品类名，只需知道工厂； \n  \n### 抽象工厂模式\n  \n#### 简介\n  \n抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。  \n允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。  \n解决了每个工厂只能创建一类产品的问题。\n  \n#### 模式组成\n  \n* 抽象产品族(Abstract Product)，抽象产品的父类，描述抽象产品的公共接口  \n* 抽象产品(Product)  \n* 具体产品(Concrete Product)  \n* 抽象工厂(Creator)  \n* 具体工厂(Concrete Creator)\n  \n抽象产品族：蜥蜴战士，魔法师；抽象产品：火属性蜥蜴战士、冰属性蜥蜴战士、电属性蜥蜴战士；火魔法师、冰魔法师、电魔法师；具体产品：中等难度的冰属性蜥蜴战士。  \n不同类型的怪物构成一个产品族，同一种但属性不同的怪物构成一个抽象产品，一个生产出来的怪物是具体产品。\n  \n#### 代码\n  \n火冰，工厂都能制造1，2两种怪物，怪物有火1，火2，冰1，冰2.  \n~~~c++\n// 抽象产品族\nclass ZaiE {\npublic:\n    void attack() { std::cout << \"GaLong\"; }\n};\n\n// 抽象工厂类\nclass MonsterFactory {\npublic:\n    ZaiE* Monster1() { return new ZaiE; };\n    ZaiE* Monster2() { return new ZaiE; };\n};\n\n// 抽象产品类\nclass MonsterOne:public ZaiE{\npublic:\n    void attack() { std::cout << \"M1\"; }\n};\n\nclass MonsterTwo:public ZaiE {\npublic:\n    void attack() { std::cout << \"M2\"; }\n};\n\n// 具体产品\nclass FireMonsterOne:public MonsterOne {\npublic:\n    void attack() { std::cout << \"Fire M1\"; }\n};\n\nclass IceMonsterOne :public MonsterOne{\npublic:\n    void attack() { std::cout << \"Ice M1\"; }\n};\n\nclass FireMonsterTwo :public MonsterTwo {\npublic:\n    void attack() { std::cout << \"Fire M2\"; }\n};\n\nclass IceMonsterTwo :public MonsterTwo {\npublic:\n    void attack() { std::cout << \"Ice M2\"; }\n};\n\n// 具体工厂\nclass FireFactory :public MonsterFactory {\npublic:\n    ZaiE* Monster1()\n    {\n        return new FireMonsterOne();\n    }\n    ZaiE* Monster2()\n    {\n        return new FireMonsterTwo();\n    }\n};\n\nclass IceFactory :public MonsterFactory {\npublic:\n    ZaiE* Monster1()\n    {\n        return new IceMonsterOne();\n    }\n    ZaiE* Monster2()\n    {\n        return new IceMonsterTwo();\n    }\n};\n\nint main()\n{\n    FireFactory ff = FireFactory();\n    IceFactory icef = IceFactory();\n    FireMonsterOne* fm1 = (FireMonsterOne*)ff.Monster1();\n    IceMonsterTwo* icem2 = (IceMonsterTwo*)icef.Monster2();\n    fm1->attack();\n    icem2->attack();\n    return 0;\n}\n~~~\n  \n#### 优缺点\n  \n* 优点  \n  * 具体产品生产，交给具体工厂，降低耦合。  \n  * 新增产品，增加产品类，修改工厂类即可  \n* 缺点  \n  * 容易增添抽象产品种类(比如增加暗属性怪物)，但是增加新的产品族比较难(比如加入新的怪)，因为抽象工厂定义内定义了能生产的所有对象，新增产品族需要修改所有的工厂，而增加新的抽象产品，只需建新的工厂。\n  \n## [单例模式](https://blog.csdn.net/unonoi/article/details/121138176)\n  \n单例模式是指在整个系统的生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。  \n特点就是全局唯一，就像世界上只有一个一个一个！啊啊啊！\n  \n### 为什么需要单例模式\n  \n单例模式是为了保证程序的线程安全。  \n#### 什么是线程安全？\n  \n线程安全是指在拥有共享数据的多条线程并行执行的过程中，线程安全的代码会通过同步机制保证各个线程可以正常且正确的执行，不会出现数据污染的情况。  \n#### 如何保证线程安全\n  \n1、使用锁，给共享的资源加锁，保证每个资源变量每时每刻至多被一个线程占用。  \n2、让线程也拥有资源，不去共享进程中的资源。  \n如：使用 threadlocal 可以为每个线程维护一个私有的本地变量。\n  \n### 单例模式分类\n  \n分为**懒汉式**和**饿汉式**，二者**区别在于创建实例的时间不同。**\n  \n* 懒汉式(比较懒，用到时候才创建)  \n  系统运行中，实例不存在，只有用到才会去创建并使用实例。我们需要考虑线程安全的问题，所以后面有普通懒汉式(*线程不安全*)和加锁的懒汉式(*线程安全*)。  \n* 饿汉式(饿的不行了，一开始就创建)  \n  系统一运行就初始化创建实例，直接调用即可。这种方式本身就是线程安全的，可以安心使用。\n  \n### 单例类的特点\n  \n* 构造函数和析构函数均为私有成员，防止外部构造和析构。  \n* 拷贝构造函数和赋值构造函数是私有类型，禁止外部拷贝和赋值。  \n* 类内有一个获取实例的静态方法，供全局访问。\n  \n### 单例模式实现\n  \n#### 普通懒汉模式\n  \n大佬没写，我也不写(\n  \n#### 加锁的懒汉模式\n  \n##### 方法1.返回普通指针\n  \n头文件  \n这里需要学习[`std::mutex`互斥量，先贴一个bing搜的，以后补充学习](https://cn.bing.com/search?q=std%3A%3Amutex&PC=U316&FORM=CHROMN)\n  \n~~~c++\n#include <mutex>\n\nclass SingleInstance {\npublic:\n    static SingleInstance* GetInstacne();   // 获取单实例对象\n    static void deleteInstance();           // 释放单实例，在进程退出时调用。\n    void PrintInstance();                   // 打印单实例的实际地址\n\nprivate:\n    // 私有的构造、析构寒素\n    SingleInstance();\n    ~SingleInstance();\n\n    // 私有的拷贝、赋值构造函数\n    SingleInstance(const SingleInstance& single);\n    const SingleInstance& operator=(const SingleInstance& single);\n\nprivate:\n    // 唯一单实例对象的指针\n    static SingleInstance* m_SingleInstance;\n    static std::mutex m_Mutex;              // 锁\n};\n~~~\n  \n源文件  \n~~~c++\n// 初始化静态成员变量\nSingleInstance* SingleInstance::m_SingleInstance = nullptr;\nstd::mutex SingleInstance::m_Mutex;\n\n// 不能返回指针的引用！会存在在外部被修改的风险\nSingleInstance* SingleInstance::GetInstacne()\n{\n    // 使用两个 if 进行双检锁；好处是，只有判断指针为空时才加锁\n    // 避免每次调用 GetInstance 的方法都进行加锁，锁存在一定的开销\n    if (m_SingleInstance == nullptr)\n    {\n        std::unique_lock<std::mutex> lock(m_Mutex);  // 加锁\n        if (m_SingleInstance == nullptr)\n        {\n            m_SingleInstance = new(std::nothrow)SingleInstance();\n        }\n    }\n\n    return m_SingleInstance;\n}\n\nvoid SingleInstance::deleteInstance()\n{\n    std::unique_lock<std::mutex> lock(m_Mutex); // 加锁\n    if (m_SingleInstance)\n    {\n        delete m_SingleInstance;\n        m_SingleInstance = nullptr;\n    }\n}\n\nvoid SingleInstance::PrintInstance()\n{\n    std::cout << \"该实例的内存地址为：\" << this << std::endl;\n}\n\nSingleInstance::SingleInstance()\n{\n    std::cout << \"单例模式构造函数\" << std::endl;\n}\n\nSingleInstance::~SingleInstance()\n{\n    std::cout << \"单例模式析构函数\" << std::endl;\n}\n~~~\n  \n##### 方法2.返回智能指针\n  \n~~~c++\n#include <mutex>\n#include <memory>\n\nclass Singleton {\npublic:\n    static std::shared_ptr<Singleton> getSingleton();\n\n    void Print() { std::cout << \"Hello World\" << std::endl; }\n\n    ~Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; } // print function name\n\nprivate:\n    Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; }\n};\n\nstatic std::shared_ptr<Singleton> singleton = nullptr;\nstatic std::mutex singletonMutex;\n\nstd::shared_ptr<Singleton> Singleton::getSingleton()\n{\n    if (singleton == nullptr)\n    {\n        std::unique_lock<std::mutex> lock(singletonMutex);\n        if (singleton == nullptr)\n        {\n            auto temp = std::shared_ptr<Singleton>(new Singleton());\n            singleton = temp;\n        }\n    }\n    return singleton;\n}\n~~~\n  \n##### 静态局部变量的懒汉单例(C++11线程安全)\n  \n头文件  \n~~~c++\nclass Single {\npublic:\n    // 获取单实例对象\n    static Single GetInstance();\n\n    void Print();\n\nprivate:\n    // 防止外部构造\n    Single();\n\n    // 禁止外部析构\n    ~Single();\n\n    // j禁止外部拷贝\n    Single(const Single& single);\n\n    // 禁止外部赋值\n    const Single& operator=(const Single& single);\n};\n~~~\n  \n源文件  \n~~~c++\nSingle Single::GetInstance()\n{\n    /*L\n    利用局部静态变量的特性实现\n    静态局部变量只能在当前函数内有效，其他函数无法访问\n    静态局部变量只有在第一次被调用的时候进行初始化，存在静态存储区，直到程序结束\n    */\n    static Single single;\n    return single;\n}\n\nvoid Single::Print()\n{\n    std::cout << \"My Single Instance Address is:\" << this << std::endl;\n}\n\nSingle::Single()\n{\n    std::cout << \"构造函数\" << std::endl;\n}\n\nSingle::~Single()\n{\n    std::cout << \"析构函数\" << std::endl;\n}\n~~~\n  \n但是这种方法其实还是有问题的，在多线程情况下，同时调用`GetInstance`方法会产生竞争，发生线程安全问题。  \n解决办法：在程序的单线程启动阶段就调用 `GetInstance` 方法\n  \n#### 饿汉式单例\n  \n头文件  \n~~~c++\n// 饿汉\nclass Singleton {\npublic:\n    // Get Instance\n    static Singleton* GetInstance();\n    // 释放单例，当进程退出时调用\n    static void deleteInstance();\n\n    //打印实例地址\n    inline void Print() { std::cout << \"This Instance Address is:\" << this << std::endl; }\n\nprivate:\n    Singleton();\n    ~Singleton();\n\n    Singleton(const Singleton& single);\n    const Singleton& operator=(const Singleton& single);\n\nprivate:\n    // 唯一单实例对象指针\n    static Singleton* g_pSingleton;\n};\n~~~\n  \n源文件  \n~~~c++\n// 代码一运行就初始化创建实例，本身即线程安全\nSingleton* Singleton::g_pSingleton = new (std::nothrow)Singleton();\n\nSingleton* Singleton::GetInstance() {\n    return g_pSingleton;\n}\n\nvoid Singleton::deleteInstance()\n{\n    if (g_pSingleton)\n    {\n        delete g_pSingleton;\n        g_pSingleton = nullptr;\n    }\n}\n\nSingleton::Singleton()\n{\n    std::cout << \"gzhs\" << std::endl;\n}\n\nSingleton::~Singleton()\n{\n    std::cout << \"xghs\" << std::endl;\n}\n~~~\n  \n##### 使用 C++11 `std::call_once` 实现单例(C++11线程安全)\n  \n~~~c++\n#include <iostrea>\n#include <memory>\n#include <mutex>\n\nclass Singleton {\npublic:\n    static std::shared_ptr<Singleton> getSingleton();\n\n    inline void Print() { std::cout << \"SingleInstance Address is:\" << this << std::endl; }\n\n    ~Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; }\n\nprivate:\n    Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; }\n};\n\nstatic std::shared_ptr<Singleton> singleton = nullptr;\nstatic std::once_flag singletonFlag;\n\nstd::shared_ptr<Singleton> Singleton::getSingleton()\n{\n    std::call_once(singletonFlag, [&] {\n        singleton = std::shared_ptr<Singleton>(new Singleton());\n        });\n    return singleton;\n}\n~~~\n  \n## 装饰模式\n  \n### 简述\n  \n装饰模式：装饰模式是*动态地将“责任”添加*到具体对象上而**不影响这个对象所对应的类或者基类的方法**。当需要拓展功能时，提供了一种比传统继承方式更为灵活的选择。  \n就如同名字一样，加上华丽的装饰，但是不改变本质。\n  \n#### 应用场景\n  \n1. 需要**动态地为对象添加功能**，且这些功能可以**动态的撤销**。  \n2. 当使用继承不利于系统维护/拓展，或者不允许直接使用继承的方式对系统进行拓展时。  \n3. 对一个原始类同时生成了多个对象，在不影响其它对象的前提下，以动态、透明的方式为单个对象添加新的职能，而不修改原始类；因为如果对原始类进行频繁的修改，会使其变得非常复杂和庞大。\n  \n### 经典例子\n  \n设食堂出售三种主食：米饭、馒头、面条；并售三种肉食：鸡蛋、火腿、牛肉；在必选主食前提下，可在三样肉食中随意搭配，最后计算价格。\n  \n这就是一个经典的装饰模式，肉食用以修饰注释，而肉食的选择顺序和组合不影响主食，比如先算鸡蛋后算牛肉，和先算牛肉后算鸡蛋，顺序并不影响。\n  \n### UML类图？并不！\n  \n* Food  \n  * FoodRice  \n  * FoodNoodle  \n  * FoodManTou  \n  * Decorator  \n    * Egg  \n    * Beef  \n    * Ham\n  \n### 代码\n  \n1.定义**抽象基类**，Food，声明公共接口 ImyInterface()，在子类中经由该接口为具体对象添加职责。\n  \n~~~c++\nclass Food\n{\npublic:\n    Food(){}\n    virtual ~Food(){}\n\n    virtual void ImyInterface() = 0;    // 纯虚函数，为后续修饰操作提供统一接口\n\n    inline virtual void setPrice(double price) { mPrice = price; }\n    inline double getPrice() { return mPrice; }\n\nprivate:\n    double mPrice;\n};\n~~~\n  \n2.从基类Food，派生出3个在售的主食类\n  \n~~~c++\n// rice\nclass FoodRice:public Food\n{\npublic:\n    FoodRice()\n    {\n        setPrice(2.5);\n    }\n\n    ~FoodRice() {}\n\n    virtual void ImyInterface()\n    {\n        std::cout << \"Rice\";\n    }\n};\n\n// Noodle\nclass FoodNoodle :public Food\n{\npublic:\n    FoodNoodle() {\n        setPrice(6.0);\n    }\n\n    ~FoodNoodle(){}\n\n    virtual void ImyInterfece()\n    {\n        std::cout << \"Noodle\";\n    }\n};\n\n// mantou\nclass FoodMantou :public Food {\npublic:\n    FoodMantou() {\n        setPrice(2);\n    }\n\n    ~FoodMantou(){}\n\n    virtual void ImyInterface()\n    {\n        std::cout << \"Mantou\";\n    }\n};\n~~~\n  \n3.定义抽象装饰类 `Decorator`，继承自 Food 类，并在内部维护一个 Food 类型的指针，将各种装饰对象和被装饰对象组织关联起来。\n  \n~~~c++\nclass Decorator :public Food\n{\npublic:\n    Decorator(Food* food)\n    {\n        mFood = food;\n    }\n\n    virtual ~Decorator(){}  \n\n    virtual void ImyInstance()\n    {\n        this->mFood->ImyInterface();\n    }\n\n    Food* getFood()\n    {\n        return this->mFood;\n    }\n\n    void setFood(Food* food)\n    {\n        this->mFood = food;\n    }\n\nprivate:\n    Food* mFood = nullptr;\n};\n~~~\n  \n4.定义具体的装饰类(Eggs, Beef, Ham)\n  \n~~~c++\nclass EggDecorator :public Decorator\n{\npublic:\n    EggDecorator(Food* food) :Decorator(food)\n    {\n        this->setFood(food);\n        decoratorPrice = 0.5;\n    }\n\n    virtual ~EggDecorator(){}\n\n    virtual void ImyInterface()\n    {\n        this->getFood()->ImyInterface();\n        doDecorator();\n    }\n\nprivate:\n    void doDecorator()\n    {\n        std::cout << \"Add Eggs\";\n        setPrice(this->getFood()->getPrice() + decoratorPrice);\n    }\n};\n\nclass BeefDecorator :public Decorator\n{\npublic:\n    BeefDecorator(Food* food) :Decorator(food)\n    {\n        this->setFood(food);\n        decoratorPrice = 10;\n    }\n\n    virtual ~BeefDecorator(){}\n\n    virtual void ImyInterface()\n    {\n        this->getFood()->ImyInterface();\n        doDecorator();\n    }\n\nprivate:\n    void doDecorator()\n    {\n        std::cout << \"Add Beef\";\n        setPrice(this->getFood()->getPrice() + decoratorPrice);\n    }\n};\n\nclass HamDecorator :public Decorator\n{\npublic:\n    HamDecorator(Food* food) :Decorator(food)\n    {\n        this->setFood(food);\n    }\n\n    virtual ~HamDecorator(){}\n\n    virtual void ImyInterface()\n    {\n        this->getFood()->ImyInterface();\n        doDecorator();\n    }\n\nprivate:\n    void doDecorator()\n    {\n        std::cout << \"Add Ham\";\n        setPrice(this->getFood()->getPrice() + decoratorPrice);\n    }\n};\n~~~\n  \n客户端调用  \n~~~c++\n// Noodle + Egg\n    std::cout << \"Food Plane One:\";\n    Food* plane1 = new FoodNoodle(); \n    Food* planeD = new EggDecorator(plane1);\n    planeD->ImyInterface();\n    std::cout << \"It is \" << planeD->getPrice() << \" \" << std::endl;\n    \n    // Rice + Egg + Beef + Ham\n    std::cout << \"Food Plane Two is\";\n    Food* rice = new FoodRice();\n    Food* riceP = new EggDecorator(rice);\n    Food* ricePB = new BeefDecorator(riceP);\n    Food* ricePH = new HamDecorator(ricePB);\n\n    // 这里我们调用 ricePH\n    // ricePH->Imyinterface:(this->food)RicePB->ImyInterface RicePH的Interface调用RicePB的Interface\n    // ricePB->ImyInterface:(this->food)RiceP->ImyInterface RicePB的Interface调用RiceP的Interface\n    // riceP->ImyInterface:(this->food)rice->ImyInterfacc 调用Rice了，然后Egg price + rice price，一级一级返回相加price\n    ricePH->ImyInterface();\n    std::cout << \"It is \" << ricePH->getPrice() << std::endl;\n~~~\n  \n通过抽象基类指针Food一个一个Decorator加到主食上，最后调用 `ImyInterface` 做包装操作。\n  \n#### 装饰模式优点\n  \n1. 可以对已存在对象进行修饰包装，在被修饰对象前面或后面添加新的行为，而无需修改原始类，符合开闭原则。**原始类不变，但是原始类的对象有新的行为。**  \n2. 在不确定后续功能的时候，可以先定义一个简单的类，使用设计模式来封装，后续利用装饰类来逐步添加新的功能，最终组合出复杂功能。  \n3. 装饰类的添加和删除非常方便，在客户端代码中就能轻松实现，因此非常适合用来实现可拔插操作频繁的插件。  \n   上述的例子只展示添加其实删除很简单，只需要用前面的对象指针即可，比如riceBH想去掉H，直接用riceBF就行了。\n  \n## 策略模式\n  \n> 策略模式就像三国演义中的模式，为了帮助主公取得胜利，有多种计策，虽然这些计策各不相同，但可以相互替换，目的都是为了取胜\n  \n定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。该模式使得算法可独立于使用它的客户而变化。\n  \n### 适用场景\n  \n一个系统需要动态的在几种算法之间切换，使用者不必关心实现的细节，全部封装到策略类内即可。\n  \n### 策略模式的优缺点\n  \n* 优点  \n  1. 算法(策略)之间可以自由切换  \n  2. 避免使用多重判断  \n  3. 拓展性好  \n  4. 对开闭原则完美支持，用户无需修改原有系统即可选择算法，没有难看的 if else  \n* 缺点  \n  1. 策略类会增多  \n  2. 所有策略类都需要对外暴露  \n  3. 调用时必须知道有哪些策略类型，才能自行决定当前场景改用何种策略。\n  \n### UML类图\n  \n<img src=\"StrategyUML.png\">\n  \nContext 依赖 Strategy，内有 Strategy 指针，维护对 Strategy 的对象引用\n  \n### 代码\n  \n~~~c++\nclass Strategy {\npublic:\n    virtual void secretStrategy() = 0;\n};\n\nclass FireStrategy : public Strategy\n{\npublic:\n    void secretStrategy() { std::cout << \"夷陵之火\" << std::endl; }\n};\n\nclass WaterStrategy :public Strategy\n{\npublic:\n    void secretStrategy() { std::cout << \"水淹七军\" << std::endl; }\n};\n\nclass PoisonStrategy :public Strategy\n{\npublic:\n    void secretStrategy() { std::cout << \"文和乱舞\" << std::endl; }\n};\n\nclass Context\n{\nprivate:\n    Strategy* pStrategy;\npublic:\n    Context(Strategy* _pStrategy) :pStrategy(_pStrategy)\n    {\n\n    }\n\n    void IContextInterface()\n    {\n        pStrategy->secretStrategy();\n    }\n};\n\nint main()\n{\n    Strategy* fireStra = new FireStrategy();\n    Strategy* waterStra = new WaterStrategy();\n    Strategy* poisonStra = new PoisonStrategy();\n\n    // 先火攻，在水淹，后文和乱武\n    Context* master = new Context(fireStra);\n    master->IContextInterface();\n    master = new Context(waterStra);\n    master->IContextInterface();\n    master = new Context(poisonStra);\n    master->IContextInterface();\n    return 0;\n}\n~~~\n  \n## 代理模式\n  \n> 三国时期天子暗弱，曹公掌权，面见天子不容易，但是可以访问曹公达到访问天子的目的，曹公就是天子的代理，对天子实施了保护(禁锢)。\n  \n代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问。代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。\n  \n### 类型\n  \n1. 远程代理（Remote Proxy）：为一个位于不同地址空间的对象提供一个本地的代理对象。不同的地址空间可以在相同或不同的主机中。它*使得客户端程序可以访问在远程主机上的对象*，远程主机可能具有更好的计算性能与处理速度，可以*快速响应并处理客户端的请求*。  \n2. 虚拟代理（Virtual Proxy）：对于一些**占用系统资源较多或者加载时间较长的对象**，可以*先创建一个消耗相对较小的对象来表示*，真实对象只在*需要时才会被真正创建*，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。  \n3. 保护代理（Protect Proxy）：给不同的用户提供不同的对象访问权限。(曹操挟天子以令诸侯和这个有点类似)  \n4. 缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时存储空间，以使更多用户可以共享这些结果。  \n5. 智能引用代理（Smart Reference Proxy）：当一个对象被引用时提供一些额外的操作，比如将对象被调用的次数记录下来等。\n  \n### 应用场景\n  \n1. 客户端需要访问远程主机，可以使用远程代理。  \n2. 需要用一个消耗资源较少的对象表示资源消耗大的对象，以降低性能开销。  \n3. 要控制不同对象的访问权限级别  \n4. 为频繁访问的某个操作结果提供临时存储空间，供多客户端共享访问，无需每个客户端重新计算  \n5. 需要为一个对象的访问(引用)提供一些额外操作\n  \n### 代理模式优缺点\n  \n#### 有点\n  \n* 代理模式可以在客户端和用户直接起到中介、保护作用  \n* 代理对象可以扩展目标对象的功能  \n* 代理模式能将客户端和目标对象分离，降低了耦合度，增加了可拓展性。\n  \n#### 缺点\n  \n* 会造成系统设计的类增加  \n* 在客户端和目标对象增加代理对象，会造成处理速度变慢  \n* 增加了系统复杂度\n  \n### UML类图\n  \n<img src=\"Proxy.jpg\">\n  \n* Proxy  \n  1. 保存一个引用使得代理，\n  \n## 观察者模式\n\n\n  \n[Carson带你学设计模式](https://cloud.tencent.com/developer/article/1963312?areaSource=&traceId=)  \n[常见设计模式](https://zhuanlan.zhihu.com/p/231526884)  \n[C++设计模式解读合集](https://www.cnblogs.com/ring1992/p/9592428.html)  ","source":"_posts/常见设计模式.md","raw":"---\ntitle: 设计模式学习\ndate: 2023-04-10 12:23:38\ntags: \ntypora-root-url: ./..\\imgs\\常见设计模式\n---\n  \n对常见设计模式的学习，从C++角度学习的，但是部分资料没找到好C++版本，所以可能会有不正确的地方。  \n<!--more-->\n  \n# [常见设计模式](https://zhuanlan.zhihu.com/p/231526884)\n  \n## 工厂模式\n  \n### 简单工厂\n  \n#### 含义\n  \n* **简单工厂模式**又叫**静态方法模式**，因为**工厂类**定义了一个**静态方法**。  \n* 简单工厂的工厂类是负责生产一个对象的类。\n  \n#### 解决的问题\n  \n“类实例化的操作”和“使用对象的操作”分开，可以做到不知道具体参数就可以实例化出所需要的“产品类”。\n  \n#### 模式原理\n  \n##### 模式组成\n  \n* 抽象产品：产品的父类；是一个描述产品的公共接口  \n* 具体产品：抽象产品的子类、工厂创建的目标类；描述生产的具体产品。  \n* 工厂：被外界调用；根据传入不同参数创建不同产品。\n  \n#### 代码实例\n  \n一个小摊位可以产出“烤冷面”、“手抓饼”、“煎饼果子”等。\n  \n```cpp  \n// 抽象的食物  \nclass Food {  \npublic: virtual void Cook() { std::cout << \"A Food\"; }  \n};\n  \n// 具体食物类  \nclass KaoLengMian :public Food {  \npublic:  \n    void Cook()  \n    {  \n        std::cout << \"烤冷面\";  \n    }  \n};\n  \nclass ShouZhuaBing :public Food {  \npublic:  \n    void Cook() {  \n        std::cout << \"手抓饼\";  \n    }  \n};\n  \nclass JianBingGuoZi :public Food {  \npublic:  \n    void Cook()  \n    {  \n        std::cout << \"煎饼果子\";  \n    }  \n};\n  \n// 创建工厂  \nclass LiuJiu {  \npublic:  \n    static Food* CookFood(const char* foodName)  \n    {  \n        if (!strcmp(foodName,\"烤冷面\"))  \n        {  \n            return new KaoLengMian();  \n        }  \n        else if (!strcmp(foodName,\"手抓饼\"))  \n        {  \n            return new ShouZhuaBing();  \n        }  \n        else if (!strcmp(foodName, \"煎饼果子\"))  \n        {  \n            return new JianBingGuoZi();  \n        }  \n        else  \n        {  \n            std::cout << \"没有这种商品\";  \n        }  \n        return new Food();  \n    }  \n};\n\n  \nint main()  \n{  \n    LiuJiu myCar=LiuJiu();  \n    std::string f;  \n    std::cin >> f;  \n    Food* myfood;  \n    myfood = myCar.CookFood(f.c_str());  \n    myfood->Cook();  \n    return 0;  \n}  \n```\n  \n#### 优缺点\n  \n* 优点  \n  * <u>把创建产品实例的操作</u> 和 <u>使用实例的工作分开</u> ，类似于消费者不需要知道怎么做煎饼果子就能吃到，不关心产品如何制造，只关心如何使用，实现了解耦。  \n  * 把初始化产品的工作全集中在工厂内进行，方便维护，更符合面向对象的原则，而不是面向过程。  \n* 缺点  \n  * 所有实例创建都在工厂内，工厂不能工作后，整个系统都会被影响。  \n  * 违背开闭原则，添加新产品，不得不修改工厂类的逻辑，会造成工厂类的逻辑复杂。  \n  * 使用了静态方法，静态方法无法被继承、重写，工厂无法基于继承形成等级结构。\n  \n#### 适用场景\n  \n产品少；只知道传入参数，对构造逻辑不关心。\n  \n### 工厂方法\n  \n#### 简介\n  \n通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。解决普通工厂一旦生产新产品就要修改工厂类的方法逻辑，造成工厂逻辑混乱复杂的问题。\n  \n#### 模式组成\n  \n* 抽象产品  \n* 具体产品  \n* 抽象工厂，具体工厂的父类，描述具体工厂的接口  \n* 具体工厂，被外界调用，实现工厂方法创建产品实例。\n  \n#### 直接上代码\n  \n~~~c++\n// 抽象的食物\nclass Food {\npublic: virtual void Cook() { std::cout << \"A Food\"; }\n};\n\n// 抽象工厂类\nclass Factory {\npublic:\n    virtual Food FactoryMeth() { std::cout << \"Can`t find Factory\"; }\n};\n\n// 具体食物类\nclass KaoLengMian :public Food {\npublic:\n    void Cook()\n    {\n        std::cout << \"烤冷面\";\n    }\npublic:\n    int a = 0;\n};\n\nclass ShouZhuaBing :public Food {\npublic:\n    void Cook() {\n        std::cout << \"手抓饼\";\n    }\n};\n\nclass JianBingGuoZi :public Food {\npublic:\n    void Cook()\n    {\n        std::cout << \"煎饼果子\";\n    }\n};\n\n// 创建工厂\nclass KLMFactory : public Factory {\npublic:\n    Food* FactoryMeth() {\n        return new KaoLengMian();\n    }\n};\n\nclass SZBFactory : public Factory {\npublic:\n    Food* FactoryMeth()\n    {\n        return new ShouZhuaBing();\n    }\n};\n\nclass JBGZFactory : public Factory {\npublic:\n    Food* FactoryMeth() {\n        return new JianBingGuoZi();\n    }\n};\n\n\nint main()\n{\n    KLMFactory klmCar = KLMFactory();\n    SZBFactory szbCar = SZBFactory();\n    JBGZFactory jbgzCar = JBGZFactory();\n    KaoLengMian* klm = (KaoLengMian*)klmCar.FactoryMeth();\n    klm->Cook();\n    std::cout << klm->a;\n    return 0;\n}\n~~~\n  \n#### 优缺点\n  \n* 优点  \n  * 更符合开闭原则  \n    新增产品时只需要新增相应的工厂即可。  \n    无需像简单工厂那样修改工厂逻辑。  \n  * 更符合单一职责原则  \n    每个工厂只负责一种产品  \n  * 不用静态方法，可以进行继承，可以实现多态。  \n* 缺点  \n  * 新增产品，还要新增工厂，系统内类的个数成对增加，一定程度上增加了系统的复杂度，编译运行时会带来一定的开销。  \n  * 抽象类多不方便理解代码  \n  * 对于使用这种工厂方法的类而言，若要更换别的商品，需要修改工厂类的实例。  \n  * 一个工厂只能生产一种产品。\n  \n#### 适用场景\n  \n不需要知道产品类名，只需知道工厂； \n  \n### 抽象工厂模式\n  \n#### 简介\n  \n抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。  \n允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。  \n解决了每个工厂只能创建一类产品的问题。\n  \n#### 模式组成\n  \n* 抽象产品族(Abstract Product)，抽象产品的父类，描述抽象产品的公共接口  \n* 抽象产品(Product)  \n* 具体产品(Concrete Product)  \n* 抽象工厂(Creator)  \n* 具体工厂(Concrete Creator)\n  \n抽象产品族：蜥蜴战士，魔法师；抽象产品：火属性蜥蜴战士、冰属性蜥蜴战士、电属性蜥蜴战士；火魔法师、冰魔法师、电魔法师；具体产品：中等难度的冰属性蜥蜴战士。  \n不同类型的怪物构成一个产品族，同一种但属性不同的怪物构成一个抽象产品，一个生产出来的怪物是具体产品。\n  \n#### 代码\n  \n火冰，工厂都能制造1，2两种怪物，怪物有火1，火2，冰1，冰2.  \n~~~c++\n// 抽象产品族\nclass ZaiE {\npublic:\n    void attack() { std::cout << \"GaLong\"; }\n};\n\n// 抽象工厂类\nclass MonsterFactory {\npublic:\n    ZaiE* Monster1() { return new ZaiE; };\n    ZaiE* Monster2() { return new ZaiE; };\n};\n\n// 抽象产品类\nclass MonsterOne:public ZaiE{\npublic:\n    void attack() { std::cout << \"M1\"; }\n};\n\nclass MonsterTwo:public ZaiE {\npublic:\n    void attack() { std::cout << \"M2\"; }\n};\n\n// 具体产品\nclass FireMonsterOne:public MonsterOne {\npublic:\n    void attack() { std::cout << \"Fire M1\"; }\n};\n\nclass IceMonsterOne :public MonsterOne{\npublic:\n    void attack() { std::cout << \"Ice M1\"; }\n};\n\nclass FireMonsterTwo :public MonsterTwo {\npublic:\n    void attack() { std::cout << \"Fire M2\"; }\n};\n\nclass IceMonsterTwo :public MonsterTwo {\npublic:\n    void attack() { std::cout << \"Ice M2\"; }\n};\n\n// 具体工厂\nclass FireFactory :public MonsterFactory {\npublic:\n    ZaiE* Monster1()\n    {\n        return new FireMonsterOne();\n    }\n    ZaiE* Monster2()\n    {\n        return new FireMonsterTwo();\n    }\n};\n\nclass IceFactory :public MonsterFactory {\npublic:\n    ZaiE* Monster1()\n    {\n        return new IceMonsterOne();\n    }\n    ZaiE* Monster2()\n    {\n        return new IceMonsterTwo();\n    }\n};\n\nint main()\n{\n    FireFactory ff = FireFactory();\n    IceFactory icef = IceFactory();\n    FireMonsterOne* fm1 = (FireMonsterOne*)ff.Monster1();\n    IceMonsterTwo* icem2 = (IceMonsterTwo*)icef.Monster2();\n    fm1->attack();\n    icem2->attack();\n    return 0;\n}\n~~~\n  \n#### 优缺点\n  \n* 优点  \n  * 具体产品生产，交给具体工厂，降低耦合。  \n  * 新增产品，增加产品类，修改工厂类即可  \n* 缺点  \n  * 容易增添抽象产品种类(比如增加暗属性怪物)，但是增加新的产品族比较难(比如加入新的怪)，因为抽象工厂定义内定义了能生产的所有对象，新增产品族需要修改所有的工厂，而增加新的抽象产品，只需建新的工厂。\n  \n## [单例模式](https://blog.csdn.net/unonoi/article/details/121138176)\n  \n单例模式是指在整个系统的生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。  \n特点就是全局唯一，就像世界上只有一个一个一个！啊啊啊！\n  \n### 为什么需要单例模式\n  \n单例模式是为了保证程序的线程安全。  \n#### 什么是线程安全？\n  \n线程安全是指在拥有共享数据的多条线程并行执行的过程中，线程安全的代码会通过同步机制保证各个线程可以正常且正确的执行，不会出现数据污染的情况。  \n#### 如何保证线程安全\n  \n1、使用锁，给共享的资源加锁，保证每个资源变量每时每刻至多被一个线程占用。  \n2、让线程也拥有资源，不去共享进程中的资源。  \n如：使用 threadlocal 可以为每个线程维护一个私有的本地变量。\n  \n### 单例模式分类\n  \n分为**懒汉式**和**饿汉式**，二者**区别在于创建实例的时间不同。**\n  \n* 懒汉式(比较懒，用到时候才创建)  \n  系统运行中，实例不存在，只有用到才会去创建并使用实例。我们需要考虑线程安全的问题，所以后面有普通懒汉式(*线程不安全*)和加锁的懒汉式(*线程安全*)。  \n* 饿汉式(饿的不行了，一开始就创建)  \n  系统一运行就初始化创建实例，直接调用即可。这种方式本身就是线程安全的，可以安心使用。\n  \n### 单例类的特点\n  \n* 构造函数和析构函数均为私有成员，防止外部构造和析构。  \n* 拷贝构造函数和赋值构造函数是私有类型，禁止外部拷贝和赋值。  \n* 类内有一个获取实例的静态方法，供全局访问。\n  \n### 单例模式实现\n  \n#### 普通懒汉模式\n  \n大佬没写，我也不写(\n  \n#### 加锁的懒汉模式\n  \n##### 方法1.返回普通指针\n  \n头文件  \n这里需要学习[`std::mutex`互斥量，先贴一个bing搜的，以后补充学习](https://cn.bing.com/search?q=std%3A%3Amutex&PC=U316&FORM=CHROMN)\n  \n~~~c++\n#include <mutex>\n\nclass SingleInstance {\npublic:\n    static SingleInstance* GetInstacne();   // 获取单实例对象\n    static void deleteInstance();           // 释放单实例，在进程退出时调用。\n    void PrintInstance();                   // 打印单实例的实际地址\n\nprivate:\n    // 私有的构造、析构寒素\n    SingleInstance();\n    ~SingleInstance();\n\n    // 私有的拷贝、赋值构造函数\n    SingleInstance(const SingleInstance& single);\n    const SingleInstance& operator=(const SingleInstance& single);\n\nprivate:\n    // 唯一单实例对象的指针\n    static SingleInstance* m_SingleInstance;\n    static std::mutex m_Mutex;              // 锁\n};\n~~~\n  \n源文件  \n~~~c++\n// 初始化静态成员变量\nSingleInstance* SingleInstance::m_SingleInstance = nullptr;\nstd::mutex SingleInstance::m_Mutex;\n\n// 不能返回指针的引用！会存在在外部被修改的风险\nSingleInstance* SingleInstance::GetInstacne()\n{\n    // 使用两个 if 进行双检锁；好处是，只有判断指针为空时才加锁\n    // 避免每次调用 GetInstance 的方法都进行加锁，锁存在一定的开销\n    if (m_SingleInstance == nullptr)\n    {\n        std::unique_lock<std::mutex> lock(m_Mutex);  // 加锁\n        if (m_SingleInstance == nullptr)\n        {\n            m_SingleInstance = new(std::nothrow)SingleInstance();\n        }\n    }\n\n    return m_SingleInstance;\n}\n\nvoid SingleInstance::deleteInstance()\n{\n    std::unique_lock<std::mutex> lock(m_Mutex); // 加锁\n    if (m_SingleInstance)\n    {\n        delete m_SingleInstance;\n        m_SingleInstance = nullptr;\n    }\n}\n\nvoid SingleInstance::PrintInstance()\n{\n    std::cout << \"该实例的内存地址为：\" << this << std::endl;\n}\n\nSingleInstance::SingleInstance()\n{\n    std::cout << \"单例模式构造函数\" << std::endl;\n}\n\nSingleInstance::~SingleInstance()\n{\n    std::cout << \"单例模式析构函数\" << std::endl;\n}\n~~~\n  \n##### 方法2.返回智能指针\n  \n~~~c++\n#include <mutex>\n#include <memory>\n\nclass Singleton {\npublic:\n    static std::shared_ptr<Singleton> getSingleton();\n\n    void Print() { std::cout << \"Hello World\" << std::endl; }\n\n    ~Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; } // print function name\n\nprivate:\n    Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; }\n};\n\nstatic std::shared_ptr<Singleton> singleton = nullptr;\nstatic std::mutex singletonMutex;\n\nstd::shared_ptr<Singleton> Singleton::getSingleton()\n{\n    if (singleton == nullptr)\n    {\n        std::unique_lock<std::mutex> lock(singletonMutex);\n        if (singleton == nullptr)\n        {\n            auto temp = std::shared_ptr<Singleton>(new Singleton());\n            singleton = temp;\n        }\n    }\n    return singleton;\n}\n~~~\n  \n##### 静态局部变量的懒汉单例(C++11线程安全)\n  \n头文件  \n~~~c++\nclass Single {\npublic:\n    // 获取单实例对象\n    static Single GetInstance();\n\n    void Print();\n\nprivate:\n    // 防止外部构造\n    Single();\n\n    // 禁止外部析构\n    ~Single();\n\n    // j禁止外部拷贝\n    Single(const Single& single);\n\n    // 禁止外部赋值\n    const Single& operator=(const Single& single);\n};\n~~~\n  \n源文件  \n~~~c++\nSingle Single::GetInstance()\n{\n    /*L\n    利用局部静态变量的特性实现\n    静态局部变量只能在当前函数内有效，其他函数无法访问\n    静态局部变量只有在第一次被调用的时候进行初始化，存在静态存储区，直到程序结束\n    */\n    static Single single;\n    return single;\n}\n\nvoid Single::Print()\n{\n    std::cout << \"My Single Instance Address is:\" << this << std::endl;\n}\n\nSingle::Single()\n{\n    std::cout << \"构造函数\" << std::endl;\n}\n\nSingle::~Single()\n{\n    std::cout << \"析构函数\" << std::endl;\n}\n~~~\n  \n但是这种方法其实还是有问题的，在多线程情况下，同时调用`GetInstance`方法会产生竞争，发生线程安全问题。  \n解决办法：在程序的单线程启动阶段就调用 `GetInstance` 方法\n  \n#### 饿汉式单例\n  \n头文件  \n~~~c++\n// 饿汉\nclass Singleton {\npublic:\n    // Get Instance\n    static Singleton* GetInstance();\n    // 释放单例，当进程退出时调用\n    static void deleteInstance();\n\n    //打印实例地址\n    inline void Print() { std::cout << \"This Instance Address is:\" << this << std::endl; }\n\nprivate:\n    Singleton();\n    ~Singleton();\n\n    Singleton(const Singleton& single);\n    const Singleton& operator=(const Singleton& single);\n\nprivate:\n    // 唯一单实例对象指针\n    static Singleton* g_pSingleton;\n};\n~~~\n  \n源文件  \n~~~c++\n// 代码一运行就初始化创建实例，本身即线程安全\nSingleton* Singleton::g_pSingleton = new (std::nothrow)Singleton();\n\nSingleton* Singleton::GetInstance() {\n    return g_pSingleton;\n}\n\nvoid Singleton::deleteInstance()\n{\n    if (g_pSingleton)\n    {\n        delete g_pSingleton;\n        g_pSingleton = nullptr;\n    }\n}\n\nSingleton::Singleton()\n{\n    std::cout << \"gzhs\" << std::endl;\n}\n\nSingleton::~Singleton()\n{\n    std::cout << \"xghs\" << std::endl;\n}\n~~~\n  \n##### 使用 C++11 `std::call_once` 实现单例(C++11线程安全)\n  \n~~~c++\n#include <iostrea>\n#include <memory>\n#include <mutex>\n\nclass Singleton {\npublic:\n    static std::shared_ptr<Singleton> getSingleton();\n\n    inline void Print() { std::cout << \"SingleInstance Address is:\" << this << std::endl; }\n\n    ~Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; }\n\nprivate:\n    Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; }\n};\n\nstatic std::shared_ptr<Singleton> singleton = nullptr;\nstatic std::once_flag singletonFlag;\n\nstd::shared_ptr<Singleton> Singleton::getSingleton()\n{\n    std::call_once(singletonFlag, [&] {\n        singleton = std::shared_ptr<Singleton>(new Singleton());\n        });\n    return singleton;\n}\n~~~\n  \n## 装饰模式\n  \n### 简述\n  \n装饰模式：装饰模式是*动态地将“责任”添加*到具体对象上而**不影响这个对象所对应的类或者基类的方法**。当需要拓展功能时，提供了一种比传统继承方式更为灵活的选择。  \n就如同名字一样，加上华丽的装饰，但是不改变本质。\n  \n#### 应用场景\n  \n1. 需要**动态地为对象添加功能**，且这些功能可以**动态的撤销**。  \n2. 当使用继承不利于系统维护/拓展，或者不允许直接使用继承的方式对系统进行拓展时。  \n3. 对一个原始类同时生成了多个对象，在不影响其它对象的前提下，以动态、透明的方式为单个对象添加新的职能，而不修改原始类；因为如果对原始类进行频繁的修改，会使其变得非常复杂和庞大。\n  \n### 经典例子\n  \n设食堂出售三种主食：米饭、馒头、面条；并售三种肉食：鸡蛋、火腿、牛肉；在必选主食前提下，可在三样肉食中随意搭配，最后计算价格。\n  \n这就是一个经典的装饰模式，肉食用以修饰注释，而肉食的选择顺序和组合不影响主食，比如先算鸡蛋后算牛肉，和先算牛肉后算鸡蛋，顺序并不影响。\n  \n### UML类图？并不！\n  \n* Food  \n  * FoodRice  \n  * FoodNoodle  \n  * FoodManTou  \n  * Decorator  \n    * Egg  \n    * Beef  \n    * Ham\n  \n### 代码\n  \n1.定义**抽象基类**，Food，声明公共接口 ImyInterface()，在子类中经由该接口为具体对象添加职责。\n  \n~~~c++\nclass Food\n{\npublic:\n    Food(){}\n    virtual ~Food(){}\n\n    virtual void ImyInterface() = 0;    // 纯虚函数，为后续修饰操作提供统一接口\n\n    inline virtual void setPrice(double price) { mPrice = price; }\n    inline double getPrice() { return mPrice; }\n\nprivate:\n    double mPrice;\n};\n~~~\n  \n2.从基类Food，派生出3个在售的主食类\n  \n~~~c++\n// rice\nclass FoodRice:public Food\n{\npublic:\n    FoodRice()\n    {\n        setPrice(2.5);\n    }\n\n    ~FoodRice() {}\n\n    virtual void ImyInterface()\n    {\n        std::cout << \"Rice\";\n    }\n};\n\n// Noodle\nclass FoodNoodle :public Food\n{\npublic:\n    FoodNoodle() {\n        setPrice(6.0);\n    }\n\n    ~FoodNoodle(){}\n\n    virtual void ImyInterfece()\n    {\n        std::cout << \"Noodle\";\n    }\n};\n\n// mantou\nclass FoodMantou :public Food {\npublic:\n    FoodMantou() {\n        setPrice(2);\n    }\n\n    ~FoodMantou(){}\n\n    virtual void ImyInterface()\n    {\n        std::cout << \"Mantou\";\n    }\n};\n~~~\n  \n3.定义抽象装饰类 `Decorator`，继承自 Food 类，并在内部维护一个 Food 类型的指针，将各种装饰对象和被装饰对象组织关联起来。\n  \n~~~c++\nclass Decorator :public Food\n{\npublic:\n    Decorator(Food* food)\n    {\n        mFood = food;\n    }\n\n    virtual ~Decorator(){}  \n\n    virtual void ImyInstance()\n    {\n        this->mFood->ImyInterface();\n    }\n\n    Food* getFood()\n    {\n        return this->mFood;\n    }\n\n    void setFood(Food* food)\n    {\n        this->mFood = food;\n    }\n\nprivate:\n    Food* mFood = nullptr;\n};\n~~~\n  \n4.定义具体的装饰类(Eggs, Beef, Ham)\n  \n~~~c++\nclass EggDecorator :public Decorator\n{\npublic:\n    EggDecorator(Food* food) :Decorator(food)\n    {\n        this->setFood(food);\n        decoratorPrice = 0.5;\n    }\n\n    virtual ~EggDecorator(){}\n\n    virtual void ImyInterface()\n    {\n        this->getFood()->ImyInterface();\n        doDecorator();\n    }\n\nprivate:\n    void doDecorator()\n    {\n        std::cout << \"Add Eggs\";\n        setPrice(this->getFood()->getPrice() + decoratorPrice);\n    }\n};\n\nclass BeefDecorator :public Decorator\n{\npublic:\n    BeefDecorator(Food* food) :Decorator(food)\n    {\n        this->setFood(food);\n        decoratorPrice = 10;\n    }\n\n    virtual ~BeefDecorator(){}\n\n    virtual void ImyInterface()\n    {\n        this->getFood()->ImyInterface();\n        doDecorator();\n    }\n\nprivate:\n    void doDecorator()\n    {\n        std::cout << \"Add Beef\";\n        setPrice(this->getFood()->getPrice() + decoratorPrice);\n    }\n};\n\nclass HamDecorator :public Decorator\n{\npublic:\n    HamDecorator(Food* food) :Decorator(food)\n    {\n        this->setFood(food);\n    }\n\n    virtual ~HamDecorator(){}\n\n    virtual void ImyInterface()\n    {\n        this->getFood()->ImyInterface();\n        doDecorator();\n    }\n\nprivate:\n    void doDecorator()\n    {\n        std::cout << \"Add Ham\";\n        setPrice(this->getFood()->getPrice() + decoratorPrice);\n    }\n};\n~~~\n  \n客户端调用  \n~~~c++\n// Noodle + Egg\n    std::cout << \"Food Plane One:\";\n    Food* plane1 = new FoodNoodle(); \n    Food* planeD = new EggDecorator(plane1);\n    planeD->ImyInterface();\n    std::cout << \"It is \" << planeD->getPrice() << \" \" << std::endl;\n    \n    // Rice + Egg + Beef + Ham\n    std::cout << \"Food Plane Two is\";\n    Food* rice = new FoodRice();\n    Food* riceP = new EggDecorator(rice);\n    Food* ricePB = new BeefDecorator(riceP);\n    Food* ricePH = new HamDecorator(ricePB);\n\n    // 这里我们调用 ricePH\n    // ricePH->Imyinterface:(this->food)RicePB->ImyInterface RicePH的Interface调用RicePB的Interface\n    // ricePB->ImyInterface:(this->food)RiceP->ImyInterface RicePB的Interface调用RiceP的Interface\n    // riceP->ImyInterface:(this->food)rice->ImyInterfacc 调用Rice了，然后Egg price + rice price，一级一级返回相加price\n    ricePH->ImyInterface();\n    std::cout << \"It is \" << ricePH->getPrice() << std::endl;\n~~~\n  \n通过抽象基类指针Food一个一个Decorator加到主食上，最后调用 `ImyInterface` 做包装操作。\n  \n#### 装饰模式优点\n  \n1. 可以对已存在对象进行修饰包装，在被修饰对象前面或后面添加新的行为，而无需修改原始类，符合开闭原则。**原始类不变，但是原始类的对象有新的行为。**  \n2. 在不确定后续功能的时候，可以先定义一个简单的类，使用设计模式来封装，后续利用装饰类来逐步添加新的功能，最终组合出复杂功能。  \n3. 装饰类的添加和删除非常方便，在客户端代码中就能轻松实现，因此非常适合用来实现可拔插操作频繁的插件。  \n   上述的例子只展示添加其实删除很简单，只需要用前面的对象指针即可，比如riceBH想去掉H，直接用riceBF就行了。\n  \n## 策略模式\n  \n> 策略模式就像三国演义中的模式，为了帮助主公取得胜利，有多种计策，虽然这些计策各不相同，但可以相互替换，目的都是为了取胜\n  \n定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。该模式使得算法可独立于使用它的客户而变化。\n  \n### 适用场景\n  \n一个系统需要动态的在几种算法之间切换，使用者不必关心实现的细节，全部封装到策略类内即可。\n  \n### 策略模式的优缺点\n  \n* 优点  \n  1. 算法(策略)之间可以自由切换  \n  2. 避免使用多重判断  \n  3. 拓展性好  \n  4. 对开闭原则完美支持，用户无需修改原有系统即可选择算法，没有难看的 if else  \n* 缺点  \n  1. 策略类会增多  \n  2. 所有策略类都需要对外暴露  \n  3. 调用时必须知道有哪些策略类型，才能自行决定当前场景改用何种策略。\n  \n### UML类图\n  \n<img src=\"StrategyUML.png\">\n  \nContext 依赖 Strategy，内有 Strategy 指针，维护对 Strategy 的对象引用\n  \n### 代码\n  \n~~~c++\nclass Strategy {\npublic:\n    virtual void secretStrategy() = 0;\n};\n\nclass FireStrategy : public Strategy\n{\npublic:\n    void secretStrategy() { std::cout << \"夷陵之火\" << std::endl; }\n};\n\nclass WaterStrategy :public Strategy\n{\npublic:\n    void secretStrategy() { std::cout << \"水淹七军\" << std::endl; }\n};\n\nclass PoisonStrategy :public Strategy\n{\npublic:\n    void secretStrategy() { std::cout << \"文和乱舞\" << std::endl; }\n};\n\nclass Context\n{\nprivate:\n    Strategy* pStrategy;\npublic:\n    Context(Strategy* _pStrategy) :pStrategy(_pStrategy)\n    {\n\n    }\n\n    void IContextInterface()\n    {\n        pStrategy->secretStrategy();\n    }\n};\n\nint main()\n{\n    Strategy* fireStra = new FireStrategy();\n    Strategy* waterStra = new WaterStrategy();\n    Strategy* poisonStra = new PoisonStrategy();\n\n    // 先火攻，在水淹，后文和乱武\n    Context* master = new Context(fireStra);\n    master->IContextInterface();\n    master = new Context(waterStra);\n    master->IContextInterface();\n    master = new Context(poisonStra);\n    master->IContextInterface();\n    return 0;\n}\n~~~\n  \n## 代理模式\n  \n> 三国时期天子暗弱，曹公掌权，面见天子不容易，但是可以访问曹公达到访问天子的目的，曹公就是天子的代理，对天子实施了保护(禁锢)。\n  \n代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问。代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。\n  \n### 类型\n  \n1. 远程代理（Remote Proxy）：为一个位于不同地址空间的对象提供一个本地的代理对象。不同的地址空间可以在相同或不同的主机中。它*使得客户端程序可以访问在远程主机上的对象*，远程主机可能具有更好的计算性能与处理速度，可以*快速响应并处理客户端的请求*。  \n2. 虚拟代理（Virtual Proxy）：对于一些**占用系统资源较多或者加载时间较长的对象**，可以*先创建一个消耗相对较小的对象来表示*，真实对象只在*需要时才会被真正创建*，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。  \n3. 保护代理（Protect Proxy）：给不同的用户提供不同的对象访问权限。(曹操挟天子以令诸侯和这个有点类似)  \n4. 缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时存储空间，以使更多用户可以共享这些结果。  \n5. 智能引用代理（Smart Reference Proxy）：当一个对象被引用时提供一些额外的操作，比如将对象被调用的次数记录下来等。\n  \n### 应用场景\n  \n1. 客户端需要访问远程主机，可以使用远程代理。  \n2. 需要用一个消耗资源较少的对象表示资源消耗大的对象，以降低性能开销。  \n3. 要控制不同对象的访问权限级别  \n4. 为频繁访问的某个操作结果提供临时存储空间，供多客户端共享访问，无需每个客户端重新计算  \n5. 需要为一个对象的访问(引用)提供一些额外操作\n  \n### 代理模式优缺点\n  \n#### 有点\n  \n* 代理模式可以在客户端和用户直接起到中介、保护作用  \n* 代理对象可以扩展目标对象的功能  \n* 代理模式能将客户端和目标对象分离，降低了耦合度，增加了可拓展性。\n  \n#### 缺点\n  \n* 会造成系统设计的类增加  \n* 在客户端和目标对象增加代理对象，会造成处理速度变慢  \n* 增加了系统复杂度\n  \n### UML类图\n  \n<img src=\"Proxy.jpg\">\n  \n* Proxy  \n  1. 保存一个引用使得代理，\n  \n## 观察者模式\n\n\n  \n[Carson带你学设计模式](https://cloud.tencent.com/developer/article/1963312?areaSource=&traceId=)  \n[常见设计模式](https://zhuanlan.zhihu.com/p/231526884)  \n[C++设计模式解读合集](https://www.cnblogs.com/ring1992/p/9592428.html)  ","slug":"常见设计模式","published":1,"updated":"2024-01-14T08:13:08.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti4000wbkbwe97qde5a","content":"<p>对常见设计模式的学习，从C++角度学习的，但是部分资料没找到好C++版本，所以可能会有不正确的地方。<br />\r\n<span id=\"more\"></span></p>\r\n<h1 id=\"常见设计模式\"><a\r\nhref=\"https://zhuanlan.zhihu.com/p/231526884\">常见设计模式</a></h1>\r\n<h2 id=\"工厂模式\">工厂模式</h2>\r\n<h3 id=\"简单工厂\">简单工厂</h3>\r\n<h4 id=\"含义\">含义</h4>\r\n<ul>\r\n<li><strong>简单工厂模式</strong>又叫<strong>静态方法模式</strong>，因为<strong>工厂类</strong>定义了一个<strong>静态方法</strong>。<br />\r\n</li>\r\n<li>简单工厂的工厂类是负责生产一个对象的类。</li>\r\n</ul>\r\n<h4 id=\"解决的问题\">解决的问题</h4>\r\n<p>“类实例化的操作”和“使用对象的操作”分开，可以做到不知道具体参数就可以实例化出所需要的“产品类”。</p>\r\n<h4 id=\"模式原理\">模式原理</h4>\r\n<h5 id=\"模式组成\">模式组成</h5>\r\n<ul>\r\n<li>抽象产品：产品的父类；是一个描述产品的公共接口<br />\r\n</li>\r\n<li>具体产品：抽象产品的子类、工厂创建的目标类；描述生产的具体产品。<br />\r\n</li>\r\n<li>工厂：被外界调用；根据传入不同参数创建不同产品。</li>\r\n</ul>\r\n<h4 id=\"代码实例\">代码实例</h4>\r\n<p>一个小摊位可以产出“烤冷面”、“手抓饼”、“煎饼果子”等。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 抽象的食物  </span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Food</span> &#123;  <br><span class=\"hljs-keyword\">public</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A Food&quot;</span>; &#125;  <br>&#125;;<br>  <br><span class=\"hljs-comment\">// 具体食物类  </span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KaoLengMian</span> :<span class=\"hljs-keyword\">public</span> Food &#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\">    </span>&#123;  <br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;烤冷面&quot;</span>;  <br>    &#125;  <br>&#125;;<br>  <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShouZhuaBing</span> :<span class=\"hljs-keyword\">public</span> Food &#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;手抓饼&quot;</span>;  <br>    &#125;  <br>&#125;;<br>  <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JianBingGuoZi</span> :<span class=\"hljs-keyword\">public</span> Food &#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\">    </span>&#123;  <br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;煎饼果子&quot;</span>;  <br>    &#125;  <br>&#125;;<br>  <br><span class=\"hljs-comment\">// 创建工厂  </span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LiuJiu</span> &#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> Food* <span class=\"hljs-title\">CookFood</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* foodName)</span>  </span><br><span class=\"hljs-function\">    </span>&#123;  <br>        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">strcmp</span>(foodName,<span class=\"hljs-string\">&quot;烤冷面&quot;</span>))  <br>        &#123;  <br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">KaoLengMian</span>();  <br>        &#125;  <br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">strcmp</span>(foodName,<span class=\"hljs-string\">&quot;手抓饼&quot;</span>))  <br>        &#123;  <br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ShouZhuaBing</span>();  <br>        &#125;  <br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">strcmp</span>(foodName, <span class=\"hljs-string\">&quot;煎饼果子&quot;</span>))  <br>        &#123;  <br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">JianBingGuoZi</span>();  <br>        &#125;  <br>        <span class=\"hljs-keyword\">else</span>  <br>        &#123;  <br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;没有这种商品&quot;</span>;  <br>        &#125;  <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Food</span>();  <br>    &#125;  <br>&#125;;<br><br>  <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    LiuJiu myCar=<span class=\"hljs-built_in\">LiuJiu</span>();  <br>    std::string f;  <br>    std::cin &gt;&gt; f;  <br>    Food* myfood;  <br>    myfood = myCar.<span class=\"hljs-built_in\">CookFood</span>(f.<span class=\"hljs-built_in\">c_str</span>());  <br>    myfood-&gt;<span class=\"hljs-built_in\">Cook</span>();  <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure>\r\n<h4 id=\"优缺点\">优缺点</h4>\r\n<ul>\r\n<li>优点\r\n<ul>\r\n<li><u>把创建产品实例的操作</u> 和 <u>使用实例的工作分开</u>\r\n，类似于消费者不需要知道怎么做煎饼果子就能吃到，不关心产品如何制造，只关心如何使用，实现了解耦。<br />\r\n</li>\r\n<li>把初始化产品的工作全集中在工厂内进行，方便维护，更符合面向对象的原则，而不是面向过程。<br />\r\n</li>\r\n</ul></li>\r\n<li>缺点\r\n<ul>\r\n<li>所有实例创建都在工厂内，工厂不能工作后，整个系统都会被影响。<br />\r\n</li>\r\n<li>违背开闭原则，添加新产品，不得不修改工厂类的逻辑，会造成工厂类的逻辑复杂。<br />\r\n</li>\r\n<li>使用了静态方法，静态方法无法被继承、重写，工厂无法基于继承形成等级结构。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"适用场景\">适用场景</h4>\r\n<p>产品少；只知道传入参数，对构造逻辑不关心。</p>\r\n<h3 id=\"工厂方法\">工厂方法</h3>\r\n<h4 id=\"简介\">简介</h4>\r\n<p>通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。解决普通工厂一旦生产新产品就要修改工厂类的方法逻辑，造成工厂逻辑混乱复杂的问题。</p>\r\n<h4 id=\"模式组成-1\">模式组成</h4>\r\n<ul>\r\n<li>抽象产品<br />\r\n</li>\r\n<li>具体产品<br />\r\n</li>\r\n<li>抽象工厂，具体工厂的父类，描述具体工厂的接口<br />\r\n</li>\r\n<li>具体工厂，被外界调用，实现工厂方法创建产品实例。</li>\r\n</ul>\r\n<h4 id=\"直接上代码\">直接上代码</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 抽象的食物</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Food</span> &#123;<br><span class=\"hljs-keyword\">public</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A Food&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 抽象工厂类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Factory</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> Food <span class=\"hljs-title\">FactoryMeth</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Can`t find Factory&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 具体食物类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KaoLengMian</span> :<span class=\"hljs-keyword\">public</span> Food &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;烤冷面&quot;</span>;<br>    &#125;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">0</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShouZhuaBing</span> :<span class=\"hljs-keyword\">public</span> Food &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;手抓饼&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JianBingGuoZi</span> :<span class=\"hljs-keyword\">public</span> Food &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;煎饼果子&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 创建工厂</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KLMFactory</span> : <span class=\"hljs-keyword\">public</span> Factory &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">Food* <span class=\"hljs-title\">FactoryMeth</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">KaoLengMian</span>();<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SZBFactory</span> : <span class=\"hljs-keyword\">public</span> Factory &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">Food* <span class=\"hljs-title\">FactoryMeth</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ShouZhuaBing</span>();<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JBGZFactory</span> : <span class=\"hljs-keyword\">public</span> Factory &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">Food* <span class=\"hljs-title\">FactoryMeth</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">JianBingGuoZi</span>();<br>    &#125;<br>&#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    KLMFactory klmCar = <span class=\"hljs-built_in\">KLMFactory</span>();<br>    SZBFactory szbCar = <span class=\"hljs-built_in\">SZBFactory</span>();<br>    JBGZFactory jbgzCar = <span class=\"hljs-built_in\">JBGZFactory</span>();<br>    KaoLengMian* klm = (KaoLengMian*)klmCar.<span class=\"hljs-built_in\">FactoryMeth</span>();<br>    klm-&gt;<span class=\"hljs-built_in\">Cook</span>();<br>    std::cout &lt;&lt; klm-&gt;a;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"优缺点-1\">优缺点</h4>\r\n<ul>\r\n<li>优点\r\n<ul>\r\n<li>更符合开闭原则<br />\r\n新增产品时只需要新增相应的工厂即可。<br />\r\n无需像简单工厂那样修改工厂逻辑。<br />\r\n</li>\r\n<li>更符合单一职责原则<br />\r\n每个工厂只负责一种产品<br />\r\n</li>\r\n<li>不用静态方法，可以进行继承，可以实现多态。<br />\r\n</li>\r\n</ul></li>\r\n<li>缺点\r\n<ul>\r\n<li>新增产品，还要新增工厂，系统内类的个数成对增加，一定程度上增加了系统的复杂度，编译运行时会带来一定的开销。<br />\r\n</li>\r\n<li>抽象类多不方便理解代码<br />\r\n</li>\r\n<li>对于使用这种工厂方法的类而言，若要更换别的商品，需要修改工厂类的实例。<br />\r\n</li>\r\n<li>一个工厂只能生产一种产品。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"适用场景-1\">适用场景</h4>\r\n<p>不需要知道产品类名，只需知道工厂；</p>\r\n<h3 id=\"抽象工厂模式\">抽象工厂模式</h3>\r\n<h4 id=\"简介-1\">简介</h4>\r\n<p>抽象工厂模式，即Abstract Factory\r\nPattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。<br />\r\n允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。<br />\r\n解决了每个工厂只能创建一类产品的问题。</p>\r\n<h4 id=\"模式组成-2\">模式组成</h4>\r\n<ul>\r\n<li>抽象产品族(Abstract\r\nProduct)，抽象产品的父类，描述抽象产品的公共接口<br />\r\n</li>\r\n<li>抽象产品(Product)<br />\r\n</li>\r\n<li>具体产品(Concrete Product)<br />\r\n</li>\r\n<li>抽象工厂(Creator)<br />\r\n</li>\r\n<li>具体工厂(Concrete Creator)</li>\r\n</ul>\r\n<p>抽象产品族：蜥蜴战士，魔法师；抽象产品：火属性蜥蜴战士、冰属性蜥蜴战士、电属性蜥蜴战士；火魔法师、冰魔法师、电魔法师；具体产品：中等难度的冰属性蜥蜴战士。<br />\r\n不同类型的怪物构成一个产品族，同一种但属性不同的怪物构成一个抽象产品，一个生产出来的怪物是具体产品。</p>\r\n<h4 id=\"代码\">代码</h4>\r\n<p>火冰，工厂都能制造1，2两种怪物，怪物有火1，火2，冰1，冰2.<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 抽象产品族</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ZaiE</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;GaLong&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 抽象工厂类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MonsterFactory</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster1</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ZaiE; &#125;;<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster2</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ZaiE; &#125;;<br>&#125;;<br><br><span class=\"hljs-comment\">// 抽象产品类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MonsterOne</span>:<span class=\"hljs-keyword\">public</span> ZaiE&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;M1&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MonsterTwo</span>:<span class=\"hljs-keyword\">public</span> ZaiE &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;M2&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 具体产品</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FireMonsterOne</span>:<span class=\"hljs-keyword\">public</span> MonsterOne &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Fire M1&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">IceMonsterOne</span> :<span class=\"hljs-keyword\">public</span> MonsterOne&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Ice M1&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FireMonsterTwo</span> :<span class=\"hljs-keyword\">public</span> MonsterTwo &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Fire M2&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">IceMonsterTwo</span> :<span class=\"hljs-keyword\">public</span> MonsterTwo &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Ice M2&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 具体工厂</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FireFactory</span> :<span class=\"hljs-keyword\">public</span> MonsterFactory &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">FireMonsterOne</span>();<br>    &#125;<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">FireMonsterTwo</span>();<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">IceFactory</span> :<span class=\"hljs-keyword\">public</span> MonsterFactory &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">IceMonsterOne</span>();<br>    &#125;<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">IceMonsterTwo</span>();<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    FireFactory ff = <span class=\"hljs-built_in\">FireFactory</span>();<br>    IceFactory icef = <span class=\"hljs-built_in\">IceFactory</span>();<br>    FireMonsterOne* fm1 = (FireMonsterOne*)ff.<span class=\"hljs-built_in\">Monster1</span>();<br>    IceMonsterTwo* icem2 = (IceMonsterTwo*)icef.<span class=\"hljs-built_in\">Monster2</span>();<br>    fm1-&gt;<span class=\"hljs-built_in\">attack</span>();<br>    icem2-&gt;<span class=\"hljs-built_in\">attack</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<h4 id=\"优缺点-2\">优缺点</h4>\r\n<ul>\r\n<li>优点\r\n<ul>\r\n<li>具体产品生产，交给具体工厂，降低耦合。<br />\r\n</li>\r\n<li>新增产品，增加产品类，修改工厂类即可<br />\r\n</li>\r\n</ul></li>\r\n<li>缺点\r\n<ul>\r\n<li>容易增添抽象产品种类(比如增加暗属性怪物)，但是增加新的产品族比较难(比如加入新的怪)，因为抽象工厂定义内定义了能生产的所有对象，新增产品族需要修改所有的工厂，而增加新的抽象产品，只需建新的工厂。</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"单例模式\"><a\r\nhref=\"https://blog.csdn.net/unonoi/article/details/121138176\">单例模式</a></h2>\r\n<p>单例模式是指在整个系统的生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。<br />\r\n特点就是全局唯一，就像世界上只有一个一个一个！啊啊啊！</p>\r\n<h3 id=\"为什么需要单例模式\">为什么需要单例模式</h3>\r\n<p>单例模式是为了保证程序的线程安全。<br />\r\n#### 什么是线程安全？</p>\r\n<p>线程安全是指在拥有共享数据的多条线程并行执行的过程中，线程安全的代码会通过同步机制保证各个线程可以正常且正确的执行，不会出现数据污染的情况。<br />\r\n#### 如何保证线程安全</p>\r\n<p>1、使用锁，给共享的资源加锁，保证每个资源变量每时每刻至多被一个线程占用。<br />\r\n2、让线程也拥有资源，不去共享进程中的资源。<br />\r\n如：使用 threadlocal 可以为每个线程维护一个私有的本地变量。</p>\r\n<h3 id=\"单例模式分类\">单例模式分类</h3>\r\n<p>分为<strong>懒汉式</strong>和<strong>饿汉式</strong>，二者<strong>区别在于创建实例的时间不同。</strong></p>\r\n<ul>\r\n<li>懒汉式(比较懒，用到时候才创建)<br />\r\n系统运行中，实例不存在，只有用到才会去创建并使用实例。我们需要考虑线程安全的问题，所以后面有普通懒汉式(<em>线程不安全</em>)和加锁的懒汉式(<em>线程安全</em>)。<br />\r\n</li>\r\n<li>饿汉式(饿的不行了，一开始就创建)<br />\r\n系统一运行就初始化创建实例，直接调用即可。这种方式本身就是线程安全的，可以安心使用。</li>\r\n</ul>\r\n<h3 id=\"单例类的特点\">单例类的特点</h3>\r\n<ul>\r\n<li>构造函数和析构函数均为私有成员，防止外部构造和析构。<br />\r\n</li>\r\n<li>拷贝构造函数和赋值构造函数是私有类型，禁止外部拷贝和赋值。<br />\r\n</li>\r\n<li>类内有一个获取实例的静态方法，供全局访问。</li>\r\n</ul>\r\n<h3 id=\"单例模式实现\">单例模式实现</h3>\r\n<h4 id=\"普通懒汉模式\">普通懒汉模式</h4>\r\n<p>大佬没写，我也不写(</p>\r\n<h4 id=\"加锁的懒汉模式\">加锁的懒汉模式</h4>\r\n<h5 id=\"方法1.返回普通指针\">方法1.返回普通指针</h5>\r\n<p>头文件<br />\r\n这里需要学习<a\r\nhref=\"https://cn.bing.com/search?q=std%3A%3Amutex&amp;PC=U316&amp;FORM=CHROMN\"><code>std::mutex</code>互斥量，先贴一个bing搜的，以后补充学习</a></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;mutex&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SingleInstance</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> SingleInstance* <span class=\"hljs-title\">GetInstacne</span><span class=\"hljs-params\">()</span></span>;   <span class=\"hljs-comment\">// 获取单实例对象</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deleteInstance</span><span class=\"hljs-params\">()</span></span>;           <span class=\"hljs-comment\">// 释放单实例，在进程退出时调用。</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintInstance</span><span class=\"hljs-params\">()</span></span>;                   <span class=\"hljs-comment\">// 打印单实例的实际地址</span><br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">// 私有的构造、析构寒素</span><br>    <span class=\"hljs-built_in\">SingleInstance</span>();<br>    ~<span class=\"hljs-built_in\">SingleInstance</span>();<br><br>    <span class=\"hljs-comment\">// 私有的拷贝、赋值构造函数</span><br>    <span class=\"hljs-built_in\">SingleInstance</span>(<span class=\"hljs-type\">const</span> SingleInstance&amp; single);<br>    <span class=\"hljs-type\">const</span> SingleInstance&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> SingleInstance&amp; single);<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">// 唯一单实例对象的指针</span><br>    <span class=\"hljs-type\">static</span> SingleInstance* m_SingleInstance;<br>    <span class=\"hljs-type\">static</span> std::mutex m_Mutex;              <span class=\"hljs-comment\">// 锁</span><br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>源文件<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 初始化静态成员变量</span><br>SingleInstance* SingleInstance::m_SingleInstance = <span class=\"hljs-literal\">nullptr</span>;<br>std::mutex SingleInstance::m_Mutex;<br><br><span class=\"hljs-comment\">// 不能返回指针的引用！会存在在外部被修改的风险</span><br><span class=\"hljs-function\">SingleInstance* <span class=\"hljs-title\">SingleInstance::GetInstacne</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// 使用两个 if 进行双检锁；好处是，只有判断指针为空时才加锁</span><br>    <span class=\"hljs-comment\">// 避免每次调用 GetInstance 的方法都进行加锁，锁存在一定的开销</span><br>    <span class=\"hljs-keyword\">if</span> (m_SingleInstance == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-function\">std::unique_lock&lt;std::mutex&gt; <span class=\"hljs-title\">lock</span><span class=\"hljs-params\">(m_Mutex)</span></span>;  <span class=\"hljs-comment\">// 加锁</span><br>        <span class=\"hljs-keyword\">if</span> (m_SingleInstance == <span class=\"hljs-literal\">nullptr</span>)<br>        &#123;<br>            m_SingleInstance = <span class=\"hljs-built_in\">new</span>(std::nothrow)<span class=\"hljs-built_in\">SingleInstance</span>();<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> m_SingleInstance;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SingleInstance::deleteInstance</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">std::unique_lock&lt;std::mutex&gt; <span class=\"hljs-title\">lock</span><span class=\"hljs-params\">(m_Mutex)</span></span>; <span class=\"hljs-comment\">// 加锁</span><br>    <span class=\"hljs-keyword\">if</span> (m_SingleInstance)<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span> m_SingleInstance;<br>        m_SingleInstance = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SingleInstance::PrintInstance</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;该实例的内存地址为：&quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span> &lt;&lt; std::endl;<br>&#125;<br><br>SingleInstance::<span class=\"hljs-built_in\">SingleInstance</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;单例模式构造函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>SingleInstance::~<span class=\"hljs-built_in\">SingleInstance</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;单例模式析构函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<h5 id=\"方法2.返回智能指针\">方法2.返回智能指针</h5>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;mutex&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Singleton</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> std::shared_ptr&lt;Singleton&gt; <span class=\"hljs-title\">getSingleton</span><span class=\"hljs-params\">()</span></span>;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hello World&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    ~<span class=\"hljs-built_in\">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125; <span class=\"hljs-comment\">// print function name</span><br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-built_in\">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> std::shared_ptr&lt;Singleton&gt; singleton = <span class=\"hljs-literal\">nullptr</span>;<br><span class=\"hljs-type\">static</span> std::mutex singletonMutex;<br><br><span class=\"hljs-function\">std::shared_ptr&lt;Singleton&gt; <span class=\"hljs-title\">Singleton::getSingleton</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (singleton == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-function\">std::unique_lock&lt;std::mutex&gt; <span class=\"hljs-title\">lock</span><span class=\"hljs-params\">(singletonMutex)</span></span>;<br>        <span class=\"hljs-keyword\">if</span> (singleton == <span class=\"hljs-literal\">nullptr</span>)<br>        &#123;<br>            <span class=\"hljs-keyword\">auto</span> temp = std::<span class=\"hljs-built_in\">shared_ptr</span>&lt;Singleton&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Singleton</span>());<br>            singleton = temp;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h5\r\nid=\"静态局部变量的懒汉单例c11线程安全\">静态局部变量的懒汉单例(C++11线程安全)</h5>\r\n<p>头文件<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Single</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 获取单实例对象</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> Single <span class=\"hljs-title\">GetInstance</span><span class=\"hljs-params\">()</span></span>;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span></span>;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">// 防止外部构造</span><br>    <span class=\"hljs-built_in\">Single</span>();<br><br>    <span class=\"hljs-comment\">// 禁止外部析构</span><br>    ~<span class=\"hljs-built_in\">Single</span>();<br><br>    <span class=\"hljs-comment\">// j禁止外部拷贝</span><br>    <span class=\"hljs-built_in\">Single</span>(<span class=\"hljs-type\">const</span> Single&amp; single);<br><br>    <span class=\"hljs-comment\">// 禁止外部赋值</span><br>    <span class=\"hljs-type\">const</span> Single&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Single&amp; single);<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<p>源文件<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Single <span class=\"hljs-title\">Single::GetInstance</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">/*L</span><br><span class=\"hljs-comment\">    利用局部静态变量的特性实现</span><br><span class=\"hljs-comment\">    静态局部变量只能在当前函数内有效，其他函数无法访问</span><br><span class=\"hljs-comment\">    静态局部变量只有在第一次被调用的时候进行初始化，存在静态存储区，直到程序结束</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-type\">static</span> Single single;<br>    <span class=\"hljs-keyword\">return</span> single;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Single::Print</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;My Single Instance Address is:&quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span> &lt;&lt; std::endl;<br>&#125;<br><br>Single::<span class=\"hljs-built_in\">Single</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;构造函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>Single::~<span class=\"hljs-built_in\">Single</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;析构函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>但是这种方法其实还是有问题的，在多线程情况下，同时调用<code>GetInstance</code>方法会产生竞争，发生线程安全问题。<br />\r\n解决办法：在程序的单线程启动阶段就调用 <code>GetInstance</code> 方法</p>\r\n<h4 id=\"饿汉式单例\">饿汉式单例</h4>\r\n<p>头文件<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 饿汉</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Singleton</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// Get Instance</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> Singleton* <span class=\"hljs-title\">GetInstance</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-comment\">// 释放单例，当进程退出时调用</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deleteInstance</span><span class=\"hljs-params\">()</span></span>;<br><br>    <span class=\"hljs-comment\">//打印实例地址</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;This Instance Address is:&quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span> &lt;&lt; std::endl; &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-built_in\">Singleton</span>();<br>    ~<span class=\"hljs-built_in\">Singleton</span>();<br><br>    <span class=\"hljs-built_in\">Singleton</span>(<span class=\"hljs-type\">const</span> Singleton&amp; single);<br>    <span class=\"hljs-type\">const</span> Singleton&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Singleton&amp; single);<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">// 唯一单实例对象指针</span><br>    <span class=\"hljs-type\">static</span> Singleton* g_pSingleton;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<p>源文件<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 代码一运行就初始化创建实例，本身即线程安全</span><br>Singleton* Singleton::g_pSingleton = <span class=\"hljs-built_in\">new</span> (std::nothrow)<span class=\"hljs-built_in\">Singleton</span>();<br><br><span class=\"hljs-function\">Singleton* <span class=\"hljs-title\">Singleton::GetInstance</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> g_pSingleton;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Singleton::deleteInstance</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (g_pSingleton)<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span> g_pSingleton;<br>        g_pSingleton = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>&#125;<br><br>Singleton::<span class=\"hljs-built_in\">Singleton</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;gzhs&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>Singleton::~<span class=\"hljs-built_in\">Singleton</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;xghs&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<h5 id=\"使用-c11-stdcall_once-实现单例c11线程安全\">使用 C++11\r\n<code>std::call_once</code> 实现单例(C++11线程安全)</h5>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostrea&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;mutex&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Singleton</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> std::shared_ptr&lt;Singleton&gt; <span class=\"hljs-title\">getSingleton</span><span class=\"hljs-params\">()</span></span>;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;SingleInstance Address is:&quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span> &lt;&lt; std::endl; &#125;<br><br>    ~<span class=\"hljs-built_in\">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-built_in\">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> std::shared_ptr&lt;Singleton&gt; singleton = <span class=\"hljs-literal\">nullptr</span>;<br><span class=\"hljs-type\">static</span> std::once_flag singletonFlag;<br><br><span class=\"hljs-function\">std::shared_ptr&lt;Singleton&gt; <span class=\"hljs-title\">Singleton::getSingleton</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::<span class=\"hljs-built_in\">call_once</span>(singletonFlag, [&amp;] &#123;<br>        singleton = std::<span class=\"hljs-built_in\">shared_ptr</span>&lt;Singleton&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Singleton</span>());<br>        &#125;);<br>    <span class=\"hljs-keyword\">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"装饰模式\">装饰模式</h2>\r\n<h3 id=\"简述\">简述</h3>\r\n<p>装饰模式：装饰模式是<em>动态地将“责任”添加</em>到具体对象上而<strong>不影响这个对象所对应的类或者基类的方法</strong>。当需要拓展功能时，提供了一种比传统继承方式更为灵活的选择。<br />\r\n就如同名字一样，加上华丽的装饰，但是不改变本质。</p>\r\n<h4 id=\"应用场景\">应用场景</h4>\r\n<ol type=\"1\">\r\n<li>需要<strong>动态地为对象添加功能</strong>，且这些功能可以<strong>动态的撤销</strong>。<br />\r\n</li>\r\n<li>当使用继承不利于系统维护/拓展，或者不允许直接使用继承的方式对系统进行拓展时。<br />\r\n</li>\r\n<li>对一个原始类同时生成了多个对象，在不影响其它对象的前提下，以动态、透明的方式为单个对象添加新的职能，而不修改原始类；因为如果对原始类进行频繁的修改，会使其变得非常复杂和庞大。</li>\r\n</ol>\r\n<h3 id=\"经典例子\">经典例子</h3>\r\n<p>设食堂出售三种主食：米饭、馒头、面条；并售三种肉食：鸡蛋、火腿、牛肉；在必选主食前提下，可在三样肉食中随意搭配，最后计算价格。</p>\r\n<p>这就是一个经典的装饰模式，肉食用以修饰注释，而肉食的选择顺序和组合不影响主食，比如先算鸡蛋后算牛肉，和先算牛肉后算鸡蛋，顺序并不影响。</p>\r\n<h3 id=\"uml类图并不\">UML类图？并不！</h3>\r\n<ul>\r\n<li>Food\r\n<ul>\r\n<li>FoodRice<br />\r\n</li>\r\n<li>FoodNoodle<br />\r\n</li>\r\n<li>FoodManTou<br />\r\n</li>\r\n<li>Decorator\r\n<ul>\r\n<li>Egg<br />\r\n</li>\r\n<li>Beef<br />\r\n</li>\r\n<li>Ham</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"代码-1\">代码</h3>\r\n<p>1.定义<strong>抽象基类</strong>，Food，声明公共接口\r\nImyInterface()，在子类中经由该接口为具体对象添加职责。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Food</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Food</span>()&#123;&#125;<br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">Food</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">// 纯虚函数，为后续修饰操作提供统一接口</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setPrice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> price)</span> </span>&#123; mPrice = price; &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title\">getPrice</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> mPrice; &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">double</span> mPrice;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>2.从基类Food，派生出3个在售的主食类</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// rice</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FoodRice</span>:<span class=\"hljs-keyword\">public</span> Food<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">FoodRice</span>()<br>    &#123;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-number\">2.5</span>);<br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">FoodRice</span>() &#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Rice&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// Noodle</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FoodNoodle</span> :<span class=\"hljs-keyword\">public</span> Food<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">FoodNoodle</span>() &#123;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-number\">6.0</span>);<br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">FoodNoodle</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterfece</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Noodle&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// mantou</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FoodMantou</span> :<span class=\"hljs-keyword\">public</span> Food &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">FoodMantou</span>() &#123;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-number\">2</span>);<br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">FoodMantou</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Mantou&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>3.定义抽象装饰类 <code>Decorator</code>，继承自 Food\r\n类，并在内部维护一个 Food\r\n类型的指针，将各种装饰对象和被装饰对象组织关联起来。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Decorator</span> :<span class=\"hljs-keyword\">public</span> Food<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Decorator</span>(Food* food)<br>    &#123;<br>        mFood = food;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">Decorator</span>()&#123;&#125;  <br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInstance</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;mFood-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>    &#125;<br><br>    <span class=\"hljs-function\">Food* <span class=\"hljs-title\">getFood</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>-&gt;mFood;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setFood</span><span class=\"hljs-params\">(Food* food)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;mFood = food;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    Food* mFood = <span class=\"hljs-literal\">nullptr</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>4.定义具体的装饰类(Eggs, Beef, Ham)</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EggDecorator</span> :<span class=\"hljs-keyword\">public</span> Decorator<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">EggDecorator</span>(Food* food) :<span class=\"hljs-built_in\">Decorator</span>(food)<br>    &#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">setFood</span>(food);<br>        decoratorPrice = <span class=\"hljs-number\">0.5</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">EggDecorator</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>        <span class=\"hljs-built_in\">doDecorator</span>();<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doDecorator</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Add Eggs&quot;</span>;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">getPrice</span>() + decoratorPrice);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BeefDecorator</span> :<span class=\"hljs-keyword\">public</span> Decorator<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">BeefDecorator</span>(Food* food) :<span class=\"hljs-built_in\">Decorator</span>(food)<br>    &#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">setFood</span>(food);<br>        decoratorPrice = <span class=\"hljs-number\">10</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">BeefDecorator</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>        <span class=\"hljs-built_in\">doDecorator</span>();<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doDecorator</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Add Beef&quot;</span>;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">getPrice</span>() + decoratorPrice);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HamDecorator</span> :<span class=\"hljs-keyword\">public</span> Decorator<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">HamDecorator</span>(Food* food) :<span class=\"hljs-built_in\">Decorator</span>(food)<br>    &#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">setFood</span>(food);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">HamDecorator</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>        <span class=\"hljs-built_in\">doDecorator</span>();<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doDecorator</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Add Ham&quot;</span>;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">getPrice</span>() + decoratorPrice);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>客户端调用<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// Noodle + Egg</span><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Food Plane One:&quot;</span>;<br>    Food* plane1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">FoodNoodle</span>(); <br>    Food* planeD = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">EggDecorator</span>(plane1);<br>    planeD-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;It is &quot;</span> &lt;&lt; planeD-&gt;<span class=\"hljs-built_in\">getPrice</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; std::endl;<br>    <br>    <span class=\"hljs-comment\">// Rice + Egg + Beef + Ham</span><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Food Plane Two is&quot;</span>;<br>    Food* rice = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">FoodRice</span>();<br>    Food* riceP = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">EggDecorator</span>(rice);<br>    Food* ricePB = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">BeefDecorator</span>(riceP);<br>    Food* ricePH = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">HamDecorator</span>(ricePB);<br><br>    <span class=\"hljs-comment\">// 这里我们调用 ricePH</span><br>    <span class=\"hljs-comment\">// ricePH-&gt;Imyinterface:(this-&gt;food)RicePB-&gt;ImyInterface RicePH的Interface调用RicePB的Interface</span><br>    <span class=\"hljs-comment\">// ricePB-&gt;ImyInterface:(this-&gt;food)RiceP-&gt;ImyInterface RicePB的Interface调用RiceP的Interface</span><br>    <span class=\"hljs-comment\">// riceP-&gt;ImyInterface:(this-&gt;food)rice-&gt;ImyInterfacc 调用Rice了，然后Egg price + rice price，一级一级返回相加price</span><br>    ricePH-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;It is &quot;</span> &lt;&lt; ricePH-&gt;<span class=\"hljs-built_in\">getPrice</span>() &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></p>\r\n<p>通过抽象基类指针Food一个一个Decorator加到主食上，最后调用\r\n<code>ImyInterface</code> 做包装操作。</p>\r\n<h4 id=\"装饰模式优点\">装饰模式优点</h4>\r\n<ol type=\"1\">\r\n<li>可以对已存在对象进行修饰包装，在被修饰对象前面或后面添加新的行为，而无需修改原始类，符合开闭原则。<strong>原始类不变，但是原始类的对象有新的行为。</strong><br />\r\n</li>\r\n<li>在不确定后续功能的时候，可以先定义一个简单的类，使用设计模式来封装，后续利用装饰类来逐步添加新的功能，最终组合出复杂功能。<br />\r\n</li>\r\n<li>装饰类的添加和删除非常方便，在客户端代码中就能轻松实现，因此非常适合用来实现可拔插操作频繁的插件。<br />\r\n上述的例子只展示添加其实删除很简单，只需要用前面的对象指针即可，比如riceBH想去掉H，直接用riceBF就行了。</li>\r\n</ol>\r\n<h2 id=\"策略模式\">策略模式</h2>\r\n<blockquote>\r\n<p>策略模式就像三国演义中的模式，为了帮助主公取得胜利，有多种计策，虽然这些计策各不相同，但可以相互替换，目的都是为了取胜</p>\r\n</blockquote>\r\n<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。该模式使得算法可独立于使用它的客户而变化。</p>\r\n<h3 id=\"适用场景-2\">适用场景</h3>\r\n<p>一个系统需要动态的在几种算法之间切换，使用者不必关心实现的细节，全部封装到策略类内即可。</p>\r\n<h3 id=\"策略模式的优缺点\">策略模式的优缺点</h3>\r\n<ul>\r\n<li>优点\r\n<ol type=\"1\">\r\n<li>算法(策略)之间可以自由切换<br />\r\n</li>\r\n<li>避免使用多重判断<br />\r\n</li>\r\n<li>拓展性好<br />\r\n</li>\r\n<li>对开闭原则完美支持，用户无需修改原有系统即可选择算法，没有难看的 if\r\nelse<br />\r\n</li>\r\n</ol></li>\r\n<li>缺点\r\n<ol type=\"1\">\r\n<li>策略类会增多<br />\r\n</li>\r\n<li>所有策略类都需要对外暴露<br />\r\n</li>\r\n<li>调用时必须知道有哪些策略类型，才能自行决定当前场景改用何种策略。</li>\r\n</ol></li>\r\n</ul>\r\n<h3 id=\"uml类图\">UML类图</h3>\r\n<p><img src=\"StrategyUML.png\"></p>\r\n<p>Context 依赖 Strategy，内有 Strategy 指针，维护对 Strategy\r\n的对象引用</p>\r\n<h3 id=\"代码-2\">代码</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Strategy</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">secretStrategy</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FireStrategy</span> : <span class=\"hljs-keyword\">public</span> Strategy<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">secretStrategy</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;夷陵之火&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WaterStrategy</span> :<span class=\"hljs-keyword\">public</span> Strategy<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">secretStrategy</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;水淹七军&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PoisonStrategy</span> :<span class=\"hljs-keyword\">public</span> Strategy<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">secretStrategy</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;文和乱舞&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Context</span><br>&#123;<br><span class=\"hljs-keyword\">private</span>:<br>    Strategy* pStrategy;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Context</span>(Strategy* _pStrategy) :<span class=\"hljs-built_in\">pStrategy</span>(_pStrategy)<br>    &#123;<br><br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">IContextInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        pStrategy-&gt;<span class=\"hljs-built_in\">secretStrategy</span>();<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Strategy* fireStra = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">FireStrategy</span>();<br>    Strategy* waterStra = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WaterStrategy</span>();<br>    Strategy* poisonStra = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">PoisonStrategy</span>();<br><br>    <span class=\"hljs-comment\">// 先火攻，在水淹，后文和乱武</span><br>    Context* master = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Context</span>(fireStra);<br>    master-&gt;<span class=\"hljs-built_in\">IContextInterface</span>();<br>    master = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Context</span>(waterStra);<br>    master-&gt;<span class=\"hljs-built_in\">IContextInterface</span>();<br>    master = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Context</span>(poisonStra);<br>    master-&gt;<span class=\"hljs-built_in\">IContextInterface</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"代理模式\">代理模式</h2>\r\n<blockquote>\r\n<p>三国时期天子暗弱，曹公掌权，面见天子不容易，但是可以访问曹公达到访问天子的目的，曹公就是天子的代理，对天子实施了保护(禁锢)。</p>\r\n</blockquote>\r\n<p>代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问。代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。</p>\r\n<h3 id=\"类型\">类型</h3>\r\n<ol type=\"1\">\r\n<li>远程代理（Remote\r\nProxy）：为一个位于不同地址空间的对象提供一个本地的代理对象。不同的地址空间可以在相同或不同的主机中。它<em>使得客户端程序可以访问在远程主机上的对象</em>，远程主机可能具有更好的计算性能与处理速度，可以<em>快速响应并处理客户端的请求</em>。<br />\r\n</li>\r\n<li>虚拟代理（Virtual\r\nProxy）：对于一些<strong>占用系统资源较多或者加载时间较长的对象</strong>，可以<em>先创建一个消耗相对较小的对象来表示</em>，真实对象只在<em>需要时才会被真正创建</em>，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。<br />\r\n</li>\r\n<li>保护代理（Protect\r\nProxy）：给不同的用户提供不同的对象访问权限。(曹操挟天子以令诸侯和这个有点类似)<br />\r\n</li>\r\n<li>缓冲代理（Cache\r\nProxy）：为某一个目标操作的结果提供临时存储空间，以使更多用户可以共享这些结果。<br />\r\n</li>\r\n<li>智能引用代理（Smart Reference\r\nProxy）：当一个对象被引用时提供一些额外的操作，比如将对象被调用的次数记录下来等。</li>\r\n</ol>\r\n<h3 id=\"应用场景-1\">应用场景</h3>\r\n<ol type=\"1\">\r\n<li>客户端需要访问远程主机，可以使用远程代理。<br />\r\n</li>\r\n<li>需要用一个消耗资源较少的对象表示资源消耗大的对象，以降低性能开销。<br />\r\n</li>\r\n<li>要控制不同对象的访问权限级别<br />\r\n</li>\r\n<li>为频繁访问的某个操作结果提供临时存储空间，供多客户端共享访问，无需每个客户端重新计算<br />\r\n</li>\r\n<li>需要为一个对象的访问(引用)提供一些额外操作</li>\r\n</ol>\r\n<h3 id=\"代理模式优缺点\">代理模式优缺点</h3>\r\n<h4 id=\"有点\">有点</h4>\r\n<ul>\r\n<li>代理模式可以在客户端和用户直接起到中介、保护作用<br />\r\n</li>\r\n<li>代理对象可以扩展目标对象的功能<br />\r\n</li>\r\n<li>代理模式能将客户端和目标对象分离，降低了耦合度，增加了可拓展性。</li>\r\n</ul>\r\n<h4 id=\"缺点\">缺点</h4>\r\n<ul>\r\n<li>会造成系统设计的类增加<br />\r\n</li>\r\n<li>在客户端和目标对象增加代理对象，会造成处理速度变慢<br />\r\n</li>\r\n<li>增加了系统复杂度</li>\r\n</ul>\r\n<h3 id=\"uml类图-1\">UML类图</h3>\r\n<p><img src=\"Proxy.jpg\"></p>\r\n<ul>\r\n<li>Proxy\r\n<ol type=\"1\">\r\n<li>保存一个引用使得代理，</li>\r\n</ol></li>\r\n</ul>\r\n<h2 id=\"观察者模式\">观察者模式</h2>\r\n<p><a\r\nhref=\"https://cloud.tencent.com/developer/article/1963312?areaSource=&amp;traceId=\">Carson带你学设计模式</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/231526884\">常见设计模式</a><br />\r\n<a\r\nhref=\"https://www.cnblogs.com/ring1992/p/9592428.html\">C++设计模式解读合集</a></p>\r\n","site":{"data":{}},"excerpt":"<p>对常见设计模式的学习，从C++角度学习的，但是部分资料没找到好C++版本，所以可能会有不正确的地方。<br />","more":"</p>\r\n<h1 id=\"常见设计模式\"><a\r\nhref=\"https://zhuanlan.zhihu.com/p/231526884\">常见设计模式</a></h1>\r\n<h2 id=\"工厂模式\">工厂模式</h2>\r\n<h3 id=\"简单工厂\">简单工厂</h3>\r\n<h4 id=\"含义\">含义</h4>\r\n<ul>\r\n<li><strong>简单工厂模式</strong>又叫<strong>静态方法模式</strong>，因为<strong>工厂类</strong>定义了一个<strong>静态方法</strong>。<br />\r\n</li>\r\n<li>简单工厂的工厂类是负责生产一个对象的类。</li>\r\n</ul>\r\n<h4 id=\"解决的问题\">解决的问题</h4>\r\n<p>“类实例化的操作”和“使用对象的操作”分开，可以做到不知道具体参数就可以实例化出所需要的“产品类”。</p>\r\n<h4 id=\"模式原理\">模式原理</h4>\r\n<h5 id=\"模式组成\">模式组成</h5>\r\n<ul>\r\n<li>抽象产品：产品的父类；是一个描述产品的公共接口<br />\r\n</li>\r\n<li>具体产品：抽象产品的子类、工厂创建的目标类；描述生产的具体产品。<br />\r\n</li>\r\n<li>工厂：被外界调用；根据传入不同参数创建不同产品。</li>\r\n</ul>\r\n<h4 id=\"代码实例\">代码实例</h4>\r\n<p>一个小摊位可以产出“烤冷面”、“手抓饼”、“煎饼果子”等。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 抽象的食物  </span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Food</span> &#123;  <br><span class=\"hljs-keyword\">public</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A Food&quot;</span>; &#125;  <br>&#125;;<br>  <br><span class=\"hljs-comment\">// 具体食物类  </span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KaoLengMian</span> :<span class=\"hljs-keyword\">public</span> Food &#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\">    </span>&#123;  <br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;烤冷面&quot;</span>;  <br>    &#125;  <br>&#125;;<br>  <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShouZhuaBing</span> :<span class=\"hljs-keyword\">public</span> Food &#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;手抓饼&quot;</span>;  <br>    &#125;  <br>&#125;;<br>  <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JianBingGuoZi</span> :<span class=\"hljs-keyword\">public</span> Food &#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\">    </span>&#123;  <br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;煎饼果子&quot;</span>;  <br>    &#125;  <br>&#125;;<br>  <br><span class=\"hljs-comment\">// 创建工厂  </span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LiuJiu</span> &#123;  <br><span class=\"hljs-keyword\">public</span>:  <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> Food* <span class=\"hljs-title\">CookFood</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* foodName)</span>  </span><br><span class=\"hljs-function\">    </span>&#123;  <br>        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">strcmp</span>(foodName,<span class=\"hljs-string\">&quot;烤冷面&quot;</span>))  <br>        &#123;  <br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">KaoLengMian</span>();  <br>        &#125;  <br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">strcmp</span>(foodName,<span class=\"hljs-string\">&quot;手抓饼&quot;</span>))  <br>        &#123;  <br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ShouZhuaBing</span>();  <br>        &#125;  <br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">strcmp</span>(foodName, <span class=\"hljs-string\">&quot;煎饼果子&quot;</span>))  <br>        &#123;  <br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">JianBingGuoZi</span>();  <br>        &#125;  <br>        <span class=\"hljs-keyword\">else</span>  <br>        &#123;  <br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;没有这种商品&quot;</span>;  <br>        &#125;  <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Food</span>();  <br>    &#125;  <br>&#125;;<br><br>  <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>  </span><br><span class=\"hljs-function\"></span>&#123;  <br>    LiuJiu myCar=<span class=\"hljs-built_in\">LiuJiu</span>();  <br>    std::string f;  <br>    std::cin &gt;&gt; f;  <br>    Food* myfood;  <br>    myfood = myCar.<span class=\"hljs-built_in\">CookFood</span>(f.<span class=\"hljs-built_in\">c_str</span>());  <br>    myfood-&gt;<span class=\"hljs-built_in\">Cook</span>();  <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure>\r\n<h4 id=\"优缺点\">优缺点</h4>\r\n<ul>\r\n<li>优点\r\n<ul>\r\n<li><u>把创建产品实例的操作</u> 和 <u>使用实例的工作分开</u>\r\n，类似于消费者不需要知道怎么做煎饼果子就能吃到，不关心产品如何制造，只关心如何使用，实现了解耦。<br />\r\n</li>\r\n<li>把初始化产品的工作全集中在工厂内进行，方便维护，更符合面向对象的原则，而不是面向过程。<br />\r\n</li>\r\n</ul></li>\r\n<li>缺点\r\n<ul>\r\n<li>所有实例创建都在工厂内，工厂不能工作后，整个系统都会被影响。<br />\r\n</li>\r\n<li>违背开闭原则，添加新产品，不得不修改工厂类的逻辑，会造成工厂类的逻辑复杂。<br />\r\n</li>\r\n<li>使用了静态方法，静态方法无法被继承、重写，工厂无法基于继承形成等级结构。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"适用场景\">适用场景</h4>\r\n<p>产品少；只知道传入参数，对构造逻辑不关心。</p>\r\n<h3 id=\"工厂方法\">工厂方法</h3>\r\n<h4 id=\"简介\">简介</h4>\r\n<p>通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。解决普通工厂一旦生产新产品就要修改工厂类的方法逻辑，造成工厂逻辑混乱复杂的问题。</p>\r\n<h4 id=\"模式组成-1\">模式组成</h4>\r\n<ul>\r\n<li>抽象产品<br />\r\n</li>\r\n<li>具体产品<br />\r\n</li>\r\n<li>抽象工厂，具体工厂的父类，描述具体工厂的接口<br />\r\n</li>\r\n<li>具体工厂，被外界调用，实现工厂方法创建产品实例。</li>\r\n</ul>\r\n<h4 id=\"直接上代码\">直接上代码</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 抽象的食物</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Food</span> &#123;<br><span class=\"hljs-keyword\">public</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;A Food&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 抽象工厂类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Factory</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> Food <span class=\"hljs-title\">FactoryMeth</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Can`t find Factory&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 具体食物类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KaoLengMian</span> :<span class=\"hljs-keyword\">public</span> Food &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;烤冷面&quot;</span>;<br>    &#125;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">0</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShouZhuaBing</span> :<span class=\"hljs-keyword\">public</span> Food &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;手抓饼&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JianBingGuoZi</span> :<span class=\"hljs-keyword\">public</span> Food &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cook</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;煎饼果子&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 创建工厂</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KLMFactory</span> : <span class=\"hljs-keyword\">public</span> Factory &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">Food* <span class=\"hljs-title\">FactoryMeth</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">KaoLengMian</span>();<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SZBFactory</span> : <span class=\"hljs-keyword\">public</span> Factory &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">Food* <span class=\"hljs-title\">FactoryMeth</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ShouZhuaBing</span>();<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JBGZFactory</span> : <span class=\"hljs-keyword\">public</span> Factory &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">Food* <span class=\"hljs-title\">FactoryMeth</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">JianBingGuoZi</span>();<br>    &#125;<br>&#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    KLMFactory klmCar = <span class=\"hljs-built_in\">KLMFactory</span>();<br>    SZBFactory szbCar = <span class=\"hljs-built_in\">SZBFactory</span>();<br>    JBGZFactory jbgzCar = <span class=\"hljs-built_in\">JBGZFactory</span>();<br>    KaoLengMian* klm = (KaoLengMian*)klmCar.<span class=\"hljs-built_in\">FactoryMeth</span>();<br>    klm-&gt;<span class=\"hljs-built_in\">Cook</span>();<br>    std::cout &lt;&lt; klm-&gt;a;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h4 id=\"优缺点-1\">优缺点</h4>\r\n<ul>\r\n<li>优点\r\n<ul>\r\n<li>更符合开闭原则<br />\r\n新增产品时只需要新增相应的工厂即可。<br />\r\n无需像简单工厂那样修改工厂逻辑。<br />\r\n</li>\r\n<li>更符合单一职责原则<br />\r\n每个工厂只负责一种产品<br />\r\n</li>\r\n<li>不用静态方法，可以进行继承，可以实现多态。<br />\r\n</li>\r\n</ul></li>\r\n<li>缺点\r\n<ul>\r\n<li>新增产品，还要新增工厂，系统内类的个数成对增加，一定程度上增加了系统的复杂度，编译运行时会带来一定的开销。<br />\r\n</li>\r\n<li>抽象类多不方便理解代码<br />\r\n</li>\r\n<li>对于使用这种工厂方法的类而言，若要更换别的商品，需要修改工厂类的实例。<br />\r\n</li>\r\n<li>一个工厂只能生产一种产品。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"适用场景-1\">适用场景</h4>\r\n<p>不需要知道产品类名，只需知道工厂；</p>\r\n<h3 id=\"抽象工厂模式\">抽象工厂模式</h3>\r\n<h4 id=\"简介-1\">简介</h4>\r\n<p>抽象工厂模式，即Abstract Factory\r\nPattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。<br />\r\n允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。<br />\r\n解决了每个工厂只能创建一类产品的问题。</p>\r\n<h4 id=\"模式组成-2\">模式组成</h4>\r\n<ul>\r\n<li>抽象产品族(Abstract\r\nProduct)，抽象产品的父类，描述抽象产品的公共接口<br />\r\n</li>\r\n<li>抽象产品(Product)<br />\r\n</li>\r\n<li>具体产品(Concrete Product)<br />\r\n</li>\r\n<li>抽象工厂(Creator)<br />\r\n</li>\r\n<li>具体工厂(Concrete Creator)</li>\r\n</ul>\r\n<p>抽象产品族：蜥蜴战士，魔法师；抽象产品：火属性蜥蜴战士、冰属性蜥蜴战士、电属性蜥蜴战士；火魔法师、冰魔法师、电魔法师；具体产品：中等难度的冰属性蜥蜴战士。<br />\r\n不同类型的怪物构成一个产品族，同一种但属性不同的怪物构成一个抽象产品，一个生产出来的怪物是具体产品。</p>\r\n<h4 id=\"代码\">代码</h4>\r\n<p>火冰，工厂都能制造1，2两种怪物，怪物有火1，火2，冰1，冰2.<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 抽象产品族</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ZaiE</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;GaLong&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 抽象工厂类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MonsterFactory</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster1</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ZaiE; &#125;;<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster2</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ZaiE; &#125;;<br>&#125;;<br><br><span class=\"hljs-comment\">// 抽象产品类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MonsterOne</span>:<span class=\"hljs-keyword\">public</span> ZaiE&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;M1&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MonsterTwo</span>:<span class=\"hljs-keyword\">public</span> ZaiE &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;M2&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 具体产品</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FireMonsterOne</span>:<span class=\"hljs-keyword\">public</span> MonsterOne &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Fire M1&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">IceMonsterOne</span> :<span class=\"hljs-keyword\">public</span> MonsterOne&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Ice M1&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FireMonsterTwo</span> :<span class=\"hljs-keyword\">public</span> MonsterTwo &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Fire M2&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">IceMonsterTwo</span> :<span class=\"hljs-keyword\">public</span> MonsterTwo &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">attack</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Ice M2&quot;</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 具体工厂</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FireFactory</span> :<span class=\"hljs-keyword\">public</span> MonsterFactory &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">FireMonsterOne</span>();<br>    &#125;<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">FireMonsterTwo</span>();<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">IceFactory</span> :<span class=\"hljs-keyword\">public</span> MonsterFactory &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">IceMonsterOne</span>();<br>    &#125;<br>    <span class=\"hljs-function\">ZaiE* <span class=\"hljs-title\">Monster2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">IceMonsterTwo</span>();<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    FireFactory ff = <span class=\"hljs-built_in\">FireFactory</span>();<br>    IceFactory icef = <span class=\"hljs-built_in\">IceFactory</span>();<br>    FireMonsterOne* fm1 = (FireMonsterOne*)ff.<span class=\"hljs-built_in\">Monster1</span>();<br>    IceMonsterTwo* icem2 = (IceMonsterTwo*)icef.<span class=\"hljs-built_in\">Monster2</span>();<br>    fm1-&gt;<span class=\"hljs-built_in\">attack</span>();<br>    icem2-&gt;<span class=\"hljs-built_in\">attack</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<h4 id=\"优缺点-2\">优缺点</h4>\r\n<ul>\r\n<li>优点\r\n<ul>\r\n<li>具体产品生产，交给具体工厂，降低耦合。<br />\r\n</li>\r\n<li>新增产品，增加产品类，修改工厂类即可<br />\r\n</li>\r\n</ul></li>\r\n<li>缺点\r\n<ul>\r\n<li>容易增添抽象产品种类(比如增加暗属性怪物)，但是增加新的产品族比较难(比如加入新的怪)，因为抽象工厂定义内定义了能生产的所有对象，新增产品族需要修改所有的工厂，而增加新的抽象产品，只需建新的工厂。</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"单例模式\"><a\r\nhref=\"https://blog.csdn.net/unonoi/article/details/121138176\">单例模式</a></h2>\r\n<p>单例模式是指在整个系统的生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。<br />\r\n特点就是全局唯一，就像世界上只有一个一个一个！啊啊啊！</p>\r\n<h3 id=\"为什么需要单例模式\">为什么需要单例模式</h3>\r\n<p>单例模式是为了保证程序的线程安全。<br />\r\n#### 什么是线程安全？</p>\r\n<p>线程安全是指在拥有共享数据的多条线程并行执行的过程中，线程安全的代码会通过同步机制保证各个线程可以正常且正确的执行，不会出现数据污染的情况。<br />\r\n#### 如何保证线程安全</p>\r\n<p>1、使用锁，给共享的资源加锁，保证每个资源变量每时每刻至多被一个线程占用。<br />\r\n2、让线程也拥有资源，不去共享进程中的资源。<br />\r\n如：使用 threadlocal 可以为每个线程维护一个私有的本地变量。</p>\r\n<h3 id=\"单例模式分类\">单例模式分类</h3>\r\n<p>分为<strong>懒汉式</strong>和<strong>饿汉式</strong>，二者<strong>区别在于创建实例的时间不同。</strong></p>\r\n<ul>\r\n<li>懒汉式(比较懒，用到时候才创建)<br />\r\n系统运行中，实例不存在，只有用到才会去创建并使用实例。我们需要考虑线程安全的问题，所以后面有普通懒汉式(<em>线程不安全</em>)和加锁的懒汉式(<em>线程安全</em>)。<br />\r\n</li>\r\n<li>饿汉式(饿的不行了，一开始就创建)<br />\r\n系统一运行就初始化创建实例，直接调用即可。这种方式本身就是线程安全的，可以安心使用。</li>\r\n</ul>\r\n<h3 id=\"单例类的特点\">单例类的特点</h3>\r\n<ul>\r\n<li>构造函数和析构函数均为私有成员，防止外部构造和析构。<br />\r\n</li>\r\n<li>拷贝构造函数和赋值构造函数是私有类型，禁止外部拷贝和赋值。<br />\r\n</li>\r\n<li>类内有一个获取实例的静态方法，供全局访问。</li>\r\n</ul>\r\n<h3 id=\"单例模式实现\">单例模式实现</h3>\r\n<h4 id=\"普通懒汉模式\">普通懒汉模式</h4>\r\n<p>大佬没写，我也不写(</p>\r\n<h4 id=\"加锁的懒汉模式\">加锁的懒汉模式</h4>\r\n<h5 id=\"方法1.返回普通指针\">方法1.返回普通指针</h5>\r\n<p>头文件<br />\r\n这里需要学习<a\r\nhref=\"https://cn.bing.com/search?q=std%3A%3Amutex&amp;PC=U316&amp;FORM=CHROMN\"><code>std::mutex</code>互斥量，先贴一个bing搜的，以后补充学习</a></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;mutex&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SingleInstance</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> SingleInstance* <span class=\"hljs-title\">GetInstacne</span><span class=\"hljs-params\">()</span></span>;   <span class=\"hljs-comment\">// 获取单实例对象</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deleteInstance</span><span class=\"hljs-params\">()</span></span>;           <span class=\"hljs-comment\">// 释放单实例，在进程退出时调用。</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintInstance</span><span class=\"hljs-params\">()</span></span>;                   <span class=\"hljs-comment\">// 打印单实例的实际地址</span><br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">// 私有的构造、析构寒素</span><br>    <span class=\"hljs-built_in\">SingleInstance</span>();<br>    ~<span class=\"hljs-built_in\">SingleInstance</span>();<br><br>    <span class=\"hljs-comment\">// 私有的拷贝、赋值构造函数</span><br>    <span class=\"hljs-built_in\">SingleInstance</span>(<span class=\"hljs-type\">const</span> SingleInstance&amp; single);<br>    <span class=\"hljs-type\">const</span> SingleInstance&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> SingleInstance&amp; single);<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">// 唯一单实例对象的指针</span><br>    <span class=\"hljs-type\">static</span> SingleInstance* m_SingleInstance;<br>    <span class=\"hljs-type\">static</span> std::mutex m_Mutex;              <span class=\"hljs-comment\">// 锁</span><br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>源文件<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 初始化静态成员变量</span><br>SingleInstance* SingleInstance::m_SingleInstance = <span class=\"hljs-literal\">nullptr</span>;<br>std::mutex SingleInstance::m_Mutex;<br><br><span class=\"hljs-comment\">// 不能返回指针的引用！会存在在外部被修改的风险</span><br><span class=\"hljs-function\">SingleInstance* <span class=\"hljs-title\">SingleInstance::GetInstacne</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// 使用两个 if 进行双检锁；好处是，只有判断指针为空时才加锁</span><br>    <span class=\"hljs-comment\">// 避免每次调用 GetInstance 的方法都进行加锁，锁存在一定的开销</span><br>    <span class=\"hljs-keyword\">if</span> (m_SingleInstance == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-function\">std::unique_lock&lt;std::mutex&gt; <span class=\"hljs-title\">lock</span><span class=\"hljs-params\">(m_Mutex)</span></span>;  <span class=\"hljs-comment\">// 加锁</span><br>        <span class=\"hljs-keyword\">if</span> (m_SingleInstance == <span class=\"hljs-literal\">nullptr</span>)<br>        &#123;<br>            m_SingleInstance = <span class=\"hljs-built_in\">new</span>(std::nothrow)<span class=\"hljs-built_in\">SingleInstance</span>();<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> m_SingleInstance;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SingleInstance::deleteInstance</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">std::unique_lock&lt;std::mutex&gt; <span class=\"hljs-title\">lock</span><span class=\"hljs-params\">(m_Mutex)</span></span>; <span class=\"hljs-comment\">// 加锁</span><br>    <span class=\"hljs-keyword\">if</span> (m_SingleInstance)<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span> m_SingleInstance;<br>        m_SingleInstance = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SingleInstance::PrintInstance</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;该实例的内存地址为：&quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span> &lt;&lt; std::endl;<br>&#125;<br><br>SingleInstance::<span class=\"hljs-built_in\">SingleInstance</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;单例模式构造函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>SingleInstance::~<span class=\"hljs-built_in\">SingleInstance</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;单例模式析构函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<h5 id=\"方法2.返回智能指针\">方法2.返回智能指针</h5>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;mutex&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Singleton</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> std::shared_ptr&lt;Singleton&gt; <span class=\"hljs-title\">getSingleton</span><span class=\"hljs-params\">()</span></span>;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hello World&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    ~<span class=\"hljs-built_in\">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125; <span class=\"hljs-comment\">// print function name</span><br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-built_in\">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> std::shared_ptr&lt;Singleton&gt; singleton = <span class=\"hljs-literal\">nullptr</span>;<br><span class=\"hljs-type\">static</span> std::mutex singletonMutex;<br><br><span class=\"hljs-function\">std::shared_ptr&lt;Singleton&gt; <span class=\"hljs-title\">Singleton::getSingleton</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (singleton == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-function\">std::unique_lock&lt;std::mutex&gt; <span class=\"hljs-title\">lock</span><span class=\"hljs-params\">(singletonMutex)</span></span>;<br>        <span class=\"hljs-keyword\">if</span> (singleton == <span class=\"hljs-literal\">nullptr</span>)<br>        &#123;<br>            <span class=\"hljs-keyword\">auto</span> temp = std::<span class=\"hljs-built_in\">shared_ptr</span>&lt;Singleton&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Singleton</span>());<br>            singleton = temp;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h5\r\nid=\"静态局部变量的懒汉单例c11线程安全\">静态局部变量的懒汉单例(C++11线程安全)</h5>\r\n<p>头文件<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Single</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 获取单实例对象</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> Single <span class=\"hljs-title\">GetInstance</span><span class=\"hljs-params\">()</span></span>;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span></span>;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">// 防止外部构造</span><br>    <span class=\"hljs-built_in\">Single</span>();<br><br>    <span class=\"hljs-comment\">// 禁止外部析构</span><br>    ~<span class=\"hljs-built_in\">Single</span>();<br><br>    <span class=\"hljs-comment\">// j禁止外部拷贝</span><br>    <span class=\"hljs-built_in\">Single</span>(<span class=\"hljs-type\">const</span> Single&amp; single);<br><br>    <span class=\"hljs-comment\">// 禁止外部赋值</span><br>    <span class=\"hljs-type\">const</span> Single&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Single&amp; single);<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<p>源文件<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Single <span class=\"hljs-title\">Single::GetInstance</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">/*L</span><br><span class=\"hljs-comment\">    利用局部静态变量的特性实现</span><br><span class=\"hljs-comment\">    静态局部变量只能在当前函数内有效，其他函数无法访问</span><br><span class=\"hljs-comment\">    静态局部变量只有在第一次被调用的时候进行初始化，存在静态存储区，直到程序结束</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-type\">static</span> Single single;<br>    <span class=\"hljs-keyword\">return</span> single;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Single::Print</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;My Single Instance Address is:&quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span> &lt;&lt; std::endl;<br>&#125;<br><br>Single::<span class=\"hljs-built_in\">Single</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;构造函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>Single::~<span class=\"hljs-built_in\">Single</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;析构函数&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>但是这种方法其实还是有问题的，在多线程情况下，同时调用<code>GetInstance</code>方法会产生竞争，发生线程安全问题。<br />\r\n解决办法：在程序的单线程启动阶段就调用 <code>GetInstance</code> 方法</p>\r\n<h4 id=\"饿汉式单例\">饿汉式单例</h4>\r\n<p>头文件<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 饿汉</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Singleton</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// Get Instance</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> Singleton* <span class=\"hljs-title\">GetInstance</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-comment\">// 释放单例，当进程退出时调用</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deleteInstance</span><span class=\"hljs-params\">()</span></span>;<br><br>    <span class=\"hljs-comment\">//打印实例地址</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;This Instance Address is:&quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span> &lt;&lt; std::endl; &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-built_in\">Singleton</span>();<br>    ~<span class=\"hljs-built_in\">Singleton</span>();<br><br>    <span class=\"hljs-built_in\">Singleton</span>(<span class=\"hljs-type\">const</span> Singleton&amp; single);<br>    <span class=\"hljs-type\">const</span> Singleton&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Singleton&amp; single);<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">// 唯一单实例对象指针</span><br>    <span class=\"hljs-type\">static</span> Singleton* g_pSingleton;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<p>源文件<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 代码一运行就初始化创建实例，本身即线程安全</span><br>Singleton* Singleton::g_pSingleton = <span class=\"hljs-built_in\">new</span> (std::nothrow)<span class=\"hljs-built_in\">Singleton</span>();<br><br><span class=\"hljs-function\">Singleton* <span class=\"hljs-title\">Singleton::GetInstance</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> g_pSingleton;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Singleton::deleteInstance</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (g_pSingleton)<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span> g_pSingleton;<br>        g_pSingleton = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>&#125;<br><br>Singleton::<span class=\"hljs-built_in\">Singleton</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;gzhs&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>Singleton::~<span class=\"hljs-built_in\">Singleton</span>()<br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;xghs&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<h5 id=\"使用-c11-stdcall_once-实现单例c11线程安全\">使用 C++11\r\n<code>std::call_once</code> 实现单例(C++11线程安全)</h5>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostrea&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;mutex&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Singleton</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> std::shared_ptr&lt;Singleton&gt; <span class=\"hljs-title\">getSingleton</span><span class=\"hljs-params\">()</span></span>;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;SingleInstance Address is:&quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span> &lt;&lt; std::endl; &#125;<br><br>    ~<span class=\"hljs-built_in\">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-built_in\">Singleton</span>() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> std::shared_ptr&lt;Singleton&gt; singleton = <span class=\"hljs-literal\">nullptr</span>;<br><span class=\"hljs-type\">static</span> std::once_flag singletonFlag;<br><br><span class=\"hljs-function\">std::shared_ptr&lt;Singleton&gt; <span class=\"hljs-title\">Singleton::getSingleton</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    std::<span class=\"hljs-built_in\">call_once</span>(singletonFlag, [&amp;] &#123;<br>        singleton = std::<span class=\"hljs-built_in\">shared_ptr</span>&lt;Singleton&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Singleton</span>());<br>        &#125;);<br>    <span class=\"hljs-keyword\">return</span> singleton;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"装饰模式\">装饰模式</h2>\r\n<h3 id=\"简述\">简述</h3>\r\n<p>装饰模式：装饰模式是<em>动态地将“责任”添加</em>到具体对象上而<strong>不影响这个对象所对应的类或者基类的方法</strong>。当需要拓展功能时，提供了一种比传统继承方式更为灵活的选择。<br />\r\n就如同名字一样，加上华丽的装饰，但是不改变本质。</p>\r\n<h4 id=\"应用场景\">应用场景</h4>\r\n<ol type=\"1\">\r\n<li>需要<strong>动态地为对象添加功能</strong>，且这些功能可以<strong>动态的撤销</strong>。<br />\r\n</li>\r\n<li>当使用继承不利于系统维护/拓展，或者不允许直接使用继承的方式对系统进行拓展时。<br />\r\n</li>\r\n<li>对一个原始类同时生成了多个对象，在不影响其它对象的前提下，以动态、透明的方式为单个对象添加新的职能，而不修改原始类；因为如果对原始类进行频繁的修改，会使其变得非常复杂和庞大。</li>\r\n</ol>\r\n<h3 id=\"经典例子\">经典例子</h3>\r\n<p>设食堂出售三种主食：米饭、馒头、面条；并售三种肉食：鸡蛋、火腿、牛肉；在必选主食前提下，可在三样肉食中随意搭配，最后计算价格。</p>\r\n<p>这就是一个经典的装饰模式，肉食用以修饰注释，而肉食的选择顺序和组合不影响主食，比如先算鸡蛋后算牛肉，和先算牛肉后算鸡蛋，顺序并不影响。</p>\r\n<h3 id=\"uml类图并不\">UML类图？并不！</h3>\r\n<ul>\r\n<li>Food\r\n<ul>\r\n<li>FoodRice<br />\r\n</li>\r\n<li>FoodNoodle<br />\r\n</li>\r\n<li>FoodManTou<br />\r\n</li>\r\n<li>Decorator\r\n<ul>\r\n<li>Egg<br />\r\n</li>\r\n<li>Beef<br />\r\n</li>\r\n<li>Ham</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"代码-1\">代码</h3>\r\n<p>1.定义<strong>抽象基类</strong>，Food，声明公共接口\r\nImyInterface()，在子类中经由该接口为具体对象添加职责。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Food</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Food</span>()&#123;&#125;<br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">Food</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">// 纯虚函数，为后续修饰操作提供统一接口</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setPrice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> price)</span> </span>&#123; mPrice = price; &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title\">getPrice</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> mPrice; &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">double</span> mPrice;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>2.从基类Food，派生出3个在售的主食类</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// rice</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FoodRice</span>:<span class=\"hljs-keyword\">public</span> Food<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">FoodRice</span>()<br>    &#123;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-number\">2.5</span>);<br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">FoodRice</span>() &#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Rice&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// Noodle</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FoodNoodle</span> :<span class=\"hljs-keyword\">public</span> Food<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">FoodNoodle</span>() &#123;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-number\">6.0</span>);<br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">FoodNoodle</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterfece</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Noodle&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// mantou</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FoodMantou</span> :<span class=\"hljs-keyword\">public</span> Food &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">FoodMantou</span>() &#123;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-number\">2</span>);<br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">FoodMantou</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Mantou&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>3.定义抽象装饰类 <code>Decorator</code>，继承自 Food\r\n类，并在内部维护一个 Food\r\n类型的指针，将各种装饰对象和被装饰对象组织关联起来。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Decorator</span> :<span class=\"hljs-keyword\">public</span> Food<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Decorator</span>(Food* food)<br>    &#123;<br>        mFood = food;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">Decorator</span>()&#123;&#125;  <br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInstance</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;mFood-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>    &#125;<br><br>    <span class=\"hljs-function\">Food* <span class=\"hljs-title\">getFood</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>-&gt;mFood;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setFood</span><span class=\"hljs-params\">(Food* food)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;mFood = food;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    Food* mFood = <span class=\"hljs-literal\">nullptr</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>4.定义具体的装饰类(Eggs, Beef, Ham)</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EggDecorator</span> :<span class=\"hljs-keyword\">public</span> Decorator<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">EggDecorator</span>(Food* food) :<span class=\"hljs-built_in\">Decorator</span>(food)<br>    &#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">setFood</span>(food);<br>        decoratorPrice = <span class=\"hljs-number\">0.5</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">EggDecorator</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>        <span class=\"hljs-built_in\">doDecorator</span>();<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doDecorator</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Add Eggs&quot;</span>;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">getPrice</span>() + decoratorPrice);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BeefDecorator</span> :<span class=\"hljs-keyword\">public</span> Decorator<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">BeefDecorator</span>(Food* food) :<span class=\"hljs-built_in\">Decorator</span>(food)<br>    &#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">setFood</span>(food);<br>        decoratorPrice = <span class=\"hljs-number\">10</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">BeefDecorator</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>        <span class=\"hljs-built_in\">doDecorator</span>();<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doDecorator</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Add Beef&quot;</span>;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">getPrice</span>() + decoratorPrice);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HamDecorator</span> :<span class=\"hljs-keyword\">public</span> Decorator<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">HamDecorator</span>(Food* food) :<span class=\"hljs-built_in\">Decorator</span>(food)<br>    &#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">setFood</span>(food);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">HamDecorator</span>()&#123;&#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ImyInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>        <span class=\"hljs-built_in\">doDecorator</span>();<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">doDecorator</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Add Ham&quot;</span>;<br>        <span class=\"hljs-built_in\">setPrice</span>(<span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-built_in\">getFood</span>()-&gt;<span class=\"hljs-built_in\">getPrice</span>() + decoratorPrice);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\r\n<p>客户端调用<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// Noodle + Egg</span><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Food Plane One:&quot;</span>;<br>    Food* plane1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">FoodNoodle</span>(); <br>    Food* planeD = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">EggDecorator</span>(plane1);<br>    planeD-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;It is &quot;</span> &lt;&lt; planeD-&gt;<span class=\"hljs-built_in\">getPrice</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; std::endl;<br>    <br>    <span class=\"hljs-comment\">// Rice + Egg + Beef + Ham</span><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Food Plane Two is&quot;</span>;<br>    Food* rice = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">FoodRice</span>();<br>    Food* riceP = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">EggDecorator</span>(rice);<br>    Food* ricePB = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">BeefDecorator</span>(riceP);<br>    Food* ricePH = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">HamDecorator</span>(ricePB);<br><br>    <span class=\"hljs-comment\">// 这里我们调用 ricePH</span><br>    <span class=\"hljs-comment\">// ricePH-&gt;Imyinterface:(this-&gt;food)RicePB-&gt;ImyInterface RicePH的Interface调用RicePB的Interface</span><br>    <span class=\"hljs-comment\">// ricePB-&gt;ImyInterface:(this-&gt;food)RiceP-&gt;ImyInterface RicePB的Interface调用RiceP的Interface</span><br>    <span class=\"hljs-comment\">// riceP-&gt;ImyInterface:(this-&gt;food)rice-&gt;ImyInterfacc 调用Rice了，然后Egg price + rice price，一级一级返回相加price</span><br>    ricePH-&gt;<span class=\"hljs-built_in\">ImyInterface</span>();<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;It is &quot;</span> &lt;&lt; ricePH-&gt;<span class=\"hljs-built_in\">getPrice</span>() &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></p>\r\n<p>通过抽象基类指针Food一个一个Decorator加到主食上，最后调用\r\n<code>ImyInterface</code> 做包装操作。</p>\r\n<h4 id=\"装饰模式优点\">装饰模式优点</h4>\r\n<ol type=\"1\">\r\n<li>可以对已存在对象进行修饰包装，在被修饰对象前面或后面添加新的行为，而无需修改原始类，符合开闭原则。<strong>原始类不变，但是原始类的对象有新的行为。</strong><br />\r\n</li>\r\n<li>在不确定后续功能的时候，可以先定义一个简单的类，使用设计模式来封装，后续利用装饰类来逐步添加新的功能，最终组合出复杂功能。<br />\r\n</li>\r\n<li>装饰类的添加和删除非常方便，在客户端代码中就能轻松实现，因此非常适合用来实现可拔插操作频繁的插件。<br />\r\n上述的例子只展示添加其实删除很简单，只需要用前面的对象指针即可，比如riceBH想去掉H，直接用riceBF就行了。</li>\r\n</ol>\r\n<h2 id=\"策略模式\">策略模式</h2>\r\n<blockquote>\r\n<p>策略模式就像三国演义中的模式，为了帮助主公取得胜利，有多种计策，虽然这些计策各不相同，但可以相互替换，目的都是为了取胜</p>\r\n</blockquote>\r\n<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。该模式使得算法可独立于使用它的客户而变化。</p>\r\n<h3 id=\"适用场景-2\">适用场景</h3>\r\n<p>一个系统需要动态的在几种算法之间切换，使用者不必关心实现的细节，全部封装到策略类内即可。</p>\r\n<h3 id=\"策略模式的优缺点\">策略模式的优缺点</h3>\r\n<ul>\r\n<li>优点\r\n<ol type=\"1\">\r\n<li>算法(策略)之间可以自由切换<br />\r\n</li>\r\n<li>避免使用多重判断<br />\r\n</li>\r\n<li>拓展性好<br />\r\n</li>\r\n<li>对开闭原则完美支持，用户无需修改原有系统即可选择算法，没有难看的 if\r\nelse<br />\r\n</li>\r\n</ol></li>\r\n<li>缺点\r\n<ol type=\"1\">\r\n<li>策略类会增多<br />\r\n</li>\r\n<li>所有策略类都需要对外暴露<br />\r\n</li>\r\n<li>调用时必须知道有哪些策略类型，才能自行决定当前场景改用何种策略。</li>\r\n</ol></li>\r\n</ul>\r\n<h3 id=\"uml类图\">UML类图</h3>\r\n<p><img src=\"StrategyUML.png\"></p>\r\n<p>Context 依赖 Strategy，内有 Strategy 指针，维护对 Strategy\r\n的对象引用</p>\r\n<h3 id=\"代码-2\">代码</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Strategy</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">secretStrategy</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FireStrategy</span> : <span class=\"hljs-keyword\">public</span> Strategy<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">secretStrategy</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;夷陵之火&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WaterStrategy</span> :<span class=\"hljs-keyword\">public</span> Strategy<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">secretStrategy</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;水淹七军&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PoisonStrategy</span> :<span class=\"hljs-keyword\">public</span> Strategy<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">secretStrategy</span><span class=\"hljs-params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;文和乱舞&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Context</span><br>&#123;<br><span class=\"hljs-keyword\">private</span>:<br>    Strategy* pStrategy;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Context</span>(Strategy* _pStrategy) :<span class=\"hljs-built_in\">pStrategy</span>(_pStrategy)<br>    &#123;<br><br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">IContextInterface</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        pStrategy-&gt;<span class=\"hljs-built_in\">secretStrategy</span>();<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Strategy* fireStra = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">FireStrategy</span>();<br>    Strategy* waterStra = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WaterStrategy</span>();<br>    Strategy* poisonStra = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">PoisonStrategy</span>();<br><br>    <span class=\"hljs-comment\">// 先火攻，在水淹，后文和乱武</span><br>    Context* master = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Context</span>(fireStra);<br>    master-&gt;<span class=\"hljs-built_in\">IContextInterface</span>();<br>    master = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Context</span>(waterStra);<br>    master-&gt;<span class=\"hljs-built_in\">IContextInterface</span>();<br>    master = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Context</span>(poisonStra);<br>    master-&gt;<span class=\"hljs-built_in\">IContextInterface</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"代理模式\">代理模式</h2>\r\n<blockquote>\r\n<p>三国时期天子暗弱，曹公掌权，面见天子不容易，但是可以访问曹公达到访问天子的目的，曹公就是天子的代理，对天子实施了保护(禁锢)。</p>\r\n</blockquote>\r\n<p>代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问。代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。</p>\r\n<h3 id=\"类型\">类型</h3>\r\n<ol type=\"1\">\r\n<li>远程代理（Remote\r\nProxy）：为一个位于不同地址空间的对象提供一个本地的代理对象。不同的地址空间可以在相同或不同的主机中。它<em>使得客户端程序可以访问在远程主机上的对象</em>，远程主机可能具有更好的计算性能与处理速度，可以<em>快速响应并处理客户端的请求</em>。<br />\r\n</li>\r\n<li>虚拟代理（Virtual\r\nProxy）：对于一些<strong>占用系统资源较多或者加载时间较长的对象</strong>，可以<em>先创建一个消耗相对较小的对象来表示</em>，真实对象只在<em>需要时才会被真正创建</em>，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。<br />\r\n</li>\r\n<li>保护代理（Protect\r\nProxy）：给不同的用户提供不同的对象访问权限。(曹操挟天子以令诸侯和这个有点类似)<br />\r\n</li>\r\n<li>缓冲代理（Cache\r\nProxy）：为某一个目标操作的结果提供临时存储空间，以使更多用户可以共享这些结果。<br />\r\n</li>\r\n<li>智能引用代理（Smart Reference\r\nProxy）：当一个对象被引用时提供一些额外的操作，比如将对象被调用的次数记录下来等。</li>\r\n</ol>\r\n<h3 id=\"应用场景-1\">应用场景</h3>\r\n<ol type=\"1\">\r\n<li>客户端需要访问远程主机，可以使用远程代理。<br />\r\n</li>\r\n<li>需要用一个消耗资源较少的对象表示资源消耗大的对象，以降低性能开销。<br />\r\n</li>\r\n<li>要控制不同对象的访问权限级别<br />\r\n</li>\r\n<li>为频繁访问的某个操作结果提供临时存储空间，供多客户端共享访问，无需每个客户端重新计算<br />\r\n</li>\r\n<li>需要为一个对象的访问(引用)提供一些额外操作</li>\r\n</ol>\r\n<h3 id=\"代理模式优缺点\">代理模式优缺点</h3>\r\n<h4 id=\"有点\">有点</h4>\r\n<ul>\r\n<li>代理模式可以在客户端和用户直接起到中介、保护作用<br />\r\n</li>\r\n<li>代理对象可以扩展目标对象的功能<br />\r\n</li>\r\n<li>代理模式能将客户端和目标对象分离，降低了耦合度，增加了可拓展性。</li>\r\n</ul>\r\n<h4 id=\"缺点\">缺点</h4>\r\n<ul>\r\n<li>会造成系统设计的类增加<br />\r\n</li>\r\n<li>在客户端和目标对象增加代理对象，会造成处理速度变慢<br />\r\n</li>\r\n<li>增加了系统复杂度</li>\r\n</ul>\r\n<h3 id=\"uml类图-1\">UML类图</h3>\r\n<p><img src=\"Proxy.jpg\"></p>\r\n<ul>\r\n<li>Proxy\r\n<ol type=\"1\">\r\n<li>保存一个引用使得代理，</li>\r\n</ol></li>\r\n</ul>\r\n<h2 id=\"观察者模式\">观察者模式</h2>\r\n<p><a\r\nhref=\"https://cloud.tencent.com/developer/article/1963312?areaSource=&amp;traceId=\">Carson带你学设计模式</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/231526884\">常见设计模式</a><br />\r\n<a\r\nhref=\"https://www.cnblogs.com/ring1992/p/9592428.html\">C++设计模式解读合集</a></p>"},{"title":"排序算法学习总结","math":true,"date":"2023-02-12T16:00:00.000Z","typora-root-url":"../","_content":"\n几天前发现自己排序算法忘光了，就从网上抄了一份，自己按照思路，C++简单敲了一遍，方便自己后续复习，下面标题放了抄袭对象。\n\n<!--more-->\n\n# [排序算法](https://www.cnblogs.com/onepixel/articles/7674659.html)\n\n## 排序算法分类\n\n* **比较类排序**  \n  通过比较数据大小来进行排序，决定相对次序，所以其时间复杂度无法突破`O(nlogn)`，  \n  因此也称为**非线性时间比较类排序**。\n  \n* **非比较类排序**  \n  不通过比较来决定元素的相对次序，可以突破基于比较排序的时间下限，  \n  因此也被称为**线性时间非比较类排序**。\n  \n* 比较排序\n  \n  * 交换排序  \n    * 冒泡排序  \n    * 快速排序  \n  * 插入排序  \n    * 简单插入排序  \n    * 希尔排序  \n  * 选择排序  \n    * 简单选择排序  \n    * 堆排序  \n  * 归并排序  \n    * 二路归并排序  \n    * 多路归并排序\n  \n* 非比较排序\n  \n  * 计数排序  \n  * 桶排序  \n  * 基数排序\n  \n## 算法复杂度\n| 排序方法 | 时间复杂度(Average)    | 时间复杂度(Worst)      | 时间复杂度(Best)       | 空间复杂度              | 稳定性 |  \n| ---- | ----------------- | ----------------- | ----------------- | ------------------ | --- |  \n| 插入排序 | $O(n^2)$          | $O(n^2)$          | $O(n)$            | $O(1)$             | 稳定  |  \n| 希尔排序 | $O(n^{1.3})$      | $O(n^2)$          | $O(n)$            | $O(1)$             | 不稳定 |  \n| 选择排序 | $O({n}^2)$        | $O(n^2)$          | $O(n^2)$          | $O(1)$             | 不稳定 |  \n| 堆排序  | $O(n\\log_{2}{n})$ | $O(n\\log_{2}{n})$ | $O(n\\log_{2}{n})$ | $O(1)$             | 不稳定 |  \n| 冒泡排序 | $O(n^2)$          | $O(n^2)$          | $O(n)$            | $O(1)$             | 稳定  |  \n| 快速排序 | $O(n\\log_{2}{n})$ | $O(n^2)$          | $O(n\\log_{2}{n})$ | $O(n \\log_{2}{n})$ | 不稳定 |  \n| 归并排序 | $O(n\\log_{2}{n})$ | $O(n\\log_{2}{n})$ | $O(n\\log_{2}{n})$ | $O(n)$             | 稳定  |  \n|      |                   |                   |                   |                    |     |  \n| 计数排序 | $O(n+k)$          | $O(n+k)$          | $O(n+k)$          | $O(n+k)$           | 稳定  |  \n| 桶排序  | $O(n+k)$          | $O(n^2)$          | $O(n)$            | $O(n+k)$           | 稳定  |  \n| 基数排序 | $O(n+k)$          | $O(n*k)$          | $O(n*k)$          | $O(n+k)$           | 稳定  |\n\n## 0.暴力排序\n\n~~~c++\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid vecCout(vector<int> nums)\n{\n    for (int i = 0; i < nums.size() - 1; ++i)\n    {\n        cout << nums[i] << ',';\n    }\n    cout << nums[nums.size() - 1];\n}\n\nvoid worstSort(vector<int>& nums)\n{\n    int n = nums.size();\n\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = i; j < n; ++j)\n        {\n            if (nums[i] > nums[j])\n            {\n                swap(nums[i], nums[j]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    vector<int> nums;\n    int num;\n    char c;\n    while (cin >> num)\n    {\n        //cin >> c;\n        nums.emplace_back(num);\n        if (cin.get() == '\\n')\n        {\n            break;\n        }\n    }\n\n    worstSort(nums);\n    vecCout(nums);\n\n    return 0;\n}\n~~~\n\n\n\n## 1.冒泡排序\n\n重复地遍历要排序的元素，每次比较两个元素，如果顺序错误，二者进行交换。  \n重复的进行直到没有交换为止，即排序完成，因为 top/last 元素会慢慢浮现到数组两端所以得名冒泡排序。\n\n### 算法描述\n\n* 比较相邻元素，不符合比较顺序则交换。  \n* 对每一对相邻元素作一样的操作，从第一对到最后一对这样最大的元素就会在末尾  \n* 针对所有的元素作上述操作，除了最后一个  \n* 重复1-3步骤，直到排序完成\n  \n### 代码实现\n~~~c++\nvoid bubbleSort(vector<int>& nums)\n{\n    int n = nums.size();\n\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < n; ++j)\n        {\n            if (nums[j] > nums[j+1])\n            {\n                swap(nums[j], nums[j+1]);\n            }\n        }\n    }\n}\n~~~\n\n\n\n## 2.选择排序\n\nSelection Sort 是一种简单直观的排序算法。  \n他的工作原理是：现在序列中找到最小(大)元素，放在起始位置，再从未排序元素中寻找最小(大)元素，放在以排列元素的末尾。重复操作，指导排序完毕。\n\n### 算法描述\n\nn 个元素可以经过 n-1 次选择排列完毕：\n\n* 初始状态，未排序区R[1……n]，有序区为空。  \n* 第 i 次排序，当前有序区 R[1……i-1]，无序区 [i……n]，这次从无序区选出最小的元素R[k]，将其与无序区第一个元素互换，使R[1……i]，[i+1……n]为新区  \n* 第 n-1 次选择结束，数组有序了\n  \n### 代码实现\n~~~c++\nvoid selectionSort(vector<int>& nums)\n{\n\tint n = nums.size();\n    int minIndex;\n    for(int i = 0; i < n-1; ++i)\n    {\n\t\tminIndex = i;\n        for(int j = i + 1; j < n; ++j)\n        {\n            if(nums[j] < nums[minIndex])\n            {\n                minIndex = j;\n            }\n        }\n        swap(nums[i],nums[minIndex]);\n    }\n}\n~~~\n\n### **算法分析**\n\n表现最稳定的算法，无论什么数据都花费 $O(n^2)$ 的时间复杂度，所以数据规模越小越好，好处是**不占用额外空间**。\n\n#### 为什么不稳定\n\n例如：4a, 4b, 4c, 1  \n选择排序后会变成 1, 4b, 4c, 4a\n\n\n\n## 3.插入排序 ( Insertion Sort )\n\n构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n### 算法描述\n\n* 从第一个元素开始，该元素可以认为已经被排序  \n* 取出下一个元素，在已排序的元素中由后至前地扫描  \n* 若该排序后元素大于取出的新元素，则将该排序元素移到下一位。  \n* 重复步骤3，直到找到新元素大于或等于已排序的元素  \n* 将新元素插入该位置  \n* 重复2-5步骤\n  \n### 代码实现\n~~~c++\nvoid insertionSort(vector<int>& nums)\n{\n    int n = nums.size();\n    int preIndex, currentNum;\n    for(int i = 1; i < n; ++i)\n    {\n        preIndex = i - 1;\n        currentNum = nums[i];\n        while(preIndex >= 0 && nums[preIndex] > currentNum)\n        {\t// 当pre比选中对象大，将pre值赋给pre+1，\n            //这样循环下去，pre一个一个赋值到后一个，current就来到了正确的位置\n            nums[preIndex+1] = nums[preIndex];\n            --preIndex;\n        }\n        nums[preIndex+1] = currentNum;\n    }\n}\n~~~\n\n### 算法分析\n\n插入排序往往是在原地进行修改，所以在遍历过程中，需要不断把已排序的元素逐步向后挪位，为新元素提供插入位置。\n\n\n\n## 4.希尔排序(Shell Sort)\n\n由 Shell 发明突破 $O(n^2) $ 的排序算法，在原本的插入排序进行改良，优先比较较远位置的元素，故而 shell sort 又叫**缩小增量排序**。\n\n### 算法描述\n\n将整个数组分割为若干子序列，分别进行插入排序：\n\n* 选择一个增量序列，t1, t2, ..., tk, 其中 ti > tj, tk = 1;  \n* 按增量序列个数 k，对序列进行 k 次排序  \n* 每次排序，根据对应的增量ti，将待排序序列分割成若干长度为 m 的子序列，下标为i*ti的为一组，分别对各子序列进行插入排序。仅在增量因子为 1 时，将整个序列作为一个表来处理，表长度即为整个序列的长度。\n  \n* 分组增量为4，则下标[0,4,8]一组，[1,5,9]一组\n  \n### 代码实现\n~~~c++\nvoid shellSort(vector<int>& nums)\n{\n    int n = nums.size();\n    for(int gap = n / 2; gap > 0; gap /= 2)\n    {\n        // insertion sort\n        // 在n/gap组中，进行insertion sort\n\t\t// insertion sort，就是从0,gap,gap*2...这样遍历，这些是一组数据\n        for(int i = gap; i < n; ++i)\n        {\n            int tmp = nums[i];\n            int j;\n            for(j = i; j >= gap && nums[j-gap] > tmp; j -= gap)\n            {\n                nums[j] = nums[j - gap];\n            }\n            nums[j] = tmp;\n        }\n    }\n}\n~~~\n\n### 算法分析\n\nShell Sort 理解还是较为容易，要将 insertion sort 怎么进行痛彻的理解就明白 shell sort 的工作原理了，算法的快慢重点在 gap 的选择，可以预先指定也可以动态生成，但最后一个 gap 一定是1。\n\n\n\n## 5.归并排序(Merge Sort)\n\n归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法( Divide and Conquer )的经典应用。将已有的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并为一个有序表，则称为2-路归并。\n\n### 算法描述\n\n* 把长度为 n 的序列，二分两个子序列  \n* 把子序列分别使用归并排序  \n* 将排好的子序列合并成一个最终的排序序列\n  \n### 代码实现\n~~~c++\nvoid merge(vector<int> &nums, int const left, int const mid, int const right)\n{\n    int const subNumsLeft = mid - left + 1;\n    int const subNumsRight = right - mid;\n\n    vector<int> leftNums = vector<int>(subNumsLeft);\n    vector<int> rightNums = vector<int>(subNumsRight);\n\n    for (int i = 0; i < subNumsLeft; ++i)\n    {\n        leftNums[i] = nums[left + i];\n    }\n    for (int j = 0; j < subNumsRight; ++j)\n    {\n        rightNums[j] = nums[mid + 1 + j];\n    }\n\n    int leftPos = 0, rightPos = 0, numsPos = left;\n\n    while (leftPos < subNumsLeft && rightPos < subNumsRight)\n    {\n        if (leftNums[leftPos] <= rightNums[rightPos])\n        {\n            nums[numsPos] = leftNums[leftPos];\n            ++leftPos;\n        }\n        else\n        {\n            nums[numsPos] = rightNums[rightPos];\n            ++rightPos;\n        }\n        ++numsPos;\n    }\n\n    while (leftPos < subNumsLeft)\n    {\n        nums[numsPos] = leftNums[leftPos];\n        ++numsPos;\n        ++leftPos;\n    }\n\n\n    while (rightPos < subNumsLeft)\n    {\n        nums[numsPos] = rightNums[rightPos];\n        ++numsPos;\n        ++rightPos;\n    }\n    return;\n}\n\nvoid mergeSort(vector<int>& nums, int const begin, int const end)\n{\n    if (begin >= end)\n    {\n        return;\n    }\n    int mid = begin + (end - begin) / 2;\n    // Dont think it, just recursion.\n    mergeSort(nums, begin, mid);\n    mergeSort(nums, mid + 1, end);\n    merge(nums, begin, mid, end);\n}\n~~~\n\n### 算法分析\n\n归并排序是一种稳定的排序方式，性能不受数据大小影响，时间都是 $O(nlogn)$ ，但是需要额外空间。\n\n\n\n## 6.快速排序\n\n基本思想：再一次遍历中，将待排序数据分为两部分，其中一部分比选定关键字小，另一部分比关键字大，再对这两部分进行排序，直到序列有序。\n\n### 算法描述\n\n使用分治法分为两部分\n\n* 从序列中选择一个元素作为基准( pivot )  \n* 重新排列序列，所有比其小的放在左边，比其大的放在右边。在排列后，该基准就位于中间位置，这个称为分区操作。  \n* 递归地把小于基准值元素的子数列和大于基准元素的子数列排序\n  \n### 代码实现\n~~~c++\nint partition(vector<int>& nums, int left, int right)\n{\n    int pivot = nums[right];\n    int i = (left - 1);\n    \n    for(int j = left; j <= right-1; ++j)\n    {\n        // 如果小于pivot，i右移表示，pivot左侧的值又增加一个\n        if(nums[j] < pivot)\n        {\n            ++i;\n            // 将i的值和j交换，这步就是把小于基准的放在左侧\n            swap(nums[i], nums[j]);\n        }\n    }\n    // 最终将基准值放在中间\n    swap(nums[i+1],nums[right]);\n    // 返回基准值位置\n    return (i + 1);\n}\n\nvoid quickSort(vector<int>& nums, int left, int right)\n{\n    if(low < right)\n    {\n        int pIndex = partition(nums, left, right);\n        \n        quickSort(nums, left, pIndex - 1);\n        quickSort(nums, pIndex, right);\n    }\n}\n~~~\n\n\n\n## 7.堆排序( Heap Sort )\n\nHeap Sort 是利用堆进行的排序算法，堆是一个类似二叉树的结构，并同时满足堆的性质：**子节点键值或索引永远小于(大于)其父节点**。\n\n### 算法描述\n\n* 将初始状态待排序序列 ( R1, R2, ..., Rn ) 构建成大根堆，此堆为初始的无序区  \n* 将堆顶元素R[1]与最后一个元素R[n]互换，得到新的无序区( R1, R2, ..., Rn-1)和新的有序区(Rn)，且满足R[1], R[2], ..., R[n-1] <= R[n]  \n* 由于交换后新的堆顶可能会违反堆的性质，因此需要对当前无序堆进行调整，然后再次将R[1]与无序区最后一个元素互换，得到新无序区( R1, R2, ..., Rn-2 ), 新有序区( Rn-1, Rn )不断重复，直到有序区元素个数为 n-1，排序完成。\n  \n### 代码实现\n~~~c++\nvoid heapify(vector<int>& nums, int numSize, int i)\n{\n    int largest = i;\n\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < numSize && nums[left] > nums[largest])\n    {\n        largest = left;\n    }\n\n    if (right < numSize && nums[right] > nums[largest])\n    {\n        largest = right;\n    }\n\n    if (largest != i)\n    {\n        swap(nums[i], nums[largest]);\n\n        heapify(nums, numSize, largest);\n    }\n}\n\nvoid heapSort(vector<int> &nums, int numSize)\n{\n    for (int i = numSize / 2 - 1; i >= 0; --i)\n    {\n        heapify(nums, numSize, i);\n    }\n\n    for (int i = numSize - 1; i > 0; --i)\n    {\n        swap(nums[0], nums[i]);\n        heapify(nums, i, 0);\n    }\n}\n~~~\n\n\n\n## 8.计数排序( Counting Sort )\n\n计数排序不是基于比较的排序算法，核心在于将输入的数据转化为键存储在额外开辟的数组空间中。作为线性时间复杂度的排序，**计数排序要求输入数据必须是有确定范围的。**\n\n### 算法描述\n\n* 找出待排序数列中的*最大*和*最小*元素  \n* 统计数组中每个值为 i 的元素出现的次数，存入额外数组的第 i 项。  \n* 对所有的次数累加, 从头到尾，这样额外数组就表示元素的实际位置  \n* 反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放入一个元素将 C(i) 减去 1\n  \n### 代码实现\n~~~c++\n\nvoid countingSort(vector<int>& nums)\n{\n    int n = nums.size();\n    int maxEle = nums[0], minEle = nums[0];\n    for (auto num : nums)\n    {\n        minEle = min(minEle, num);\n        maxEle = max(maxEle, num);\n    }\n    int offset = maxEle - minEle + 1;\n    vector<int> count(offset + 1, 0);\n    // 计数，每个元素有多少个\n    for (int i = 0; i < n; ++i)\n    {\n        ++count[nums[i] - minEle + 1];\n    }\n   \t\n    // 计算每个元素的下标\n    for (int i = 0; i < offset; ++i)\n    {\n        count[i + 1] += count[i];\n    }\n    \n    vector<int> outPut(n);\n    for (int i = 0; i < n; ++i)\n    {\n        outPut[count[nums[i] - minEle+1]-1] = nums[i];\n        count[nums[i] - minEle + 1]--;\n    }\n\n    \n    for (int i = 0; i < n; ++i)\n    {\n        nums[i] = outPut[i];\n    }\n}\n\n// 1,100,22,55,22,11,33,11\n~~~\n\n### 算法分析\n\n计数排序是一个稳定的排序算法，当输入元素是 n 个 0~k 的整数时，时间复杂度是 $O(n+k)$，空间复杂度也是 $O(n+k)$ ，其速度快于任何比较排序算法，当 k 不是很大，且序列集中时，计数排序是一个很好的排序法。\n\n\n\n## 9.桶排序 ( Bucket Sort)\n\n桶排序是计数排序的升级版。它利用了函数的映射关系，其性能高效与否就在于这个映射函数的选取。 Bucket Sort 工作原理：假设数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序( 可能使用别的排序方法或者递归地使用桶排序 )\n\n### 算法描述\n\n* 设置一个定量的数组作为空桶  \n* 遍历输入数据放入对应桶中  \n* 对每个不是空的桶进行排序  \n* 从非空桶中把排好序的数据拼接起来\n  \n### 代码实现\n~~~c++\nvoid bucketSort(vector<int>& nums, int bucketSize)\n{\n    int minValue, maxValue;\n    for(auto num : nums)\n    {\n\t\tminValue = min(minValue,num);\n        maxValue = max(maxValue,num);\n    }\n    \n    int bucketCount = (maxValue - minValue) / bucketSize + 1;\n    vector<vector<int>> buckets(bucketCount)\n    \n    for(int i = 0; i < nums.size(); ++i)\n    {\n        int bucketIndex = (nums[i] - minValue) / bucketSize;\n        bucket[bucketIndex].push_back(nums[i]);\n    }\n    \n    for(int i = 0; i < n; ++i)\n    {\n        sort(bucket[i].begin(), bucket[i].end());\n    }\n    \n    int index = 0;\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < bucket[i].size(); ++j)\n        {\n            nums[index++] = bucket[i][j];\n        }\n    }\n}\n~~~\n\n### 算法分析\n\n桶排序最好情况下时间复杂度为 $O(n)$ ，其取决于各个桶之间数据进行排列的时间复杂度，因为其他部分的时间复杂度都为 $O(n)$ 。显然桶划分的越小时间复杂度越低，但是与之相对的，空间消耗就会上升。\n\n\n\n## 基数排序(Radix Sort)\n\n基数排序是按照低位先排序，后收集；在按照高位排序再收集；依次类推直到最高位也排序完毕。此外，有些属性是有优先级顺序的，按低优先级部分先排序，再按照高优先级排序，最后就是高优先级高的在前，高优先级相同者低优先级高的在前。在游戏开发中可能常常用这个排序？\n\n### 算法描述\n\n* 取得数组中的最大数，并取其位数。  \n* nums 为原始数组，从最低位开始取每个位组成 radix 数组；  \n* 对 radix 数据进行计数排序 ( 计数排序适用于小范围 )\n  \n### 代码实现\n~~~c++\nint getMaxNum(vector<int> num)\n{\n\tint maxNum = INT_MIN;\n    for(auto num : nums)\n    {\n        maxNum = max(num,maxNum);\n    }\n    return maxNum;\n}\n\nvoid countSort(vector<int>& nums, int n, int exp)\n{\n    vector<int> outPut(n);\n    int i, count[10]= {0};\n    \n    for(i = 0; i < n; ++i)\n    {\n        count[(nums[i]/exp) % 10]++;\n    }\n    \n    for(i = 1; i < 10; ++i)\n    {\n        count[i] += count[i-1];\n    }\n    \n    for(i = n - 1; i >= 0; --i)\n    {\n        outPut[count[(nums[i]/exp)%10]-1] = nums[i];\n        count[(num[i]/exp)%10]--;\n    }\n    \n    for(i = 0; i < n; ++i)\n    {\n        nums[i] = outPut[i];\n    }\n}\n\nvoid radixSort(vector<int>& nums)\n{\n    int n = nums.size();\n    int maxValue = getMaxNum(nums);\n    \n    for(int exp = 1; maxValue/exp > 0; exp *= 10)\n    {\n        countSort(nums,n,exp);\n    }\n}\n~~~\n\n### 算法分析\n\n基数排序分别排序，分别收集，所以是稳定的，但是基数排序性能可能会比桶排序性能要差，每一次关键字的桶分配都需要 $O(n)$ 时间复杂度，分配之后又需要 $O(n)$ 时间排序。假设待排列序列可分出 m 关键字，其时间复杂度为 $O(m*2n)$，但是 m 远小于n，所有还是线性时间级别。  \n其空间复杂度为 $O(n+k)$ ，k 为桶的数量，一般来讲 n >> k，所有额外空间需要 n。  ","source":"_posts/排序算法.md","raw":"---\ntitle: 排序算法学习总结\ntags: 算法\nmath: true\ndate: 2023-02-13\ntypora-root-url: ../\n---\n\n几天前发现自己排序算法忘光了，就从网上抄了一份，自己按照思路，C++简单敲了一遍，方便自己后续复习，下面标题放了抄袭对象。\n\n<!--more-->\n\n# [排序算法](https://www.cnblogs.com/onepixel/articles/7674659.html)\n\n## 排序算法分类\n\n* **比较类排序**  \n  通过比较数据大小来进行排序，决定相对次序，所以其时间复杂度无法突破`O(nlogn)`，  \n  因此也称为**非线性时间比较类排序**。\n  \n* **非比较类排序**  \n  不通过比较来决定元素的相对次序，可以突破基于比较排序的时间下限，  \n  因此也被称为**线性时间非比较类排序**。\n  \n* 比较排序\n  \n  * 交换排序  \n    * 冒泡排序  \n    * 快速排序  \n  * 插入排序  \n    * 简单插入排序  \n    * 希尔排序  \n  * 选择排序  \n    * 简单选择排序  \n    * 堆排序  \n  * 归并排序  \n    * 二路归并排序  \n    * 多路归并排序\n  \n* 非比较排序\n  \n  * 计数排序  \n  * 桶排序  \n  * 基数排序\n  \n## 算法复杂度\n| 排序方法 | 时间复杂度(Average)    | 时间复杂度(Worst)      | 时间复杂度(Best)       | 空间复杂度              | 稳定性 |  \n| ---- | ----------------- | ----------------- | ----------------- | ------------------ | --- |  \n| 插入排序 | $O(n^2)$          | $O(n^2)$          | $O(n)$            | $O(1)$             | 稳定  |  \n| 希尔排序 | $O(n^{1.3})$      | $O(n^2)$          | $O(n)$            | $O(1)$             | 不稳定 |  \n| 选择排序 | $O({n}^2)$        | $O(n^2)$          | $O(n^2)$          | $O(1)$             | 不稳定 |  \n| 堆排序  | $O(n\\log_{2}{n})$ | $O(n\\log_{2}{n})$ | $O(n\\log_{2}{n})$ | $O(1)$             | 不稳定 |  \n| 冒泡排序 | $O(n^2)$          | $O(n^2)$          | $O(n)$            | $O(1)$             | 稳定  |  \n| 快速排序 | $O(n\\log_{2}{n})$ | $O(n^2)$          | $O(n\\log_{2}{n})$ | $O(n \\log_{2}{n})$ | 不稳定 |  \n| 归并排序 | $O(n\\log_{2}{n})$ | $O(n\\log_{2}{n})$ | $O(n\\log_{2}{n})$ | $O(n)$             | 稳定  |  \n|      |                   |                   |                   |                    |     |  \n| 计数排序 | $O(n+k)$          | $O(n+k)$          | $O(n+k)$          | $O(n+k)$           | 稳定  |  \n| 桶排序  | $O(n+k)$          | $O(n^2)$          | $O(n)$            | $O(n+k)$           | 稳定  |  \n| 基数排序 | $O(n+k)$          | $O(n*k)$          | $O(n*k)$          | $O(n+k)$           | 稳定  |\n\n## 0.暴力排序\n\n~~~c++\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid vecCout(vector<int> nums)\n{\n    for (int i = 0; i < nums.size() - 1; ++i)\n    {\n        cout << nums[i] << ',';\n    }\n    cout << nums[nums.size() - 1];\n}\n\nvoid worstSort(vector<int>& nums)\n{\n    int n = nums.size();\n\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = i; j < n; ++j)\n        {\n            if (nums[i] > nums[j])\n            {\n                swap(nums[i], nums[j]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    vector<int> nums;\n    int num;\n    char c;\n    while (cin >> num)\n    {\n        //cin >> c;\n        nums.emplace_back(num);\n        if (cin.get() == '\\n')\n        {\n            break;\n        }\n    }\n\n    worstSort(nums);\n    vecCout(nums);\n\n    return 0;\n}\n~~~\n\n\n\n## 1.冒泡排序\n\n重复地遍历要排序的元素，每次比较两个元素，如果顺序错误，二者进行交换。  \n重复的进行直到没有交换为止，即排序完成，因为 top/last 元素会慢慢浮现到数组两端所以得名冒泡排序。\n\n### 算法描述\n\n* 比较相邻元素，不符合比较顺序则交换。  \n* 对每一对相邻元素作一样的操作，从第一对到最后一对这样最大的元素就会在末尾  \n* 针对所有的元素作上述操作，除了最后一个  \n* 重复1-3步骤，直到排序完成\n  \n### 代码实现\n~~~c++\nvoid bubbleSort(vector<int>& nums)\n{\n    int n = nums.size();\n\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < n; ++j)\n        {\n            if (nums[j] > nums[j+1])\n            {\n                swap(nums[j], nums[j+1]);\n            }\n        }\n    }\n}\n~~~\n\n\n\n## 2.选择排序\n\nSelection Sort 是一种简单直观的排序算法。  \n他的工作原理是：现在序列中找到最小(大)元素，放在起始位置，再从未排序元素中寻找最小(大)元素，放在以排列元素的末尾。重复操作，指导排序完毕。\n\n### 算法描述\n\nn 个元素可以经过 n-1 次选择排列完毕：\n\n* 初始状态，未排序区R[1……n]，有序区为空。  \n* 第 i 次排序，当前有序区 R[1……i-1]，无序区 [i……n]，这次从无序区选出最小的元素R[k]，将其与无序区第一个元素互换，使R[1……i]，[i+1……n]为新区  \n* 第 n-1 次选择结束，数组有序了\n  \n### 代码实现\n~~~c++\nvoid selectionSort(vector<int>& nums)\n{\n\tint n = nums.size();\n    int minIndex;\n    for(int i = 0; i < n-1; ++i)\n    {\n\t\tminIndex = i;\n        for(int j = i + 1; j < n; ++j)\n        {\n            if(nums[j] < nums[minIndex])\n            {\n                minIndex = j;\n            }\n        }\n        swap(nums[i],nums[minIndex]);\n    }\n}\n~~~\n\n### **算法分析**\n\n表现最稳定的算法，无论什么数据都花费 $O(n^2)$ 的时间复杂度，所以数据规模越小越好，好处是**不占用额外空间**。\n\n#### 为什么不稳定\n\n例如：4a, 4b, 4c, 1  \n选择排序后会变成 1, 4b, 4c, 4a\n\n\n\n## 3.插入排序 ( Insertion Sort )\n\n构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n\n### 算法描述\n\n* 从第一个元素开始，该元素可以认为已经被排序  \n* 取出下一个元素，在已排序的元素中由后至前地扫描  \n* 若该排序后元素大于取出的新元素，则将该排序元素移到下一位。  \n* 重复步骤3，直到找到新元素大于或等于已排序的元素  \n* 将新元素插入该位置  \n* 重复2-5步骤\n  \n### 代码实现\n~~~c++\nvoid insertionSort(vector<int>& nums)\n{\n    int n = nums.size();\n    int preIndex, currentNum;\n    for(int i = 1; i < n; ++i)\n    {\n        preIndex = i - 1;\n        currentNum = nums[i];\n        while(preIndex >= 0 && nums[preIndex] > currentNum)\n        {\t// 当pre比选中对象大，将pre值赋给pre+1，\n            //这样循环下去，pre一个一个赋值到后一个，current就来到了正确的位置\n            nums[preIndex+1] = nums[preIndex];\n            --preIndex;\n        }\n        nums[preIndex+1] = currentNum;\n    }\n}\n~~~\n\n### 算法分析\n\n插入排序往往是在原地进行修改，所以在遍历过程中，需要不断把已排序的元素逐步向后挪位，为新元素提供插入位置。\n\n\n\n## 4.希尔排序(Shell Sort)\n\n由 Shell 发明突破 $O(n^2) $ 的排序算法，在原本的插入排序进行改良，优先比较较远位置的元素，故而 shell sort 又叫**缩小增量排序**。\n\n### 算法描述\n\n将整个数组分割为若干子序列，分别进行插入排序：\n\n* 选择一个增量序列，t1, t2, ..., tk, 其中 ti > tj, tk = 1;  \n* 按增量序列个数 k，对序列进行 k 次排序  \n* 每次排序，根据对应的增量ti，将待排序序列分割成若干长度为 m 的子序列，下标为i*ti的为一组，分别对各子序列进行插入排序。仅在增量因子为 1 时，将整个序列作为一个表来处理，表长度即为整个序列的长度。\n  \n* 分组增量为4，则下标[0,4,8]一组，[1,5,9]一组\n  \n### 代码实现\n~~~c++\nvoid shellSort(vector<int>& nums)\n{\n    int n = nums.size();\n    for(int gap = n / 2; gap > 0; gap /= 2)\n    {\n        // insertion sort\n        // 在n/gap组中，进行insertion sort\n\t\t// insertion sort，就是从0,gap,gap*2...这样遍历，这些是一组数据\n        for(int i = gap; i < n; ++i)\n        {\n            int tmp = nums[i];\n            int j;\n            for(j = i; j >= gap && nums[j-gap] > tmp; j -= gap)\n            {\n                nums[j] = nums[j - gap];\n            }\n            nums[j] = tmp;\n        }\n    }\n}\n~~~\n\n### 算法分析\n\nShell Sort 理解还是较为容易，要将 insertion sort 怎么进行痛彻的理解就明白 shell sort 的工作原理了，算法的快慢重点在 gap 的选择，可以预先指定也可以动态生成，但最后一个 gap 一定是1。\n\n\n\n## 5.归并排序(Merge Sort)\n\n归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法( Divide and Conquer )的经典应用。将已有的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并为一个有序表，则称为2-路归并。\n\n### 算法描述\n\n* 把长度为 n 的序列，二分两个子序列  \n* 把子序列分别使用归并排序  \n* 将排好的子序列合并成一个最终的排序序列\n  \n### 代码实现\n~~~c++\nvoid merge(vector<int> &nums, int const left, int const mid, int const right)\n{\n    int const subNumsLeft = mid - left + 1;\n    int const subNumsRight = right - mid;\n\n    vector<int> leftNums = vector<int>(subNumsLeft);\n    vector<int> rightNums = vector<int>(subNumsRight);\n\n    for (int i = 0; i < subNumsLeft; ++i)\n    {\n        leftNums[i] = nums[left + i];\n    }\n    for (int j = 0; j < subNumsRight; ++j)\n    {\n        rightNums[j] = nums[mid + 1 + j];\n    }\n\n    int leftPos = 0, rightPos = 0, numsPos = left;\n\n    while (leftPos < subNumsLeft && rightPos < subNumsRight)\n    {\n        if (leftNums[leftPos] <= rightNums[rightPos])\n        {\n            nums[numsPos] = leftNums[leftPos];\n            ++leftPos;\n        }\n        else\n        {\n            nums[numsPos] = rightNums[rightPos];\n            ++rightPos;\n        }\n        ++numsPos;\n    }\n\n    while (leftPos < subNumsLeft)\n    {\n        nums[numsPos] = leftNums[leftPos];\n        ++numsPos;\n        ++leftPos;\n    }\n\n\n    while (rightPos < subNumsLeft)\n    {\n        nums[numsPos] = rightNums[rightPos];\n        ++numsPos;\n        ++rightPos;\n    }\n    return;\n}\n\nvoid mergeSort(vector<int>& nums, int const begin, int const end)\n{\n    if (begin >= end)\n    {\n        return;\n    }\n    int mid = begin + (end - begin) / 2;\n    // Dont think it, just recursion.\n    mergeSort(nums, begin, mid);\n    mergeSort(nums, mid + 1, end);\n    merge(nums, begin, mid, end);\n}\n~~~\n\n### 算法分析\n\n归并排序是一种稳定的排序方式，性能不受数据大小影响，时间都是 $O(nlogn)$ ，但是需要额外空间。\n\n\n\n## 6.快速排序\n\n基本思想：再一次遍历中，将待排序数据分为两部分，其中一部分比选定关键字小，另一部分比关键字大，再对这两部分进行排序，直到序列有序。\n\n### 算法描述\n\n使用分治法分为两部分\n\n* 从序列中选择一个元素作为基准( pivot )  \n* 重新排列序列，所有比其小的放在左边，比其大的放在右边。在排列后，该基准就位于中间位置，这个称为分区操作。  \n* 递归地把小于基准值元素的子数列和大于基准元素的子数列排序\n  \n### 代码实现\n~~~c++\nint partition(vector<int>& nums, int left, int right)\n{\n    int pivot = nums[right];\n    int i = (left - 1);\n    \n    for(int j = left; j <= right-1; ++j)\n    {\n        // 如果小于pivot，i右移表示，pivot左侧的值又增加一个\n        if(nums[j] < pivot)\n        {\n            ++i;\n            // 将i的值和j交换，这步就是把小于基准的放在左侧\n            swap(nums[i], nums[j]);\n        }\n    }\n    // 最终将基准值放在中间\n    swap(nums[i+1],nums[right]);\n    // 返回基准值位置\n    return (i + 1);\n}\n\nvoid quickSort(vector<int>& nums, int left, int right)\n{\n    if(low < right)\n    {\n        int pIndex = partition(nums, left, right);\n        \n        quickSort(nums, left, pIndex - 1);\n        quickSort(nums, pIndex, right);\n    }\n}\n~~~\n\n\n\n## 7.堆排序( Heap Sort )\n\nHeap Sort 是利用堆进行的排序算法，堆是一个类似二叉树的结构，并同时满足堆的性质：**子节点键值或索引永远小于(大于)其父节点**。\n\n### 算法描述\n\n* 将初始状态待排序序列 ( R1, R2, ..., Rn ) 构建成大根堆，此堆为初始的无序区  \n* 将堆顶元素R[1]与最后一个元素R[n]互换，得到新的无序区( R1, R2, ..., Rn-1)和新的有序区(Rn)，且满足R[1], R[2], ..., R[n-1] <= R[n]  \n* 由于交换后新的堆顶可能会违反堆的性质，因此需要对当前无序堆进行调整，然后再次将R[1]与无序区最后一个元素互换，得到新无序区( R1, R2, ..., Rn-2 ), 新有序区( Rn-1, Rn )不断重复，直到有序区元素个数为 n-1，排序完成。\n  \n### 代码实现\n~~~c++\nvoid heapify(vector<int>& nums, int numSize, int i)\n{\n    int largest = i;\n\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < numSize && nums[left] > nums[largest])\n    {\n        largest = left;\n    }\n\n    if (right < numSize && nums[right] > nums[largest])\n    {\n        largest = right;\n    }\n\n    if (largest != i)\n    {\n        swap(nums[i], nums[largest]);\n\n        heapify(nums, numSize, largest);\n    }\n}\n\nvoid heapSort(vector<int> &nums, int numSize)\n{\n    for (int i = numSize / 2 - 1; i >= 0; --i)\n    {\n        heapify(nums, numSize, i);\n    }\n\n    for (int i = numSize - 1; i > 0; --i)\n    {\n        swap(nums[0], nums[i]);\n        heapify(nums, i, 0);\n    }\n}\n~~~\n\n\n\n## 8.计数排序( Counting Sort )\n\n计数排序不是基于比较的排序算法，核心在于将输入的数据转化为键存储在额外开辟的数组空间中。作为线性时间复杂度的排序，**计数排序要求输入数据必须是有确定范围的。**\n\n### 算法描述\n\n* 找出待排序数列中的*最大*和*最小*元素  \n* 统计数组中每个值为 i 的元素出现的次数，存入额外数组的第 i 项。  \n* 对所有的次数累加, 从头到尾，这样额外数组就表示元素的实际位置  \n* 反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放入一个元素将 C(i) 减去 1\n  \n### 代码实现\n~~~c++\n\nvoid countingSort(vector<int>& nums)\n{\n    int n = nums.size();\n    int maxEle = nums[0], minEle = nums[0];\n    for (auto num : nums)\n    {\n        minEle = min(minEle, num);\n        maxEle = max(maxEle, num);\n    }\n    int offset = maxEle - minEle + 1;\n    vector<int> count(offset + 1, 0);\n    // 计数，每个元素有多少个\n    for (int i = 0; i < n; ++i)\n    {\n        ++count[nums[i] - minEle + 1];\n    }\n   \t\n    // 计算每个元素的下标\n    for (int i = 0; i < offset; ++i)\n    {\n        count[i + 1] += count[i];\n    }\n    \n    vector<int> outPut(n);\n    for (int i = 0; i < n; ++i)\n    {\n        outPut[count[nums[i] - minEle+1]-1] = nums[i];\n        count[nums[i] - minEle + 1]--;\n    }\n\n    \n    for (int i = 0; i < n; ++i)\n    {\n        nums[i] = outPut[i];\n    }\n}\n\n// 1,100,22,55,22,11,33,11\n~~~\n\n### 算法分析\n\n计数排序是一个稳定的排序算法，当输入元素是 n 个 0~k 的整数时，时间复杂度是 $O(n+k)$，空间复杂度也是 $O(n+k)$ ，其速度快于任何比较排序算法，当 k 不是很大，且序列集中时，计数排序是一个很好的排序法。\n\n\n\n## 9.桶排序 ( Bucket Sort)\n\n桶排序是计数排序的升级版。它利用了函数的映射关系，其性能高效与否就在于这个映射函数的选取。 Bucket Sort 工作原理：假设数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序( 可能使用别的排序方法或者递归地使用桶排序 )\n\n### 算法描述\n\n* 设置一个定量的数组作为空桶  \n* 遍历输入数据放入对应桶中  \n* 对每个不是空的桶进行排序  \n* 从非空桶中把排好序的数据拼接起来\n  \n### 代码实现\n~~~c++\nvoid bucketSort(vector<int>& nums, int bucketSize)\n{\n    int minValue, maxValue;\n    for(auto num : nums)\n    {\n\t\tminValue = min(minValue,num);\n        maxValue = max(maxValue,num);\n    }\n    \n    int bucketCount = (maxValue - minValue) / bucketSize + 1;\n    vector<vector<int>> buckets(bucketCount)\n    \n    for(int i = 0; i < nums.size(); ++i)\n    {\n        int bucketIndex = (nums[i] - minValue) / bucketSize;\n        bucket[bucketIndex].push_back(nums[i]);\n    }\n    \n    for(int i = 0; i < n; ++i)\n    {\n        sort(bucket[i].begin(), bucket[i].end());\n    }\n    \n    int index = 0;\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < bucket[i].size(); ++j)\n        {\n            nums[index++] = bucket[i][j];\n        }\n    }\n}\n~~~\n\n### 算法分析\n\n桶排序最好情况下时间复杂度为 $O(n)$ ，其取决于各个桶之间数据进行排列的时间复杂度，因为其他部分的时间复杂度都为 $O(n)$ 。显然桶划分的越小时间复杂度越低，但是与之相对的，空间消耗就会上升。\n\n\n\n## 基数排序(Radix Sort)\n\n基数排序是按照低位先排序，后收集；在按照高位排序再收集；依次类推直到最高位也排序完毕。此外，有些属性是有优先级顺序的，按低优先级部分先排序，再按照高优先级排序，最后就是高优先级高的在前，高优先级相同者低优先级高的在前。在游戏开发中可能常常用这个排序？\n\n### 算法描述\n\n* 取得数组中的最大数，并取其位数。  \n* nums 为原始数组，从最低位开始取每个位组成 radix 数组；  \n* 对 radix 数据进行计数排序 ( 计数排序适用于小范围 )\n  \n### 代码实现\n~~~c++\nint getMaxNum(vector<int> num)\n{\n\tint maxNum = INT_MIN;\n    for(auto num : nums)\n    {\n        maxNum = max(num,maxNum);\n    }\n    return maxNum;\n}\n\nvoid countSort(vector<int>& nums, int n, int exp)\n{\n    vector<int> outPut(n);\n    int i, count[10]= {0};\n    \n    for(i = 0; i < n; ++i)\n    {\n        count[(nums[i]/exp) % 10]++;\n    }\n    \n    for(i = 1; i < 10; ++i)\n    {\n        count[i] += count[i-1];\n    }\n    \n    for(i = n - 1; i >= 0; --i)\n    {\n        outPut[count[(nums[i]/exp)%10]-1] = nums[i];\n        count[(num[i]/exp)%10]--;\n    }\n    \n    for(i = 0; i < n; ++i)\n    {\n        nums[i] = outPut[i];\n    }\n}\n\nvoid radixSort(vector<int>& nums)\n{\n    int n = nums.size();\n    int maxValue = getMaxNum(nums);\n    \n    for(int exp = 1; maxValue/exp > 0; exp *= 10)\n    {\n        countSort(nums,n,exp);\n    }\n}\n~~~\n\n### 算法分析\n\n基数排序分别排序，分别收集，所以是稳定的，但是基数排序性能可能会比桶排序性能要差，每一次关键字的桶分配都需要 $O(n)$ 时间复杂度，分配之后又需要 $O(n)$ 时间排序。假设待排列序列可分出 m 关键字，其时间复杂度为 $O(m*2n)$，但是 m 远小于n，所有还是线性时间级别。  \n其空间复杂度为 $O(n+k)$ ，k 为桶的数量，一般来讲 n >> k，所有额外空间需要 n。  ","slug":"排序算法","published":1,"updated":"2025-08-12T15:42:00.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti5000zbkbwgucg3w9i","content":"<p>几天前发现自己排序算法忘光了，就从网上抄了一份，自己按照思路，C++简单敲了一遍，方便自己后续复习，下面标题放了抄袭对象。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"排序算法\"><a\r\nhref=\"https://www.cnblogs.com/onepixel/articles/7674659.html\">排序算法</a></h1>\r\n<h2 id=\"排序算法分类\">排序算法分类</h2>\r\n<ul>\r\n<li><p><strong>比较类排序</strong><br />\r\n通过比较数据大小来进行排序，决定相对次序，所以其时间复杂度无法突破<code>O(nlogn)</code>，<br />\r\n因此也称为<strong>非线性时间比较类排序</strong>。</p></li>\r\n<li><p><strong>非比较类排序</strong><br />\r\n不通过比较来决定元素的相对次序，可以突破基于比较排序的时间下限，<br />\r\n因此也被称为<strong>线性时间非比较类排序</strong>。</p></li>\r\n<li><p>比较排序</p>\r\n<ul>\r\n<li>交换排序\r\n<ul>\r\n<li>冒泡排序<br />\r\n</li>\r\n<li>快速排序<br />\r\n</li>\r\n</ul></li>\r\n<li>插入排序\r\n<ul>\r\n<li>简单插入排序<br />\r\n</li>\r\n<li>希尔排序<br />\r\n</li>\r\n</ul></li>\r\n<li>选择排序\r\n<ul>\r\n<li>简单选择排序<br />\r\n</li>\r\n<li>堆排序<br />\r\n</li>\r\n</ul></li>\r\n<li>归并排序\r\n<ul>\r\n<li>二路归并排序<br />\r\n</li>\r\n<li>多路归并排序</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>非比较排序</p>\r\n<ul>\r\n<li>计数排序<br />\r\n</li>\r\n<li>桶排序<br />\r\n</li>\r\n<li>基数排序</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"算法复杂度\">算法复杂度</h2>\r\n<table>\r\n\r\n<thead>\r\n<tr class=\"header\">\r\n<th>排序方法</th>\r\n<th>时间复杂度(Average)</th>\r\n<th>时间复杂度(Worst)</th>\r\n<th>时间复杂度(Best)</th>\r\n<th>空间复杂度</th>\r\n<th>稳定性</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>插入排序</td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(1)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>希尔排序</td>\r\n<td><span class=\"math inline\">\\(O(n^{1.3})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(1)\\)</span></td>\r\n<td>不稳定</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>选择排序</td>\r\n<td><span class=\"math inline\">\\(O({n}^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(1)\\)</span></td>\r\n<td>不稳定</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>堆排序</td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(1)\\)</span></td>\r\n<td>不稳定</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>冒泡排序</td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(1)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>快速排序</td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n \\log_{2}{n})\\)</span></td>\r\n<td>不稳定</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>归并排序</td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td></td>\r\n<td></td>\r\n<td></td>\r\n<td></td>\r\n<td></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>计数排序</td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>桶排序</td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>基数排序</td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n*k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n*k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"暴力排序\">0.暴力排序</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vecCout</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>; ++i)<br>    &#123;<br>        cout &lt;&lt; nums[i] &lt;&lt; <span class=\"hljs-string\">&#x27;,&#x27;</span>;<br>    &#125;<br>    cout &lt;&lt; nums[nums.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>];<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">worstSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i; j &lt; n; ++j)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span> (nums[i] &gt; nums[j])<br>            &#123;<br>                <span class=\"hljs-built_in\">swap</span>(nums[i], nums[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; nums;<br>    <span class=\"hljs-type\">int</span> num;<br>    <span class=\"hljs-type\">char</span> c;<br>    <span class=\"hljs-keyword\">while</span> (cin &gt;&gt; num)<br>    &#123;<br>        <span class=\"hljs-comment\">//cin &gt;&gt; c;</span><br>        nums.<span class=\"hljs-built_in\">emplace_back</span>(num);<br>        <span class=\"hljs-keyword\">if</span> (cin.<span class=\"hljs-built_in\">get</span>() == <span class=\"hljs-string\">&#x27;\\n&#x27;</span>)<br>        &#123;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-built_in\">worstSort</span>(nums);<br>    <span class=\"hljs-built_in\">vecCout</span>(nums);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"冒泡排序\">1.冒泡排序</h2>\r\n<p>重复地遍历要排序的元素，每次比较两个元素，如果顺序错误，二者进行交换。<br />\r\n重复的进行直到没有交换为止，即排序完成，因为 top/last\r\n元素会慢慢浮现到数组两端所以得名冒泡排序。</p>\r\n<h3 id=\"算法描述\">算法描述</h3>\r\n<ul>\r\n<li>比较相邻元素，不符合比较顺序则交换。<br />\r\n</li>\r\n<li>对每一对相邻元素作一样的操作，从第一对到最后一对这样最大的元素就会在末尾<br />\r\n</li>\r\n<li>针对所有的元素作上述操作，除了最后一个<br />\r\n</li>\r\n<li>重复1-3步骤，直到排序完成</li>\r\n</ul>\r\n<h3 id=\"代码实现\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bubbleSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; ++j)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span> (nums[j] &gt; nums[j+<span class=\"hljs-number\">1</span>])<br>            &#123;<br>                <span class=\"hljs-built_in\">swap</span>(nums[j], nums[j+<span class=\"hljs-number\">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"选择排序\">2.选择排序</h2>\r\n<p>Selection Sort 是一种简单直观的排序算法。<br />\r\n他的工作原理是：现在序列中找到最小(大)元素，放在起始位置，再从未排序元素中寻找最小(大)元素，放在以排列元素的末尾。重复操作，指导排序完毕。</p>\r\n<h3 id=\"算法描述-1\">算法描述</h3>\r\n<p>n 个元素可以经过 n-1 次选择排列完毕：</p>\r\n<ul>\r\n<li>初始状态，未排序区R[1……n]，有序区为空。<br />\r\n</li>\r\n<li>第 i 次排序，当前有序区 R[1……i-1]，无序区\r\n[i……n]，这次从无序区选出最小的元素R[k]，将其与无序区第一个元素互换，使R[1……i]，[i+1……n]为新区<br />\r\n</li>\r\n<li>第 n-1 次选择结束，数组有序了</li>\r\n</ul>\r\n<h3 id=\"代码实现-1\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">selectionSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-type\">int</span> minIndex;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n<span class=\"hljs-number\">-1</span>; ++i)<br>    &#123;<br>\t\tminIndex = i;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; n; ++j)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(nums[j] &lt; nums[minIndex])<br>            &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-built_in\">swap</span>(nums[i],nums[minIndex]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析\"><strong>算法分析</strong></h3>\r\n<p>表现最稳定的算法，无论什么数据都花费 <span\r\nclass=\"math inline\">\\(O(n^2)\\)</span>\r\n的时间复杂度，所以数据规模越小越好，好处是<strong>不占用额外空间</strong>。</p>\r\n<h4 id=\"为什么不稳定\">为什么不稳定</h4>\r\n<p>例如：4a, 4b, 4c, 1<br />\r\n选择排序后会变成 1, 4b, 4c, 4a</p>\r\n<h2 id=\"插入排序-insertion-sort\">3.插入排序 ( Insertion Sort )</h2>\r\n<p>构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\r\n<h3 id=\"算法描述-2\">算法描述</h3>\r\n<ul>\r\n<li>从第一个元素开始，该元素可以认为已经被排序<br />\r\n</li>\r\n<li>取出下一个元素，在已排序的元素中由后至前地扫描<br />\r\n</li>\r\n<li>若该排序后元素大于取出的新元素，则将该排序元素移到下一位。<br />\r\n</li>\r\n<li>重复步骤3，直到找到新元素大于或等于已排序的元素<br />\r\n</li>\r\n<li>将新元素插入该位置<br />\r\n</li>\r\n<li>重复2-5步骤</li>\r\n</ul>\r\n<h3 id=\"代码实现-2\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insertionSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-type\">int</span> preIndex, currentNum;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i)<br>    &#123;<br>        preIndex = i - <span class=\"hljs-number\">1</span>;<br>        currentNum = nums[i];<br>        <span class=\"hljs-keyword\">while</span>(preIndex &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; nums[preIndex] &gt; currentNum)<br>        &#123;\t<span class=\"hljs-comment\">// 当pre比选中对象大，将pre值赋给pre+1，</span><br>            <span class=\"hljs-comment\">//这样循环下去，pre一个一个赋值到后一个，current就来到了正确的位置</span><br>            nums[preIndex+<span class=\"hljs-number\">1</span>] = nums[preIndex];<br>            --preIndex;<br>        &#125;<br>        nums[preIndex+<span class=\"hljs-number\">1</span>] = currentNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-1\">算法分析</h3>\r\n<p>插入排序往往是在原地进行修改，所以在遍历过程中，需要不断把已排序的元素逐步向后挪位，为新元素提供插入位置。</p>\r\n<h2 id=\"希尔排序shell-sort\">4.希尔排序(Shell Sort)</h2>\r\n<p>由 Shell 发明突破 $O(n^2) $\r\n的排序算法，在原本的插入排序进行改良，优先比较较远位置的元素，故而 shell\r\nsort 又叫<strong>缩小增量排序</strong>。</p>\r\n<h3 id=\"算法描述-3\">算法描述</h3>\r\n<p>将整个数组分割为若干子序列，分别进行插入排序：</p>\r\n<ul>\r\n<li><p>选择一个增量序列，t1, t2, ..., tk, 其中 ti &gt; tj, tk = 1;<br />\r\n</p></li>\r\n<li><p>按增量序列个数 k，对序列进行 k 次排序<br />\r\n</p></li>\r\n<li><p>每次排序，根据对应的增量ti，将待排序序列分割成若干长度为 m\r\n的子序列，下标为i*ti的为一组，分别对各子序列进行插入排序。仅在增量因子为\r\n1 时，将整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li>\r\n<li><p>分组增量为4，则下标[0,4,8]一组，[1,5,9]一组</p></li>\r\n</ul>\r\n<h3 id=\"代码实现-3\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">shellSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> gap = n / <span class=\"hljs-number\">2</span>; gap &gt; <span class=\"hljs-number\">0</span>; gap /= <span class=\"hljs-number\">2</span>)<br>    &#123;<br>        <span class=\"hljs-comment\">// insertion sort</span><br>        <span class=\"hljs-comment\">// 在n/gap组中，进行insertion sort</span><br>\t\t<span class=\"hljs-comment\">// insertion sort，就是从0,gap,gap*2...这样遍历，这些是一组数据</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = gap; i &lt; n; ++i)<br>        &#123;<br>            <span class=\"hljs-type\">int</span> tmp = nums[i];<br>            <span class=\"hljs-type\">int</span> j;<br>            <span class=\"hljs-keyword\">for</span>(j = i; j &gt;= gap &amp;&amp; nums[j-gap] &gt; tmp; j -= gap)<br>            &#123;<br>                nums[j] = nums[j - gap];<br>            &#125;<br>            nums[j] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-2\">算法分析</h3>\r\n<p>Shell Sort 理解还是较为容易，要将 insertion sort\r\n怎么进行痛彻的理解就明白 shell sort 的工作原理了，算法的快慢重点在 gap\r\n的选择，可以预先指定也可以动态生成，但最后一个 gap 一定是1。</p>\r\n<h2 id=\"归并排序merge-sort\">5.归并排序(Merge Sort)</h2>\r\n<p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法(\r\nDivide and Conquer\r\n)的经典应用。将已有的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并为一个有序表，则称为2-路归并。</p>\r\n<h3 id=\"算法描述-4\">算法描述</h3>\r\n<ul>\r\n<li>把长度为 n 的序列，二分两个子序列<br />\r\n</li>\r\n<li>把子序列分别使用归并排序<br />\r\n</li>\r\n<li>将排好的子序列合并成一个最终的排序序列</li>\r\n</ul>\r\n<h3 id=\"代码实现-4\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;nums, <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> left, <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> mid, <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> right)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> subNumsLeft = mid - left + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> subNumsRight = right - mid;<br><br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; leftNums = <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(subNumsLeft);<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; rightNums = <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(subNumsRight);<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; subNumsLeft; ++i)<br>    &#123;<br>        leftNums[i] = nums[left + i];<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; subNumsRight; ++j)<br>    &#123;<br>        rightNums[j] = nums[mid + <span class=\"hljs-number\">1</span> + j];<br>    &#125;<br><br>    <span class=\"hljs-type\">int</span> leftPos = <span class=\"hljs-number\">0</span>, rightPos = <span class=\"hljs-number\">0</span>, numsPos = left;<br><br>    <span class=\"hljs-keyword\">while</span> (leftPos &lt; subNumsLeft &amp;&amp; rightPos &lt; subNumsRight)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (leftNums[leftPos] &lt;= rightNums[rightPos])<br>        &#123;<br>            nums[numsPos] = leftNums[leftPos];<br>            ++leftPos;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>        &#123;<br>            nums[numsPos] = rightNums[rightPos];<br>            ++rightPos;<br>        &#125;<br>        ++numsPos;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">while</span> (leftPos &lt; subNumsLeft)<br>    &#123;<br>        nums[numsPos] = leftNums[leftPos];<br>        ++numsPos;<br>        ++leftPos;<br>    &#125;<br><br><br>    <span class=\"hljs-keyword\">while</span> (rightPos &lt; subNumsLeft)<br>    &#123;<br>        nums[numsPos] = rightNums[rightPos];<br>        ++numsPos;<br>        ++rightPos;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mergeSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> begin, <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> end)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (begin &gt;= end)<br>    &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-type\">int</span> mid = begin + (end - begin) / <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-comment\">// Dont think it, just recursion.</span><br>    <span class=\"hljs-built_in\">mergeSort</span>(nums, begin, mid);<br>    <span class=\"hljs-built_in\">mergeSort</span>(nums, mid + <span class=\"hljs-number\">1</span>, end);<br>    <span class=\"hljs-built_in\">merge</span>(nums, begin, mid, end);<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-3\">算法分析</h3>\r\n<p>归并排序是一种稳定的排序方式，性能不受数据大小影响，时间都是 <span\r\nclass=\"math inline\">\\(O(nlogn)\\)</span> ，但是需要额外空间。</p>\r\n<h2 id=\"快速排序\">6.快速排序</h2>\r\n<p>基本思想：再一次遍历中，将待排序数据分为两部分，其中一部分比选定关键字小，另一部分比关键字大，再对这两部分进行排序，直到序列有序。</p>\r\n<h3 id=\"算法描述-5\">算法描述</h3>\r\n<p>使用分治法分为两部分</p>\r\n<ul>\r\n<li>从序列中选择一个元素作为基准( pivot )<br />\r\n</li>\r\n<li>重新排列序列，所有比其小的放在左边，比其大的放在右边。在排列后，该基准就位于中间位置，这个称为分区操作。<br />\r\n</li>\r\n<li>递归地把小于基准值元素的子数列和大于基准元素的子数列排序</li>\r\n</ul>\r\n<h3 id=\"代码实现-5\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">partition</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> left, <span class=\"hljs-type\">int</span> right)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> pivot = nums[right];<br>    <span class=\"hljs-type\">int</span> i = (left - <span class=\"hljs-number\">1</span>);<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = left; j &lt;= right<span class=\"hljs-number\">-1</span>; ++j)<br>    &#123;<br>        <span class=\"hljs-comment\">// 如果小于pivot，i右移表示，pivot左侧的值又增加一个</span><br>        <span class=\"hljs-keyword\">if</span>(nums[j] &lt; pivot)<br>        &#123;<br>            ++i;<br>            <span class=\"hljs-comment\">// 将i的值和j交换，这步就是把小于基准的放在左侧</span><br>            <span class=\"hljs-built_in\">swap</span>(nums[i], nums[j]);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 最终将基准值放在中间</span><br>    <span class=\"hljs-built_in\">swap</span>(nums[i+<span class=\"hljs-number\">1</span>],nums[right]);<br>    <span class=\"hljs-comment\">// 返回基准值位置</span><br>    <span class=\"hljs-keyword\">return</span> (i + <span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">quickSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> left, <span class=\"hljs-type\">int</span> right)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(low &lt; right)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> pIndex = <span class=\"hljs-built_in\">partition</span>(nums, left, right);<br>        <br>        <span class=\"hljs-built_in\">quickSort</span>(nums, left, pIndex - <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-built_in\">quickSort</span>(nums, pIndex, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"堆排序-heap-sort\">7.堆排序( Heap Sort )</h2>\r\n<p>Heap Sort\r\n是利用堆进行的排序算法，堆是一个类似二叉树的结构，并同时满足堆的性质：<strong>子节点键值或索引永远小于(大于)其父节点</strong>。</p>\r\n<h3 id=\"算法描述-6\">算法描述</h3>\r\n<ul>\r\n<li>将初始状态待排序序列 ( R1, R2, ..., Rn )\r\n构建成大根堆，此堆为初始的无序区<br />\r\n</li>\r\n<li>将堆顶元素R[1]与最后一个元素R[n]互换，得到新的无序区( R1, R2, ...,\r\nRn-1)和新的有序区(Rn)，且满足R[1], R[2], ..., R[n-1] &lt;= R[n]<br />\r\n</li>\r\n<li>由于交换后新的堆顶可能会违反堆的性质，因此需要对当前无序堆进行调整，然后再次将R[1]与无序区最后一个元素互换，得到新无序区(\r\nR1, R2, ..., Rn-2 ), 新有序区( Rn-1, Rn )不断重复，直到有序区元素个数为\r\nn-1，排序完成。</li>\r\n</ul>\r\n<h3 id=\"代码实现-6\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">heapify</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> numSize, <span class=\"hljs-type\">int</span> i)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> largest = i;<br><br>    <span class=\"hljs-type\">int</span> left = <span class=\"hljs-number\">2</span> * i + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-type\">int</span> right = <span class=\"hljs-number\">2</span> * i + <span class=\"hljs-number\">2</span>;<br><br>    <span class=\"hljs-keyword\">if</span> (left &lt; numSize &amp;&amp; nums[left] &gt; nums[largest])<br>    &#123;<br>        largest = left;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (right &lt; numSize &amp;&amp; nums[right] &gt; nums[largest])<br>    &#123;<br>        largest = right;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (largest != i)<br>    &#123;<br>        <span class=\"hljs-built_in\">swap</span>(nums[i], nums[largest]);<br><br>        <span class=\"hljs-built_in\">heapify</span>(nums, numSize, largest);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">heapSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;nums, <span class=\"hljs-type\">int</span> numSize)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = numSize / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i)<br>    &#123;<br>        <span class=\"hljs-built_in\">heapify</span>(nums, numSize, i);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = numSize - <span class=\"hljs-number\">1</span>; i &gt; <span class=\"hljs-number\">0</span>; --i)<br>    &#123;<br>        <span class=\"hljs-built_in\">swap</span>(nums[<span class=\"hljs-number\">0</span>], nums[i]);<br>        <span class=\"hljs-built_in\">heapify</span>(nums, i, <span class=\"hljs-number\">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"计数排序-counting-sort\">8.计数排序( Counting Sort )</h2>\r\n<p>计数排序不是基于比较的排序算法，核心在于将输入的数据转化为键存储在额外开辟的数组空间中。作为线性时间复杂度的排序，<strong>计数排序要求输入数据必须是有确定范围的。</strong></p>\r\n<h3 id=\"算法描述-7\">算法描述</h3>\r\n<ul>\r\n<li>找出待排序数列中的<em>最大</em>和<em>最小</em>元素<br />\r\n</li>\r\n<li>统计数组中每个值为 i 的元素出现的次数，存入额外数组的第 i 项。<br />\r\n</li>\r\n<li>对所有的次数累加, 从头到尾，这样额外数组就表示元素的实际位置<br />\r\n</li>\r\n<li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i)\r\n项，每放入一个元素将 C(i) 减去 1</li>\r\n</ul>\r\n<h3 id=\"代码实现-7\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">countingSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-type\">int</span> maxEle = nums[<span class=\"hljs-number\">0</span>], minEle = nums[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> num : nums)<br>    &#123;<br>        minEle = <span class=\"hljs-built_in\">min</span>(minEle, num);<br>        maxEle = <span class=\"hljs-built_in\">max</span>(maxEle, num);<br>    &#125;<br>    <span class=\"hljs-type\">int</span> offset = maxEle - minEle + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">count</span><span class=\"hljs-params\">(offset + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>)</span></span>;<br>    <span class=\"hljs-comment\">// 计数，每个元素有多少个</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        ++count[nums[i] - minEle + <span class=\"hljs-number\">1</span>];<br>    &#125;<br>   \t<br>    <span class=\"hljs-comment\">// 计算每个元素的下标</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; offset; ++i)<br>    &#123;<br>        count[i + <span class=\"hljs-number\">1</span>] += count[i];<br>    &#125;<br>    <br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">outPut</span><span class=\"hljs-params\">(n)</span></span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        outPut[count[nums[i] - minEle+<span class=\"hljs-number\">1</span>]<span class=\"hljs-number\">-1</span>] = nums[i];<br>        count[nums[i] - minEle + <span class=\"hljs-number\">1</span>]--;<br>    &#125;<br><br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        nums[i] = outPut[i];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 1,100,22,55,22,11,33,11</span><br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-4\">算法分析</h3>\r\n<p>计数排序是一个稳定的排序算法，当输入元素是 n 个 0~k\r\n的整数时，时间复杂度是 <span\r\nclass=\"math inline\">\\(O(n+k)\\)</span>，空间复杂度也是 <span\r\nclass=\"math inline\">\\(O(n+k)\\)</span> ，其速度快于任何比较排序算法，当 k\r\n不是很大，且序列集中时，计数排序是一个很好的排序法。</p>\r\n<h2 id=\"桶排序-bucket-sort\">9.桶排序 ( Bucket Sort)</h2>\r\n<p>桶排序是计数排序的升级版。它利用了函数的映射关系，其性能高效与否就在于这个映射函数的选取。\r\nBucket Sort\r\n工作原理：假设数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(\r\n可能使用别的排序方法或者递归地使用桶排序 )</p>\r\n<h3 id=\"算法描述-8\">算法描述</h3>\r\n<ul>\r\n<li>设置一个定量的数组作为空桶<br />\r\n</li>\r\n<li>遍历输入数据放入对应桶中<br />\r\n</li>\r\n<li>对每个不是空的桶进行排序<br />\r\n</li>\r\n<li>从非空桶中把排好序的数据拼接起来</li>\r\n</ul>\r\n<h3 id=\"代码实现-8\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bucketSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> bucketSize)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> minValue, maxValue;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> num : nums)<br>    &#123;<br>\t\tminValue = <span class=\"hljs-built_in\">min</span>(minValue,num);<br>        maxValue = <span class=\"hljs-built_in\">max</span>(maxValue,num);<br>    &#125;<br>    <br>    <span class=\"hljs-type\">int</span> bucketCount = (maxValue - minValue) / bucketSize + <span class=\"hljs-number\">1</span>;<br>    vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">buckets</span>(bucketCount)<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.<span class=\"hljs-built_in\">size</span>(); ++i)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> bucketIndex = (nums[i] - minValue) / bucketSize;<br>        bucket[bucketIndex].<span class=\"hljs-built_in\">push_back</span>(nums[i]);<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class=\"hljs-built_in\">sort</span>(bucket[i].<span class=\"hljs-built_in\">begin</span>(), bucket[i].<span class=\"hljs-built_in\">end</span>());<br>    &#125;<br>    <br>    <span class=\"hljs-type\">int</span> index = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; bucket[i].<span class=\"hljs-built_in\">size</span>(); ++j)<br>        &#123;<br>            nums[index++] = bucket[i][j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-5\">算法分析</h3>\r\n<p>桶排序最好情况下时间复杂度为 <span\r\nclass=\"math inline\">\\(O(n)\\)</span>\r\n，其取决于各个桶之间数据进行排列的时间复杂度，因为其他部分的时间复杂度都为\r\n<span class=\"math inline\">\\(O(n)\\)</span>\r\n。显然桶划分的越小时间复杂度越低，但是与之相对的，空间消耗就会上升。</p>\r\n<h2 id=\"基数排序radix-sort\">基数排序(Radix Sort)</h2>\r\n<p>基数排序是按照低位先排序，后收集；在按照高位排序再收集；依次类推直到最高位也排序完毕。此外，有些属性是有优先级顺序的，按低优先级部分先排序，再按照高优先级排序，最后就是高优先级高的在前，高优先级相同者低优先级高的在前。在游戏开发中可能常常用这个排序？</p>\r\n<h3 id=\"算法描述-9\">算法描述</h3>\r\n<ul>\r\n<li>取得数组中的最大数，并取其位数。<br />\r\n</li>\r\n<li>nums 为原始数组，从最低位开始取每个位组成 radix 数组；<br />\r\n</li>\r\n<li>对 radix 数据进行计数排序 ( 计数排序适用于小范围 )</li>\r\n</ul>\r\n<h3 id=\"代码实现-9\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getMaxNum</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; num)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> maxNum = INT_MIN;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> num : nums)<br>    &#123;<br>        maxNum = <span class=\"hljs-built_in\">max</span>(num,maxNum);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> maxNum;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">countSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> exp)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">outPut</span><span class=\"hljs-params\">(n)</span></span>;<br>    <span class=\"hljs-type\">int</span> i, count[<span class=\"hljs-number\">10</span>]= &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        count[(nums[i]/exp) % <span class=\"hljs-number\">10</span>]++;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-number\">10</span>; ++i)<br>    &#123;<br>        count[i] += count[i<span class=\"hljs-number\">-1</span>];<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span>(i = n - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i)<br>    &#123;<br>        outPut[count[(nums[i]/exp)%<span class=\"hljs-number\">10</span>]<span class=\"hljs-number\">-1</span>] = nums[i];<br>        count[(num[i]/exp)%<span class=\"hljs-number\">10</span>]--;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        nums[i] = outPut[i];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">radixSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-type\">int</span> maxValue = <span class=\"hljs-built_in\">getMaxNum</span>(nums);<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> exp = <span class=\"hljs-number\">1</span>; maxValue/exp &gt; <span class=\"hljs-number\">0</span>; exp *= <span class=\"hljs-number\">10</span>)<br>    &#123;<br>        <span class=\"hljs-built_in\">countSort</span>(nums,n,exp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-6\">算法分析</h3>\r\n<p>基数排序分别排序，分别收集，所以是稳定的，但是基数排序性能可能会比桶排序性能要差，每一次关键字的桶分配都需要\r\n<span class=\"math inline\">\\(O(n)\\)</span> 时间复杂度，分配之后又需要\r\n<span class=\"math inline\">\\(O(n)\\)</span> 时间排序。假设待排列序列可分出\r\nm 关键字，其时间复杂度为 <span\r\nclass=\"math inline\">\\(O(m*2n)\\)</span>，但是 m\r\n远小于n，所有还是线性时间级别。<br />\r\n其空间复杂度为 <span class=\"math inline\">\\(O(n+k)\\)</span> ，k\r\n为桶的数量，一般来讲 n &gt;&gt; k，所有额外空间需要 n。</p>\r\n","site":{"data":{}},"excerpt":"<p>几天前发现自己排序算法忘光了，就从网上抄了一份，自己按照思路，C++简单敲了一遍，方便自己后续复习，下面标题放了抄袭对象。</p>","more":"<h1 id=\"排序算法\"><a\r\nhref=\"https://www.cnblogs.com/onepixel/articles/7674659.html\">排序算法</a></h1>\r\n<h2 id=\"排序算法分类\">排序算法分类</h2>\r\n<ul>\r\n<li><p><strong>比较类排序</strong><br />\r\n通过比较数据大小来进行排序，决定相对次序，所以其时间复杂度无法突破<code>O(nlogn)</code>，<br />\r\n因此也称为<strong>非线性时间比较类排序</strong>。</p></li>\r\n<li><p><strong>非比较类排序</strong><br />\r\n不通过比较来决定元素的相对次序，可以突破基于比较排序的时间下限，<br />\r\n因此也被称为<strong>线性时间非比较类排序</strong>。</p></li>\r\n<li><p>比较排序</p>\r\n<ul>\r\n<li>交换排序\r\n<ul>\r\n<li>冒泡排序<br />\r\n</li>\r\n<li>快速排序<br />\r\n</li>\r\n</ul></li>\r\n<li>插入排序\r\n<ul>\r\n<li>简单插入排序<br />\r\n</li>\r\n<li>希尔排序<br />\r\n</li>\r\n</ul></li>\r\n<li>选择排序\r\n<ul>\r\n<li>简单选择排序<br />\r\n</li>\r\n<li>堆排序<br />\r\n</li>\r\n</ul></li>\r\n<li>归并排序\r\n<ul>\r\n<li>二路归并排序<br />\r\n</li>\r\n<li>多路归并排序</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>非比较排序</p>\r\n<ul>\r\n<li>计数排序<br />\r\n</li>\r\n<li>桶排序<br />\r\n</li>\r\n<li>基数排序</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"算法复杂度\">算法复杂度</h2>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 5%\" />\r\n<col style=\"width: 22%\" />\r\n<col style=\"width: 22%\" />\r\n<col style=\"width: 22%\" />\r\n<col style=\"width: 23%\" />\r\n<col style=\"width: 3%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>排序方法</th>\r\n<th>时间复杂度(Average)</th>\r\n<th>时间复杂度(Worst)</th>\r\n<th>时间复杂度(Best)</th>\r\n<th>空间复杂度</th>\r\n<th>稳定性</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>插入排序</td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(1)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>希尔排序</td>\r\n<td><span class=\"math inline\">\\(O(n^{1.3})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(1)\\)</span></td>\r\n<td>不稳定</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>选择排序</td>\r\n<td><span class=\"math inline\">\\(O({n}^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(1)\\)</span></td>\r\n<td>不稳定</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>堆排序</td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(1)\\)</span></td>\r\n<td>不稳定</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>冒泡排序</td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(1)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>快速排序</td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n \\log_{2}{n})\\)</span></td>\r\n<td>不稳定</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>归并排序</td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n\\log_{2}{n})\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td></td>\r\n<td></td>\r\n<td></td>\r\n<td></td>\r\n<td></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>计数排序</td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>桶排序</td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n^2)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>基数排序</td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n*k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n*k)\\)</span></td>\r\n<td><span class=\"math inline\">\\(O(n+k)\\)</span></td>\r\n<td>稳定</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"暴力排序\">0.暴力排序</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vecCout</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>; ++i)<br>    &#123;<br>        cout &lt;&lt; nums[i] &lt;&lt; <span class=\"hljs-string\">&#x27;,&#x27;</span>;<br>    &#125;<br>    cout &lt;&lt; nums[nums.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>];<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">worstSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i; j &lt; n; ++j)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span> (nums[i] &gt; nums[j])<br>            &#123;<br>                <span class=\"hljs-built_in\">swap</span>(nums[i], nums[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; nums;<br>    <span class=\"hljs-type\">int</span> num;<br>    <span class=\"hljs-type\">char</span> c;<br>    <span class=\"hljs-keyword\">while</span> (cin &gt;&gt; num)<br>    &#123;<br>        <span class=\"hljs-comment\">//cin &gt;&gt; c;</span><br>        nums.<span class=\"hljs-built_in\">emplace_back</span>(num);<br>        <span class=\"hljs-keyword\">if</span> (cin.<span class=\"hljs-built_in\">get</span>() == <span class=\"hljs-string\">&#x27;\\n&#x27;</span>)<br>        &#123;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-built_in\">worstSort</span>(nums);<br>    <span class=\"hljs-built_in\">vecCout</span>(nums);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"冒泡排序\">1.冒泡排序</h2>\r\n<p>重复地遍历要排序的元素，每次比较两个元素，如果顺序错误，二者进行交换。<br />\r\n重复的进行直到没有交换为止，即排序完成，因为 top/last\r\n元素会慢慢浮现到数组两端所以得名冒泡排序。</p>\r\n<h3 id=\"算法描述\">算法描述</h3>\r\n<ul>\r\n<li>比较相邻元素，不符合比较顺序则交换。<br />\r\n</li>\r\n<li>对每一对相邻元素作一样的操作，从第一对到最后一对这样最大的元素就会在末尾<br />\r\n</li>\r\n<li>针对所有的元素作上述操作，除了最后一个<br />\r\n</li>\r\n<li>重复1-3步骤，直到排序完成</li>\r\n</ul>\r\n<h3 id=\"代码实现\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bubbleSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; ++j)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span> (nums[j] &gt; nums[j+<span class=\"hljs-number\">1</span>])<br>            &#123;<br>                <span class=\"hljs-built_in\">swap</span>(nums[j], nums[j+<span class=\"hljs-number\">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"选择排序\">2.选择排序</h2>\r\n<p>Selection Sort 是一种简单直观的排序算法。<br />\r\n他的工作原理是：现在序列中找到最小(大)元素，放在起始位置，再从未排序元素中寻找最小(大)元素，放在以排列元素的末尾。重复操作，指导排序完毕。</p>\r\n<h3 id=\"算法描述-1\">算法描述</h3>\r\n<p>n 个元素可以经过 n-1 次选择排列完毕：</p>\r\n<ul>\r\n<li>初始状态，未排序区R[1……n]，有序区为空。<br />\r\n</li>\r\n<li>第 i 次排序，当前有序区 R[1……i-1]，无序区\r\n[i……n]，这次从无序区选出最小的元素R[k]，将其与无序区第一个元素互换，使R[1……i]，[i+1……n]为新区<br />\r\n</li>\r\n<li>第 n-1 次选择结束，数组有序了</li>\r\n</ul>\r\n<h3 id=\"代码实现-1\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">selectionSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-type\">int</span> minIndex;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n<span class=\"hljs-number\">-1</span>; ++i)<br>    &#123;<br>\t\tminIndex = i;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; n; ++j)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(nums[j] &lt; nums[minIndex])<br>            &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-built_in\">swap</span>(nums[i],nums[minIndex]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析\"><strong>算法分析</strong></h3>\r\n<p>表现最稳定的算法，无论什么数据都花费 <span\r\nclass=\"math inline\">\\(O(n^2)\\)</span>\r\n的时间复杂度，所以数据规模越小越好，好处是<strong>不占用额外空间</strong>。</p>\r\n<h4 id=\"为什么不稳定\">为什么不稳定</h4>\r\n<p>例如：4a, 4b, 4c, 1<br />\r\n选择排序后会变成 1, 4b, 4c, 4a</p>\r\n<h2 id=\"插入排序-insertion-sort\">3.插入排序 ( Insertion Sort )</h2>\r\n<p>构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\r\n<h3 id=\"算法描述-2\">算法描述</h3>\r\n<ul>\r\n<li>从第一个元素开始，该元素可以认为已经被排序<br />\r\n</li>\r\n<li>取出下一个元素，在已排序的元素中由后至前地扫描<br />\r\n</li>\r\n<li>若该排序后元素大于取出的新元素，则将该排序元素移到下一位。<br />\r\n</li>\r\n<li>重复步骤3，直到找到新元素大于或等于已排序的元素<br />\r\n</li>\r\n<li>将新元素插入该位置<br />\r\n</li>\r\n<li>重复2-5步骤</li>\r\n</ul>\r\n<h3 id=\"代码实现-2\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insertionSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-type\">int</span> preIndex, currentNum;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i)<br>    &#123;<br>        preIndex = i - <span class=\"hljs-number\">1</span>;<br>        currentNum = nums[i];<br>        <span class=\"hljs-keyword\">while</span>(preIndex &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; nums[preIndex] &gt; currentNum)<br>        &#123;\t<span class=\"hljs-comment\">// 当pre比选中对象大，将pre值赋给pre+1，</span><br>            <span class=\"hljs-comment\">//这样循环下去，pre一个一个赋值到后一个，current就来到了正确的位置</span><br>            nums[preIndex+<span class=\"hljs-number\">1</span>] = nums[preIndex];<br>            --preIndex;<br>        &#125;<br>        nums[preIndex+<span class=\"hljs-number\">1</span>] = currentNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-1\">算法分析</h3>\r\n<p>插入排序往往是在原地进行修改，所以在遍历过程中，需要不断把已排序的元素逐步向后挪位，为新元素提供插入位置。</p>\r\n<h2 id=\"希尔排序shell-sort\">4.希尔排序(Shell Sort)</h2>\r\n<p>由 Shell 发明突破 $O(n^2) $\r\n的排序算法，在原本的插入排序进行改良，优先比较较远位置的元素，故而 shell\r\nsort 又叫<strong>缩小增量排序</strong>。</p>\r\n<h3 id=\"算法描述-3\">算法描述</h3>\r\n<p>将整个数组分割为若干子序列，分别进行插入排序：</p>\r\n<ul>\r\n<li><p>选择一个增量序列，t1, t2, ..., tk, 其中 ti &gt; tj, tk = 1;<br />\r\n</p></li>\r\n<li><p>按增量序列个数 k，对序列进行 k 次排序<br />\r\n</p></li>\r\n<li><p>每次排序，根据对应的增量ti，将待排序序列分割成若干长度为 m\r\n的子序列，下标为i*ti的为一组，分别对各子序列进行插入排序。仅在增量因子为\r\n1 时，将整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li>\r\n<li><p>分组增量为4，则下标[0,4,8]一组，[1,5,9]一组</p></li>\r\n</ul>\r\n<h3 id=\"代码实现-3\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">shellSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> gap = n / <span class=\"hljs-number\">2</span>; gap &gt; <span class=\"hljs-number\">0</span>; gap /= <span class=\"hljs-number\">2</span>)<br>    &#123;<br>        <span class=\"hljs-comment\">// insertion sort</span><br>        <span class=\"hljs-comment\">// 在n/gap组中，进行insertion sort</span><br>\t\t<span class=\"hljs-comment\">// insertion sort，就是从0,gap,gap*2...这样遍历，这些是一组数据</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = gap; i &lt; n; ++i)<br>        &#123;<br>            <span class=\"hljs-type\">int</span> tmp = nums[i];<br>            <span class=\"hljs-type\">int</span> j;<br>            <span class=\"hljs-keyword\">for</span>(j = i; j &gt;= gap &amp;&amp; nums[j-gap] &gt; tmp; j -= gap)<br>            &#123;<br>                nums[j] = nums[j - gap];<br>            &#125;<br>            nums[j] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-2\">算法分析</h3>\r\n<p>Shell Sort 理解还是较为容易，要将 insertion sort\r\n怎么进行痛彻的理解就明白 shell sort 的工作原理了，算法的快慢重点在 gap\r\n的选择，可以预先指定也可以动态生成，但最后一个 gap 一定是1。</p>\r\n<h2 id=\"归并排序merge-sort\">5.归并排序(Merge Sort)</h2>\r\n<p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法(\r\nDivide and Conquer\r\n)的经典应用。将已有的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并为一个有序表，则称为2-路归并。</p>\r\n<h3 id=\"算法描述-4\">算法描述</h3>\r\n<ul>\r\n<li>把长度为 n 的序列，二分两个子序列<br />\r\n</li>\r\n<li>把子序列分别使用归并排序<br />\r\n</li>\r\n<li>将排好的子序列合并成一个最终的排序序列</li>\r\n</ul>\r\n<h3 id=\"代码实现-4\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;nums, <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> left, <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> mid, <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> right)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> subNumsLeft = mid - left + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> subNumsRight = right - mid;<br><br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; leftNums = <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(subNumsLeft);<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; rightNums = <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(subNumsRight);<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; subNumsLeft; ++i)<br>    &#123;<br>        leftNums[i] = nums[left + i];<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; subNumsRight; ++j)<br>    &#123;<br>        rightNums[j] = nums[mid + <span class=\"hljs-number\">1</span> + j];<br>    &#125;<br><br>    <span class=\"hljs-type\">int</span> leftPos = <span class=\"hljs-number\">0</span>, rightPos = <span class=\"hljs-number\">0</span>, numsPos = left;<br><br>    <span class=\"hljs-keyword\">while</span> (leftPos &lt; subNumsLeft &amp;&amp; rightPos &lt; subNumsRight)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (leftNums[leftPos] &lt;= rightNums[rightPos])<br>        &#123;<br>            nums[numsPos] = leftNums[leftPos];<br>            ++leftPos;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>        &#123;<br>            nums[numsPos] = rightNums[rightPos];<br>            ++rightPos;<br>        &#125;<br>        ++numsPos;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">while</span> (leftPos &lt; subNumsLeft)<br>    &#123;<br>        nums[numsPos] = leftNums[leftPos];<br>        ++numsPos;<br>        ++leftPos;<br>    &#125;<br><br><br>    <span class=\"hljs-keyword\">while</span> (rightPos &lt; subNumsLeft)<br>    &#123;<br>        nums[numsPos] = rightNums[rightPos];<br>        ++numsPos;<br>        ++rightPos;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mergeSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> begin, <span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> end)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (begin &gt;= end)<br>    &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-type\">int</span> mid = begin + (end - begin) / <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-comment\">// Dont think it, just recursion.</span><br>    <span class=\"hljs-built_in\">mergeSort</span>(nums, begin, mid);<br>    <span class=\"hljs-built_in\">mergeSort</span>(nums, mid + <span class=\"hljs-number\">1</span>, end);<br>    <span class=\"hljs-built_in\">merge</span>(nums, begin, mid, end);<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-3\">算法分析</h3>\r\n<p>归并排序是一种稳定的排序方式，性能不受数据大小影响，时间都是 <span\r\nclass=\"math inline\">\\(O(nlogn)\\)</span> ，但是需要额外空间。</p>\r\n<h2 id=\"快速排序\">6.快速排序</h2>\r\n<p>基本思想：再一次遍历中，将待排序数据分为两部分，其中一部分比选定关键字小，另一部分比关键字大，再对这两部分进行排序，直到序列有序。</p>\r\n<h3 id=\"算法描述-5\">算法描述</h3>\r\n<p>使用分治法分为两部分</p>\r\n<ul>\r\n<li>从序列中选择一个元素作为基准( pivot )<br />\r\n</li>\r\n<li>重新排列序列，所有比其小的放在左边，比其大的放在右边。在排列后，该基准就位于中间位置，这个称为分区操作。<br />\r\n</li>\r\n<li>递归地把小于基准值元素的子数列和大于基准元素的子数列排序</li>\r\n</ul>\r\n<h3 id=\"代码实现-5\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">partition</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> left, <span class=\"hljs-type\">int</span> right)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> pivot = nums[right];<br>    <span class=\"hljs-type\">int</span> i = (left - <span class=\"hljs-number\">1</span>);<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = left; j &lt;= right<span class=\"hljs-number\">-1</span>; ++j)<br>    &#123;<br>        <span class=\"hljs-comment\">// 如果小于pivot，i右移表示，pivot左侧的值又增加一个</span><br>        <span class=\"hljs-keyword\">if</span>(nums[j] &lt; pivot)<br>        &#123;<br>            ++i;<br>            <span class=\"hljs-comment\">// 将i的值和j交换，这步就是把小于基准的放在左侧</span><br>            <span class=\"hljs-built_in\">swap</span>(nums[i], nums[j]);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 最终将基准值放在中间</span><br>    <span class=\"hljs-built_in\">swap</span>(nums[i+<span class=\"hljs-number\">1</span>],nums[right]);<br>    <span class=\"hljs-comment\">// 返回基准值位置</span><br>    <span class=\"hljs-keyword\">return</span> (i + <span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">quickSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> left, <span class=\"hljs-type\">int</span> right)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(low &lt; right)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> pIndex = <span class=\"hljs-built_in\">partition</span>(nums, left, right);<br>        <br>        <span class=\"hljs-built_in\">quickSort</span>(nums, left, pIndex - <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-built_in\">quickSort</span>(nums, pIndex, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"堆排序-heap-sort\">7.堆排序( Heap Sort )</h2>\r\n<p>Heap Sort\r\n是利用堆进行的排序算法，堆是一个类似二叉树的结构，并同时满足堆的性质：<strong>子节点键值或索引永远小于(大于)其父节点</strong>。</p>\r\n<h3 id=\"算法描述-6\">算法描述</h3>\r\n<ul>\r\n<li>将初始状态待排序序列 ( R1, R2, ..., Rn )\r\n构建成大根堆，此堆为初始的无序区<br />\r\n</li>\r\n<li>将堆顶元素R[1]与最后一个元素R[n]互换，得到新的无序区( R1, R2, ...,\r\nRn-1)和新的有序区(Rn)，且满足R[1], R[2], ..., R[n-1] &lt;= R[n]<br />\r\n</li>\r\n<li>由于交换后新的堆顶可能会违反堆的性质，因此需要对当前无序堆进行调整，然后再次将R[1]与无序区最后一个元素互换，得到新无序区(\r\nR1, R2, ..., Rn-2 ), 新有序区( Rn-1, Rn )不断重复，直到有序区元素个数为\r\nn-1，排序完成。</li>\r\n</ul>\r\n<h3 id=\"代码实现-6\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">heapify</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> numSize, <span class=\"hljs-type\">int</span> i)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> largest = i;<br><br>    <span class=\"hljs-type\">int</span> left = <span class=\"hljs-number\">2</span> * i + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-type\">int</span> right = <span class=\"hljs-number\">2</span> * i + <span class=\"hljs-number\">2</span>;<br><br>    <span class=\"hljs-keyword\">if</span> (left &lt; numSize &amp;&amp; nums[left] &gt; nums[largest])<br>    &#123;<br>        largest = left;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (right &lt; numSize &amp;&amp; nums[right] &gt; nums[largest])<br>    &#123;<br>        largest = right;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (largest != i)<br>    &#123;<br>        <span class=\"hljs-built_in\">swap</span>(nums[i], nums[largest]);<br><br>        <span class=\"hljs-built_in\">heapify</span>(nums, numSize, largest);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">heapSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; &amp;nums, <span class=\"hljs-type\">int</span> numSize)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = numSize / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i)<br>    &#123;<br>        <span class=\"hljs-built_in\">heapify</span>(nums, numSize, i);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = numSize - <span class=\"hljs-number\">1</span>; i &gt; <span class=\"hljs-number\">0</span>; --i)<br>    &#123;<br>        <span class=\"hljs-built_in\">swap</span>(nums[<span class=\"hljs-number\">0</span>], nums[i]);<br>        <span class=\"hljs-built_in\">heapify</span>(nums, i, <span class=\"hljs-number\">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h2 id=\"计数排序-counting-sort\">8.计数排序( Counting Sort )</h2>\r\n<p>计数排序不是基于比较的排序算法，核心在于将输入的数据转化为键存储在额外开辟的数组空间中。作为线性时间复杂度的排序，<strong>计数排序要求输入数据必须是有确定范围的。</strong></p>\r\n<h3 id=\"算法描述-7\">算法描述</h3>\r\n<ul>\r\n<li>找出待排序数列中的<em>最大</em>和<em>最小</em>元素<br />\r\n</li>\r\n<li>统计数组中每个值为 i 的元素出现的次数，存入额外数组的第 i 项。<br />\r\n</li>\r\n<li>对所有的次数累加, 从头到尾，这样额外数组就表示元素的实际位置<br />\r\n</li>\r\n<li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i)\r\n项，每放入一个元素将 C(i) 减去 1</li>\r\n</ul>\r\n<h3 id=\"代码实现-7\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">countingSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-type\">int</span> maxEle = nums[<span class=\"hljs-number\">0</span>], minEle = nums[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> num : nums)<br>    &#123;<br>        minEle = <span class=\"hljs-built_in\">min</span>(minEle, num);<br>        maxEle = <span class=\"hljs-built_in\">max</span>(maxEle, num);<br>    &#125;<br>    <span class=\"hljs-type\">int</span> offset = maxEle - minEle + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">count</span><span class=\"hljs-params\">(offset + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>)</span></span>;<br>    <span class=\"hljs-comment\">// 计数，每个元素有多少个</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        ++count[nums[i] - minEle + <span class=\"hljs-number\">1</span>];<br>    &#125;<br>   \t<br>    <span class=\"hljs-comment\">// 计算每个元素的下标</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; offset; ++i)<br>    &#123;<br>        count[i + <span class=\"hljs-number\">1</span>] += count[i];<br>    &#125;<br>    <br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">outPut</span><span class=\"hljs-params\">(n)</span></span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        outPut[count[nums[i] - minEle+<span class=\"hljs-number\">1</span>]<span class=\"hljs-number\">-1</span>] = nums[i];<br>        count[nums[i] - minEle + <span class=\"hljs-number\">1</span>]--;<br>    &#125;<br><br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        nums[i] = outPut[i];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 1,100,22,55,22,11,33,11</span><br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-4\">算法分析</h3>\r\n<p>计数排序是一个稳定的排序算法，当输入元素是 n 个 0~k\r\n的整数时，时间复杂度是 <span\r\nclass=\"math inline\">\\(O(n+k)\\)</span>，空间复杂度也是 <span\r\nclass=\"math inline\">\\(O(n+k)\\)</span> ，其速度快于任何比较排序算法，当 k\r\n不是很大，且序列集中时，计数排序是一个很好的排序法。</p>\r\n<h2 id=\"桶排序-bucket-sort\">9.桶排序 ( Bucket Sort)</h2>\r\n<p>桶排序是计数排序的升级版。它利用了函数的映射关系，其性能高效与否就在于这个映射函数的选取。\r\nBucket Sort\r\n工作原理：假设数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(\r\n可能使用别的排序方法或者递归地使用桶排序 )</p>\r\n<h3 id=\"算法描述-8\">算法描述</h3>\r\n<ul>\r\n<li>设置一个定量的数组作为空桶<br />\r\n</li>\r\n<li>遍历输入数据放入对应桶中<br />\r\n</li>\r\n<li>对每个不是空的桶进行排序<br />\r\n</li>\r\n<li>从非空桶中把排好序的数据拼接起来</li>\r\n</ul>\r\n<h3 id=\"代码实现-8\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bucketSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> bucketSize)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> minValue, maxValue;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> num : nums)<br>    &#123;<br>\t\tminValue = <span class=\"hljs-built_in\">min</span>(minValue,num);<br>        maxValue = <span class=\"hljs-built_in\">max</span>(maxValue,num);<br>    &#125;<br>    <br>    <span class=\"hljs-type\">int</span> bucketCount = (maxValue - minValue) / bucketSize + <span class=\"hljs-number\">1</span>;<br>    vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">buckets</span>(bucketCount)<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.<span class=\"hljs-built_in\">size</span>(); ++i)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> bucketIndex = (nums[i] - minValue) / bucketSize;<br>        bucket[bucketIndex].<span class=\"hljs-built_in\">push_back</span>(nums[i]);<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class=\"hljs-built_in\">sort</span>(bucket[i].<span class=\"hljs-built_in\">begin</span>(), bucket[i].<span class=\"hljs-built_in\">end</span>());<br>    &#125;<br>    <br>    <span class=\"hljs-type\">int</span> index = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; bucket[i].<span class=\"hljs-built_in\">size</span>(); ++j)<br>        &#123;<br>            nums[index++] = bucket[i][j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-5\">算法分析</h3>\r\n<p>桶排序最好情况下时间复杂度为 <span\r\nclass=\"math inline\">\\(O(n)\\)</span>\r\n，其取决于各个桶之间数据进行排列的时间复杂度，因为其他部分的时间复杂度都为\r\n<span class=\"math inline\">\\(O(n)\\)</span>\r\n。显然桶划分的越小时间复杂度越低，但是与之相对的，空间消耗就会上升。</p>\r\n<h2 id=\"基数排序radix-sort\">基数排序(Radix Sort)</h2>\r\n<p>基数排序是按照低位先排序，后收集；在按照高位排序再收集；依次类推直到最高位也排序完毕。此外，有些属性是有优先级顺序的，按低优先级部分先排序，再按照高优先级排序，最后就是高优先级高的在前，高优先级相同者低优先级高的在前。在游戏开发中可能常常用这个排序？</p>\r\n<h3 id=\"算法描述-9\">算法描述</h3>\r\n<ul>\r\n<li>取得数组中的最大数，并取其位数。<br />\r\n</li>\r\n<li>nums 为原始数组，从最低位开始取每个位组成 radix 数组；<br />\r\n</li>\r\n<li>对 radix 数据进行计数排序 ( 计数排序适用于小范围 )</li>\r\n</ul>\r\n<h3 id=\"代码实现-9\">代码实现</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getMaxNum</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; num)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> maxNum = INT_MIN;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> num : nums)<br>    &#123;<br>        maxNum = <span class=\"hljs-built_in\">max</span>(num,maxNum);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> maxNum;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">countSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> exp)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">outPut</span><span class=\"hljs-params\">(n)</span></span>;<br>    <span class=\"hljs-type\">int</span> i, count[<span class=\"hljs-number\">10</span>]= &#123;<span class=\"hljs-number\">0</span>&#125;;<br>    <br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        count[(nums[i]/exp) % <span class=\"hljs-number\">10</span>]++;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-number\">10</span>; ++i)<br>    &#123;<br>        count[i] += count[i<span class=\"hljs-number\">-1</span>];<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span>(i = n - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i)<br>    &#123;<br>        outPut[count[(nums[i]/exp)%<span class=\"hljs-number\">10</span>]<span class=\"hljs-number\">-1</span>] = nums[i];<br>        count[(num[i]/exp)%<span class=\"hljs-number\">10</span>]--;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        nums[i] = outPut[i];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">radixSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-type\">int</span> maxValue = <span class=\"hljs-built_in\">getMaxNum</span>(nums);<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> exp = <span class=\"hljs-number\">1</span>; maxValue/exp &gt; <span class=\"hljs-number\">0</span>; exp *= <span class=\"hljs-number\">10</span>)<br>    &#123;<br>        <span class=\"hljs-built_in\">countSort</span>(nums,n,exp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h3 id=\"算法分析-6\">算法分析</h3>\r\n<p>基数排序分别排序，分别收集，所以是稳定的，但是基数排序性能可能会比桶排序性能要差，每一次关键字的桶分配都需要\r\n<span class=\"math inline\">\\(O(n)\\)</span> 时间复杂度，分配之后又需要\r\n<span class=\"math inline\">\\(O(n)\\)</span> 时间排序。假设待排列序列可分出\r\nm 关键字，其时间复杂度为 <span\r\nclass=\"math inline\">\\(O(m*2n)\\)</span>，但是 m\r\n远小于n，所有还是线性时间级别。<br />\r\n其空间复杂度为 <span class=\"math inline\">\\(O(n+k)\\)</span> ，k\r\n为桶的数量，一般来讲 n &gt;&gt; k，所有额外空间需要 n。</p>"},{"typora-root-url":"./..","title":"包围盒与物体碰撞(学习中)","date":"2023-02-27T05:10:02.000Z","_content":"  \n学海无涯，学！  \n从来没系统地了解过包围盒和碰撞问题  \n学习总结一下吧。\n  \n<!--more-->\n  \n# 包围盒与物体碰撞\n  \n## 什么是包围盒\n  \n包围盒是一个简单的集合体，盒内包含着复杂的物体。为物体添加包围盒是为了**进行快速的碰撞检测**或者**在<u>更为精确的碰撞检测前</u>进行过滤**。包围盒一般有几种类型，如**球体**、**轴对齐包围盒(AABB——Axis-Aligned Bounding Box)**、**有向包围盒(OBB——Oriented Bounding Boxes)**、**8-DOP**以及**凸壳**。  \n包围盒经常被用于*碰撞检测*，比如射击、点击、相撞等；每一个物体都有自己的包围盒，因为包围盒一般都是规则物体，因此用其来代替物体本身进行计算，比直接用物体本体计算更加高效简单。\n  \n<img src=\"/imgs/包围盒与物体碰撞/AABB&OBB.jfif\" alt=\"不同的包围盒\">\n  \n目前最常见的为AABB和OBB两种包围盒，其中AABB因为简单的生成方式更加常见，但是**AABB包围盒是与坐标轴平行对齐的，故而不会随着物体旋转**。从上图可以看出AABB包围盒比OOBB包围盒多了很多空隙，**对精确度有点要求的碰撞检测的效果不好**。这时候就需要OBB包围盒，**OBB包围盒始终沿着物体的主成分方向生成一个最小的矩形包围盒，可以随物体旋转，适用于较精确的碰撞检测**。\n  \n## 参考资料\n  \n[如何生成OBB( Oriented Bounding Box) 协方差矩阵](https://blog.csdn.net/qing101hua/article/details/53100112)  \n[碰撞检测之分离轴定理算法讲解_ 分离轴定理](https://blog.csdn.net/yorhomwang/article/details/54869018)  \n[OBB包围盒的碰撞检测(SAT算法)](https://visualgmq.gitee.io/2019/08/10/OBB%E5%8C%85%E5%9B%B4%E7%9B%92%E7%9A%84%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/)  \n[Collision Detection Using the Separating Axis Theorem](https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169)  \n[碰撞检测之OBB-OBB检测](https://blog.csdn.net/silangquan/article/details/50812425)  \n[碰撞检测之 AABB 包围盒 aabb包围盒](https://blog.csdn.net/weixin_43022263/article/details/108550538)  \n[AABB包围盒和OBB包围盒区别_哈市雪花的博客-CSDN博客_aabb obb](https://blog.csdn.net/baidu_38621657/article/details/113788440)  \n[[算法][包围盒]球，AABB，OBB - 南水之源 - 博客园](https://www.cnblogs.com/lyggqm/p/5386174.html)  ","source":"_posts/包围盒与物体碰撞.md","raw":"---\ntypora-root-url: ./..\ntitle: 包围盒与物体碰撞(学习中)\ndate: 2023-02-27 13:10:02\ntags:\n---\n  \n学海无涯，学！  \n从来没系统地了解过包围盒和碰撞问题  \n学习总结一下吧。\n  \n<!--more-->\n  \n# 包围盒与物体碰撞\n  \n## 什么是包围盒\n  \n包围盒是一个简单的集合体，盒内包含着复杂的物体。为物体添加包围盒是为了**进行快速的碰撞检测**或者**在<u>更为精确的碰撞检测前</u>进行过滤**。包围盒一般有几种类型，如**球体**、**轴对齐包围盒(AABB——Axis-Aligned Bounding Box)**、**有向包围盒(OBB——Oriented Bounding Boxes)**、**8-DOP**以及**凸壳**。  \n包围盒经常被用于*碰撞检测*，比如射击、点击、相撞等；每一个物体都有自己的包围盒，因为包围盒一般都是规则物体，因此用其来代替物体本身进行计算，比直接用物体本体计算更加高效简单。\n  \n<img src=\"/imgs/包围盒与物体碰撞/AABB&OBB.jfif\" alt=\"不同的包围盒\">\n  \n目前最常见的为AABB和OBB两种包围盒，其中AABB因为简单的生成方式更加常见，但是**AABB包围盒是与坐标轴平行对齐的，故而不会随着物体旋转**。从上图可以看出AABB包围盒比OOBB包围盒多了很多空隙，**对精确度有点要求的碰撞检测的效果不好**。这时候就需要OBB包围盒，**OBB包围盒始终沿着物体的主成分方向生成一个最小的矩形包围盒，可以随物体旋转，适用于较精确的碰撞检测**。\n  \n## 参考资料\n  \n[如何生成OBB( Oriented Bounding Box) 协方差矩阵](https://blog.csdn.net/qing101hua/article/details/53100112)  \n[碰撞检测之分离轴定理算法讲解_ 分离轴定理](https://blog.csdn.net/yorhomwang/article/details/54869018)  \n[OBB包围盒的碰撞检测(SAT算法)](https://visualgmq.gitee.io/2019/08/10/OBB%E5%8C%85%E5%9B%B4%E7%9B%92%E7%9A%84%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/)  \n[Collision Detection Using the Separating Axis Theorem](https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169)  \n[碰撞检测之OBB-OBB检测](https://blog.csdn.net/silangquan/article/details/50812425)  \n[碰撞检测之 AABB 包围盒 aabb包围盒](https://blog.csdn.net/weixin_43022263/article/details/108550538)  \n[AABB包围盒和OBB包围盒区别_哈市雪花的博客-CSDN博客_aabb obb](https://blog.csdn.net/baidu_38621657/article/details/113788440)  \n[[算法][包围盒]球，AABB，OBB - 南水之源 - 博客园](https://www.cnblogs.com/lyggqm/p/5386174.html)  ","slug":"包围盒与物体碰撞","published":1,"updated":"2024-01-14T08:13:08.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti50011bkbw7wx5bv6k","content":"<p>学海无涯，学！<br />\r\n从来没系统地了解过包围盒和碰撞问题<br />\r\n学习总结一下吧。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"包围盒与物体碰撞\">包围盒与物体碰撞</h1>\r\n<h2 id=\"什么是包围盒\">什么是包围盒</h2>\r\n<p>包围盒是一个简单的集合体，盒内包含着复杂的物体。为物体添加包围盒是为了<strong>进行快速的碰撞检测</strong>或者<strong>在<u>更为精确的碰撞检测前</u>进行过滤</strong>。包围盒一般有几种类型，如<strong>球体</strong>、<strong>轴对齐包围盒(AABB——Axis-Aligned\r\nBounding Box)</strong>、<strong>有向包围盒(OBB——Oriented Bounding\r\nBoxes)</strong>、<strong>8-DOP</strong>以及<strong>凸壳</strong>。<br />\r\n包围盒经常被用于<em>碰撞检测</em>，比如射击、点击、相撞等；每一个物体都有自己的包围盒，因为包围盒一般都是规则物体，因此用其来代替物体本身进行计算，比直接用物体本体计算更加高效简单。</p>\r\n<p><img src=\"/imgs/包围盒与物体碰撞/AABB&OBB.jfif\" alt=\"不同的包围盒\"></p>\r\n<p>目前最常见的为AABB和OBB两种包围盒，其中AABB因为简单的生成方式更加常见，但是<strong>AABB包围盒是与坐标轴平行对齐的，故而不会随着物体旋转</strong>。从上图可以看出AABB包围盒比OOBB包围盒多了很多空隙，<strong>对精确度有点要求的碰撞检测的效果不好</strong>。这时候就需要OBB包围盒，<strong>OBB包围盒始终沿着物体的主成分方向生成一个最小的矩形包围盒，可以随物体旋转，适用于较精确的碰撞检测</strong>。</p>\r\n<h2 id=\"参考资料\">参考资料</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/qing101hua/article/details/53100112\">如何生成OBB(\r\nOriented Bounding Box) 协方差矩阵</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/yorhomwang/article/details/54869018\">碰撞检测之分离轴定理算法讲解_\r\n分离轴定理</a><br />\r\n<a\r\nhref=\"https://visualgmq.gitee.io/2019/08/10/OBB%E5%8C%85%E5%9B%B4%E7%9B%92%E7%9A%84%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/\">OBB包围盒的碰撞检测(SAT算法)</a><br />\r\n<a\r\nhref=\"https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\">Collision\r\nDetection Using the Separating Axis Theorem</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/silangquan/article/details/50812425\">碰撞检测之OBB-OBB检测</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/weixin_43022263/article/details/108550538\">碰撞检测之\r\nAABB 包围盒 aabb包围盒</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/baidu_38621657/article/details/113788440\">AABB包围盒和OBB包围盒区别_哈市雪花的博客-CSDN博客_aabb\r\nobb</a><br />\r\n<a\r\nhref=\"https://www.cnblogs.com/lyggqm/p/5386174.html\">[算法][包围盒]球，AABB，OBB\r\n- 南水之源 - 博客园</a></p>\r\n","site":{"data":{}},"excerpt":"<p>学海无涯，学！<br />\r\n从来没系统地了解过包围盒和碰撞问题<br />\r\n学习总结一下吧。</p>","more":"<h1 id=\"包围盒与物体碰撞\">包围盒与物体碰撞</h1>\r\n<h2 id=\"什么是包围盒\">什么是包围盒</h2>\r\n<p>包围盒是一个简单的集合体，盒内包含着复杂的物体。为物体添加包围盒是为了<strong>进行快速的碰撞检测</strong>或者<strong>在<u>更为精确的碰撞检测前</u>进行过滤</strong>。包围盒一般有几种类型，如<strong>球体</strong>、<strong>轴对齐包围盒(AABB——Axis-Aligned\r\nBounding Box)</strong>、<strong>有向包围盒(OBB——Oriented Bounding\r\nBoxes)</strong>、<strong>8-DOP</strong>以及<strong>凸壳</strong>。<br />\r\n包围盒经常被用于<em>碰撞检测</em>，比如射击、点击、相撞等；每一个物体都有自己的包围盒，因为包围盒一般都是规则物体，因此用其来代替物体本身进行计算，比直接用物体本体计算更加高效简单。</p>\r\n<p><img src=\"/imgs/包围盒与物体碰撞/AABB&OBB.jfif\" alt=\"不同的包围盒\"></p>\r\n<p>目前最常见的为AABB和OBB两种包围盒，其中AABB因为简单的生成方式更加常见，但是<strong>AABB包围盒是与坐标轴平行对齐的，故而不会随着物体旋转</strong>。从上图可以看出AABB包围盒比OOBB包围盒多了很多空隙，<strong>对精确度有点要求的碰撞检测的效果不好</strong>。这时候就需要OBB包围盒，<strong>OBB包围盒始终沿着物体的主成分方向生成一个最小的矩形包围盒，可以随物体旋转，适用于较精确的碰撞检测</strong>。</p>\r\n<h2 id=\"参考资料\">参考资料</h2>\r\n<p><a\r\nhref=\"https://blog.csdn.net/qing101hua/article/details/53100112\">如何生成OBB(\r\nOriented Bounding Box) 协方差矩阵</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/yorhomwang/article/details/54869018\">碰撞检测之分离轴定理算法讲解_\r\n分离轴定理</a><br />\r\n<a\r\nhref=\"https://visualgmq.gitee.io/2019/08/10/OBB%E5%8C%85%E5%9B%B4%E7%9B%92%E7%9A%84%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/\">OBB包围盒的碰撞检测(SAT算法)</a><br />\r\n<a\r\nhref=\"https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\">Collision\r\nDetection Using the Separating Axis Theorem</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/silangquan/article/details/50812425\">碰撞检测之OBB-OBB检测</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/weixin_43022263/article/details/108550538\">碰撞检测之\r\nAABB 包围盒 aabb包围盒</a><br />\r\n<a\r\nhref=\"https://blog.csdn.net/baidu_38621657/article/details/113788440\">AABB包围盒和OBB包围盒区别_哈市雪花的博客-CSDN博客_aabb\r\nobb</a><br />\r\n<a\r\nhref=\"https://www.cnblogs.com/lyggqm/p/5386174.html\">[算法][包围盒]球，AABB，OBB\r\n- 南水之源 - 博客园</a></p>"},{"title":"简单学习球谐函数","date":"2023-04-11T11:20:11.000Z","_content":"  ","source":"_posts/球谐函数.md","raw":"---\ntitle: 简单学习球谐函数\ndate: 2023-04-11 19:20:11\ntags: \n---\n  ","slug":"球谐函数","published":1,"updated":"2024-01-14T08:13:08.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti50014bkbwatfqf7wq","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"title":"每日Emo小短句","date":"2020-04-09T16:04:13.000Z","math":true,"_content":"你能翻到这整明你很有耐心啊，说明你对我的Blog还是有一定兴趣的，或者是我直接发的链接。  \n这里记录一下自己在群里的每日Emo小短句，\"每日一句emo小短句，我们明日再见。\"  \n<!--more-->  \n温情提示偶尔伤痛文学一下舒缓压力可以理解，但是不能实际地跟本地解决问题，美好的生活需要自己创造。  \n还有如果你时常心情低落，难受，要注意心理健康，必要的时候要去看医生哦~  \n那么废话结束，我们开始Emo吧。  \n$$\n我从未看透，我只想感受慷慨赴死的颤抖。\n$$\n\n这里只有低级的思考和最卑劣的情绪宣泄， 除此之外没有任何文学意义，我所述之一切，不过尘烟。\n\n# 独油群每日Emo小短句\n\n2023/04/09  \n“我好想问一问进入游戏行业打工的愿望就这么奢侈吗？”\n\n2023/04/10  \n虚拟的数据能分析出我真实的病情，为什么真实的世界却不能带给我一丝虚假的温暖呢？\n\n2023/04/11  \n人生最大的悲哀也许就是平庸的自己配不上远大的理想吧，纵有孟德之志，却无丞相之才啊。可是即便意识到也在名为平凡的泥潭中越陷越深……  \n这场名为人生的冒险好艰难啊。\n\n2023/04/12  \n今人又见古时月，古月不救今时人。  \n这里用救字，是我自己对外的求救，是一种直白的表述方法，我希望给读者更强烈的情感冲击，如果追求诗歌的美可以用别的字，比如照、抚、望。  \n**今人又见古时月，古月已忘今时人。**  \n这里又想到一句更好的，不知道好不好。\n\n2023/04/13  \n无能是灼烧我的业火，他人的光辉刺痛我阴暗的鼠目，宏大的理想也变作狂妄。  \n每日一句emo小短句，我们明天日永别。\n\n2023/04/14  \n浑浑噩噩成了日常，萎靡颓废成了习惯。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/15  \n骑马跨栏的判定太阴间了，cnmd。  \n每日一句emo小短句，今天开始摆烂，我们明天再见。 \n\n2023/04/16  \n小时候父母告诉我要有一颗，像铁一样坚强的心，但是他们没告诉我的是，这世界上磁铁太多了。  \n每日一句emo小短句，今天的emo比以往来的更早一些，我们明天再见。\n\n2023/04/17  \n好想回到过去，好想变成芝士面包。  \n每日一句emo小短句，我们明天再见。  \n是因为我早就死在了过去，所以灵魂索求着还阳吗？\n2023/04/18  \n我是一个怀旧的人，因为我的未来没什么希望，我在过往的欢乐中，种下了一棵在未来通向衰败的枯树，  \n当我茫然地走上自己铺就的幽暗小道时，我总是回头望去，我怀念那些欢乐的日子，我悔恨那些蹉跎的日子，  \n我在枯树旁的荆棘丛中哭泣，我在梦境的虚幻里沉沦，以忘却这痛苦的生活，在美丽的梦里，我是一个怀旧的人，因为我的未来充满希望。  \n每日一句emo小短句，我们明天再见。\n2023/04/19  \n于我而言，生活的琐碎就是一个不断发现自己失败的过程，  \n我时常懊悔无助，但我想，发现自己的失败不应像我一样悲伤、自怨自艾，理当奋起直追、弥补不足，   \n可惜我是做不到的，因为我总是在发现新失败的伟大征程上，义无反顾地航行，  \n我是绘制不出五彩蓝图的幽灵，我已经同海底的死寂共赴沉默。  \n岸上的人不要上我这条残破不堪的船，去在广阔的大海上勇敢地航行吧，去开辟你的新航路吧，  \n鼓足你的风帆去禁受狂风的肆虐，不论前方是文兰或是礁石。  \n“面朝大海，春暖花开。”  \n每日一句emo小短句，我们明天再见。\n\n2023/04/20同理心是种可贵的品质，我好希望每个人都能有这种品质，这样大家就都会关心我了，可惜我只想着别人来关心我，这样看也许这种可贵的品质我自己是没有的，不知不觉又犯了宽于待己，严于律人的错误，我想我是不配这样的奢望的，渐渐地我便不再去幻想了。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/21  \n看到你们美好的生活我真的很羡慕，我也好想和你们一样，虽然理想的工作和实际存在差距，但是能进入自己热爱的行业对目前的我来说就是最大的愿望了，但这愿望终究是小女孩划燃的火柴，在这寒冬中燃不久，便消失了。我蜷缩着身体彷佛看见自己坐在一家游戏公司里，同事都温柔可近，工作生活都很愉快，这样的梦好虚假啊，连我也意识到这是弥留的回光，人们渐渐围在了我的身边，对我指指点点，我依稀听到他们说“活该啊，冻死了吧”，随后我也指着自己说道“活该啊，冻死了吧”。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/22  \n躺在床上怅然若失的望着天空，青春的活力和萎靡的精神在我体内冲突，我同旧厂街过去的哪些青年一样，眼中充满对未来的迷茫，从梦幻中惊醒，面对的是生活残忍的另一面。  \n哪些在镜头前迷茫的青年曾经是一定存在过的，昏暗的室内和朦胧的镜头记录下他们短暂的一瞬，我希望未来别再有他们了，想到这，我再看向窗户映出的模糊倒影，越发清晰却渐渐的陌生了。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/23  \n我想，把自己的痛苦与挣扎用矫情的文字表示出来，是不值得夸耀的、甚至是应当感到耻辱的；用人们共同的痛楚去博取同情未免有些太卑鄙了，但我一直都是这么做的。所以我常对自己感到厌恶、对他人感到羞愧；一个真正有爱的、坚强的人，我想应当是在痛苦之中感受、反思；在有所顿悟后，用爱和希望去鼓舞他人，带给他人力量！人们因生活的痛苦而困顿，却也因困顿而坚强，我在生活的沉沦中越陷越深，唯一能带给别人的就是一首赞歌，一首歌唱反抗平庸、超脱自我的赞歌。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/24  \n小短句总是越写越长，可能是因为压抑不住的表达欲和内心深处对于他人认同的渴望吧，写得越多自己向外暴露出的也就越多。向外表达的行为也是祈求认同的过程，是想被他人了解、关心的强烈渴望。  \n所以我决定继续写小作文。  \n我在行动的过程中内心总是充满怯懦，对于自己的目标总是处在一种迷茫的状态，找不到前进的方向，在光怪陆离的森林中不断地徘徊、观望他人的世界，美好的青春和时光就在自己的惘然中眼睁睁的溜走了，直到今日也未能触及心中的理想。如果说理想是名为文兰的陆地，抵达它的过程，就是一场被称为人生的伟大航行，我们时常同海上的漩涡斡旋，和水下的礁石战斗，而脆弱的风帆和桅杆已经在终日地雨打风吹中受伤磨损，但依旧看不见陆地，却常常听闻别人登陆文兰的讯息。有时我会想投入这广袤的海洋中结束我悲哀的航行，或是祈祷一场巨浪掀翻我的扁舟让我拥有退出的理由，但是在朝露打湿我干瘪的嘴唇，在凄冷的素晖映得海面粼光闪闪时，我又在幻想中看见了文兰的影子。  \n每日一句emo小短句，我们明天再见。\n2023/04/25  \n孤独是上天赐予我的礼物，死亡是世界给我的解脱。  \n我是有意识的玩偶，在戏谑的闹剧中进行着荒诞的演出，宇宙和眼白是我变态的观众，平庸和愚蠢是他们最爱的戏码。广阔的舞台扭曲我的身体，我的精神不甘地嘶吼，软弱的躯体和颓唐的精神揉搓成一团混沌的烂泥，而这丑陋的模样就是他们解闷的笑料。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/26  \n今天一如既往的浑浑噩噩度过一天可是并没有感到快乐，没有休息也没有玩乐，也没有工作，但是一晃就到了晚上，心中更烦闷了，很疲惫。罗素曾说悲伤让人疲惫，我本不知如今倒是感同身受了，也许我应当痛下决断，去正常的生活。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/27  \n我靠着虚假的希望和混沌的疯狂来麻痹自己，这膨胀的幻想被他人用现实刺破，我沉浸在真实的伤痛里，我的诉说和抱怨都是无用的呻吟，在锋利的剃刀前迎接我的是毁灭的命运，在这口疯狂旋转的大染缸里我只是时代光鲜背后被丢弃的渣滓。我是一个失败者，我决定从这场残酷的战争中逃走，做一个懦弱的逃兵，于是在一个最美丽的清晨，我坐在冲入云霄的花托上，对着太阳说我的故事，和月亮谈我的理想，最后我和风自言自语道“我将走向死亡”。  \n每日一句emo小短句，我们明天再见。\n\n2023/4/28  \n钟鼓磨灭了意志，平常让人麻木，在平静中一步步走向海的深处，意识到这毁灭的到来，却没有做出反抗，只是左顾右盼地张望，虽然激起朵朵的浪花可脚下的步伐并未停止，沙滩上的足迹被一袭又一袭的波涛卷走，海里的鱼对着断翅的海鸥说，别害怕，海啸会带走一切的。  \n每日一句emo小短句，我们明天再见。  \n生活是一场无法规避的战斗，  \n有的人轻松写意，有的人举步维艰，  \n无论是胜利还是溃败，世界并不在乎，  \n受伤的只有向着红色风车冲锋的傻鸟。  \n每日一句emo小短句被对线爆出金币了。(\n\n2023/04/29  \n有一条鱼拼命地往渔夫的网口里钻，渔夫把他拎起来看了看，肉少的可怜、长得又颇为难看，“浑身的腌臜味，一看就不好吃”，然后把他扔回了浑浊的泥潭，鱼想着要是自己是一只锦鲤就好了，这样渔夫们都会挣着捕获、是什么“濒危物种”也好啊，可笑的是这年头“濒危”也是要持证上岗的，像他这条只是快死了的鱼，是远远碰不上“濒危”的边的；他望着泥潭外的世界，万类霜天竞自由，飞禽走兽、奇珍异兽，可谓是无奇不有，从蒲公英的耳语中他也曾听闻隔壁池塘和远处大海的景象，那里的水更清澈、那里的水草更细腻，远是比这片小小的泥潭好得多的。他又沉下泥潭里，在他翻身休憩的过程中，他督见一条鱼摆在盘子里，浇上了些许酱汁，被筷子们分食着，“呸，这条鱼刺又多肉又少，还这么腥，真他妈难吃。”，少顷后，盘子里只有被开膛破肚的残羹，一片狼藉。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/30  \n现在这个世界真有趣，虚拟的东西越来越活灵活现，这块荧光屏幕里的小东西们总是那么动人，比外面的世界有趣多了，盯着这绚丽的光彩久了，现实的色彩便显得灰暗下来了，目之所及便没什么趣味，甚至感觉到些许的烦躁，也有投机倒把的人抓住这追求七彩祥云的心理，造出炫丽门面的假象吸引猎物上钩；也许离现实太久了，生命和精力融进了这块小小的屏幕中，等发觉才意识到，这发光的不是太阳，过于沉迷是会食人心血的。  \n是时候做出些改变了，因为该给手机充电了。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/01  \n心中很烦很急，每次总是拖延，最后又是悔过，但是终究不改，为什么我的性格如此低劣。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/02  \n我常用宏伟的目标和理想主义者的虚伪躯壳来遮蔽我丑陋的容貌，然而在这重重伪装之下真实的内心中，是一个彻头彻尾的幻想主义者，我用这些东西来麻痹自我、达到精神世界的超脱，只是假借幻想来满足自我的私欲，就如刘森所言**“你从未看透 你只想感受 慷慨赴死的 颤抖”**，犹如一片落叶追寻着秋日的肃杀和远方坠落的夕阳，希望毁灭和宏伟能装饰自己蹉跎的一生。  \n面对这样的踌躇，我要抽出宝剑斩断这懒惰的羁绊，随着盖格计数的哒哒声，我要义无反顾地冲向那片红色的海阳。我想在每个人的生命旅程当中难免会有失败、会被路边美丽的风光所吸引，但是每个人都应该拥有鼓起勇气、提起胸膛去修正错误的机会，和对自己人生负责的义务，从今天十点钟开始我就要发奋图强，追回失去的光阴！  \n但是十点钟已经过了，那没关系……我不是今天的十点钟开始，我不定哪天的十点钟开始！  \n每日一句emo小短句，我们明天再见。\n\n2023/05/03  \n我看着他踉跄地走在铁道旁散乱着灰黄石头的小路上，他的步伐太慢，已经追不上这趟向前飞奔的火车了；他总是提着一瓶酒，那并非笑看生活洒脱自我的、潇洒的酒，而是为了麻痹自我逃避现实所依赖的毒药，最后一次我看见他走在秧歌队里，脸上带着些许的红晕，和花扇一起舞动，他的舞姿无法称为曼妙，只能说是灾难，这最后的放荡自我和追寻解脱的舞让我感到了毁灭和死亡的味道。后来直到今天，我再也没见他了，听说他害了病，也许他死了，不过我想虽然他迈上了死亡，但是终是没死绝的，我看了看镜子，再望了望太阳，我想大抵是如此的。  \n每日一句emo小短句，我们明天再见。\n\n2023/5/4  \n好怀念小时候，稚嫩的画笔虽然绘制不出写实的画风，却充满着童趣，那是一幅粗糙的蜡笔画，阳光明媚、绿树成荫，背景里奏起的是悠扬的音乐，那时候不知道什么是烦恼，我只负责快乐就好，那个夏日的下午骄阳暖的正好，身上挎着清凉的背心，在可爱明艳的画面中我为了快乐而努力，我似乎还朦胧的记着那些我可爱的伙伴们，我还记得那个美丽奇幻的世界，我的脸上露出了开心的笑容。  \n那时候一切是那么的简单、一切是那么的美好，彷佛一切都是有希望的、一切都是光明的，我怀念那个时候。  \n快乐是怎么样消失的呢？那个无忧无虑的孩子到底去哪里了？我想不通，我不明白，我只觉得指尖有些疼痛，现在才知道快乐原来也是会伤人的，这天真的童趣在我这破败的一生中显得少见而珍贵，我想是不会再有了。  \n每日一句emo小短句，我们明天再见。\n2023/05/05  \n自嘲也许也是自卑的一种吧，在别人指出自己的弱点之前先把自我贬低一番，这样他人的批评也就是“自我反思”的一剂辅药罢了，以此来宣誓自我的主导权，也免得自己不那么尴尬。这种自嘲就和舔舐伤口一样，实际上无用，但是甜蜜的鲜血流进唇齿之间时能品到一种满足的滋味，作为痛苦的调剂。自己虽然也知道有缺点、有问题，但是是难以去纠正的，便摆出一副“啊对对对”这般的态度，不过也是应该比被人指出便暴跳如雷要好得多的。极强的自尊也许会使自己很愤怒别人指出自身短板，在时间久了之后，发现自己终不能改正，这种自尊便化作一种自卑了吧，锋利的尖刺就在世故的雨水中慢慢的侵蚀掉了。  \n今天感觉没有那么emo，也许是回光返照吧，也可能是用一天虚假的努力欺骗了懒惰的自己，得到了一丝宽慰吧，所以也就随便写写，我想这事是不能放弃的，因为我已经蹉跎了太多，这小小的玩乐也许能作为我极少的坚持吧。  \n每日一句emo小短句，我们明天再见。\n2023/05/06  \n如果我能开花，  \n我会在清晨和太阳耳语，  \n我会在夜晚和婵娟摇曳；\n\n如果我能开花，  \n我会把思念揉碎在风中，让他携着我的愿望，飘向远方；  \n我会把诗意溶化在雨中，让她裹着我的烂漫，浸入大地；\n\n如果我能开花，  \n我会把花瓣葬在泥土中，回馈他的恩德；  \n我会把芳香散在世界中，歌颂她的美丽；\n\n如果我能开花，我将带着马头骨一起葬在海中央；  \n如果我能开花，我将偕同蒲公英一起散在风中央；  \n如果我能开花，我将绽放一朵血色的玉英。\n\n每日一句emo小短句，我们明天再见。\n\n2023/05/07  \n人类的SNP排除体外后通过马桶可以全部链接在一起，为什么人类内心的想法不能通过马桶连在一起呢？是因为其实人类只痴迷于肉体的链接，而不在乎心境的联通吗？  \n如果可以的话，我要造一个大大的马桶把所有的心理SNP收集起来，把大家全部连接到一起，就用这条链接彼此的管道，贯穿你我之间的壁垒吧。就算是为了我，对全人类的内心使用发光马桶吧。  \n补充：snp可能是最接近人内在的东西了，想要理解人的内心就去理解snp吧，比良坂曾云“你连心爱的女人的大便都不敢吃，还敢说爱她”，相必背后也是有着这样的哲思吧。(  \n每日一句emo小短句，我们明天再见。\n\n2023/05/08  \n生活大多都是苦闷，羊只顾着食草，至于草是经过怎样的艰难他是不顾的，在人生的创作中你我虽然是作者，但是很多时候剧情没办法自己做主，名叫老天的混蛋编辑总是喜欢安排一些稀奇古怪的操蛋情节，嘛，迫于种种的无奈，我们也许只能在这苦闷中自己去创造快乐了。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/09  \n人生最大的痛苦不是整日都只能陷在悲伤之中不能自已，而是无悲无喜，面对残酷的现实精神和肉体都被摧残的麻木，一切的动荡都激不起涟漪，无论是福是祸都无动于衷。  \n在这样悲喜不加的琐碎平常中我已经渐渐看不清曾经的影像，他慢慢的从我枯燥的生活中消失，没和我道别。他也许就和我一样自私吧，自顾自地离开，而我自顾自地放他走了。我们在这无法言说的默契中被分离了，自他走后我常常忘记了这梦幻的过往，但我有时又会猛地记起，这段记忆就像夏日傍晚时映过窗户的那束橙黄的光——我是记住了的，但却真真地忘记了。  \n“1997年过去了，我很怀念他。”  \n每日一句emo小短句，我们明天再见。\n2023/05/10  \n上天曾赋予我天真的秉性让我能发现生活中的快乐，但是现在他想收回这份馈赠，于是便用残酷的现实一点一点磨灭我的心智，但是我不想放手，因为我会再也找不到快乐。  \n可无论我放不放手，都已经不再快乐了，这个世界有太多的难题我解不开了，有太多的问题我不会了。也许我真的不行，但是我不想承认，我知道认输很轻松，但是一旦低了头就再也抬不起来了，我的自信就像在一把锉刀下一点点的磨碎了。不能再像曾经的那个中二的少年一样冲着一无所有的广袤世界大喊了，那样豪言壮志的盛情已经不再了，如今只有被现实打败的萎靡和颓废了。  \n他朝着被夕阳映红的世界大喊，回应他的只有随风起伏的草场和远处寂静的校舍，但是其实他并不在乎有无回应，他只是想宣战罢了。  \n每日一句emo小短句，我们明天再见。\n2023/05/11  \n我想喝可乐，碳酸充斥口腔很奇妙，因为很好喝所以很想喝，但是妈妈说不健康呢，而且已经很晚了，所以不能喝呢。如果我有钱的话我会买一瓶可乐，最好是冰的，但是我没有，所以我很想喝可乐。  \n我想如果我长大了就可以喝可乐了吧，但是浑身脏兮兮的大哥哥却说不要长大会很痛苦呢，大哥哥说话很有趣人也很好玩。有时大哥哥会拿一个红色的大罐子和我炫耀说多么好喝，但其实是我知道的，那是他在绿色箱子里找到的，因为我看见过别人偷偷把罐子塞进去，也许大家和大哥哥早就商量好了，在玩找宝藏游戏吧，但是大哥哥每次都不让我找，他总是一个人找，好贪心啊。大哥哥每次都会和我说可乐有多么好喝，但是我一次也没看过他喝过，大哥哥到底有没有喝过可乐呢？  \n大哥哥常常躺在广场上的长椅上，他总是给我看到他在绿色宝箱里发现的宝藏，有园的有方的，又蓝色的有白色的。他总能掏出我没见过的东西，我想他应该是个探险家吧，但是他很多时候总是阴沉沉的而且不准我叫他大叔；他有长长的头发却是大哥哥呢，好奇怪啊，但是却很有趣，可能长大的世界就是这么好玩吧，也许大哥哥是怕我和他抢可乐喝，才害怕我会长大吧，大哥哥好小气啊，我会分给他喝的，因为可乐很好喝所以没问题的。  \n不过妈妈不让我和大哥哥玩，说什么他很脏，可是他的眼睛明明很干净很漂亮啊，为什么妈妈会说很脏呢？妈妈说我长大就明白了，看来还是要长大的，但是大哥哥不想让我长大，为什么呢？这也要我长大之后才明白吗？那我还是快点长大吧，因为我想喝好喝的冰可乐啊。  \n我到底喝没喝过可乐呢……\n\n其实我就是大哥哥，而写下这些文字的也是我，充满童趣的我和沧桑的我是我的两面，最后一句是我和大哥哥一起的感叹。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/12  \n今天大哥哥没有来，我也没有喝可乐，大哥哥去哪了呢？大哥哥说过他曾经也是有梦想的，但是不知怎么的就变成浑身破破烂烂的样子了，然后梦想也走丢了，梦想是什么啊？我不太清楚，大哥哥是因为有梦想才会破破烂烂的吗？我也经常做梦，我也会变得破破烂烂吗？变得破破烂烂是不是可以变得和大哥哥一样去冒险了呢？  \n今天没见到大哥哥，心中有什么奇怪的感觉涌上来了，大哥哥今天应该是到新的地方去冒险了吧，不知道他明天会不会回来。  \n大哥哥今天还是没有来，是迷路了吗？还是被新的冒险吸引了？不会是一个人偷偷去喝可乐了吧？  \n……  \n大哥哥已经一周都没来了，也许他不会回来了。我想他可能是去找那个走丢了的梦想了，如果是这样那大哥哥就是我的梦想，因为他和梦想一样都走丢了，等有一天，我也去找大哥哥吧。  \n大哥哥究竟喝没喝过可乐呢？  \n每日一句emo小短句，我们明天再见。\n2023/05/13  \n大哥哥回来了，但是我没有问他前几天去了哪里，就像我没有问他从哪里来，他也没有说去了哪里。他没什么变化只是身上的衣服换的更轻便了，白色的短袖已经变得灰黄了，他好像很没有精神，我和他打招呼他也只是木讷的回应，他是怎么了呢？大哥哥变得和其他大人一样了，总是面无表情、无精打采的样子，可能只有拿红色的可乐罐才能把他明亮的眼睛变回来了。也许大哥哥只想快乐，但是繁重的现实令他无法超脱，难道源自内心的欢愉只能依借外物来所求吗，难道精神的享受只能由物质带来吗……我想不是的，但是精神的交流和思想的碰撞是难得的追求，所以我只能用物质的华丽和感官的疯狂哺乳我混沌的精神。  \n所以，我想喝可乐。  \n大哥哥究竟喝没喝过可乐呢？  \n每日一句emo小短句，我们明天再见。\n2023/05/14  \n今天是阴天，我一如既往的去广场找大哥哥，大哥哥一如既往的瘫坐在长椅上，他灰暗的眼睛里映着被天空压得蒙蒙的广场，蓝色的建材旁没有曾经嬉戏的孩子们，只有略带潮湿的风抚摸着我的脸。大哥哥没有理我，自顾自的唱起了歌，但我听不太清，不知道唱的什么，他萎靡地神往、我无措的徘徊，很快淅淅沥沥的雨散在我的肩头，我转头逃走了，我可耻的遁走，我又羞愧地回头望去，大哥哥已经不见了，我有些怅然地走在雨中，唱起了歌。  \n“没有花香，没有树高，我是一棵无人知道的小草……”  \n下雨天很凉，所以我自是又一天没有喝到可乐的。  \n大哥哥究竟喝没喝过可乐呢？  \n每日一句emo小短句，我们明天再见。\n2023/05/15  \n我是新时代出土的崭新古老废柴，在泥土捏住的废墟中起身后，在绚丽的装饰中不知所向。一面是小县城日趋衰败的丧钟，一面是城市钢筋的逼近和霓虹的威慑；一面是无所适从的现实破烂，一面是歌舞升平的虚拟狂欢；一面是家庭崩塌的通牒，一面是生存无计的惘然；我和马大帅一样在这个崭新的世界无处藏身，生活的琐碎片片地压在头上，无处藏身、无地自容；被迫在这个混沌的垃圾堆里左支右绌，希望能找到点活下去的办法，可迎来的只有广厦高楼里传出的欢乐，连一生讥笑都没有、没有回应就是世界给我最后的回应。我面对宏大时代产生的困窘太大了，大到我不知道怎么形容、我不知道怎么表述内心的感受，但是这种困窘又太小了，小到别人看不见他。  \n”而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。“  \n也许唯一幸运的是，迫于我的精神状态和身体原因，至少还有人能对我展露出一丝理解的姿态，不知是自愿还是出于道德的被迫，想到这里我更加悲伤了。如你所见，宽容和理解也可以作为伤心的利器，温柔和体贴也会带来痛苦，而咒骂和拳脚更不必言说。我想我病了，我在最嘈杂的时代失声，我在最杂乱的树丛迷路，我，一个崭新出土的时代废柴。  \n“那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。我来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。”  \n这一天，我23岁，在我一生的黄金时代，我有好多奢望——**我渴望死亡**。  \n每日一句emo小短句，我们明天再见。\n2023/05/16  \n在无数次的失败中我知道的，其实是我自己的问题，怨不了天也怨不了地，“废话，你不过不是你的问题，还是我的问题吗”，也曾无数次的被讥笑过。人生也许就是这样吧，在浑浑噩噩中就突然直接没有了能前进的路，我的生活就像窗外黑沉沉的天气一样，已经走向了全部哒咩的end了。在这场没有鲜血的残酷竞技中，输家是没有发言的权利和表演的镜头的，我走在自我否定的螺旋中，在如海般的寂寥中下沉。我不害怕挑战，我畏惧失败；我不会失败，因为我总有借口。借口是一把刀，用它来逃避，用它割碎我的梦。我是人生的懦夫，我是战场的逃兵，我是竞技的输家，我是新时代鼓钟旁最丑陋的尸体。  \n我已经死亡。  \n每日一句emo小短句，我们明天再见。\n2023/05/17  \n我好像做了一场梦，  \n在混沌的梦中我看见有人刨开垃圾堆寻找着残羹冷炙以求果腹，有人倒在街头红色点缀天空，  \n在糜乱的梦中我看见贵族门阀极尽奢华，  \n在无助的梦中我看见一个人茫然的站在风中眼神中无悲无喜，  \n在无尽的梦中我看见一个个荒诞的轮回，一股股鲜血浇筑这片大地，可是没有什么神迹，这炽热的血很快就被衣冠禽兽的虫豸吸食干净了，  \n在衰败的梦中我看见一个个消瘦的皮囊，  \n在梦中我看见了一场梦，在朦胧中我依稀听见不能言说的蛊惑。  \n在这荒诞的梦中我醒了过来，看见了一场真实的梦。  \n每日一句emo小短句，我们明天再见。\n2023/05/18  \n梦幻的灯光在淅沥的雨水映衬下更外动人，  \n今夜天空没有月亮也没有星辰，面对这美丽的人类荣光，他们自然是羞愧的躲起来了，  \n水浸的马路映出如幻般的城市炫丽，耸入云宵的是无法逾越的高塔，  \n现代的奇迹循着古时的悲哀螺旋上前，  \n但这一切的磅礴都是他的背景，他从那灰暗的角落露出身来说  \n“城市的绚烂霓虹照不到我们的黑暗生活”  \n是的，无论远处的光多么妖艳，无论多少个日夜在天空上接力，这残破的窟洞也未曾见过一丝光明。  \n上个世纪一个孩子对父亲说想成为艺术家被暴打了一顿，这个世纪一个孩子想成为艺术家却没有道出，时间的分界就如同一面镜子照出相似的彼此，我们怀着同样对理想的执着，然后被生活打击到失去对一切的热爱，在无数的悲天悯人后激发出愤恨与悔过，昨日的夕阳是今朝的晨光，今日的余晖是明早的梦想。  \n每日一句emo小短句，我们明天再见。\n2023/05/19  \n世界总是充满着变化，把自信好强变为偏执自卑，生活的作弊就在于把困苦转嫁旁人，在从襁褓中慢慢褪去外壳面对这疯狂的一切时，正常的精神认知早就沦为玩物，巨大的手抽离矫造着癫狂的心智，若如是亦无需置论，却有得意者假借他人的痛楚予以调味，痛苦后深层的哀伤他自然是不懂的，只觉得好玩消遣罢了，我的肉体、我的精神、我的心智都被这疯狂的世界夺走，而这躯空旷的泥瓦罐也只能装满癫狂的海水。  \n把我的一切还给我，还给我吧，那年轻的亲人，那些离去的人，那无忧无虑，那个没有丑陋伤痕的我，我会在那最美的瞬间按下暂停，哪怕这是永恒的死寂，也比这无尽的疯狂来的更有意义。  \n“因为再往后就是只有失去的现实”  \n每日一句emo小短句，我们明天再见。\n\n2023/05/20  \n坏了，把每日一句给忘了……就连这么重视的事情都在昏昏度日中忘却了，我想我没什么可以辩解的了，之前那么忙都想的起来，现在休息了一天反倒忘记了。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/21  \n我不知道是我萎靡的精神导致我诸多的失败还是我那不顺的过往导致我失去活力，我唯一能确信的就是在这个疯狂而糟糕的社会中，我的失败和顿挫不会就此止步，目光所及的未来是一片狼藉，在他人蓬勃一生开始的年龄，我的生命已经所剩无多，迎来的并非接近疯狂的不甘，反倒有种解脱的释然——终于能从这混沌中离开了。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/22  \n我的人生就和我破烂的电脑一样，也许在某一天，就突然开不了机了，光怪的屏幕里堆满着无用的别人毫不在意的垃圾，这狭小的窗口成了井底的死尸观望广阔天空的井口，可笑的是我的电脑可以因为莫名其妙的原因黑屏宕机，我却卑微地不敢指责他；而我荒诞的生活已经不能继续却仍要强撑，我却严格的咒骂着自己。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/22  \n我是如何的失败我自是清楚不过的了，我是如何的无能导致我这般的颓丧，在这场只有lost的游戏当中，会有人乐在其中吗？我只是找不到完美的退出方式，却又没有直接关闭电源的勇气罢了。  \n我当然知道自己多么可笑，我当然知道自己是如何的软弱，用结束去要挟一切就是我最大的勇气，我不过是一个疯狂的病人，在试验田的舞台上做最癫狂的表演，我不配在这个陆离的世界中拥有聚光灯，我只能在底层的泥泞中失去我曾假借的一切。  \n如果我这极致的失败、这几乎疯狂的精神是独一无二的，是否我也能说自己拥有过人之处，而显得不那么狼狈？如果曾有人和我一样，是否说明我不过如此，而我所相似的那个他是否比我更加悲哀，毕竟我只配做别人的影子，从来都是我像别人，我只不过是后来的低劣、无能地模仿着。我面对这一切真的累了，我想我的Quit就是电源键了。  \n每日一句emo小短句，我们明天再见。\n2023/05/23  \n电脑因为C盘的爆满而黑屏宕机了，不过经过他自我的紧急修复又腾出几个G的空间，彷佛一切都可以继续，只是我不知道黑屏的时间里电脑失去了什么。  \n如果世界黑屏宕机了是不是第一个删除的就是我呢？之后的一切都会照常进行但是不会有我了，而世界应该也不会在乎。  \n电脑比我更会内存释放，也许他比我更配用电脑？那为什么是我在用电脑？还是我在被电脑使用着用电脑。我不知道，我只能借着胡乱的思考来假装对生活的深思，用故作高深来麻痹自己的浅薄。  \n电脑黑屏宕机能修好继续，我的生活可以吗？我能修好他吗？或许根本就没有修好只是出卖了什么东西而我并不自知罢了。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/24  \n人生的一切可能都会在平常和迷茫中渐渐磨灭，在物理角度看熵增的世界以混沌为食，所以一切的荒诞和疯狂似乎都理所当然，而在这如黑暗般的一切中是曾有过耀眼的光辉的，宛若一颗流行划破漆黑的夜幕，似乎是黎明的到来，而那光亮往往被周围的雾霭所吞噬，“面对我们的骨灰高尚的人挥洒下热泪”，我并不高尚，我的泪是因为惋惜和痛恨。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/25  \n浸润着都市淅淅沥沥的夏雨，朦胧的雾气蒙上了我失明的双眼，  \n肉体和灵魂在此刻分割，我昏昏的青春倒进这炫丽的城，  \n外边是奔波的迫切，里面是梦寐的挣扎，  \n我在月光铺就的路上疯狂的向前奔跑，  \n甩开身体、甩开安睡、甩开梦想、甩开月亮，  \n在这个千年之月和都市夜灯共同辉耀的雨夜，  \n我甩开自我，奔向月亮。  \n在月亮上，我抱着干瘪的红薯，离月亮越来越远。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/26  \n原来快乐也使人堕落，所谓生活就是在一团混乱不堪的琐事之中挣扎，最终结束的过程。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/27  \n生活的痛苦就在于，处在毫无新鲜的平静中疲于奔命。人们渴望改变却又不希望动荡，人们希望安慰却又不希望枯燥平常，每天的生活就像一条可以看见的、逐渐平缓的线，渐渐的没有波澜、没有改变的可能，一切都走向热寂。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/28  \n在不舍和茫然中踏上了旅途，途中我看见拉满羊的货车，货车上的羊在想什么呢？我和羊有什么区别呢？我们都在无形的压力下被迫登上这辆不知终点何方的列车。最终的结局都是被残酷的刀屠戮殆尽，我想我和羊是没有区别的，想到这我不仅的发出”咩“的一声。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/29  \n我悲哀的一生还未开始就已经结束，别人的起点是我一生都难以企及的高度，人生就在一个个不知不觉慢慢的错开了，等意识到时已经无可挽回，别人都在一步一步的积累着成功而我一步一步地迈向失败，面对我一团乱麻的生活我只觉得悲哀和无助。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/30  \n在旁人每日的伟大进度推进时，我无忧无虑的快乐时光就一天天消耗了。我曾经是开放世界里那个无忧无虑的孩子，每日在和煦的阳光下踏上去学校的乡间小路，但是残酷的勇者一天天坐着篝火，我不多的童年急速地消失了，我只能看着我变得不再快乐，烦恼和忧愁日益增多，但我什么都做不了，因为这个过程叫做长大，在长大的过程中我要独自面对一个藏在安全屋外数年的劲敌叫生活。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/31  \n人与人之间的差距实在是太大了，这巨大的鸿沟令我难以逾越，他人数倍、百倍于我的智慧和实力地位，我所有的一切别人只不过弹指之间，而我唯一的成就只有拼命地活着。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/01  \n第一步:沉淀。  \n第二步:那场寒冬毁了我的游戏梦。  \n第三步:黑作坊也能做游戏。  \n第四步:两年换皮游，一生氪金情。  \n第五步:游手好闲也是游！  \n第六步:Steam我想你了。  \n第七步:独油炒粉。  \n第八步:城管太凶了，独油地摊。  \n第九步:经济不景气，独油代驾。  \n第十步:吊销驾驶证，碧桂园五星上将  \n第十一步：指点天天打游戏的业主，欺负骗氪的策划狗，遇到危险全身而退。  \n第十二步：若Jam召必回。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/02  \n我好像丢了什么东西，或者缺了什么东西，但是我不知道那是什么，我想我找到它一切都会好起来，但是我都不知道那是什么，我只是茫然。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/03  \n分别的日子日渐近了，我不想那一天到来，却无法阻止，这就是生活、这就是长大，不再无敌，事情不再和美好的想像一样。但我不会忘记，我是活在过去的人，所以我不会忘记。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/04  \n相聚的时间不多了，结束的那一天一步步到来，我不能阻止这别离，也看不到未来的希望，渴望着更好的明天会到来，但不论我的期望如何混沌的未来终将如期而至，“正义会在正义的终点等着所有人”。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/05  \n现实不能靠勤劳致富，所以我想在游戏里满足一下这个心愿。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/06  \n今天是个沉重的日子，不仅因为分别的日子更近了，还有一位同系的同学和这个残酷的世界做了最后的悲惨的告别，生命的沉重和死亡的压抑在这一刻涌上来心头，强权和威压摧残了一条鲜活的生命，我曾想人终是要积极的面对生活，迎难而上的，即便结果是惨败，这样的冲锋至少能让自己以英雄的身份离开；然而残酷的现实是脆弱的身心可能根本抵不住生活的压力和强权的逼迫，稚嫩的生命所留存最后的坚强只有纵身的勇气。  \n我不配去理解，我只感到悲伤，希望每个人都能拥有美好的生活，希望每个人都能有幸福的明天。  \n也许之后，他们会给你看论文、帮你改PPT、平台审核第一时间进行，但这都是因为有鲜血来过这里。正义会 找到的，一 直沿着海 滨找到他的终点。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/07  \n回到学校这几天总是打游戏，完全无心学习，明明自己的人生已经是一塌糊涂却还是一副等死的样子。我这样的人注定是一团垃圾。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/08  \n我以前一直不懂克苏鲁，现在我明白了我的克苏鲁就是生活当我看见他是，那无法用语言描绘的疯狂就充斥在我的大脑中。我处处低人一等没有人认可我，我就是一条处在社会底层的虫子，面对这样的现实我陷入深深的自卑，我想过改变却没有成效。这混乱疯狂的一切，血淋淋的才是现实，幻想和谎言所修饰的只是最悲惨的故事。\n\n2023/06/09  \n一切都要结束了，我最美好的过去就要画上一个句号。  \n每日Emo小短句，我们明天再见。\n\n2023/06/10  \n离别总是匆匆，形形色色的人各自奔向自己的前程，回想我的当今犹如一团烂泥，我做什么事都是半成不就，烂透了的样子，这样满身疮痍的我将要迎接一段注定会满是烂泥的人生，我想不如轰轰烈烈地死去来的痛快一点，在我这样胡思乱想时，离别的匆匆又渐渐地近了。  \n每日Emo小短句，我们明天再见。\n\n2023/06/11  \n我只能说个人的职业选择和社会环境密不可分，每个人的选择都情有可原，但是可悲的是九品中正制，各大门阀家族互相举荐，构成自己错综复杂的利益网络，朝廷官员冗余等问题，大清已经烂透了。  \n每日Emo小短句，我们明天再见。\n\n2023/06/12  \n我转过头去没有看他，我坐在共享单车的座垫上，看着这个颓唐的小镇中心，脑中不知道在想什么，却又感觉有万般思绪涌上心头，我盯着天空，不知不觉地就留下泪了，从此一别我想不会再见了，他会有新的朋友，新的美好生活，我的好朋友又一个离我远去了。我哭得更伤心了，我想这就是分别的感觉吧。今晚的小镇一如既往，没有什么新鲜的事发生，只有一场无可奈何的雨，在月光满轮的晴夜落下。  \n每日Emo小短句，我们明天再见。\n\n2023/06/13  \n所有年轻的人啊，不要长大，所有年轻的人啊，不要让生活夺走你的梦想，所有年轻的人啊，不要成为我这样的人。  \n所有年轻的人啊，长大是件悲伤又无可奈何的事，长大意味着你不再无所不能，曾经的无限活力都变为深深的无力，长大意味着生活很可能会夺走你的梦想，长大意味着你可能会不再是你自己，意味着你可能会成为自己最讨厌的人和那场美好祥和的梦越走越远。  \n所有年轻的人啊，不要长大。  \n每日Emo小短句，我们明天再见。\n\n2023/06/14  \n分别和重逢相冲突在这一刻我不知道是该悲伤还是快乐，我的心中充满无措，我其实一直都是个天真的孩子，本就没准备好去面对这一切，生活不像game那样有趣还可以重来，面对未卜的多艰和枯燥的死寂，我每每消沉，这欢聚只是短暂的，离别又近了一天，欢乐和悲伤浇筑出一杯苦涩的酒，我的脸上没有了表情。  \n每日Emo小短句，我们明天再见。\n\n2023/06/15  \n回到这最温馨的地方，我终于感到了放松，哪些令我烦恼的、令我悲伤的我仿佛都看不见、听不到了，在这短暂的快乐的时光中，我应格外珍惜，因为这美妙的一切都将要离我而去，这曾经最不以为然的平常，从今往后也许就是我最大的奢望，我爱你我的爸爸，我爱你我的妈妈，我厌恶它这可悲的生活。  \n每日Emo小短句，我们明天再见。\n\n2023/06/16  \n时间总是无情，岁月给心爱的人平添了伤痕，看到她瘦峋的样子和手背上青色的血管、白色的胶带，这个面露苍老的人已经不再年轻了，我所爱的人都回不去了，我最无忧无虑的快乐日子也不在了。每感时光飞逝的无力，才知亲情的可贵，回家的路上我想说“我大姑老了”，但我终究没说出口，我极力让自己不去思考、不去悲伤，我想我的父亲会说“别太愁了，儿子”，而我会回道“你也是”。  \n每日Emo小短句，我们明天再见。\n\n2023/06/17  \n有时提笔真不知道写些什么，但觉得这写些东西的习惯自是不能丢掉的，毕竟已经别无什么长处，唯有这一点还能作乐给自己些许的开脱，也算是一种倾诉，不过没有人聆听罢了。最近都在打王国之泪比较放松，没什么思考，没什么感伤。只是觉得王国之泪很有趣，玩起来很忘我，但是再也没有当初第一次玩旷野之息的震撼来的猛烈了，倒不是麻木我想，应是自己“脱敏”了，见识到的也有些了。所以智慧、快乐、财富对大多数人而言其实并不是能全部得到的，不过像我这样一无所有的倒也是少见，也许我可以领个勋章，毕竟在这个物欲横流的社会中，我也是个不小的珍稀物种。  \n每日Emo小短句，我们明天再见。\n\n2023/06/18  \n“公道不在人心，是非在乎实力”——《笑傲江湖·东方不败》，正义和公道只是小孩子的游戏，在这个世界上那只不过是可遇而不可求的奢望，在这波涛滚滚的江湖中，有太多的不公了。天下英雄又有几人能够笑傲江湖呢……  \n每日Emo小短句，我们明天再见。\n\n2023/06/19  \n我喜欢下雨天，因为可以随便哭，雨落在脸上也没人知道那是我的眼泪。  \n每日Emo小短句，我们明天再见。  \n句子不在多寡，兵刃不在长短，功力一到，便可力通人心。\n\n2023/06/20  \n我知道的，在雨里能蒙混过关的只有我糟糕的人生，想流泪的话就放声哭泣吧，即便是阳光万丈的日子。  \n每日Emo小短句，我们明天再见。\n\n2023/06/21  \n我觉得自己再一次放松了，沉浸在混乱的日子中，这种生活就像是沼泽，不知不觉越陷越深，想改变却做不了什么。  \n每日Emo小短句，我们明天再见。\n\n2023/06/22  \n有时候隐瞒是一种让事情更混乱的方式。  \n每日Emo小短句，我们明天再见。\n\n2023/06/23  \n也许现要承认自己的无能不足才能更好的前进，每日的emo感觉更像是命题作文了，思考一些东西，然后记录下来，也算是一种对写作的锻炼吧，不过断然不是日记的，这种东西还是太……做作了，最近没有什么灵感，也很少思考，所以笔下也都是些鸡毛蒜皮了。  \n每日Emo小短句，我们明天再见。\n\n2023/06/24  \n一味地恐惧担忧未来是愚昧的，“不看当下而盼未来，不看未来而盼过去。”，恐惧来源于未知，而未来永远未知，原地踱步永远无法克服这种担忧，而解决这种忧虑的方法就是行动，基于当下去行动，总是思考担心并不能让我们认清未知，只有一步一步地向前迈进才能揭开未知的面纱，把曾经的忧虑变为当下或过去的不足为奇；当然不是说毫不思索上去蛮干，而是要有一个核心的思路方针，所有的行动都依赖于它，并在实践的过程中不断修正，我想大概应该是这样的。  \n每日Emo小短句，我们明天再见。\n\n2023/06/25不看当下而盼未来，不看未来而盼过去。  \n如雷灌顶，我就是一个怀旧的人，总是回忆过去，对现在麻木，对未来迷茫，我一直觉得我的生活充满了绝望，想做什么都不敢开始，也没有坚持，也不知道自己怎么就变成了这个样子。  \n每日Emo小短句，我们明天再见。\n\n2023/06/26  \n我终于知道梦想在生活面前是多么无力 梦想只是自我的虚幻，而生活是庞大的真实，这份真实的重量无比沉重，它变成一个黑洞吞噬了所有的一切。  \n这是我在家的最后一个日子，也是我最后的无忧无虑的日子，面对我最爱的父母和未来未知的生活，我的眼泪止不住的流。  \n我不知道什么毁了这一切，然后把它灌满了悲伤。  \n每日Emo小短句，我们明天再见。\n\n2023/06/27  \n后来我才懂得那些我不曾理解的文字背后的含义，当再次回想时都有了不同的感觉，可惜的是人很难跨越地成长没有经历便没有体会，我终于明白了初读不识文中意，再看已是剧中人。  \n每日Emo小短句，我们明天再见。\n\n2023/06/28  \n我的父亲中午只点了一份白米饭加小葱拌豆腐，这洁白的一餐就如同他洁白的一生，我想说“你怎么不多点几个菜”，但我想我是没资格说的，彷佛他少吃了一些这个举步维艰的家就能多往前走上那么一步，我想了良久不知道说什么，只能打出一串省略号“……”。  \n每日Emo小短句，我们明天再见。\n\n2023/06/29  \n我来到这陌生的城市看见了不同的人，有暴躁吼人的大巴司机，和对我网开一面的保安，和提示我的路人，收留我过夜的华莱士服务员，帮助我使用优惠的店员以及想帮我省钱的打工小哥，和太阳下辛苦的外卖员，在这里我看见了各式各样的人，在这里我看到了那么多我不曾看到的。  \n每日Emo小短句，我们明天再见。\n\n2023/06/30  \nBefore was was was, was was is.  \n逝时曾是时。  \n一颗玻璃球在液压机的压力下可能会瞬间粉碎，但若是一把玻璃球那是击不碎的，一个人也许抵不住那可怕的压迫，但是千千万万的人民群众团结起来时一切的压迫都不足为惧怕。  \n每日Emo小短句，我们明天再见。\n\n2023/07/01  \n茫然地走在这陌生的街头，世界上的一切都和我息息相关却又毫无关联，我找不到未来，只觉得生活的悲哀。  \n每日Emo小短句，我们明天再见。\n\n2023/07/02  \n我不懂得这陌生的一切，我所了解的只有我卑微的生活，机遇被乌鸦叼走，苦难留我独自品尝，不甘和焦虑灌注满我的心头，我的泪已经不再流，时代飘落在人上的从来都不是一颗沙，只不过是有的人在山顶而我在五行山下。  \n每日Emo小短句，我们明天再见。\n\n2023/07/18  \n如果死亡，也许会有人为我流泪；  \n如果死亡，也许会有零星的人感伤；  \n如果死亡，也许会有人诧异；  \n但是，我仍苟延残喘，  \n活着，便没有人去关心；  \n活着，便没有人开始理解；  \n活着，便没有死亡。  \n活着，便是死亡；  \n所以死亡不必落泪，因为我曾获得了悲伤。  \n每日Emo小短句，我们会再见吗？\n\n2023/07/21  \n我小时候总是幻想未来的自己会穿越回来把我杀了，现在我才明白，如果我回到过去，可能会哀求小时候的我把长大的我杀掉。  \n每日一句emo小短句，我们有缘再见。\n\n2023/07/25  \n我走到路口，落日低垂和红色的灯光相得益彰，零散的人整齐地插在路旁，头垂进手机里。  \n在这规律的耕作旁倒也是有别样的风景，一辆黄色的环卫三轮，上面有四五个大叔，皮肤已经变得褐黄了，我偷偷看着他们，假意望向空荡的路口，目光触及到围栏里的楼，就在这落日下他们望着西边的远方，我望着繁华世界中的荒凉，然后灯变绿了。  \n每日一句emo小短句，我们有缘就会再见。\n2023/08/04  \n初中读《我是猫》时倒也谈不上多么被惊艳到，现在唯一能回想起来的就是，那个在猫眼中一切祥和安适的氛围。  \n如今我却真真切切地想变成一只猫，我不知道我是否怀着和夏目漱石一样的心情，但我总会回想起那个夏日慵懒的午后，翻开那本厚厚的书一页一页地读着，那时候我应该没有那么多烦恼，回忆为房间铺满了温柔的阳光，眼中的一切只是宁静和美好，就像那只猫一样。  \n夏目漱石先生，我想变成猫。  \n每日一句emo小短句，希望陌生的你可以像猫一样，充满童真和快乐，我们会再见，哪怕你不记得我。\n\n2023/08/08  \n生活也许会欺骗你，也许会愚弄你，你可能对一切都感到绝望，但是别像我一样沉浸在悲伤中妄想活着的感觉，爱自己，我的朋友。  \n每日一句emo小短句，我们偶尔见上一面吧\n\n2023/08/11  \n苍天已死，黄天当立。  \n岁在甲子，天下大吉。  \n今天偶然看到了13年的一个交友贴，我仿佛能看到有一群拥有共同爱好的人聚在一起，那热闹的气氛，但9年过去曾经年轻的人可能已被生活催的岁月已老，不禁感叹这群互联网遗老会不会偶尔怀念过去，是否我们曾怀着同样的心情看过去、望未来。点开这崭新的古老链接时，能看到的也不过是独属于那个时期的一个又一个有趣的灵魂罢了。但是也可能由于重拳或压力，现在望去，曾经热闹的讨论版如今也不过是纷繁混乱的网络世界中，又一个少缺人烟、落满时代尘埃的犄角罢了。  \n每日一句emo小短句，神马都是浮云。\n2023/08/20  \ncheems早就不是表面上那一只普通的柴犬了，  \n我认为这是一种文化现象或者浪潮，他已经成为了一种意象，其中最为珍贵的是cheems浪潮传递的那些思想和被人们带来的激励、感动。  \n当他被遗忘时，才是他真正死亡的时候。  \n存其意而忘其形，如果你活着你早晚都会死，如果你死了，你永远都活着。  \ncheems的离世无疑是一件让人悲伤的事，但是我会记住这一切。\n\n见过互联网的波涛汹涌后，已经习以为常，光怪陆离、充斥着荒诞的新世纪发生什么都不足为奇，在这个美妙而不知所向的时代里，我被赋予了一颗石之心，麻木地感受着无数的悲与喜。  \n每日一句emo小短句，今日突袭群友！劫营速战，措手不及。![img](D:\\biancheng\\Blog\\source\\imgs\\每日Emo小短句\\F1SZC9}W}_XEA5S]5FCJM3.png)\n\n他们都太优秀了，优秀到被照到的我居然以为自己也能成为一颗星星，突然有那么一天就被随意的聊天惊醒了，什么星星啊，原来我还是那个在下水道里发臭的垃圾啊，如今切实地体会到那句话了“天才这种东西，常会不自觉地将周遭的人卷入，然后弄得遍体鳞伤。越是靠近，越会被撕裂成碎片。”，等回过神来时已经菠萝菠萝哒了。\n\n2023/09/01  \n\"我爱你。\"  \n你可能觉得奇怪，也可能感到突兀或者冒犯；但是有时人们之间确实会有那种莫名的憎恨，甚至没有任何理由，所以我想人和人之间也会有这种不需要理由的爱。可能这种爱并非是深入骨髓、刻骨铭心的海誓山盟，更像是一句寻常的关心，哪怕是一种冲动。  \n然而，如果这份爱是虚假的，那我希望那莫名其妙的恨也失去意义。  \n每日一句 emo 小短句，我们有缘再会。\n2023/09/02  \n触不可及却刻骨铭心，生活的无奈就在每日的平凡中展开，  \n我们也许都在做着正确的事，但悲哀的是当我们彼此交汇，这本该在时间的河流上编织的诗歌如今只有混沌。  \n“如果我不直播了 我可能会突然上个厕所 然后再也不回来了”  \n“泥头车每天还是准点来，只是车上再也没有那个女孩的身影。如果当初知道，应该放下一切，上车，不再回来。”  \n“圣地亚哥在下雨，智利别为我哭泣”  \n每日一句 emo 小短句，我们有缘再会。\n2023/09/04  \n狗彘食人食而不知检，途有饿殍而不知发  \n指望资本主义的走狗良心发现简直是异想天开，为自己徒增烦恼，要明白谁是敌人，谁是朋友。  \n团结一切可以团结的力量，打倒所有的敌人。\n2023/09/29  \n爱而不得才是常态，充满遗憾就是人生；  \n壮志未酬不过稀松平常，苦海无涯乃是我的命运。  \n“试问天下英雄又有几人能够真正的笑傲江湖呢”  \n我原以为自己这卑劣的样貌不过是不讨喜，对于旁人也不过是稀松平常，没想到自己竟然如此的令人恶心。在这昭然的事实后展示出的是这场淘汰机制的生存竞争，从古至今一刻不停。可悲的是，无论你赋予生命怎样的意义，在这场追寻宇宙真理或生存真谛的比赛中，败者只能是一无所有，直至死亡，所有的思辨最后恐怕都是自我安慰，一次名为自我欺骗的“和自己和解”。  \n在这场比赛中，我从来没有获胜过，我只是个loser 所以我恨，我的立场不是中立，因为我尝尽了悔恨、嫉妒、憎恶的滋味，那必定不是甘甜的也不是苦涩的，而是刺痛。  \n每日一句 emo 小短句，我们有缘再会。\n2023/09/29  \n当我蜷缩在这大到无边城市里阴暗的一角时，我想起了那句台词  \n“我要这满城的人都来陪葬”  \n“千里皇城尽作焦土”|  \n我仿佛能理解李儒的焚城决策，但我没有那样的智慧，我只有偏执的疯狂。  \n每日一句 emo 小短句，我们有缘再会。\n2023/10/06  \n有时候我们耗尽一切都得不到自己渴望的东西，其实这才是生活的常态，长大的世界就是求而不得、学着放手；不知不觉我们都不再是那个哭哭闹闹就能得到冰淇淋的小孩子了，那种无忧无虑的时光最后只能成为宝贵的回忆，让我们在痛苦的现实中去怀念、去流泪。  \n不过我没吃过冰淇淋。  \n如果不用上班是否所有的悲伤都会变作欢乐呢？  \n今日 emo 能量赞助来源，歌曲《Duvet》，演唱者 Bôa ，别名《TVアニメ「serial experiments lain」OP1テーマ》，收录于《Tall Snake Ep》专辑中。(就是《Lain》的 OP 哦)  \n每日一句 emo 小短句，我们有缘再见。\n\n2023/10/15  \n从互联网文学，到农村纪实(在如今这个城市化程度很高的时代，还有人去关心乡村去记录现实，我是表示敬佩和珍惜的)，再到修正主义和牛鬼蛇神，再到过去的抗争记忆，再到古代新学和现代桎梧，还有当下未来的科幻，一切都与我无关，却都发生在我身边。  \n[图片] 已过期\n\n2023/11/02  \n清醒令人痛苦，麻木使人沉沦，人记性太好会很痛苦。  \n每日一句 emo 小短句，我们有缘再见。\n\n弱智吧小集合  \n敬老院的新人都是老人，这个世界的大人都是小人。  \n所有的桥都是温暖的，因为他们让河流不再难过。  \n从我确诊出生的那一刻，我的死亡就只是时间问题。  \n皱纹是时间吹过身体时泛起的涟漪。  \n月亮——摘自《星空》  \n看到花开放时，花就已经在枯萎了。  \n我的梦想是一对情侣，白天我压的她说不出话，晚上她压得我难以入眠。  \n我最新的照片是我最老的照片。  \n生鱼片是死鱼片。  \n世界是个大象，我们每个人都在盲人摸象，抽象是对世界最好的鞭笞。\n\n2023/11/19  \n我已经燃烧殆尽了，只剩下雪白的灰。  \n燃え尽きたぜ…真っ白にな…\n\n如果只能有一个李哥，为什么不能是我李元浩的李。  \n这可能是你唯一的机会了，小虎。  \n也就是说，现在是LPL苍蓝猛虎登场的时候了。  \n昼虎！夜凯！  \n地虎铠甲，合体！\n\n小虎需要这个冠军来证明自己。\n\n2023/12/15  \n害，卡姐真的是太惨了，幼年丧母，青年丧父，碰到了戈塔屎，以为是好人结果被坑了。  \n到博德之门后，她对死去的父母，以前的朋友都是在做死前的最后道别。  \n在饭店的夜里，她说干净床单的味道能让她想起妈妈，因为她妈妈是一个洗洁工，她畅想假如自己还有50年，未来会有多么美好……  \n但是这一切注定都是悲剧，逃窜到最不愿回首地狱也不过是在惨淡的命运驱使下痛苦地活着，“再见，大海。再见，太阳。再见。”  \n我爱你，卡菈克。\n\n203/12/17  \n如果没有遗憾，我是否还会爱你？\n\n2024/01/08  \n在最黑暗的晴空万里我为太阳哭泣，如果明天我不再升起，  \n请别为我忧郁，  \n如果明天我不再呼吸，  \n世界请为他人欢愉。  \n在麻木和壁垒中流浪，清醒让我渴望死亡。  \n如果懦弱是种疯狂，麻木是否已经渗入我的骨髓。  \n我渴望哭泣，我渴望结束，我渴望渴望。  \n每日一句 emo 小短句，我们有缘再见。  \n\n2024/01/20  \n哦，妈妈请别为我哭泣，我们将回到故乡。  \n读哈马斯的勇敢有感。  \n每日一句 emo 小短句，我们有缘再见。  \n神只是人类美好的倒影，至少于我而言，最伟大的是人类历史中那些充满勇气的瞬间。  \n\n2024/05/10  \n原来幻想中反派听到音乐被迷惑困住甚至感悟的情况是真实存在的。  \n当我听到童年熟悉的音乐才知道自己再也回不到那个，炎热却温暖，茫然却快乐的日子了。  \n我在熟悉的旋律在忘却了当下，只记得那个温和的午后，  \n我被这悠扬的笛声困在了过去，又逃不出现在，  \n这是一种奇妙的感觉，温馨快乐做了泪水的底料而悲伤洒在了我的脸颊。  \nhttps://www.bilibili.com/video/BV1dy42187pm  \n每日一句 emo 小短句，我们有缘再见。  \n对了，也许我的可可果已经熟了吧。  \n难道人生注定是一个塑造自己，丢失自己，怀念自己，找寻自己的过程吗……可悲的是我无法找回自己了，我只想杀死自己。 \n\n2024/07/14  \n坐火车是一件挺有心理压力的事。  \n在车上能看见各个年龄段，和很多不同的人，从小孩到大人，再到老人，从体力工人再到脑力劳动者。  \n仿佛人生的大部分状态和未来的可能都被压缩到这一个狭窄的通往过去或未来的车型上。  \n在这里看到自己记忆中的过去，也能投射出自己些许的未来。  \n我为不能回到过去而感到悲伤，我为昏暗的未来感到悲伤。  \n我为座位如此接近，阶级差距却如此之大而感到悲伤。\n\n2024/07/15  \n在混杂的音响和众人的祝福中，我的思绪其实早已飞到过去，我只看得见一屡长发在我眼前拂过，  \n阳光顺着发间映出，仿佛发光的是她，而不是背后的太阳，我怯懦地用残缺把她的脸从回忆中抹去，  \n仿佛这样就不会悲伤。  \n于是我坐在喜宴的桌沿上，沐浴着礼炮的彩色飘带，大家都在笑，我也笑了，  \n“祝你幸福”。\n\n2024/09/14  \n难道人生就是一个被当下蹂躏，焦虑未来，怀念过去的体验吗？  \n如果一向如此，我美好的曾经是否子虚乌有，我的焦虑是否杞人忧天，我的现在是否镜花水月。  \n你好，我已经去了未来，如果你看到了这段信息，请在现在把我带到过去。 \n\n2024/11/24  \n阳光好刺眼啊，仿佛要把我全身的潮湿和阴暗都蒸发掉一样，即便是这样的白日青天、朗朗乾坤，我的前程为何还是一片灰暗。  \n要何等的烈焰才能驱散笼罩在心头的阴霾。\n\n2024/10/25  \n为什么现实是这样复杂且痛苦的呢？  \n也许这个世界就是一口大锅里面炖着一切，当我品尝生活的滋味时，不是咸，也不是甜，那种味道很复杂，很多时候这种味道让我说不出话。  \n也许五味杂陈的意思我现在才理解吧。  \n我的现实是没有幸运星的。  \n也许一开始这就不是一个开心温暖的故事，不过虽然我开了一个糟糕的起承，但至少我还是作者，这个故事还不会封笔。  \n写到这里时不由得想到巴勒斯坦人民的遭遇，真是场卑劣的战争，悲怆和残忍正在这片土地上演，巴勒斯坦人民万岁。\n\n2024/11/01  \n我闭上眼睛，勇气没有增长。  \n这薄薄的无尽黑暗中，我看到了未来，  \n所以无需畏惧，大啖食粮之刻已至。\n\n2024/11/28  \n我只是在原地兜圈子的一个孩子，  \n我渴望有人主动跑过来爱我，  \n我希望有人能拉着我的手前进，  \n而现实是，不会有这样的人了，  \n而幼稚的我只知道坐在原地大哭，  \n这不是一场悲剧，只是我个人的丑态。\n\n2024/12/03  \n正义是杀不完的，无论是真的还是希望相信，正义都是杀不完的。  \n即便我们只能像“我们必须想象西西弗斯是幸福的”一样略带无奈和妥协地去相信自我价值。  \n正义是杀不完的。\n\n悲歌可以当泣，远望可以当归\n\n2024/12/05  \n望未来•娄山关  \n冬风裂，空留萧索孤影夜。孤影夜，霜飞雨泄，亭台幽咽。  \n崎岖闭路了无疟，今夕空作亡魂雀。亡魂雀，幽闭犹怨，寒玉犹泪。\n\n2024/12/05  \n我时常感到悲伤，\n说悲伤是陪我之现在的朋友也不为过，\n所以我想既然我摆脱不了它，\n不如去享受这一刻，把我的感受和思考记下来，哪怕给人作为玩乐的笑料，\n渐渐的这也成为了我的一种习惯或者说乐趣。  \n人活一世也许真的会留下点什么。\n\n2024/12/11  \n雨打在外套上窸窸窣窣，上海的冬天，也不能说为冬天吧，比家乡来讲应是晚秋的气温，虽然如此但气温也低，寒冷的夜有些伤感，能听到只有汽车呼啸而过带起的水泽和雨滴滴答答。\n没有月亮，没有星星，就像没有太阳一样，我想不明白游戏行业为什么这样的，有的人已经金缕玉衣，而我能还在一堆烂泥淤成的潭里，不仅狼狈丑陋而且一无所有。\n每每想到这我都感到十分的伤心，甚至想大哭一场以此来发泄来麻痹这庞大的、痛苦的、无助的感觉。\n我想璀璨的人生我是不会拥有了，有的故事就是这样的能够扭扭歪歪地写出几个字就已经很不容易了，哪里还有什么美学或者意义呢。\n我的人生已经开始了，但是我的人生其实早就结束了。\n雨漏进了泥潭，天有些凉，我也有些冷了，但是我看不见月亮。\n\n*注释：雨没有漏进泥潭，其实是笔者的眼泪在心窝中流转。*\n\n2024/12/12  \n\n* 分不清是被子冷，还是天气冷，还是世态炎凉。\n* 所以说人与人之间的隔阂就像at立场一样，我撞不开，强行撕开只会让人受伤。\n* 冷暖自知，能感受到的只会有冷。\n  这是个最冰冷的词汇，因为不能和别人拥抱才只能自己窝在寒冷里幻想温暖。\n\n* 没人爱我。  \n  倒不是说大家都不喜欢我，可能会有人喜欢我，但是是没有爱的勇气的，我也没有，我就是那个害怕幸福而逃走的胆小鬼。  \n  xx，你戏谑的外表下藏着什么呢？  \n  嘻嘻哈哈也金缮不了被生活伤害的残破的心。  \n  我不要。  \n  我要未来，我要希望，我想要爱，我想要真理。\n* 我所做的工作都是微不足道的，我只是把那个缤纷绚丽的世界搬到大家面前，除此之外别无他长。  \n  只要用心观察世界，每个人都是伟大的作家。\n\n2024/12/19  \n你说得对。  \n我的一生确实是浪费了。  \n我不再是那个有所期望的人了，  \n在自己的软弱催使下，在见证一起冷漠的爱和爱抽象的人却转身向现实铡刀者之后，我不在爱人类了。\n\n所谓的博爱和温柔，只不过是披着抽象外衣的自我感动，卑劣至极罢了。\n我不再爱自己，在试着爱人类时，也失败了。\n人所之人，非人哉。\n\n2024/12/25  \n前人之述备矣。  \n我每次有所感悟，有所表达时，特别是选题相近，比如对时间流逝的感悟，其实早有绝笔，所以总有些彷徨，我对着千古已定的命题还有所疑虑，仿佛我已经忘却了前人的教诲，有些羞愧。  \n但是我突然想到，所感前人之感，也并非说明我们遗忘了什么。  \n恰恰说明人类从未遗忘，对于相同的困境和问题，拥有了相同的感悟或表达抑或不同，恰恰说明人类没有忘却。  \n面对相同的问题，我相信这种重复思考会继续下去，直到它解决的那天。  \n虽然后人可能忘记我当下随感，但是当他们遇到相同的问题时这一切的思考会再次涌现。  \n也许对于人类而言，时间的流向已经固定，宇宙就是如此的残忍无情，那么如此脆弱的人类，所能拥有对抗这一切的、唯一的脆弱武器便是思想，唯有思想才能穿越时间。  \n我称之为，遗忘的记忆。\n\n去忘记吧，等你忘记所有招式你就练成了太极拳。\n\n2024/12/26  \n\"雪融\"，我看不见太阳升起了，我的雪在这里就要化了，只不过只能以泪水的方式了。  \n明年7月，如果你有时间的话，对风声说一句天气如何吧。\n\n2024/12/27  \n有时候做梦就梦见审死官里面那一幕，  \n星爷演的那个状师，拿着金元宝轻蔑地指着我，“做游戏啊！做游戏啊！”，  \n于是我也和他一起戏谑了。\n\n2025/01/07  \n昨天我大学同学的朋友问我，你读这么多年书现在加班那么晚，有没有后悔过，  \n当时没觉得什么只是说，还能怎么办想那么干啥，得生活啊。  \n现在冷静下来，想想心里突然有点东西放不下了。  \n我知道他是想问问我答案，但是我也不知道答案，  \n我其实和他一样，  \n至少在对人生的迷惘上，出奇的一致。\n\n2025/01/08\n看一次哭一次，如果真的有爱情的话希望别是这个样子。  \n伤心莫采琵琶树，断魂不照小轩窗。\n\n2025/01/24  \n幸福是主观的，浮动的，不可定义的，同时也是无法衡量，不能经由测试的。  \n很多时候幸福可能是一瞬间的感觉，当然会有幸福存在。  \n然而从长远看人生更可能是一场悲剧，幸福也许是不存在的。  \n选择做一个无知的人欺骗自己是幸福的，或者做一个痛苦的人接受幸福是少数的。  \n很难说这两者是聪明的愚蠢，还是愚蠢的聪明。\n\n2025/02/21  \n你怎么开始怀念过去了？  \n你老了吗？可是你最多可能也就30岁，不太老也不太年轻。  \n我不知道，也许是……过得有点辛苦让我想起了从前。  \n你呢？朋友。\n\n2025/02/21  \n落叶魔音，见落叶而知深秋，  \n晓得盎然春日遥遥。  \n初听不觉何足道，十年邈邈，  \n再奏断万股愁肠，千滴泪。\n\n2025/02/26  \n牛马哥，我总是想起从前，  \n我现在生活地很痛苦，在夜深人静的时候，我努力回想小时候那些美好的时光，那些日子因为遥远反而显得格外温暖。  \n但是我的身心已经冰冷，只有在回忆中逃避当下的时，才能感受到什么叫生命。  \n在我去逐步认识这个世界的现实中，疫情又给了我沉重的打击，在哪个迷惘和无措的时光惶惶然，我被迫进入了社会，没有承担责任的勇气，没有敢于面对困难的魄力，有的只有对未来的迷惘和昨日的创伤。  \n于是我再次回忆，那个慵懒的躺在午后阳光里的孩子，那个和朋友有说有笑不知愁滋味的男孩。  \n对我而言过去是欢乐的，但是我站在原地往回跑的时候，却无论如何也追不上了。\n\n2025/03/18  \n就像我总怀念那年夏天的风，  \n我记得那是一个凉爽的下午，  \n它从窗户钻了进来，  \n卷起前桌黑色的长发，  \n来到我的桌前，  \n它给的感觉很轻快，仿佛在拖着我无拘无束，  \n它就这样的一阵阵来，一阵阵去，  \n直到那个夏天过去了，  \n我以为他还会回来，我也以为那个夏天会再来。  \n可是夏天总是，但是那股风再也没回来过。\n\n2025/03/30  \n如果严肃的文学作品消失那将是整个时代的悲剧，  \n在当下我们可以看到，文娱作品越来越轻量化，娱乐化，  \n表达内容浮于表面，过去的严肃叙事仿佛消失了，  \n那些曾经激烈探讨的问题不再成为作品创作的素材了，  \n可是那些问题就真的消失了吗？  \n尤其是在去政治化特别严重的某些国家，   \n甚至是谈之色变，政治和每个人的生活、权力、义务相关，  \n放弃严肃叙事，放弃政治讨论，等同于放弃思考，放弃社会权益。  \n我觉得这是可悲的、可怕的。\n\n2025/3/30  \n省流，匹配成功。\n不过不用想这么多，玩游戏的时候感觉到开心就好了。  \n游戏作为文娱产品的目的就是取悦用户的。  \n有反思有向往是好事，但是个人的努力无法和时代的洪流抗争，  \n所以，去享受人生吧，在生活的痛苦中，给自己找一颗糖吧。\n\n2025/05/11  \n追寻梦想总是痛苦的，尤其是在这片土地上，现实太过沉重，把我们每个人拖向地狱，  \n为生活妥协无可指责，但是在回首过去时，总会心有不甘，人生就是抱着遗憾漫无目的踱步的过程。\n\n2025/05/21  \n仇恨就像螺旋一开始还有迹可循，可世事不能离散只有连续。\n\n>- Agent Ross, Pinkerton Detective Agency.\n>- Enjoy your fishing kid, while you still can.\n>\n>- Excuse me! You Edgar Ross?\n>- Do I know you?\n>- Forgive me for startling you, sir. I have a message for you.\n>  My name is Jack Marston. You know my father.\n>- I see... I remember your father.\n>- I've come for you, Ross.\n>- And you, boy, have sure as shit found me.\n>- You killed my father. You shot him like a dog.\n>- Your father killed himself with the life he lived.\n>- You killed him! I saw you!\n>- You keep saying that.\n>- You sent him to do your dirty work, then you shot him like a dog!\n>- And I'll shoot you like one too, you little piece of trash!\n>  Now get out of here before I kill you as well!\n>- I ain't going nowhere, old man!\n>\n>RED DEAD REDEMPTION \n\n> - You can't erase the past, John. Killin' me, it won't make it go away.\n> ...\n> - Hello again, John.\n> - Hello, Dutch.\n> - We gotta stop meeting like this!\n> - Sure.\n> - I've got a plan, John.\n> - You've always got a plan, Dutch.\n> - This is a good one.\n> - I don't doubt it.\n> - We can't always fight nature, John. We can't fight change.\n>   We can't fight gravirty. We can't fight nothing. My whole life, all I ever did was fight.\n> - Then give up, Dutch.\n> - But I can't give up, neither. I can't fight my own nature.\n>   That's the paradox, John. You see?\n> - Then I have to shoot you.\n> - When I'm gone, they'll just find another monster.\n>   They have to, because they have to justify their wages.\n> - That's their business.\n> - Out time is passed, John.\n\n2025/06/07  \n繁重的工作压得人喘不过气，\n连打游戏作为消遣的动力都没有，\n在夜深人静放松思绪能够思考什么的时候，\n往日观看的asoul视频又浮现在眼前，已经很遥远了，但是有希望能够近一些。\n无论接受与否那都成了过去，必须学着接受，\n这就是生活残酷的地方，\n我们漫无目的来到这个世界，遵从生存的本能，\n短短数十年在史书中不过寥寥几笔，\n整个人类历史于宇宙而言不过尘烟，\n这一切真的有意义吗？宇宙存在所谓意义吗？\n我怀疑，但悲哀的是我只能相信，无所谓与否。\n\n清风乱弄两三页，提笔一拨百十年。\n长叹飘渺江中月，落花点水了人间。\n\n2025/06/15  \n从《巴黎的忧郁》到《凉宫秋日的忧郁》他们的悲伤不及我的万分之一，  \n早在落笔之前忧郁已悄然而至，媒体所载至少有人同悲，而我的忧郁只属于我自己。\n\n摘抄自《知乎》，中华人民共和国的一款人民分享见闻观点，芝士的平台。\n\n2025/07/04  \n在21世纪还能看到联合小团体迫害一个人在网上发表言论的自由，这种情景也是少见了。\n当你在为同胞争取权益时，还要被倒打一耙，要怪罪你破坏了他们安定祥和的生活，  \n与之前其痛恨其作为资本家走狗的同事时的面孔截然相反，换了副面孔便高高在上，圣洁无暇了。  \n若是真的有罪便也受的没什么怨言，狺狺野狗也学起秦桧的手段了，真不得令人发笑。\n\n2025/07/08  \n树死叶落黄，飞沙填泥漳，  \n猢狲不可言秋凉，唯恐泣涕泪叶扬。\n\n2025/07/25  \n在某国你上班得忍受被压干最后一滴血的觉悟，  \n没有基本的人权保障，没有合理的假期安排，没有休息时间，  \n还要被当权者拿走产出，还得看着他们用你的辛勤劳动去花天酒地肆意挥霍。\n\n2025/07/25  \n回万古长夜月明，多少英雄不在，  \n哀一生前途晦暗，几许气概无存。  \n多少千百事，都做尘与土。\n","source":"_posts/每日Emo小短句.md","raw":"---\ntitle: 每日Emo小短句\ndate: 2020-4-10 00:04:13\nmath: true\ntags:\n---\n你能翻到这整明你很有耐心啊，说明你对我的Blog还是有一定兴趣的，或者是我直接发的链接。  \n这里记录一下自己在群里的每日Emo小短句，\"每日一句emo小短句，我们明日再见。\"  \n<!--more-->  \n温情提示偶尔伤痛文学一下舒缓压力可以理解，但是不能实际地跟本地解决问题，美好的生活需要自己创造。  \n还有如果你时常心情低落，难受，要注意心理健康，必要的时候要去看医生哦~  \n那么废话结束，我们开始Emo吧。  \n$$\n我从未看透，我只想感受慷慨赴死的颤抖。\n$$\n\n这里只有低级的思考和最卑劣的情绪宣泄， 除此之外没有任何文学意义，我所述之一切，不过尘烟。\n\n# 独油群每日Emo小短句\n\n2023/04/09  \n“我好想问一问进入游戏行业打工的愿望就这么奢侈吗？”\n\n2023/04/10  \n虚拟的数据能分析出我真实的病情，为什么真实的世界却不能带给我一丝虚假的温暖呢？\n\n2023/04/11  \n人生最大的悲哀也许就是平庸的自己配不上远大的理想吧，纵有孟德之志，却无丞相之才啊。可是即便意识到也在名为平凡的泥潭中越陷越深……  \n这场名为人生的冒险好艰难啊。\n\n2023/04/12  \n今人又见古时月，古月不救今时人。  \n这里用救字，是我自己对外的求救，是一种直白的表述方法，我希望给读者更强烈的情感冲击，如果追求诗歌的美可以用别的字，比如照、抚、望。  \n**今人又见古时月，古月已忘今时人。**  \n这里又想到一句更好的，不知道好不好。\n\n2023/04/13  \n无能是灼烧我的业火，他人的光辉刺痛我阴暗的鼠目，宏大的理想也变作狂妄。  \n每日一句emo小短句，我们明天日永别。\n\n2023/04/14  \n浑浑噩噩成了日常，萎靡颓废成了习惯。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/15  \n骑马跨栏的判定太阴间了，cnmd。  \n每日一句emo小短句，今天开始摆烂，我们明天再见。 \n\n2023/04/16  \n小时候父母告诉我要有一颗，像铁一样坚强的心，但是他们没告诉我的是，这世界上磁铁太多了。  \n每日一句emo小短句，今天的emo比以往来的更早一些，我们明天再见。\n\n2023/04/17  \n好想回到过去，好想变成芝士面包。  \n每日一句emo小短句，我们明天再见。  \n是因为我早就死在了过去，所以灵魂索求着还阳吗？\n2023/04/18  \n我是一个怀旧的人，因为我的未来没什么希望，我在过往的欢乐中，种下了一棵在未来通向衰败的枯树，  \n当我茫然地走上自己铺就的幽暗小道时，我总是回头望去，我怀念那些欢乐的日子，我悔恨那些蹉跎的日子，  \n我在枯树旁的荆棘丛中哭泣，我在梦境的虚幻里沉沦，以忘却这痛苦的生活，在美丽的梦里，我是一个怀旧的人，因为我的未来充满希望。  \n每日一句emo小短句，我们明天再见。\n2023/04/19  \n于我而言，生活的琐碎就是一个不断发现自己失败的过程，  \n我时常懊悔无助，但我想，发现自己的失败不应像我一样悲伤、自怨自艾，理当奋起直追、弥补不足，   \n可惜我是做不到的，因为我总是在发现新失败的伟大征程上，义无反顾地航行，  \n我是绘制不出五彩蓝图的幽灵，我已经同海底的死寂共赴沉默。  \n岸上的人不要上我这条残破不堪的船，去在广阔的大海上勇敢地航行吧，去开辟你的新航路吧，  \n鼓足你的风帆去禁受狂风的肆虐，不论前方是文兰或是礁石。  \n“面朝大海，春暖花开。”  \n每日一句emo小短句，我们明天再见。\n\n2023/04/20同理心是种可贵的品质，我好希望每个人都能有这种品质，这样大家就都会关心我了，可惜我只想着别人来关心我，这样看也许这种可贵的品质我自己是没有的，不知不觉又犯了宽于待己，严于律人的错误，我想我是不配这样的奢望的，渐渐地我便不再去幻想了。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/21  \n看到你们美好的生活我真的很羡慕，我也好想和你们一样，虽然理想的工作和实际存在差距，但是能进入自己热爱的行业对目前的我来说就是最大的愿望了，但这愿望终究是小女孩划燃的火柴，在这寒冬中燃不久，便消失了。我蜷缩着身体彷佛看见自己坐在一家游戏公司里，同事都温柔可近，工作生活都很愉快，这样的梦好虚假啊，连我也意识到这是弥留的回光，人们渐渐围在了我的身边，对我指指点点，我依稀听到他们说“活该啊，冻死了吧”，随后我也指着自己说道“活该啊，冻死了吧”。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/22  \n躺在床上怅然若失的望着天空，青春的活力和萎靡的精神在我体内冲突，我同旧厂街过去的哪些青年一样，眼中充满对未来的迷茫，从梦幻中惊醒，面对的是生活残忍的另一面。  \n哪些在镜头前迷茫的青年曾经是一定存在过的，昏暗的室内和朦胧的镜头记录下他们短暂的一瞬，我希望未来别再有他们了，想到这，我再看向窗户映出的模糊倒影，越发清晰却渐渐的陌生了。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/23  \n我想，把自己的痛苦与挣扎用矫情的文字表示出来，是不值得夸耀的、甚至是应当感到耻辱的；用人们共同的痛楚去博取同情未免有些太卑鄙了，但我一直都是这么做的。所以我常对自己感到厌恶、对他人感到羞愧；一个真正有爱的、坚强的人，我想应当是在痛苦之中感受、反思；在有所顿悟后，用爱和希望去鼓舞他人，带给他人力量！人们因生活的痛苦而困顿，却也因困顿而坚强，我在生活的沉沦中越陷越深，唯一能带给别人的就是一首赞歌，一首歌唱反抗平庸、超脱自我的赞歌。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/24  \n小短句总是越写越长，可能是因为压抑不住的表达欲和内心深处对于他人认同的渴望吧，写得越多自己向外暴露出的也就越多。向外表达的行为也是祈求认同的过程，是想被他人了解、关心的强烈渴望。  \n所以我决定继续写小作文。  \n我在行动的过程中内心总是充满怯懦，对于自己的目标总是处在一种迷茫的状态，找不到前进的方向，在光怪陆离的森林中不断地徘徊、观望他人的世界，美好的青春和时光就在自己的惘然中眼睁睁的溜走了，直到今日也未能触及心中的理想。如果说理想是名为文兰的陆地，抵达它的过程，就是一场被称为人生的伟大航行，我们时常同海上的漩涡斡旋，和水下的礁石战斗，而脆弱的风帆和桅杆已经在终日地雨打风吹中受伤磨损，但依旧看不见陆地，却常常听闻别人登陆文兰的讯息。有时我会想投入这广袤的海洋中结束我悲哀的航行，或是祈祷一场巨浪掀翻我的扁舟让我拥有退出的理由，但是在朝露打湿我干瘪的嘴唇，在凄冷的素晖映得海面粼光闪闪时，我又在幻想中看见了文兰的影子。  \n每日一句emo小短句，我们明天再见。\n2023/04/25  \n孤独是上天赐予我的礼物，死亡是世界给我的解脱。  \n我是有意识的玩偶，在戏谑的闹剧中进行着荒诞的演出，宇宙和眼白是我变态的观众，平庸和愚蠢是他们最爱的戏码。广阔的舞台扭曲我的身体，我的精神不甘地嘶吼，软弱的躯体和颓唐的精神揉搓成一团混沌的烂泥，而这丑陋的模样就是他们解闷的笑料。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/26  \n今天一如既往的浑浑噩噩度过一天可是并没有感到快乐，没有休息也没有玩乐，也没有工作，但是一晃就到了晚上，心中更烦闷了，很疲惫。罗素曾说悲伤让人疲惫，我本不知如今倒是感同身受了，也许我应当痛下决断，去正常的生活。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/27  \n我靠着虚假的希望和混沌的疯狂来麻痹自己，这膨胀的幻想被他人用现实刺破，我沉浸在真实的伤痛里，我的诉说和抱怨都是无用的呻吟，在锋利的剃刀前迎接我的是毁灭的命运，在这口疯狂旋转的大染缸里我只是时代光鲜背后被丢弃的渣滓。我是一个失败者，我决定从这场残酷的战争中逃走，做一个懦弱的逃兵，于是在一个最美丽的清晨，我坐在冲入云霄的花托上，对着太阳说我的故事，和月亮谈我的理想，最后我和风自言自语道“我将走向死亡”。  \n每日一句emo小短句，我们明天再见。\n\n2023/4/28  \n钟鼓磨灭了意志，平常让人麻木，在平静中一步步走向海的深处，意识到这毁灭的到来，却没有做出反抗，只是左顾右盼地张望，虽然激起朵朵的浪花可脚下的步伐并未停止，沙滩上的足迹被一袭又一袭的波涛卷走，海里的鱼对着断翅的海鸥说，别害怕，海啸会带走一切的。  \n每日一句emo小短句，我们明天再见。  \n生活是一场无法规避的战斗，  \n有的人轻松写意，有的人举步维艰，  \n无论是胜利还是溃败，世界并不在乎，  \n受伤的只有向着红色风车冲锋的傻鸟。  \n每日一句emo小短句被对线爆出金币了。(\n\n2023/04/29  \n有一条鱼拼命地往渔夫的网口里钻，渔夫把他拎起来看了看，肉少的可怜、长得又颇为难看，“浑身的腌臜味，一看就不好吃”，然后把他扔回了浑浊的泥潭，鱼想着要是自己是一只锦鲤就好了，这样渔夫们都会挣着捕获、是什么“濒危物种”也好啊，可笑的是这年头“濒危”也是要持证上岗的，像他这条只是快死了的鱼，是远远碰不上“濒危”的边的；他望着泥潭外的世界，万类霜天竞自由，飞禽走兽、奇珍异兽，可谓是无奇不有，从蒲公英的耳语中他也曾听闻隔壁池塘和远处大海的景象，那里的水更清澈、那里的水草更细腻，远是比这片小小的泥潭好得多的。他又沉下泥潭里，在他翻身休憩的过程中，他督见一条鱼摆在盘子里，浇上了些许酱汁，被筷子们分食着，“呸，这条鱼刺又多肉又少，还这么腥，真他妈难吃。”，少顷后，盘子里只有被开膛破肚的残羹，一片狼藉。  \n每日一句emo小短句，我们明天再见。\n\n2023/04/30  \n现在这个世界真有趣，虚拟的东西越来越活灵活现，这块荧光屏幕里的小东西们总是那么动人，比外面的世界有趣多了，盯着这绚丽的光彩久了，现实的色彩便显得灰暗下来了，目之所及便没什么趣味，甚至感觉到些许的烦躁，也有投机倒把的人抓住这追求七彩祥云的心理，造出炫丽门面的假象吸引猎物上钩；也许离现实太久了，生命和精力融进了这块小小的屏幕中，等发觉才意识到，这发光的不是太阳，过于沉迷是会食人心血的。  \n是时候做出些改变了，因为该给手机充电了。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/01  \n心中很烦很急，每次总是拖延，最后又是悔过，但是终究不改，为什么我的性格如此低劣。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/02  \n我常用宏伟的目标和理想主义者的虚伪躯壳来遮蔽我丑陋的容貌，然而在这重重伪装之下真实的内心中，是一个彻头彻尾的幻想主义者，我用这些东西来麻痹自我、达到精神世界的超脱，只是假借幻想来满足自我的私欲，就如刘森所言**“你从未看透 你只想感受 慷慨赴死的 颤抖”**，犹如一片落叶追寻着秋日的肃杀和远方坠落的夕阳，希望毁灭和宏伟能装饰自己蹉跎的一生。  \n面对这样的踌躇，我要抽出宝剑斩断这懒惰的羁绊，随着盖格计数的哒哒声，我要义无反顾地冲向那片红色的海阳。我想在每个人的生命旅程当中难免会有失败、会被路边美丽的风光所吸引，但是每个人都应该拥有鼓起勇气、提起胸膛去修正错误的机会，和对自己人生负责的义务，从今天十点钟开始我就要发奋图强，追回失去的光阴！  \n但是十点钟已经过了，那没关系……我不是今天的十点钟开始，我不定哪天的十点钟开始！  \n每日一句emo小短句，我们明天再见。\n\n2023/05/03  \n我看着他踉跄地走在铁道旁散乱着灰黄石头的小路上，他的步伐太慢，已经追不上这趟向前飞奔的火车了；他总是提着一瓶酒，那并非笑看生活洒脱自我的、潇洒的酒，而是为了麻痹自我逃避现实所依赖的毒药，最后一次我看见他走在秧歌队里，脸上带着些许的红晕，和花扇一起舞动，他的舞姿无法称为曼妙，只能说是灾难，这最后的放荡自我和追寻解脱的舞让我感到了毁灭和死亡的味道。后来直到今天，我再也没见他了，听说他害了病，也许他死了，不过我想虽然他迈上了死亡，但是终是没死绝的，我看了看镜子，再望了望太阳，我想大抵是如此的。  \n每日一句emo小短句，我们明天再见。\n\n2023/5/4  \n好怀念小时候，稚嫩的画笔虽然绘制不出写实的画风，却充满着童趣，那是一幅粗糙的蜡笔画，阳光明媚、绿树成荫，背景里奏起的是悠扬的音乐，那时候不知道什么是烦恼，我只负责快乐就好，那个夏日的下午骄阳暖的正好，身上挎着清凉的背心，在可爱明艳的画面中我为了快乐而努力，我似乎还朦胧的记着那些我可爱的伙伴们，我还记得那个美丽奇幻的世界，我的脸上露出了开心的笑容。  \n那时候一切是那么的简单、一切是那么的美好，彷佛一切都是有希望的、一切都是光明的，我怀念那个时候。  \n快乐是怎么样消失的呢？那个无忧无虑的孩子到底去哪里了？我想不通，我不明白，我只觉得指尖有些疼痛，现在才知道快乐原来也是会伤人的，这天真的童趣在我这破败的一生中显得少见而珍贵，我想是不会再有了。  \n每日一句emo小短句，我们明天再见。\n2023/05/05  \n自嘲也许也是自卑的一种吧，在别人指出自己的弱点之前先把自我贬低一番，这样他人的批评也就是“自我反思”的一剂辅药罢了，以此来宣誓自我的主导权，也免得自己不那么尴尬。这种自嘲就和舔舐伤口一样，实际上无用，但是甜蜜的鲜血流进唇齿之间时能品到一种满足的滋味，作为痛苦的调剂。自己虽然也知道有缺点、有问题，但是是难以去纠正的，便摆出一副“啊对对对”这般的态度，不过也是应该比被人指出便暴跳如雷要好得多的。极强的自尊也许会使自己很愤怒别人指出自身短板，在时间久了之后，发现自己终不能改正，这种自尊便化作一种自卑了吧，锋利的尖刺就在世故的雨水中慢慢的侵蚀掉了。  \n今天感觉没有那么emo，也许是回光返照吧，也可能是用一天虚假的努力欺骗了懒惰的自己，得到了一丝宽慰吧，所以也就随便写写，我想这事是不能放弃的，因为我已经蹉跎了太多，这小小的玩乐也许能作为我极少的坚持吧。  \n每日一句emo小短句，我们明天再见。\n2023/05/06  \n如果我能开花，  \n我会在清晨和太阳耳语，  \n我会在夜晚和婵娟摇曳；\n\n如果我能开花，  \n我会把思念揉碎在风中，让他携着我的愿望，飘向远方；  \n我会把诗意溶化在雨中，让她裹着我的烂漫，浸入大地；\n\n如果我能开花，  \n我会把花瓣葬在泥土中，回馈他的恩德；  \n我会把芳香散在世界中，歌颂她的美丽；\n\n如果我能开花，我将带着马头骨一起葬在海中央；  \n如果我能开花，我将偕同蒲公英一起散在风中央；  \n如果我能开花，我将绽放一朵血色的玉英。\n\n每日一句emo小短句，我们明天再见。\n\n2023/05/07  \n人类的SNP排除体外后通过马桶可以全部链接在一起，为什么人类内心的想法不能通过马桶连在一起呢？是因为其实人类只痴迷于肉体的链接，而不在乎心境的联通吗？  \n如果可以的话，我要造一个大大的马桶把所有的心理SNP收集起来，把大家全部连接到一起，就用这条链接彼此的管道，贯穿你我之间的壁垒吧。就算是为了我，对全人类的内心使用发光马桶吧。  \n补充：snp可能是最接近人内在的东西了，想要理解人的内心就去理解snp吧，比良坂曾云“你连心爱的女人的大便都不敢吃，还敢说爱她”，相必背后也是有着这样的哲思吧。(  \n每日一句emo小短句，我们明天再见。\n\n2023/05/08  \n生活大多都是苦闷，羊只顾着食草，至于草是经过怎样的艰难他是不顾的，在人生的创作中你我虽然是作者，但是很多时候剧情没办法自己做主，名叫老天的混蛋编辑总是喜欢安排一些稀奇古怪的操蛋情节，嘛，迫于种种的无奈，我们也许只能在这苦闷中自己去创造快乐了。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/09  \n人生最大的痛苦不是整日都只能陷在悲伤之中不能自已，而是无悲无喜，面对残酷的现实精神和肉体都被摧残的麻木，一切的动荡都激不起涟漪，无论是福是祸都无动于衷。  \n在这样悲喜不加的琐碎平常中我已经渐渐看不清曾经的影像，他慢慢的从我枯燥的生活中消失，没和我道别。他也许就和我一样自私吧，自顾自地离开，而我自顾自地放他走了。我们在这无法言说的默契中被分离了，自他走后我常常忘记了这梦幻的过往，但我有时又会猛地记起，这段记忆就像夏日傍晚时映过窗户的那束橙黄的光——我是记住了的，但却真真地忘记了。  \n“1997年过去了，我很怀念他。”  \n每日一句emo小短句，我们明天再见。\n2023/05/10  \n上天曾赋予我天真的秉性让我能发现生活中的快乐，但是现在他想收回这份馈赠，于是便用残酷的现实一点一点磨灭我的心智，但是我不想放手，因为我会再也找不到快乐。  \n可无论我放不放手，都已经不再快乐了，这个世界有太多的难题我解不开了，有太多的问题我不会了。也许我真的不行，但是我不想承认，我知道认输很轻松，但是一旦低了头就再也抬不起来了，我的自信就像在一把锉刀下一点点的磨碎了。不能再像曾经的那个中二的少年一样冲着一无所有的广袤世界大喊了，那样豪言壮志的盛情已经不再了，如今只有被现实打败的萎靡和颓废了。  \n他朝着被夕阳映红的世界大喊，回应他的只有随风起伏的草场和远处寂静的校舍，但是其实他并不在乎有无回应，他只是想宣战罢了。  \n每日一句emo小短句，我们明天再见。\n2023/05/11  \n我想喝可乐，碳酸充斥口腔很奇妙，因为很好喝所以很想喝，但是妈妈说不健康呢，而且已经很晚了，所以不能喝呢。如果我有钱的话我会买一瓶可乐，最好是冰的，但是我没有，所以我很想喝可乐。  \n我想如果我长大了就可以喝可乐了吧，但是浑身脏兮兮的大哥哥却说不要长大会很痛苦呢，大哥哥说话很有趣人也很好玩。有时大哥哥会拿一个红色的大罐子和我炫耀说多么好喝，但其实是我知道的，那是他在绿色箱子里找到的，因为我看见过别人偷偷把罐子塞进去，也许大家和大哥哥早就商量好了，在玩找宝藏游戏吧，但是大哥哥每次都不让我找，他总是一个人找，好贪心啊。大哥哥每次都会和我说可乐有多么好喝，但是我一次也没看过他喝过，大哥哥到底有没有喝过可乐呢？  \n大哥哥常常躺在广场上的长椅上，他总是给我看到他在绿色宝箱里发现的宝藏，有园的有方的，又蓝色的有白色的。他总能掏出我没见过的东西，我想他应该是个探险家吧，但是他很多时候总是阴沉沉的而且不准我叫他大叔；他有长长的头发却是大哥哥呢，好奇怪啊，但是却很有趣，可能长大的世界就是这么好玩吧，也许大哥哥是怕我和他抢可乐喝，才害怕我会长大吧，大哥哥好小气啊，我会分给他喝的，因为可乐很好喝所以没问题的。  \n不过妈妈不让我和大哥哥玩，说什么他很脏，可是他的眼睛明明很干净很漂亮啊，为什么妈妈会说很脏呢？妈妈说我长大就明白了，看来还是要长大的，但是大哥哥不想让我长大，为什么呢？这也要我长大之后才明白吗？那我还是快点长大吧，因为我想喝好喝的冰可乐啊。  \n我到底喝没喝过可乐呢……\n\n其实我就是大哥哥，而写下这些文字的也是我，充满童趣的我和沧桑的我是我的两面，最后一句是我和大哥哥一起的感叹。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/12  \n今天大哥哥没有来，我也没有喝可乐，大哥哥去哪了呢？大哥哥说过他曾经也是有梦想的，但是不知怎么的就变成浑身破破烂烂的样子了，然后梦想也走丢了，梦想是什么啊？我不太清楚，大哥哥是因为有梦想才会破破烂烂的吗？我也经常做梦，我也会变得破破烂烂吗？变得破破烂烂是不是可以变得和大哥哥一样去冒险了呢？  \n今天没见到大哥哥，心中有什么奇怪的感觉涌上来了，大哥哥今天应该是到新的地方去冒险了吧，不知道他明天会不会回来。  \n大哥哥今天还是没有来，是迷路了吗？还是被新的冒险吸引了？不会是一个人偷偷去喝可乐了吧？  \n……  \n大哥哥已经一周都没来了，也许他不会回来了。我想他可能是去找那个走丢了的梦想了，如果是这样那大哥哥就是我的梦想，因为他和梦想一样都走丢了，等有一天，我也去找大哥哥吧。  \n大哥哥究竟喝没喝过可乐呢？  \n每日一句emo小短句，我们明天再见。\n2023/05/13  \n大哥哥回来了，但是我没有问他前几天去了哪里，就像我没有问他从哪里来，他也没有说去了哪里。他没什么变化只是身上的衣服换的更轻便了，白色的短袖已经变得灰黄了，他好像很没有精神，我和他打招呼他也只是木讷的回应，他是怎么了呢？大哥哥变得和其他大人一样了，总是面无表情、无精打采的样子，可能只有拿红色的可乐罐才能把他明亮的眼睛变回来了。也许大哥哥只想快乐，但是繁重的现实令他无法超脱，难道源自内心的欢愉只能依借外物来所求吗，难道精神的享受只能由物质带来吗……我想不是的，但是精神的交流和思想的碰撞是难得的追求，所以我只能用物质的华丽和感官的疯狂哺乳我混沌的精神。  \n所以，我想喝可乐。  \n大哥哥究竟喝没喝过可乐呢？  \n每日一句emo小短句，我们明天再见。\n2023/05/14  \n今天是阴天，我一如既往的去广场找大哥哥，大哥哥一如既往的瘫坐在长椅上，他灰暗的眼睛里映着被天空压得蒙蒙的广场，蓝色的建材旁没有曾经嬉戏的孩子们，只有略带潮湿的风抚摸着我的脸。大哥哥没有理我，自顾自的唱起了歌，但我听不太清，不知道唱的什么，他萎靡地神往、我无措的徘徊，很快淅淅沥沥的雨散在我的肩头，我转头逃走了，我可耻的遁走，我又羞愧地回头望去，大哥哥已经不见了，我有些怅然地走在雨中，唱起了歌。  \n“没有花香，没有树高，我是一棵无人知道的小草……”  \n下雨天很凉，所以我自是又一天没有喝到可乐的。  \n大哥哥究竟喝没喝过可乐呢？  \n每日一句emo小短句，我们明天再见。\n2023/05/15  \n我是新时代出土的崭新古老废柴，在泥土捏住的废墟中起身后，在绚丽的装饰中不知所向。一面是小县城日趋衰败的丧钟，一面是城市钢筋的逼近和霓虹的威慑；一面是无所适从的现实破烂，一面是歌舞升平的虚拟狂欢；一面是家庭崩塌的通牒，一面是生存无计的惘然；我和马大帅一样在这个崭新的世界无处藏身，生活的琐碎片片地压在头上，无处藏身、无地自容；被迫在这个混沌的垃圾堆里左支右绌，希望能找到点活下去的办法，可迎来的只有广厦高楼里传出的欢乐，连一生讥笑都没有、没有回应就是世界给我最后的回应。我面对宏大时代产生的困窘太大了，大到我不知道怎么形容、我不知道怎么表述内心的感受，但是这种困窘又太小了，小到别人看不见他。  \n”而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。“  \n也许唯一幸运的是，迫于我的精神状态和身体原因，至少还有人能对我展露出一丝理解的姿态，不知是自愿还是出于道德的被迫，想到这里我更加悲伤了。如你所见，宽容和理解也可以作为伤心的利器，温柔和体贴也会带来痛苦，而咒骂和拳脚更不必言说。我想我病了，我在最嘈杂的时代失声，我在最杂乱的树丛迷路，我，一个崭新出土的时代废柴。  \n“那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。我来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。”  \n这一天，我23岁，在我一生的黄金时代，我有好多奢望——**我渴望死亡**。  \n每日一句emo小短句，我们明天再见。\n2023/05/16  \n在无数次的失败中我知道的，其实是我自己的问题，怨不了天也怨不了地，“废话，你不过不是你的问题，还是我的问题吗”，也曾无数次的被讥笑过。人生也许就是这样吧，在浑浑噩噩中就突然直接没有了能前进的路，我的生活就像窗外黑沉沉的天气一样，已经走向了全部哒咩的end了。在这场没有鲜血的残酷竞技中，输家是没有发言的权利和表演的镜头的，我走在自我否定的螺旋中，在如海般的寂寥中下沉。我不害怕挑战，我畏惧失败；我不会失败，因为我总有借口。借口是一把刀，用它来逃避，用它割碎我的梦。我是人生的懦夫，我是战场的逃兵，我是竞技的输家，我是新时代鼓钟旁最丑陋的尸体。  \n我已经死亡。  \n每日一句emo小短句，我们明天再见。\n2023/05/17  \n我好像做了一场梦，  \n在混沌的梦中我看见有人刨开垃圾堆寻找着残羹冷炙以求果腹，有人倒在街头红色点缀天空，  \n在糜乱的梦中我看见贵族门阀极尽奢华，  \n在无助的梦中我看见一个人茫然的站在风中眼神中无悲无喜，  \n在无尽的梦中我看见一个个荒诞的轮回，一股股鲜血浇筑这片大地，可是没有什么神迹，这炽热的血很快就被衣冠禽兽的虫豸吸食干净了，  \n在衰败的梦中我看见一个个消瘦的皮囊，  \n在梦中我看见了一场梦，在朦胧中我依稀听见不能言说的蛊惑。  \n在这荒诞的梦中我醒了过来，看见了一场真实的梦。  \n每日一句emo小短句，我们明天再见。\n2023/05/18  \n梦幻的灯光在淅沥的雨水映衬下更外动人，  \n今夜天空没有月亮也没有星辰，面对这美丽的人类荣光，他们自然是羞愧的躲起来了，  \n水浸的马路映出如幻般的城市炫丽，耸入云宵的是无法逾越的高塔，  \n现代的奇迹循着古时的悲哀螺旋上前，  \n但这一切的磅礴都是他的背景，他从那灰暗的角落露出身来说  \n“城市的绚烂霓虹照不到我们的黑暗生活”  \n是的，无论远处的光多么妖艳，无论多少个日夜在天空上接力，这残破的窟洞也未曾见过一丝光明。  \n上个世纪一个孩子对父亲说想成为艺术家被暴打了一顿，这个世纪一个孩子想成为艺术家却没有道出，时间的分界就如同一面镜子照出相似的彼此，我们怀着同样对理想的执着，然后被生活打击到失去对一切的热爱，在无数的悲天悯人后激发出愤恨与悔过，昨日的夕阳是今朝的晨光，今日的余晖是明早的梦想。  \n每日一句emo小短句，我们明天再见。\n2023/05/19  \n世界总是充满着变化，把自信好强变为偏执自卑，生活的作弊就在于把困苦转嫁旁人，在从襁褓中慢慢褪去外壳面对这疯狂的一切时，正常的精神认知早就沦为玩物，巨大的手抽离矫造着癫狂的心智，若如是亦无需置论，却有得意者假借他人的痛楚予以调味，痛苦后深层的哀伤他自然是不懂的，只觉得好玩消遣罢了，我的肉体、我的精神、我的心智都被这疯狂的世界夺走，而这躯空旷的泥瓦罐也只能装满癫狂的海水。  \n把我的一切还给我，还给我吧，那年轻的亲人，那些离去的人，那无忧无虑，那个没有丑陋伤痕的我，我会在那最美的瞬间按下暂停，哪怕这是永恒的死寂，也比这无尽的疯狂来的更有意义。  \n“因为再往后就是只有失去的现实”  \n每日一句emo小短句，我们明天再见。\n\n2023/05/20  \n坏了，把每日一句给忘了……就连这么重视的事情都在昏昏度日中忘却了，我想我没什么可以辩解的了，之前那么忙都想的起来，现在休息了一天反倒忘记了。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/21  \n我不知道是我萎靡的精神导致我诸多的失败还是我那不顺的过往导致我失去活力，我唯一能确信的就是在这个疯狂而糟糕的社会中，我的失败和顿挫不会就此止步，目光所及的未来是一片狼藉，在他人蓬勃一生开始的年龄，我的生命已经所剩无多，迎来的并非接近疯狂的不甘，反倒有种解脱的释然——终于能从这混沌中离开了。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/22  \n我的人生就和我破烂的电脑一样，也许在某一天，就突然开不了机了，光怪的屏幕里堆满着无用的别人毫不在意的垃圾，这狭小的窗口成了井底的死尸观望广阔天空的井口，可笑的是我的电脑可以因为莫名其妙的原因黑屏宕机，我却卑微地不敢指责他；而我荒诞的生活已经不能继续却仍要强撑，我却严格的咒骂着自己。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/22  \n我是如何的失败我自是清楚不过的了，我是如何的无能导致我这般的颓丧，在这场只有lost的游戏当中，会有人乐在其中吗？我只是找不到完美的退出方式，却又没有直接关闭电源的勇气罢了。  \n我当然知道自己多么可笑，我当然知道自己是如何的软弱，用结束去要挟一切就是我最大的勇气，我不过是一个疯狂的病人，在试验田的舞台上做最癫狂的表演，我不配在这个陆离的世界中拥有聚光灯，我只能在底层的泥泞中失去我曾假借的一切。  \n如果我这极致的失败、这几乎疯狂的精神是独一无二的，是否我也能说自己拥有过人之处，而显得不那么狼狈？如果曾有人和我一样，是否说明我不过如此，而我所相似的那个他是否比我更加悲哀，毕竟我只配做别人的影子，从来都是我像别人，我只不过是后来的低劣、无能地模仿着。我面对这一切真的累了，我想我的Quit就是电源键了。  \n每日一句emo小短句，我们明天再见。\n2023/05/23  \n电脑因为C盘的爆满而黑屏宕机了，不过经过他自我的紧急修复又腾出几个G的空间，彷佛一切都可以继续，只是我不知道黑屏的时间里电脑失去了什么。  \n如果世界黑屏宕机了是不是第一个删除的就是我呢？之后的一切都会照常进行但是不会有我了，而世界应该也不会在乎。  \n电脑比我更会内存释放，也许他比我更配用电脑？那为什么是我在用电脑？还是我在被电脑使用着用电脑。我不知道，我只能借着胡乱的思考来假装对生活的深思，用故作高深来麻痹自己的浅薄。  \n电脑黑屏宕机能修好继续，我的生活可以吗？我能修好他吗？或许根本就没有修好只是出卖了什么东西而我并不自知罢了。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/24  \n人生的一切可能都会在平常和迷茫中渐渐磨灭，在物理角度看熵增的世界以混沌为食，所以一切的荒诞和疯狂似乎都理所当然，而在这如黑暗般的一切中是曾有过耀眼的光辉的，宛若一颗流行划破漆黑的夜幕，似乎是黎明的到来，而那光亮往往被周围的雾霭所吞噬，“面对我们的骨灰高尚的人挥洒下热泪”，我并不高尚，我的泪是因为惋惜和痛恨。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/25  \n浸润着都市淅淅沥沥的夏雨，朦胧的雾气蒙上了我失明的双眼，  \n肉体和灵魂在此刻分割，我昏昏的青春倒进这炫丽的城，  \n外边是奔波的迫切，里面是梦寐的挣扎，  \n我在月光铺就的路上疯狂的向前奔跑，  \n甩开身体、甩开安睡、甩开梦想、甩开月亮，  \n在这个千年之月和都市夜灯共同辉耀的雨夜，  \n我甩开自我，奔向月亮。  \n在月亮上，我抱着干瘪的红薯，离月亮越来越远。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/26  \n原来快乐也使人堕落，所谓生活就是在一团混乱不堪的琐事之中挣扎，最终结束的过程。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/27  \n生活的痛苦就在于，处在毫无新鲜的平静中疲于奔命。人们渴望改变却又不希望动荡，人们希望安慰却又不希望枯燥平常，每天的生活就像一条可以看见的、逐渐平缓的线，渐渐的没有波澜、没有改变的可能，一切都走向热寂。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/28  \n在不舍和茫然中踏上了旅途，途中我看见拉满羊的货车，货车上的羊在想什么呢？我和羊有什么区别呢？我们都在无形的压力下被迫登上这辆不知终点何方的列车。最终的结局都是被残酷的刀屠戮殆尽，我想我和羊是没有区别的，想到这我不仅的发出”咩“的一声。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/29  \n我悲哀的一生还未开始就已经结束，别人的起点是我一生都难以企及的高度，人生就在一个个不知不觉慢慢的错开了，等意识到时已经无可挽回，别人都在一步一步的积累着成功而我一步一步地迈向失败，面对我一团乱麻的生活我只觉得悲哀和无助。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/30  \n在旁人每日的伟大进度推进时，我无忧无虑的快乐时光就一天天消耗了。我曾经是开放世界里那个无忧无虑的孩子，每日在和煦的阳光下踏上去学校的乡间小路，但是残酷的勇者一天天坐着篝火，我不多的童年急速地消失了，我只能看着我变得不再快乐，烦恼和忧愁日益增多，但我什么都做不了，因为这个过程叫做长大，在长大的过程中我要独自面对一个藏在安全屋外数年的劲敌叫生活。  \n每日一句emo小短句，我们明天再见。\n\n2023/05/31  \n人与人之间的差距实在是太大了，这巨大的鸿沟令我难以逾越，他人数倍、百倍于我的智慧和实力地位，我所有的一切别人只不过弹指之间，而我唯一的成就只有拼命地活着。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/01  \n第一步:沉淀。  \n第二步:那场寒冬毁了我的游戏梦。  \n第三步:黑作坊也能做游戏。  \n第四步:两年换皮游，一生氪金情。  \n第五步:游手好闲也是游！  \n第六步:Steam我想你了。  \n第七步:独油炒粉。  \n第八步:城管太凶了，独油地摊。  \n第九步:经济不景气，独油代驾。  \n第十步:吊销驾驶证，碧桂园五星上将  \n第十一步：指点天天打游戏的业主，欺负骗氪的策划狗，遇到危险全身而退。  \n第十二步：若Jam召必回。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/02  \n我好像丢了什么东西，或者缺了什么东西，但是我不知道那是什么，我想我找到它一切都会好起来，但是我都不知道那是什么，我只是茫然。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/03  \n分别的日子日渐近了，我不想那一天到来，却无法阻止，这就是生活、这就是长大，不再无敌，事情不再和美好的想像一样。但我不会忘记，我是活在过去的人，所以我不会忘记。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/04  \n相聚的时间不多了，结束的那一天一步步到来，我不能阻止这别离，也看不到未来的希望，渴望着更好的明天会到来，但不论我的期望如何混沌的未来终将如期而至，“正义会在正义的终点等着所有人”。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/05  \n现实不能靠勤劳致富，所以我想在游戏里满足一下这个心愿。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/06  \n今天是个沉重的日子，不仅因为分别的日子更近了，还有一位同系的同学和这个残酷的世界做了最后的悲惨的告别，生命的沉重和死亡的压抑在这一刻涌上来心头，强权和威压摧残了一条鲜活的生命，我曾想人终是要积极的面对生活，迎难而上的，即便结果是惨败，这样的冲锋至少能让自己以英雄的身份离开；然而残酷的现实是脆弱的身心可能根本抵不住生活的压力和强权的逼迫，稚嫩的生命所留存最后的坚强只有纵身的勇气。  \n我不配去理解，我只感到悲伤，希望每个人都能拥有美好的生活，希望每个人都能有幸福的明天。  \n也许之后，他们会给你看论文、帮你改PPT、平台审核第一时间进行，但这都是因为有鲜血来过这里。正义会 找到的，一 直沿着海 滨找到他的终点。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/07  \n回到学校这几天总是打游戏，完全无心学习，明明自己的人生已经是一塌糊涂却还是一副等死的样子。我这样的人注定是一团垃圾。  \n每日一句emo小短句，我们明天再见。\n\n2023/06/08  \n我以前一直不懂克苏鲁，现在我明白了我的克苏鲁就是生活当我看见他是，那无法用语言描绘的疯狂就充斥在我的大脑中。我处处低人一等没有人认可我，我就是一条处在社会底层的虫子，面对这样的现实我陷入深深的自卑，我想过改变却没有成效。这混乱疯狂的一切，血淋淋的才是现实，幻想和谎言所修饰的只是最悲惨的故事。\n\n2023/06/09  \n一切都要结束了，我最美好的过去就要画上一个句号。  \n每日Emo小短句，我们明天再见。\n\n2023/06/10  \n离别总是匆匆，形形色色的人各自奔向自己的前程，回想我的当今犹如一团烂泥，我做什么事都是半成不就，烂透了的样子，这样满身疮痍的我将要迎接一段注定会满是烂泥的人生，我想不如轰轰烈烈地死去来的痛快一点，在我这样胡思乱想时，离别的匆匆又渐渐地近了。  \n每日Emo小短句，我们明天再见。\n\n2023/06/11  \n我只能说个人的职业选择和社会环境密不可分，每个人的选择都情有可原，但是可悲的是九品中正制，各大门阀家族互相举荐，构成自己错综复杂的利益网络，朝廷官员冗余等问题，大清已经烂透了。  \n每日Emo小短句，我们明天再见。\n\n2023/06/12  \n我转过头去没有看他，我坐在共享单车的座垫上，看着这个颓唐的小镇中心，脑中不知道在想什么，却又感觉有万般思绪涌上心头，我盯着天空，不知不觉地就留下泪了，从此一别我想不会再见了，他会有新的朋友，新的美好生活，我的好朋友又一个离我远去了。我哭得更伤心了，我想这就是分别的感觉吧。今晚的小镇一如既往，没有什么新鲜的事发生，只有一场无可奈何的雨，在月光满轮的晴夜落下。  \n每日Emo小短句，我们明天再见。\n\n2023/06/13  \n所有年轻的人啊，不要长大，所有年轻的人啊，不要让生活夺走你的梦想，所有年轻的人啊，不要成为我这样的人。  \n所有年轻的人啊，长大是件悲伤又无可奈何的事，长大意味着你不再无所不能，曾经的无限活力都变为深深的无力，长大意味着生活很可能会夺走你的梦想，长大意味着你可能会不再是你自己，意味着你可能会成为自己最讨厌的人和那场美好祥和的梦越走越远。  \n所有年轻的人啊，不要长大。  \n每日Emo小短句，我们明天再见。\n\n2023/06/14  \n分别和重逢相冲突在这一刻我不知道是该悲伤还是快乐，我的心中充满无措，我其实一直都是个天真的孩子，本就没准备好去面对这一切，生活不像game那样有趣还可以重来，面对未卜的多艰和枯燥的死寂，我每每消沉，这欢聚只是短暂的，离别又近了一天，欢乐和悲伤浇筑出一杯苦涩的酒，我的脸上没有了表情。  \n每日Emo小短句，我们明天再见。\n\n2023/06/15  \n回到这最温馨的地方，我终于感到了放松，哪些令我烦恼的、令我悲伤的我仿佛都看不见、听不到了，在这短暂的快乐的时光中，我应格外珍惜，因为这美妙的一切都将要离我而去，这曾经最不以为然的平常，从今往后也许就是我最大的奢望，我爱你我的爸爸，我爱你我的妈妈，我厌恶它这可悲的生活。  \n每日Emo小短句，我们明天再见。\n\n2023/06/16  \n时间总是无情，岁月给心爱的人平添了伤痕，看到她瘦峋的样子和手背上青色的血管、白色的胶带，这个面露苍老的人已经不再年轻了，我所爱的人都回不去了，我最无忧无虑的快乐日子也不在了。每感时光飞逝的无力，才知亲情的可贵，回家的路上我想说“我大姑老了”，但我终究没说出口，我极力让自己不去思考、不去悲伤，我想我的父亲会说“别太愁了，儿子”，而我会回道“你也是”。  \n每日Emo小短句，我们明天再见。\n\n2023/06/17  \n有时提笔真不知道写些什么，但觉得这写些东西的习惯自是不能丢掉的，毕竟已经别无什么长处，唯有这一点还能作乐给自己些许的开脱，也算是一种倾诉，不过没有人聆听罢了。最近都在打王国之泪比较放松，没什么思考，没什么感伤。只是觉得王国之泪很有趣，玩起来很忘我，但是再也没有当初第一次玩旷野之息的震撼来的猛烈了，倒不是麻木我想，应是自己“脱敏”了，见识到的也有些了。所以智慧、快乐、财富对大多数人而言其实并不是能全部得到的，不过像我这样一无所有的倒也是少见，也许我可以领个勋章，毕竟在这个物欲横流的社会中，我也是个不小的珍稀物种。  \n每日Emo小短句，我们明天再见。\n\n2023/06/18  \n“公道不在人心，是非在乎实力”——《笑傲江湖·东方不败》，正义和公道只是小孩子的游戏，在这个世界上那只不过是可遇而不可求的奢望，在这波涛滚滚的江湖中，有太多的不公了。天下英雄又有几人能够笑傲江湖呢……  \n每日Emo小短句，我们明天再见。\n\n2023/06/19  \n我喜欢下雨天，因为可以随便哭，雨落在脸上也没人知道那是我的眼泪。  \n每日Emo小短句，我们明天再见。  \n句子不在多寡，兵刃不在长短，功力一到，便可力通人心。\n\n2023/06/20  \n我知道的，在雨里能蒙混过关的只有我糟糕的人生，想流泪的话就放声哭泣吧，即便是阳光万丈的日子。  \n每日Emo小短句，我们明天再见。\n\n2023/06/21  \n我觉得自己再一次放松了，沉浸在混乱的日子中，这种生活就像是沼泽，不知不觉越陷越深，想改变却做不了什么。  \n每日Emo小短句，我们明天再见。\n\n2023/06/22  \n有时候隐瞒是一种让事情更混乱的方式。  \n每日Emo小短句，我们明天再见。\n\n2023/06/23  \n也许现要承认自己的无能不足才能更好的前进，每日的emo感觉更像是命题作文了，思考一些东西，然后记录下来，也算是一种对写作的锻炼吧，不过断然不是日记的，这种东西还是太……做作了，最近没有什么灵感，也很少思考，所以笔下也都是些鸡毛蒜皮了。  \n每日Emo小短句，我们明天再见。\n\n2023/06/24  \n一味地恐惧担忧未来是愚昧的，“不看当下而盼未来，不看未来而盼过去。”，恐惧来源于未知，而未来永远未知，原地踱步永远无法克服这种担忧，而解决这种忧虑的方法就是行动，基于当下去行动，总是思考担心并不能让我们认清未知，只有一步一步地向前迈进才能揭开未知的面纱，把曾经的忧虑变为当下或过去的不足为奇；当然不是说毫不思索上去蛮干，而是要有一个核心的思路方针，所有的行动都依赖于它，并在实践的过程中不断修正，我想大概应该是这样的。  \n每日Emo小短句，我们明天再见。\n\n2023/06/25不看当下而盼未来，不看未来而盼过去。  \n如雷灌顶，我就是一个怀旧的人，总是回忆过去，对现在麻木，对未来迷茫，我一直觉得我的生活充满了绝望，想做什么都不敢开始，也没有坚持，也不知道自己怎么就变成了这个样子。  \n每日Emo小短句，我们明天再见。\n\n2023/06/26  \n我终于知道梦想在生活面前是多么无力 梦想只是自我的虚幻，而生活是庞大的真实，这份真实的重量无比沉重，它变成一个黑洞吞噬了所有的一切。  \n这是我在家的最后一个日子，也是我最后的无忧无虑的日子，面对我最爱的父母和未来未知的生活，我的眼泪止不住的流。  \n我不知道什么毁了这一切，然后把它灌满了悲伤。  \n每日Emo小短句，我们明天再见。\n\n2023/06/27  \n后来我才懂得那些我不曾理解的文字背后的含义，当再次回想时都有了不同的感觉，可惜的是人很难跨越地成长没有经历便没有体会，我终于明白了初读不识文中意，再看已是剧中人。  \n每日Emo小短句，我们明天再见。\n\n2023/06/28  \n我的父亲中午只点了一份白米饭加小葱拌豆腐，这洁白的一餐就如同他洁白的一生，我想说“你怎么不多点几个菜”，但我想我是没资格说的，彷佛他少吃了一些这个举步维艰的家就能多往前走上那么一步，我想了良久不知道说什么，只能打出一串省略号“……”。  \n每日Emo小短句，我们明天再见。\n\n2023/06/29  \n我来到这陌生的城市看见了不同的人，有暴躁吼人的大巴司机，和对我网开一面的保安，和提示我的路人，收留我过夜的华莱士服务员，帮助我使用优惠的店员以及想帮我省钱的打工小哥，和太阳下辛苦的外卖员，在这里我看见了各式各样的人，在这里我看到了那么多我不曾看到的。  \n每日Emo小短句，我们明天再见。\n\n2023/06/30  \nBefore was was was, was was is.  \n逝时曾是时。  \n一颗玻璃球在液压机的压力下可能会瞬间粉碎，但若是一把玻璃球那是击不碎的，一个人也许抵不住那可怕的压迫，但是千千万万的人民群众团结起来时一切的压迫都不足为惧怕。  \n每日Emo小短句，我们明天再见。\n\n2023/07/01  \n茫然地走在这陌生的街头，世界上的一切都和我息息相关却又毫无关联，我找不到未来，只觉得生活的悲哀。  \n每日Emo小短句，我们明天再见。\n\n2023/07/02  \n我不懂得这陌生的一切，我所了解的只有我卑微的生活，机遇被乌鸦叼走，苦难留我独自品尝，不甘和焦虑灌注满我的心头，我的泪已经不再流，时代飘落在人上的从来都不是一颗沙，只不过是有的人在山顶而我在五行山下。  \n每日Emo小短句，我们明天再见。\n\n2023/07/18  \n如果死亡，也许会有人为我流泪；  \n如果死亡，也许会有零星的人感伤；  \n如果死亡，也许会有人诧异；  \n但是，我仍苟延残喘，  \n活着，便没有人去关心；  \n活着，便没有人开始理解；  \n活着，便没有死亡。  \n活着，便是死亡；  \n所以死亡不必落泪，因为我曾获得了悲伤。  \n每日Emo小短句，我们会再见吗？\n\n2023/07/21  \n我小时候总是幻想未来的自己会穿越回来把我杀了，现在我才明白，如果我回到过去，可能会哀求小时候的我把长大的我杀掉。  \n每日一句emo小短句，我们有缘再见。\n\n2023/07/25  \n我走到路口，落日低垂和红色的灯光相得益彰，零散的人整齐地插在路旁，头垂进手机里。  \n在这规律的耕作旁倒也是有别样的风景，一辆黄色的环卫三轮，上面有四五个大叔，皮肤已经变得褐黄了，我偷偷看着他们，假意望向空荡的路口，目光触及到围栏里的楼，就在这落日下他们望着西边的远方，我望着繁华世界中的荒凉，然后灯变绿了。  \n每日一句emo小短句，我们有缘就会再见。\n2023/08/04  \n初中读《我是猫》时倒也谈不上多么被惊艳到，现在唯一能回想起来的就是，那个在猫眼中一切祥和安适的氛围。  \n如今我却真真切切地想变成一只猫，我不知道我是否怀着和夏目漱石一样的心情，但我总会回想起那个夏日慵懒的午后，翻开那本厚厚的书一页一页地读着，那时候我应该没有那么多烦恼，回忆为房间铺满了温柔的阳光，眼中的一切只是宁静和美好，就像那只猫一样。  \n夏目漱石先生，我想变成猫。  \n每日一句emo小短句，希望陌生的你可以像猫一样，充满童真和快乐，我们会再见，哪怕你不记得我。\n\n2023/08/08  \n生活也许会欺骗你，也许会愚弄你，你可能对一切都感到绝望，但是别像我一样沉浸在悲伤中妄想活着的感觉，爱自己，我的朋友。  \n每日一句emo小短句，我们偶尔见上一面吧\n\n2023/08/11  \n苍天已死，黄天当立。  \n岁在甲子，天下大吉。  \n今天偶然看到了13年的一个交友贴，我仿佛能看到有一群拥有共同爱好的人聚在一起，那热闹的气氛，但9年过去曾经年轻的人可能已被生活催的岁月已老，不禁感叹这群互联网遗老会不会偶尔怀念过去，是否我们曾怀着同样的心情看过去、望未来。点开这崭新的古老链接时，能看到的也不过是独属于那个时期的一个又一个有趣的灵魂罢了。但是也可能由于重拳或压力，现在望去，曾经热闹的讨论版如今也不过是纷繁混乱的网络世界中，又一个少缺人烟、落满时代尘埃的犄角罢了。  \n每日一句emo小短句，神马都是浮云。\n2023/08/20  \ncheems早就不是表面上那一只普通的柴犬了，  \n我认为这是一种文化现象或者浪潮，他已经成为了一种意象，其中最为珍贵的是cheems浪潮传递的那些思想和被人们带来的激励、感动。  \n当他被遗忘时，才是他真正死亡的时候。  \n存其意而忘其形，如果你活着你早晚都会死，如果你死了，你永远都活着。  \ncheems的离世无疑是一件让人悲伤的事，但是我会记住这一切。\n\n见过互联网的波涛汹涌后，已经习以为常，光怪陆离、充斥着荒诞的新世纪发生什么都不足为奇，在这个美妙而不知所向的时代里，我被赋予了一颗石之心，麻木地感受着无数的悲与喜。  \n每日一句emo小短句，今日突袭群友！劫营速战，措手不及。![img](D:\\biancheng\\Blog\\source\\imgs\\每日Emo小短句\\F1SZC9}W}_XEA5S]5FCJM3.png)\n\n他们都太优秀了，优秀到被照到的我居然以为自己也能成为一颗星星，突然有那么一天就被随意的聊天惊醒了，什么星星啊，原来我还是那个在下水道里发臭的垃圾啊，如今切实地体会到那句话了“天才这种东西，常会不自觉地将周遭的人卷入，然后弄得遍体鳞伤。越是靠近，越会被撕裂成碎片。”，等回过神来时已经菠萝菠萝哒了。\n\n2023/09/01  \n\"我爱你。\"  \n你可能觉得奇怪，也可能感到突兀或者冒犯；但是有时人们之间确实会有那种莫名的憎恨，甚至没有任何理由，所以我想人和人之间也会有这种不需要理由的爱。可能这种爱并非是深入骨髓、刻骨铭心的海誓山盟，更像是一句寻常的关心，哪怕是一种冲动。  \n然而，如果这份爱是虚假的，那我希望那莫名其妙的恨也失去意义。  \n每日一句 emo 小短句，我们有缘再会。\n2023/09/02  \n触不可及却刻骨铭心，生活的无奈就在每日的平凡中展开，  \n我们也许都在做着正确的事，但悲哀的是当我们彼此交汇，这本该在时间的河流上编织的诗歌如今只有混沌。  \n“如果我不直播了 我可能会突然上个厕所 然后再也不回来了”  \n“泥头车每天还是准点来，只是车上再也没有那个女孩的身影。如果当初知道，应该放下一切，上车，不再回来。”  \n“圣地亚哥在下雨，智利别为我哭泣”  \n每日一句 emo 小短句，我们有缘再会。\n2023/09/04  \n狗彘食人食而不知检，途有饿殍而不知发  \n指望资本主义的走狗良心发现简直是异想天开，为自己徒增烦恼，要明白谁是敌人，谁是朋友。  \n团结一切可以团结的力量，打倒所有的敌人。\n2023/09/29  \n爱而不得才是常态，充满遗憾就是人生；  \n壮志未酬不过稀松平常，苦海无涯乃是我的命运。  \n“试问天下英雄又有几人能够真正的笑傲江湖呢”  \n我原以为自己这卑劣的样貌不过是不讨喜，对于旁人也不过是稀松平常，没想到自己竟然如此的令人恶心。在这昭然的事实后展示出的是这场淘汰机制的生存竞争，从古至今一刻不停。可悲的是，无论你赋予生命怎样的意义，在这场追寻宇宙真理或生存真谛的比赛中，败者只能是一无所有，直至死亡，所有的思辨最后恐怕都是自我安慰，一次名为自我欺骗的“和自己和解”。  \n在这场比赛中，我从来没有获胜过，我只是个loser 所以我恨，我的立场不是中立，因为我尝尽了悔恨、嫉妒、憎恶的滋味，那必定不是甘甜的也不是苦涩的，而是刺痛。  \n每日一句 emo 小短句，我们有缘再会。\n2023/09/29  \n当我蜷缩在这大到无边城市里阴暗的一角时，我想起了那句台词  \n“我要这满城的人都来陪葬”  \n“千里皇城尽作焦土”|  \n我仿佛能理解李儒的焚城决策，但我没有那样的智慧，我只有偏执的疯狂。  \n每日一句 emo 小短句，我们有缘再会。\n2023/10/06  \n有时候我们耗尽一切都得不到自己渴望的东西，其实这才是生活的常态，长大的世界就是求而不得、学着放手；不知不觉我们都不再是那个哭哭闹闹就能得到冰淇淋的小孩子了，那种无忧无虑的时光最后只能成为宝贵的回忆，让我们在痛苦的现实中去怀念、去流泪。  \n不过我没吃过冰淇淋。  \n如果不用上班是否所有的悲伤都会变作欢乐呢？  \n今日 emo 能量赞助来源，歌曲《Duvet》，演唱者 Bôa ，别名《TVアニメ「serial experiments lain」OP1テーマ》，收录于《Tall Snake Ep》专辑中。(就是《Lain》的 OP 哦)  \n每日一句 emo 小短句，我们有缘再见。\n\n2023/10/15  \n从互联网文学，到农村纪实(在如今这个城市化程度很高的时代，还有人去关心乡村去记录现实，我是表示敬佩和珍惜的)，再到修正主义和牛鬼蛇神，再到过去的抗争记忆，再到古代新学和现代桎梧，还有当下未来的科幻，一切都与我无关，却都发生在我身边。  \n[图片] 已过期\n\n2023/11/02  \n清醒令人痛苦，麻木使人沉沦，人记性太好会很痛苦。  \n每日一句 emo 小短句，我们有缘再见。\n\n弱智吧小集合  \n敬老院的新人都是老人，这个世界的大人都是小人。  \n所有的桥都是温暖的，因为他们让河流不再难过。  \n从我确诊出生的那一刻，我的死亡就只是时间问题。  \n皱纹是时间吹过身体时泛起的涟漪。  \n月亮——摘自《星空》  \n看到花开放时，花就已经在枯萎了。  \n我的梦想是一对情侣，白天我压的她说不出话，晚上她压得我难以入眠。  \n我最新的照片是我最老的照片。  \n生鱼片是死鱼片。  \n世界是个大象，我们每个人都在盲人摸象，抽象是对世界最好的鞭笞。\n\n2023/11/19  \n我已经燃烧殆尽了，只剩下雪白的灰。  \n燃え尽きたぜ…真っ白にな…\n\n如果只能有一个李哥，为什么不能是我李元浩的李。  \n这可能是你唯一的机会了，小虎。  \n也就是说，现在是LPL苍蓝猛虎登场的时候了。  \n昼虎！夜凯！  \n地虎铠甲，合体！\n\n小虎需要这个冠军来证明自己。\n\n2023/12/15  \n害，卡姐真的是太惨了，幼年丧母，青年丧父，碰到了戈塔屎，以为是好人结果被坑了。  \n到博德之门后，她对死去的父母，以前的朋友都是在做死前的最后道别。  \n在饭店的夜里，她说干净床单的味道能让她想起妈妈，因为她妈妈是一个洗洁工，她畅想假如自己还有50年，未来会有多么美好……  \n但是这一切注定都是悲剧，逃窜到最不愿回首地狱也不过是在惨淡的命运驱使下痛苦地活着，“再见，大海。再见，太阳。再见。”  \n我爱你，卡菈克。\n\n203/12/17  \n如果没有遗憾，我是否还会爱你？\n\n2024/01/08  \n在最黑暗的晴空万里我为太阳哭泣，如果明天我不再升起，  \n请别为我忧郁，  \n如果明天我不再呼吸，  \n世界请为他人欢愉。  \n在麻木和壁垒中流浪，清醒让我渴望死亡。  \n如果懦弱是种疯狂，麻木是否已经渗入我的骨髓。  \n我渴望哭泣，我渴望结束，我渴望渴望。  \n每日一句 emo 小短句，我们有缘再见。  \n\n2024/01/20  \n哦，妈妈请别为我哭泣，我们将回到故乡。  \n读哈马斯的勇敢有感。  \n每日一句 emo 小短句，我们有缘再见。  \n神只是人类美好的倒影，至少于我而言，最伟大的是人类历史中那些充满勇气的瞬间。  \n\n2024/05/10  \n原来幻想中反派听到音乐被迷惑困住甚至感悟的情况是真实存在的。  \n当我听到童年熟悉的音乐才知道自己再也回不到那个，炎热却温暖，茫然却快乐的日子了。  \n我在熟悉的旋律在忘却了当下，只记得那个温和的午后，  \n我被这悠扬的笛声困在了过去，又逃不出现在，  \n这是一种奇妙的感觉，温馨快乐做了泪水的底料而悲伤洒在了我的脸颊。  \nhttps://www.bilibili.com/video/BV1dy42187pm  \n每日一句 emo 小短句，我们有缘再见。  \n对了，也许我的可可果已经熟了吧。  \n难道人生注定是一个塑造自己，丢失自己，怀念自己，找寻自己的过程吗……可悲的是我无法找回自己了，我只想杀死自己。 \n\n2024/07/14  \n坐火车是一件挺有心理压力的事。  \n在车上能看见各个年龄段，和很多不同的人，从小孩到大人，再到老人，从体力工人再到脑力劳动者。  \n仿佛人生的大部分状态和未来的可能都被压缩到这一个狭窄的通往过去或未来的车型上。  \n在这里看到自己记忆中的过去，也能投射出自己些许的未来。  \n我为不能回到过去而感到悲伤，我为昏暗的未来感到悲伤。  \n我为座位如此接近，阶级差距却如此之大而感到悲伤。\n\n2024/07/15  \n在混杂的音响和众人的祝福中，我的思绪其实早已飞到过去，我只看得见一屡长发在我眼前拂过，  \n阳光顺着发间映出，仿佛发光的是她，而不是背后的太阳，我怯懦地用残缺把她的脸从回忆中抹去，  \n仿佛这样就不会悲伤。  \n于是我坐在喜宴的桌沿上，沐浴着礼炮的彩色飘带，大家都在笑，我也笑了，  \n“祝你幸福”。\n\n2024/09/14  \n难道人生就是一个被当下蹂躏，焦虑未来，怀念过去的体验吗？  \n如果一向如此，我美好的曾经是否子虚乌有，我的焦虑是否杞人忧天，我的现在是否镜花水月。  \n你好，我已经去了未来，如果你看到了这段信息，请在现在把我带到过去。 \n\n2024/11/24  \n阳光好刺眼啊，仿佛要把我全身的潮湿和阴暗都蒸发掉一样，即便是这样的白日青天、朗朗乾坤，我的前程为何还是一片灰暗。  \n要何等的烈焰才能驱散笼罩在心头的阴霾。\n\n2024/10/25  \n为什么现实是这样复杂且痛苦的呢？  \n也许这个世界就是一口大锅里面炖着一切，当我品尝生活的滋味时，不是咸，也不是甜，那种味道很复杂，很多时候这种味道让我说不出话。  \n也许五味杂陈的意思我现在才理解吧。  \n我的现实是没有幸运星的。  \n也许一开始这就不是一个开心温暖的故事，不过虽然我开了一个糟糕的起承，但至少我还是作者，这个故事还不会封笔。  \n写到这里时不由得想到巴勒斯坦人民的遭遇，真是场卑劣的战争，悲怆和残忍正在这片土地上演，巴勒斯坦人民万岁。\n\n2024/11/01  \n我闭上眼睛，勇气没有增长。  \n这薄薄的无尽黑暗中，我看到了未来，  \n所以无需畏惧，大啖食粮之刻已至。\n\n2024/11/28  \n我只是在原地兜圈子的一个孩子，  \n我渴望有人主动跑过来爱我，  \n我希望有人能拉着我的手前进，  \n而现实是，不会有这样的人了，  \n而幼稚的我只知道坐在原地大哭，  \n这不是一场悲剧，只是我个人的丑态。\n\n2024/12/03  \n正义是杀不完的，无论是真的还是希望相信，正义都是杀不完的。  \n即便我们只能像“我们必须想象西西弗斯是幸福的”一样略带无奈和妥协地去相信自我价值。  \n正义是杀不完的。\n\n悲歌可以当泣，远望可以当归\n\n2024/12/05  \n望未来•娄山关  \n冬风裂，空留萧索孤影夜。孤影夜，霜飞雨泄，亭台幽咽。  \n崎岖闭路了无疟，今夕空作亡魂雀。亡魂雀，幽闭犹怨，寒玉犹泪。\n\n2024/12/05  \n我时常感到悲伤，\n说悲伤是陪我之现在的朋友也不为过，\n所以我想既然我摆脱不了它，\n不如去享受这一刻，把我的感受和思考记下来，哪怕给人作为玩乐的笑料，\n渐渐的这也成为了我的一种习惯或者说乐趣。  \n人活一世也许真的会留下点什么。\n\n2024/12/11  \n雨打在外套上窸窸窣窣，上海的冬天，也不能说为冬天吧，比家乡来讲应是晚秋的气温，虽然如此但气温也低，寒冷的夜有些伤感，能听到只有汽车呼啸而过带起的水泽和雨滴滴答答。\n没有月亮，没有星星，就像没有太阳一样，我想不明白游戏行业为什么这样的，有的人已经金缕玉衣，而我能还在一堆烂泥淤成的潭里，不仅狼狈丑陋而且一无所有。\n每每想到这我都感到十分的伤心，甚至想大哭一场以此来发泄来麻痹这庞大的、痛苦的、无助的感觉。\n我想璀璨的人生我是不会拥有了，有的故事就是这样的能够扭扭歪歪地写出几个字就已经很不容易了，哪里还有什么美学或者意义呢。\n我的人生已经开始了，但是我的人生其实早就结束了。\n雨漏进了泥潭，天有些凉，我也有些冷了，但是我看不见月亮。\n\n*注释：雨没有漏进泥潭，其实是笔者的眼泪在心窝中流转。*\n\n2024/12/12  \n\n* 分不清是被子冷，还是天气冷，还是世态炎凉。\n* 所以说人与人之间的隔阂就像at立场一样，我撞不开，强行撕开只会让人受伤。\n* 冷暖自知，能感受到的只会有冷。\n  这是个最冰冷的词汇，因为不能和别人拥抱才只能自己窝在寒冷里幻想温暖。\n\n* 没人爱我。  \n  倒不是说大家都不喜欢我，可能会有人喜欢我，但是是没有爱的勇气的，我也没有，我就是那个害怕幸福而逃走的胆小鬼。  \n  xx，你戏谑的外表下藏着什么呢？  \n  嘻嘻哈哈也金缮不了被生活伤害的残破的心。  \n  我不要。  \n  我要未来，我要希望，我想要爱，我想要真理。\n* 我所做的工作都是微不足道的，我只是把那个缤纷绚丽的世界搬到大家面前，除此之外别无他长。  \n  只要用心观察世界，每个人都是伟大的作家。\n\n2024/12/19  \n你说得对。  \n我的一生确实是浪费了。  \n我不再是那个有所期望的人了，  \n在自己的软弱催使下，在见证一起冷漠的爱和爱抽象的人却转身向现实铡刀者之后，我不在爱人类了。\n\n所谓的博爱和温柔，只不过是披着抽象外衣的自我感动，卑劣至极罢了。\n我不再爱自己，在试着爱人类时，也失败了。\n人所之人，非人哉。\n\n2024/12/25  \n前人之述备矣。  \n我每次有所感悟，有所表达时，特别是选题相近，比如对时间流逝的感悟，其实早有绝笔，所以总有些彷徨，我对着千古已定的命题还有所疑虑，仿佛我已经忘却了前人的教诲，有些羞愧。  \n但是我突然想到，所感前人之感，也并非说明我们遗忘了什么。  \n恰恰说明人类从未遗忘，对于相同的困境和问题，拥有了相同的感悟或表达抑或不同，恰恰说明人类没有忘却。  \n面对相同的问题，我相信这种重复思考会继续下去，直到它解决的那天。  \n虽然后人可能忘记我当下随感，但是当他们遇到相同的问题时这一切的思考会再次涌现。  \n也许对于人类而言，时间的流向已经固定，宇宙就是如此的残忍无情，那么如此脆弱的人类，所能拥有对抗这一切的、唯一的脆弱武器便是思想，唯有思想才能穿越时间。  \n我称之为，遗忘的记忆。\n\n去忘记吧，等你忘记所有招式你就练成了太极拳。\n\n2024/12/26  \n\"雪融\"，我看不见太阳升起了，我的雪在这里就要化了，只不过只能以泪水的方式了。  \n明年7月，如果你有时间的话，对风声说一句天气如何吧。\n\n2024/12/27  \n有时候做梦就梦见审死官里面那一幕，  \n星爷演的那个状师，拿着金元宝轻蔑地指着我，“做游戏啊！做游戏啊！”，  \n于是我也和他一起戏谑了。\n\n2025/01/07  \n昨天我大学同学的朋友问我，你读这么多年书现在加班那么晚，有没有后悔过，  \n当时没觉得什么只是说，还能怎么办想那么干啥，得生活啊。  \n现在冷静下来，想想心里突然有点东西放不下了。  \n我知道他是想问问我答案，但是我也不知道答案，  \n我其实和他一样，  \n至少在对人生的迷惘上，出奇的一致。\n\n2025/01/08\n看一次哭一次，如果真的有爱情的话希望别是这个样子。  \n伤心莫采琵琶树，断魂不照小轩窗。\n\n2025/01/24  \n幸福是主观的，浮动的，不可定义的，同时也是无法衡量，不能经由测试的。  \n很多时候幸福可能是一瞬间的感觉，当然会有幸福存在。  \n然而从长远看人生更可能是一场悲剧，幸福也许是不存在的。  \n选择做一个无知的人欺骗自己是幸福的，或者做一个痛苦的人接受幸福是少数的。  \n很难说这两者是聪明的愚蠢，还是愚蠢的聪明。\n\n2025/02/21  \n你怎么开始怀念过去了？  \n你老了吗？可是你最多可能也就30岁，不太老也不太年轻。  \n我不知道，也许是……过得有点辛苦让我想起了从前。  \n你呢？朋友。\n\n2025/02/21  \n落叶魔音，见落叶而知深秋，  \n晓得盎然春日遥遥。  \n初听不觉何足道，十年邈邈，  \n再奏断万股愁肠，千滴泪。\n\n2025/02/26  \n牛马哥，我总是想起从前，  \n我现在生活地很痛苦，在夜深人静的时候，我努力回想小时候那些美好的时光，那些日子因为遥远反而显得格外温暖。  \n但是我的身心已经冰冷，只有在回忆中逃避当下的时，才能感受到什么叫生命。  \n在我去逐步认识这个世界的现实中，疫情又给了我沉重的打击，在哪个迷惘和无措的时光惶惶然，我被迫进入了社会，没有承担责任的勇气，没有敢于面对困难的魄力，有的只有对未来的迷惘和昨日的创伤。  \n于是我再次回忆，那个慵懒的躺在午后阳光里的孩子，那个和朋友有说有笑不知愁滋味的男孩。  \n对我而言过去是欢乐的，但是我站在原地往回跑的时候，却无论如何也追不上了。\n\n2025/03/18  \n就像我总怀念那年夏天的风，  \n我记得那是一个凉爽的下午，  \n它从窗户钻了进来，  \n卷起前桌黑色的长发，  \n来到我的桌前，  \n它给的感觉很轻快，仿佛在拖着我无拘无束，  \n它就这样的一阵阵来，一阵阵去，  \n直到那个夏天过去了，  \n我以为他还会回来，我也以为那个夏天会再来。  \n可是夏天总是，但是那股风再也没回来过。\n\n2025/03/30  \n如果严肃的文学作品消失那将是整个时代的悲剧，  \n在当下我们可以看到，文娱作品越来越轻量化，娱乐化，  \n表达内容浮于表面，过去的严肃叙事仿佛消失了，  \n那些曾经激烈探讨的问题不再成为作品创作的素材了，  \n可是那些问题就真的消失了吗？  \n尤其是在去政治化特别严重的某些国家，   \n甚至是谈之色变，政治和每个人的生活、权力、义务相关，  \n放弃严肃叙事，放弃政治讨论，等同于放弃思考，放弃社会权益。  \n我觉得这是可悲的、可怕的。\n\n2025/3/30  \n省流，匹配成功。\n不过不用想这么多，玩游戏的时候感觉到开心就好了。  \n游戏作为文娱产品的目的就是取悦用户的。  \n有反思有向往是好事，但是个人的努力无法和时代的洪流抗争，  \n所以，去享受人生吧，在生活的痛苦中，给自己找一颗糖吧。\n\n2025/05/11  \n追寻梦想总是痛苦的，尤其是在这片土地上，现实太过沉重，把我们每个人拖向地狱，  \n为生活妥协无可指责，但是在回首过去时，总会心有不甘，人生就是抱着遗憾漫无目的踱步的过程。\n\n2025/05/21  \n仇恨就像螺旋一开始还有迹可循，可世事不能离散只有连续。\n\n>- Agent Ross, Pinkerton Detective Agency.\n>- Enjoy your fishing kid, while you still can.\n>\n>- Excuse me! You Edgar Ross?\n>- Do I know you?\n>- Forgive me for startling you, sir. I have a message for you.\n>  My name is Jack Marston. You know my father.\n>- I see... I remember your father.\n>- I've come for you, Ross.\n>- And you, boy, have sure as shit found me.\n>- You killed my father. You shot him like a dog.\n>- Your father killed himself with the life he lived.\n>- You killed him! I saw you!\n>- You keep saying that.\n>- You sent him to do your dirty work, then you shot him like a dog!\n>- And I'll shoot you like one too, you little piece of trash!\n>  Now get out of here before I kill you as well!\n>- I ain't going nowhere, old man!\n>\n>RED DEAD REDEMPTION \n\n> - You can't erase the past, John. Killin' me, it won't make it go away.\n> ...\n> - Hello again, John.\n> - Hello, Dutch.\n> - We gotta stop meeting like this!\n> - Sure.\n> - I've got a plan, John.\n> - You've always got a plan, Dutch.\n> - This is a good one.\n> - I don't doubt it.\n> - We can't always fight nature, John. We can't fight change.\n>   We can't fight gravirty. We can't fight nothing. My whole life, all I ever did was fight.\n> - Then give up, Dutch.\n> - But I can't give up, neither. I can't fight my own nature.\n>   That's the paradox, John. You see?\n> - Then I have to shoot you.\n> - When I'm gone, they'll just find another monster.\n>   They have to, because they have to justify their wages.\n> - That's their business.\n> - Out time is passed, John.\n\n2025/06/07  \n繁重的工作压得人喘不过气，\n连打游戏作为消遣的动力都没有，\n在夜深人静放松思绪能够思考什么的时候，\n往日观看的asoul视频又浮现在眼前，已经很遥远了，但是有希望能够近一些。\n无论接受与否那都成了过去，必须学着接受，\n这就是生活残酷的地方，\n我们漫无目的来到这个世界，遵从生存的本能，\n短短数十年在史书中不过寥寥几笔，\n整个人类历史于宇宙而言不过尘烟，\n这一切真的有意义吗？宇宙存在所谓意义吗？\n我怀疑，但悲哀的是我只能相信，无所谓与否。\n\n清风乱弄两三页，提笔一拨百十年。\n长叹飘渺江中月，落花点水了人间。\n\n2025/06/15  \n从《巴黎的忧郁》到《凉宫秋日的忧郁》他们的悲伤不及我的万分之一，  \n早在落笔之前忧郁已悄然而至，媒体所载至少有人同悲，而我的忧郁只属于我自己。\n\n摘抄自《知乎》，中华人民共和国的一款人民分享见闻观点，芝士的平台。\n\n2025/07/04  \n在21世纪还能看到联合小团体迫害一个人在网上发表言论的自由，这种情景也是少见了。\n当你在为同胞争取权益时，还要被倒打一耙，要怪罪你破坏了他们安定祥和的生活，  \n与之前其痛恨其作为资本家走狗的同事时的面孔截然相反，换了副面孔便高高在上，圣洁无暇了。  \n若是真的有罪便也受的没什么怨言，狺狺野狗也学起秦桧的手段了，真不得令人发笑。\n\n2025/07/08  \n树死叶落黄，飞沙填泥漳，  \n猢狲不可言秋凉，唯恐泣涕泪叶扬。\n\n2025/07/25  \n在某国你上班得忍受被压干最后一滴血的觉悟，  \n没有基本的人权保障，没有合理的假期安排，没有休息时间，  \n还要被当权者拿走产出，还得看着他们用你的辛勤劳动去花天酒地肆意挥霍。\n\n2025/07/25  \n回万古长夜月明，多少英雄不在，  \n哀一生前途晦暗，几许气概无存。  \n多少千百事，都做尘与土。\n","slug":"每日Emo小短句","published":1,"updated":"2025-08-12T15:41:55.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti50016bkbw5bt2c59k","content":"<p>你能翻到这整明你很有耐心啊，说明你对我的Blog还是有一定兴趣的，或者是我直接发的链接。<br />\r\n这里记录一下自己在群里的每日Emo小短句，\"每日一句emo小短句，我们明日再见。\"<br />\r\n<span id=\"more\"></span><br />\r\n温情提示偶尔伤痛文学一下舒缓压力可以理解，但是不能实际地跟本地解决问题，美好的生活需要自己创造。<br />\r\n还有如果你时常心情低落，难受，要注意心理健康，必要的时候要去看医生哦~<br />\r\n那么废话结束，我们开始Emo吧。<br />\r\n<span class=\"math display\">\\[\r\n我从未看透，我只想感受慷慨赴死的颤抖。\r\n\\]</span></p>\r\n<p>这里只有低级的思考和最卑劣的情绪宣泄，\r\n除此之外没有任何文学意义，我所述之一切，不过尘烟。</p>\r\n<h1 id=\"独油群每日emo小短句\">独油群每日Emo小短句</h1>\r\n<p>2023/04/09<br />\r\n“我好想问一问进入游戏行业打工的愿望就这么奢侈吗？”</p>\r\n<p>2023/04/10<br />\r\n虚拟的数据能分析出我真实的病情，为什么真实的世界却不能带给我一丝虚假的温暖呢？</p>\r\n<p>2023/04/11<br />\r\n人生最大的悲哀也许就是平庸的自己配不上远大的理想吧，纵有孟德之志，却无丞相之才啊。可是即便意识到也在名为平凡的泥潭中越陷越深……<br />\r\n这场名为人生的冒险好艰难啊。</p>\r\n<p>2023/04/12<br />\r\n今人又见古时月，古月不救今时人。<br />\r\n这里用救字，是我自己对外的求救，是一种直白的表述方法，我希望给读者更强烈的情感冲击，如果追求诗歌的美可以用别的字，比如照、抚、望。<br />\r\n<strong>今人又见古时月，古月已忘今时人。</strong><br />\r\n这里又想到一句更好的，不知道好不好。</p>\r\n<p>2023/04/13<br />\r\n无能是灼烧我的业火，他人的光辉刺痛我阴暗的鼠目，宏大的理想也变作狂妄。<br />\r\n每日一句emo小短句，我们明天日永别。</p>\r\n<p>2023/04/14<br />\r\n浑浑噩噩成了日常，萎靡颓废成了习惯。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/15<br />\r\n骑马跨栏的判定太阴间了，cnmd。<br />\r\n每日一句emo小短句，今天开始摆烂，我们明天再见。</p>\r\n<p>2023/04/16<br />\r\n小时候父母告诉我要有一颗，像铁一样坚强的心，但是他们没告诉我的是，这世界上磁铁太多了。<br />\r\n每日一句emo小短句，今天的emo比以往来的更早一些，我们明天再见。</p>\r\n<p>2023/04/17<br />\r\n好想回到过去，好想变成芝士面包。<br />\r\n每日一句emo小短句，我们明天再见。<br />\r\n是因为我早就死在了过去，所以灵魂索求着还阳吗？ 2023/04/18<br />\r\n我是一个怀旧的人，因为我的未来没什么希望，我在过往的欢乐中，种下了一棵在未来通向衰败的枯树，<br />\r\n当我茫然地走上自己铺就的幽暗小道时，我总是回头望去，我怀念那些欢乐的日子，我悔恨那些蹉跎的日子，<br />\r\n我在枯树旁的荆棘丛中哭泣，我在梦境的虚幻里沉沦，以忘却这痛苦的生活，在美丽的梦里，我是一个怀旧的人，因为我的未来充满希望。<br />\r\n每日一句emo小短句，我们明天再见。 2023/04/19<br />\r\n于我而言，生活的琐碎就是一个不断发现自己失败的过程，<br />\r\n我时常懊悔无助，但我想，发现自己的失败不应像我一样悲伤、自怨自艾，理当奋起直追、弥补不足，<br />\r\n可惜我是做不到的，因为我总是在发现新失败的伟大征程上，义无反顾地航行，<br />\r\n我是绘制不出五彩蓝图的幽灵，我已经同海底的死寂共赴沉默。<br />\r\n岸上的人不要上我这条残破不堪的船，去在广阔的大海上勇敢地航行吧，去开辟你的新航路吧，<br />\r\n鼓足你的风帆去禁受狂风的肆虐，不论前方是文兰或是礁石。<br />\r\n“面朝大海，春暖花开。”<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/20同理心是种可贵的品质，我好希望每个人都能有这种品质，这样大家就都会关心我了，可惜我只想着别人来关心我，这样看也许这种可贵的品质我自己是没有的，不知不觉又犯了宽于待己，严于律人的错误，我想我是不配这样的奢望的，渐渐地我便不再去幻想了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/21<br />\r\n看到你们美好的生活我真的很羡慕，我也好想和你们一样，虽然理想的工作和实际存在差距，但是能进入自己热爱的行业对目前的我来说就是最大的愿望了，但这愿望终究是小女孩划燃的火柴，在这寒冬中燃不久，便消失了。我蜷缩着身体彷佛看见自己坐在一家游戏公司里，同事都温柔可近，工作生活都很愉快，这样的梦好虚假啊，连我也意识到这是弥留的回光，人们渐渐围在了我的身边，对我指指点点，我依稀听到他们说“活该啊，冻死了吧”，随后我也指着自己说道“活该啊，冻死了吧”。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/22<br />\r\n躺在床上怅然若失的望着天空，青春的活力和萎靡的精神在我体内冲突，我同旧厂街过去的哪些青年一样，眼中充满对未来的迷茫，从梦幻中惊醒，面对的是生活残忍的另一面。<br />\r\n哪些在镜头前迷茫的青年曾经是一定存在过的，昏暗的室内和朦胧的镜头记录下他们短暂的一瞬，我希望未来别再有他们了，想到这，我再看向窗户映出的模糊倒影，越发清晰却渐渐的陌生了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/23<br />\r\n我想，把自己的痛苦与挣扎用矫情的文字表示出来，是不值得夸耀的、甚至是应当感到耻辱的；用人们共同的痛楚去博取同情未免有些太卑鄙了，但我一直都是这么做的。所以我常对自己感到厌恶、对他人感到羞愧；一个真正有爱的、坚强的人，我想应当是在痛苦之中感受、反思；在有所顿悟后，用爱和希望去鼓舞他人，带给他人力量！人们因生活的痛苦而困顿，却也因困顿而坚强，我在生活的沉沦中越陷越深，唯一能带给别人的就是一首赞歌，一首歌唱反抗平庸、超脱自我的赞歌。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/24<br />\r\n小短句总是越写越长，可能是因为压抑不住的表达欲和内心深处对于他人认同的渴望吧，写得越多自己向外暴露出的也就越多。向外表达的行为也是祈求认同的过程，是想被他人了解、关心的强烈渴望。<br />\r\n所以我决定继续写小作文。<br />\r\n我在行动的过程中内心总是充满怯懦，对于自己的目标总是处在一种迷茫的状态，找不到前进的方向，在光怪陆离的森林中不断地徘徊、观望他人的世界，美好的青春和时光就在自己的惘然中眼睁睁的溜走了，直到今日也未能触及心中的理想。如果说理想是名为文兰的陆地，抵达它的过程，就是一场被称为人生的伟大航行，我们时常同海上的漩涡斡旋，和水下的礁石战斗，而脆弱的风帆和桅杆已经在终日地雨打风吹中受伤磨损，但依旧看不见陆地，却常常听闻别人登陆文兰的讯息。有时我会想投入这广袤的海洋中结束我悲哀的航行，或是祈祷一场巨浪掀翻我的扁舟让我拥有退出的理由，但是在朝露打湿我干瘪的嘴唇，在凄冷的素晖映得海面粼光闪闪时，我又在幻想中看见了文兰的影子。<br />\r\n每日一句emo小短句，我们明天再见。 2023/04/25<br />\r\n孤独是上天赐予我的礼物，死亡是世界给我的解脱。<br />\r\n我是有意识的玩偶，在戏谑的闹剧中进行着荒诞的演出，宇宙和眼白是我变态的观众，平庸和愚蠢是他们最爱的戏码。广阔的舞台扭曲我的身体，我的精神不甘地嘶吼，软弱的躯体和颓唐的精神揉搓成一团混沌的烂泥，而这丑陋的模样就是他们解闷的笑料。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/26<br />\r\n今天一如既往的浑浑噩噩度过一天可是并没有感到快乐，没有休息也没有玩乐，也没有工作，但是一晃就到了晚上，心中更烦闷了，很疲惫。罗素曾说悲伤让人疲惫，我本不知如今倒是感同身受了，也许我应当痛下决断，去正常的生活。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/27<br />\r\n我靠着虚假的希望和混沌的疯狂来麻痹自己，这膨胀的幻想被他人用现实刺破，我沉浸在真实的伤痛里，我的诉说和抱怨都是无用的呻吟，在锋利的剃刀前迎接我的是毁灭的命运，在这口疯狂旋转的大染缸里我只是时代光鲜背后被丢弃的渣滓。我是一个失败者，我决定从这场残酷的战争中逃走，做一个懦弱的逃兵，于是在一个最美丽的清晨，我坐在冲入云霄的花托上，对着太阳说我的故事，和月亮谈我的理想，最后我和风自言自语道“我将走向死亡”。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/4/28<br />\r\n钟鼓磨灭了意志，平常让人麻木，在平静中一步步走向海的深处，意识到这毁灭的到来，却没有做出反抗，只是左顾右盼地张望，虽然激起朵朵的浪花可脚下的步伐并未停止，沙滩上的足迹被一袭又一袭的波涛卷走，海里的鱼对着断翅的海鸥说，别害怕，海啸会带走一切的。<br />\r\n每日一句emo小短句，我们明天再见。<br />\r\n生活是一场无法规避的战斗，<br />\r\n有的人轻松写意，有的人举步维艰，<br />\r\n无论是胜利还是溃败，世界并不在乎，<br />\r\n受伤的只有向着红色风车冲锋的傻鸟。<br />\r\n每日一句emo小短句被对线爆出金币了。(</p>\r\n<p>2023/04/29<br />\r\n有一条鱼拼命地往渔夫的网口里钻，渔夫把他拎起来看了看，肉少的可怜、长得又颇为难看，“浑身的腌臜味，一看就不好吃”，然后把他扔回了浑浊的泥潭，鱼想着要是自己是一只锦鲤就好了，这样渔夫们都会挣着捕获、是什么“濒危物种”也好啊，可笑的是这年头“濒危”也是要持证上岗的，像他这条只是快死了的鱼，是远远碰不上“濒危”的边的；他望着泥潭外的世界，万类霜天竞自由，飞禽走兽、奇珍异兽，可谓是无奇不有，从蒲公英的耳语中他也曾听闻隔壁池塘和远处大海的景象，那里的水更清澈、那里的水草更细腻，远是比这片小小的泥潭好得多的。他又沉下泥潭里，在他翻身休憩的过程中，他督见一条鱼摆在盘子里，浇上了些许酱汁，被筷子们分食着，“呸，这条鱼刺又多肉又少，还这么腥，真他妈难吃。”，少顷后，盘子里只有被开膛破肚的残羹，一片狼藉。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/30<br />\r\n现在这个世界真有趣，虚拟的东西越来越活灵活现，这块荧光屏幕里的小东西们总是那么动人，比外面的世界有趣多了，盯着这绚丽的光彩久了，现实的色彩便显得灰暗下来了，目之所及便没什么趣味，甚至感觉到些许的烦躁，也有投机倒把的人抓住这追求七彩祥云的心理，造出炫丽门面的假象吸引猎物上钩；也许离现实太久了，生命和精力融进了这块小小的屏幕中，等发觉才意识到，这发光的不是太阳，过于沉迷是会食人心血的。<br />\r\n是时候做出些改变了，因为该给手机充电了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/01<br />\r\n心中很烦很急，每次总是拖延，最后又是悔过，但是终究不改，为什么我的性格如此低劣。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/02<br />\r\n我常用宏伟的目标和理想主义者的虚伪躯壳来遮蔽我丑陋的容貌，然而在这重重伪装之下真实的内心中，是一个彻头彻尾的幻想主义者，我用这些东西来麻痹自我、达到精神世界的超脱，只是假借幻想来满足自我的私欲，就如刘森所言<strong>“你从未看透\r\n你只想感受 慷慨赴死的\r\n颤抖”</strong>，犹如一片落叶追寻着秋日的肃杀和远方坠落的夕阳，希望毁灭和宏伟能装饰自己蹉跎的一生。<br />\r\n面对这样的踌躇，我要抽出宝剑斩断这懒惰的羁绊，随着盖格计数的哒哒声，我要义无反顾地冲向那片红色的海阳。我想在每个人的生命旅程当中难免会有失败、会被路边美丽的风光所吸引，但是每个人都应该拥有鼓起勇气、提起胸膛去修正错误的机会，和对自己人生负责的义务，从今天十点钟开始我就要发奋图强，追回失去的光阴！<br />\r\n但是十点钟已经过了，那没关系……我不是今天的十点钟开始，我不定哪天的十点钟开始！<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/03<br />\r\n我看着他踉跄地走在铁道旁散乱着灰黄石头的小路上，他的步伐太慢，已经追不上这趟向前飞奔的火车了；他总是提着一瓶酒，那并非笑看生活洒脱自我的、潇洒的酒，而是为了麻痹自我逃避现实所依赖的毒药，最后一次我看见他走在秧歌队里，脸上带着些许的红晕，和花扇一起舞动，他的舞姿无法称为曼妙，只能说是灾难，这最后的放荡自我和追寻解脱的舞让我感到了毁灭和死亡的味道。后来直到今天，我再也没见他了，听说他害了病，也许他死了，不过我想虽然他迈上了死亡，但是终是没死绝的，我看了看镜子，再望了望太阳，我想大抵是如此的。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/5/4<br />\r\n好怀念小时候，稚嫩的画笔虽然绘制不出写实的画风，却充满着童趣，那是一幅粗糙的蜡笔画，阳光明媚、绿树成荫，背景里奏起的是悠扬的音乐，那时候不知道什么是烦恼，我只负责快乐就好，那个夏日的下午骄阳暖的正好，身上挎着清凉的背心，在可爱明艳的画面中我为了快乐而努力，我似乎还朦胧的记着那些我可爱的伙伴们，我还记得那个美丽奇幻的世界，我的脸上露出了开心的笑容。<br />\r\n那时候一切是那么的简单、一切是那么的美好，彷佛一切都是有希望的、一切都是光明的，我怀念那个时候。<br />\r\n快乐是怎么样消失的呢？那个无忧无虑的孩子到底去哪里了？我想不通，我不明白，我只觉得指尖有些疼痛，现在才知道快乐原来也是会伤人的，这天真的童趣在我这破败的一生中显得少见而珍贵，我想是不会再有了。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/05<br />\r\n自嘲也许也是自卑的一种吧，在别人指出自己的弱点之前先把自我贬低一番，这样他人的批评也就是“自我反思”的一剂辅药罢了，以此来宣誓自我的主导权，也免得自己不那么尴尬。这种自嘲就和舔舐伤口一样，实际上无用，但是甜蜜的鲜血流进唇齿之间时能品到一种满足的滋味，作为痛苦的调剂。自己虽然也知道有缺点、有问题，但是是难以去纠正的，便摆出一副“啊对对对”这般的态度，不过也是应该比被人指出便暴跳如雷要好得多的。极强的自尊也许会使自己很愤怒别人指出自身短板，在时间久了之后，发现自己终不能改正，这种自尊便化作一种自卑了吧，锋利的尖刺就在世故的雨水中慢慢的侵蚀掉了。<br />\r\n今天感觉没有那么emo，也许是回光返照吧，也可能是用一天虚假的努力欺骗了懒惰的自己，得到了一丝宽慰吧，所以也就随便写写，我想这事是不能放弃的，因为我已经蹉跎了太多，这小小的玩乐也许能作为我极少的坚持吧。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/06<br />\r\n如果我能开花，<br />\r\n我会在清晨和太阳耳语，<br />\r\n我会在夜晚和婵娟摇曳；</p>\r\n<p>如果我能开花，<br />\r\n我会把思念揉碎在风中，让他携着我的愿望，飘向远方；<br />\r\n我会把诗意溶化在雨中，让她裹着我的烂漫，浸入大地；</p>\r\n<p>如果我能开花，<br />\r\n我会把花瓣葬在泥土中，回馈他的恩德；<br />\r\n我会把芳香散在世界中，歌颂她的美丽；</p>\r\n<p>如果我能开花，我将带着马头骨一起葬在海中央；<br />\r\n如果我能开花，我将偕同蒲公英一起散在风中央；<br />\r\n如果我能开花，我将绽放一朵血色的玉英。</p>\r\n<p>每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/07<br />\r\n人类的SNP排除体外后通过马桶可以全部链接在一起，为什么人类内心的想法不能通过马桶连在一起呢？是因为其实人类只痴迷于肉体的链接，而不在乎心境的联通吗？<br />\r\n如果可以的话，我要造一个大大的马桶把所有的心理SNP收集起来，把大家全部连接到一起，就用这条链接彼此的管道，贯穿你我之间的壁垒吧。就算是为了我，对全人类的内心使用发光马桶吧。<br />\r\n补充：snp可能是最接近人内在的东西了，想要理解人的内心就去理解snp吧，比良坂曾云“你连心爱的女人的大便都不敢吃，还敢说爱她”，相必背后也是有着这样的哲思吧。(<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/08<br />\r\n生活大多都是苦闷，羊只顾着食草，至于草是经过怎样的艰难他是不顾的，在人生的创作中你我虽然是作者，但是很多时候剧情没办法自己做主，名叫老天的混蛋编辑总是喜欢安排一些稀奇古怪的操蛋情节，嘛，迫于种种的无奈，我们也许只能在这苦闷中自己去创造快乐了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/09<br />\r\n人生最大的痛苦不是整日都只能陷在悲伤之中不能自已，而是无悲无喜，面对残酷的现实精神和肉体都被摧残的麻木，一切的动荡都激不起涟漪，无论是福是祸都无动于衷。<br />\r\n在这样悲喜不加的琐碎平常中我已经渐渐看不清曾经的影像，他慢慢的从我枯燥的生活中消失，没和我道别。他也许就和我一样自私吧，自顾自地离开，而我自顾自地放他走了。我们在这无法言说的默契中被分离了，自他走后我常常忘记了这梦幻的过往，但我有时又会猛地记起，这段记忆就像夏日傍晚时映过窗户的那束橙黄的光——我是记住了的，但却真真地忘记了。<br />\r\n“1997年过去了，我很怀念他。”<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/10<br />\r\n上天曾赋予我天真的秉性让我能发现生活中的快乐，但是现在他想收回这份馈赠，于是便用残酷的现实一点一点磨灭我的心智，但是我不想放手，因为我会再也找不到快乐。<br />\r\n可无论我放不放手，都已经不再快乐了，这个世界有太多的难题我解不开了，有太多的问题我不会了。也许我真的不行，但是我不想承认，我知道认输很轻松，但是一旦低了头就再也抬不起来了，我的自信就像在一把锉刀下一点点的磨碎了。不能再像曾经的那个中二的少年一样冲着一无所有的广袤世界大喊了，那样豪言壮志的盛情已经不再了，如今只有被现实打败的萎靡和颓废了。<br />\r\n他朝着被夕阳映红的世界大喊，回应他的只有随风起伏的草场和远处寂静的校舍，但是其实他并不在乎有无回应，他只是想宣战罢了。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/11<br />\r\n我想喝可乐，碳酸充斥口腔很奇妙，因为很好喝所以很想喝，但是妈妈说不健康呢，而且已经很晚了，所以不能喝呢。如果我有钱的话我会买一瓶可乐，最好是冰的，但是我没有，所以我很想喝可乐。<br />\r\n我想如果我长大了就可以喝可乐了吧，但是浑身脏兮兮的大哥哥却说不要长大会很痛苦呢，大哥哥说话很有趣人也很好玩。有时大哥哥会拿一个红色的大罐子和我炫耀说多么好喝，但其实是我知道的，那是他在绿色箱子里找到的，因为我看见过别人偷偷把罐子塞进去，也许大家和大哥哥早就商量好了，在玩找宝藏游戏吧，但是大哥哥每次都不让我找，他总是一个人找，好贪心啊。大哥哥每次都会和我说可乐有多么好喝，但是我一次也没看过他喝过，大哥哥到底有没有喝过可乐呢？<br />\r\n大哥哥常常躺在广场上的长椅上，他总是给我看到他在绿色宝箱里发现的宝藏，有园的有方的，又蓝色的有白色的。他总能掏出我没见过的东西，我想他应该是个探险家吧，但是他很多时候总是阴沉沉的而且不准我叫他大叔；他有长长的头发却是大哥哥呢，好奇怪啊，但是却很有趣，可能长大的世界就是这么好玩吧，也许大哥哥是怕我和他抢可乐喝，才害怕我会长大吧，大哥哥好小气啊，我会分给他喝的，因为可乐很好喝所以没问题的。<br />\r\n不过妈妈不让我和大哥哥玩，说什么他很脏，可是他的眼睛明明很干净很漂亮啊，为什么妈妈会说很脏呢？妈妈说我长大就明白了，看来还是要长大的，但是大哥哥不想让我长大，为什么呢？这也要我长大之后才明白吗？那我还是快点长大吧，因为我想喝好喝的冰可乐啊。<br />\r\n我到底喝没喝过可乐呢……</p>\r\n<p>其实我就是大哥哥，而写下这些文字的也是我，充满童趣的我和沧桑的我是我的两面，最后一句是我和大哥哥一起的感叹。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/12<br />\r\n今天大哥哥没有来，我也没有喝可乐，大哥哥去哪了呢？大哥哥说过他曾经也是有梦想的，但是不知怎么的就变成浑身破破烂烂的样子了，然后梦想也走丢了，梦想是什么啊？我不太清楚，大哥哥是因为有梦想才会破破烂烂的吗？我也经常做梦，我也会变得破破烂烂吗？变得破破烂烂是不是可以变得和大哥哥一样去冒险了呢？<br />\r\n今天没见到大哥哥，心中有什么奇怪的感觉涌上来了，大哥哥今天应该是到新的地方去冒险了吧，不知道他明天会不会回来。<br />\r\n大哥哥今天还是没有来，是迷路了吗？还是被新的冒险吸引了？不会是一个人偷偷去喝可乐了吧？<br />\r\n……<br />\r\n大哥哥已经一周都没来了，也许他不会回来了。我想他可能是去找那个走丢了的梦想了，如果是这样那大哥哥就是我的梦想，因为他和梦想一样都走丢了，等有一天，我也去找大哥哥吧。<br />\r\n大哥哥究竟喝没喝过可乐呢？<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/13<br />\r\n大哥哥回来了，但是我没有问他前几天去了哪里，就像我没有问他从哪里来，他也没有说去了哪里。他没什么变化只是身上的衣服换的更轻便了，白色的短袖已经变得灰黄了，他好像很没有精神，我和他打招呼他也只是木讷的回应，他是怎么了呢？大哥哥变得和其他大人一样了，总是面无表情、无精打采的样子，可能只有拿红色的可乐罐才能把他明亮的眼睛变回来了。也许大哥哥只想快乐，但是繁重的现实令他无法超脱，难道源自内心的欢愉只能依借外物来所求吗，难道精神的享受只能由物质带来吗……我想不是的，但是精神的交流和思想的碰撞是难得的追求，所以我只能用物质的华丽和感官的疯狂哺乳我混沌的精神。<br />\r\n所以，我想喝可乐。<br />\r\n大哥哥究竟喝没喝过可乐呢？<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/14<br />\r\n今天是阴天，我一如既往的去广场找大哥哥，大哥哥一如既往的瘫坐在长椅上，他灰暗的眼睛里映着被天空压得蒙蒙的广场，蓝色的建材旁没有曾经嬉戏的孩子们，只有略带潮湿的风抚摸着我的脸。大哥哥没有理我，自顾自的唱起了歌，但我听不太清，不知道唱的什么，他萎靡地神往、我无措的徘徊，很快淅淅沥沥的雨散在我的肩头，我转头逃走了，我可耻的遁走，我又羞愧地回头望去，大哥哥已经不见了，我有些怅然地走在雨中，唱起了歌。<br />\r\n“没有花香，没有树高，我是一棵无人知道的小草……”<br />\r\n下雨天很凉，所以我自是又一天没有喝到可乐的。<br />\r\n大哥哥究竟喝没喝过可乐呢？<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/15<br />\r\n我是新时代出土的崭新古老废柴，在泥土捏住的废墟中起身后，在绚丽的装饰中不知所向。一面是小县城日趋衰败的丧钟，一面是城市钢筋的逼近和霓虹的威慑；一面是无所适从的现实破烂，一面是歌舞升平的虚拟狂欢；一面是家庭崩塌的通牒，一面是生存无计的惘然；我和马大帅一样在这个崭新的世界无处藏身，生活的琐碎片片地压在头上，无处藏身、无地自容；被迫在这个混沌的垃圾堆里左支右绌，希望能找到点活下去的办法，可迎来的只有广厦高楼里传出的欢乐，连一生讥笑都没有、没有回应就是世界给我最后的回应。我面对宏大时代产生的困窘太大了，大到我不知道怎么形容、我不知道怎么表述内心的感受，但是这种困窘又太小了，小到别人看不见他。<br />\r\n”而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。“<br />\r\n也许唯一幸运的是，迫于我的精神状态和身体原因，至少还有人能对我展露出一丝理解的姿态，不知是自愿还是出于道德的被迫，想到这里我更加悲伤了。如你所见，宽容和理解也可以作为伤心的利器，温柔和体贴也会带来痛苦，而咒骂和拳脚更不必言说。我想我病了，我在最嘈杂的时代失声，我在最杂乱的树丛迷路，我，一个崭新出土的时代废柴。<br />\r\n“那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。我来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。”<br />\r\n这一天，我23岁，在我一生的黄金时代，我有好多奢望——<strong>我渴望死亡</strong>。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/16<br />\r\n在无数次的失败中我知道的，其实是我自己的问题，怨不了天也怨不了地，“废话，你不过不是你的问题，还是我的问题吗”，也曾无数次的被讥笑过。人生也许就是这样吧，在浑浑噩噩中就突然直接没有了能前进的路，我的生活就像窗外黑沉沉的天气一样，已经走向了全部哒咩的end了。在这场没有鲜血的残酷竞技中，输家是没有发言的权利和表演的镜头的，我走在自我否定的螺旋中，在如海般的寂寥中下沉。我不害怕挑战，我畏惧失败；我不会失败，因为我总有借口。借口是一把刀，用它来逃避，用它割碎我的梦。我是人生的懦夫，我是战场的逃兵，我是竞技的输家，我是新时代鼓钟旁最丑陋的尸体。<br />\r\n我已经死亡。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/17<br />\r\n我好像做了一场梦，<br />\r\n在混沌的梦中我看见有人刨开垃圾堆寻找着残羹冷炙以求果腹，有人倒在街头红色点缀天空，<br />\r\n在糜乱的梦中我看见贵族门阀极尽奢华，<br />\r\n在无助的梦中我看见一个人茫然的站在风中眼神中无悲无喜，<br />\r\n在无尽的梦中我看见一个个荒诞的轮回，一股股鲜血浇筑这片大地，可是没有什么神迹，这炽热的血很快就被衣冠禽兽的虫豸吸食干净了，<br />\r\n在衰败的梦中我看见一个个消瘦的皮囊，<br />\r\n在梦中我看见了一场梦，在朦胧中我依稀听见不能言说的蛊惑。<br />\r\n在这荒诞的梦中我醒了过来，看见了一场真实的梦。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/18<br />\r\n梦幻的灯光在淅沥的雨水映衬下更外动人，<br />\r\n今夜天空没有月亮也没有星辰，面对这美丽的人类荣光，他们自然是羞愧的躲起来了，<br />\r\n水浸的马路映出如幻般的城市炫丽，耸入云宵的是无法逾越的高塔，<br />\r\n现代的奇迹循着古时的悲哀螺旋上前，<br />\r\n但这一切的磅礴都是他的背景，他从那灰暗的角落露出身来说<br />\r\n“城市的绚烂霓虹照不到我们的黑暗生活”<br />\r\n是的，无论远处的光多么妖艳，无论多少个日夜在天空上接力，这残破的窟洞也未曾见过一丝光明。<br />\r\n上个世纪一个孩子对父亲说想成为艺术家被暴打了一顿，这个世纪一个孩子想成为艺术家却没有道出，时间的分界就如同一面镜子照出相似的彼此，我们怀着同样对理想的执着，然后被生活打击到失去对一切的热爱，在无数的悲天悯人后激发出愤恨与悔过，昨日的夕阳是今朝的晨光，今日的余晖是明早的梦想。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/19<br />\r\n世界总是充满着变化，把自信好强变为偏执自卑，生活的作弊就在于把困苦转嫁旁人，在从襁褓中慢慢褪去外壳面对这疯狂的一切时，正常的精神认知早就沦为玩物，巨大的手抽离矫造着癫狂的心智，若如是亦无需置论，却有得意者假借他人的痛楚予以调味，痛苦后深层的哀伤他自然是不懂的，只觉得好玩消遣罢了，我的肉体、我的精神、我的心智都被这疯狂的世界夺走，而这躯空旷的泥瓦罐也只能装满癫狂的海水。<br />\r\n把我的一切还给我，还给我吧，那年轻的亲人，那些离去的人，那无忧无虑，那个没有丑陋伤痕的我，我会在那最美的瞬间按下暂停，哪怕这是永恒的死寂，也比这无尽的疯狂来的更有意义。<br />\r\n“因为再往后就是只有失去的现实”<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/20<br />\r\n坏了，把每日一句给忘了……就连这么重视的事情都在昏昏度日中忘却了，我想我没什么可以辩解的了，之前那么忙都想的起来，现在休息了一天反倒忘记了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/21<br />\r\n我不知道是我萎靡的精神导致我诸多的失败还是我那不顺的过往导致我失去活力，我唯一能确信的就是在这个疯狂而糟糕的社会中，我的失败和顿挫不会就此止步，目光所及的未来是一片狼藉，在他人蓬勃一生开始的年龄，我的生命已经所剩无多，迎来的并非接近疯狂的不甘，反倒有种解脱的释然——终于能从这混沌中离开了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/22<br />\r\n我的人生就和我破烂的电脑一样，也许在某一天，就突然开不了机了，光怪的屏幕里堆满着无用的别人毫不在意的垃圾，这狭小的窗口成了井底的死尸观望广阔天空的井口，可笑的是我的电脑可以因为莫名其妙的原因黑屏宕机，我却卑微地不敢指责他；而我荒诞的生活已经不能继续却仍要强撑，我却严格的咒骂着自己。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/22<br />\r\n我是如何的失败我自是清楚不过的了，我是如何的无能导致我这般的颓丧，在这场只有lost的游戏当中，会有人乐在其中吗？我只是找不到完美的退出方式，却又没有直接关闭电源的勇气罢了。<br />\r\n我当然知道自己多么可笑，我当然知道自己是如何的软弱，用结束去要挟一切就是我最大的勇气，我不过是一个疯狂的病人，在试验田的舞台上做最癫狂的表演，我不配在这个陆离的世界中拥有聚光灯，我只能在底层的泥泞中失去我曾假借的一切。<br />\r\n如果我这极致的失败、这几乎疯狂的精神是独一无二的，是否我也能说自己拥有过人之处，而显得不那么狼狈？如果曾有人和我一样，是否说明我不过如此，而我所相似的那个他是否比我更加悲哀，毕竟我只配做别人的影子，从来都是我像别人，我只不过是后来的低劣、无能地模仿着。我面对这一切真的累了，我想我的Quit就是电源键了。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/23<br />\r\n电脑因为C盘的爆满而黑屏宕机了，不过经过他自我的紧急修复又腾出几个G的空间，彷佛一切都可以继续，只是我不知道黑屏的时间里电脑失去了什么。<br />\r\n如果世界黑屏宕机了是不是第一个删除的就是我呢？之后的一切都会照常进行但是不会有我了，而世界应该也不会在乎。<br />\r\n电脑比我更会内存释放，也许他比我更配用电脑？那为什么是我在用电脑？还是我在被电脑使用着用电脑。我不知道，我只能借着胡乱的思考来假装对生活的深思，用故作高深来麻痹自己的浅薄。<br />\r\n电脑黑屏宕机能修好继续，我的生活可以吗？我能修好他吗？或许根本就没有修好只是出卖了什么东西而我并不自知罢了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/24<br />\r\n人生的一切可能都会在平常和迷茫中渐渐磨灭，在物理角度看熵增的世界以混沌为食，所以一切的荒诞和疯狂似乎都理所当然，而在这如黑暗般的一切中是曾有过耀眼的光辉的，宛若一颗流行划破漆黑的夜幕，似乎是黎明的到来，而那光亮往往被周围的雾霭所吞噬，“面对我们的骨灰高尚的人挥洒下热泪”，我并不高尚，我的泪是因为惋惜和痛恨。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/25<br />\r\n浸润着都市淅淅沥沥的夏雨，朦胧的雾气蒙上了我失明的双眼，<br />\r\n肉体和灵魂在此刻分割，我昏昏的青春倒进这炫丽的城，<br />\r\n外边是奔波的迫切，里面是梦寐的挣扎，<br />\r\n我在月光铺就的路上疯狂的向前奔跑，<br />\r\n甩开身体、甩开安睡、甩开梦想、甩开月亮，<br />\r\n在这个千年之月和都市夜灯共同辉耀的雨夜，<br />\r\n我甩开自我，奔向月亮。<br />\r\n在月亮上，我抱着干瘪的红薯，离月亮越来越远。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/26<br />\r\n原来快乐也使人堕落，所谓生活就是在一团混乱不堪的琐事之中挣扎，最终结束的过程。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/27<br />\r\n生活的痛苦就在于，处在毫无新鲜的平静中疲于奔命。人们渴望改变却又不希望动荡，人们希望安慰却又不希望枯燥平常，每天的生活就像一条可以看见的、逐渐平缓的线，渐渐的没有波澜、没有改变的可能，一切都走向热寂。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/28<br />\r\n在不舍和茫然中踏上了旅途，途中我看见拉满羊的货车，货车上的羊在想什么呢？我和羊有什么区别呢？我们都在无形的压力下被迫登上这辆不知终点何方的列车。最终的结局都是被残酷的刀屠戮殆尽，我想我和羊是没有区别的，想到这我不仅的发出”咩“的一声。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/29<br />\r\n我悲哀的一生还未开始就已经结束，别人的起点是我一生都难以企及的高度，人生就在一个个不知不觉慢慢的错开了，等意识到时已经无可挽回，别人都在一步一步的积累着成功而我一步一步地迈向失败，面对我一团乱麻的生活我只觉得悲哀和无助。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/30<br />\r\n在旁人每日的伟大进度推进时，我无忧无虑的快乐时光就一天天消耗了。我曾经是开放世界里那个无忧无虑的孩子，每日在和煦的阳光下踏上去学校的乡间小路，但是残酷的勇者一天天坐着篝火，我不多的童年急速地消失了，我只能看着我变得不再快乐，烦恼和忧愁日益增多，但我什么都做不了，因为这个过程叫做长大，在长大的过程中我要独自面对一个藏在安全屋外数年的劲敌叫生活。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/31<br />\r\n人与人之间的差距实在是太大了，这巨大的鸿沟令我难以逾越，他人数倍、百倍于我的智慧和实力地位，我所有的一切别人只不过弹指之间，而我唯一的成就只有拼命地活着。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/01<br />\r\n第一步:沉淀。<br />\r\n第二步:那场寒冬毁了我的游戏梦。<br />\r\n第三步:黑作坊也能做游戏。<br />\r\n第四步:两年换皮游，一生氪金情。<br />\r\n第五步:游手好闲也是游！<br />\r\n第六步:Steam我想你了。<br />\r\n第七步:独油炒粉。<br />\r\n第八步:城管太凶了，独油地摊。<br />\r\n第九步:经济不景气，独油代驾。<br />\r\n第十步:吊销驾驶证，碧桂园五星上将<br />\r\n第十一步：指点天天打游戏的业主，欺负骗氪的策划狗，遇到危险全身而退。<br />\r\n第十二步：若Jam召必回。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/02<br />\r\n我好像丢了什么东西，或者缺了什么东西，但是我不知道那是什么，我想我找到它一切都会好起来，但是我都不知道那是什么，我只是茫然。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/03<br />\r\n分别的日子日渐近了，我不想那一天到来，却无法阻止，这就是生活、这就是长大，不再无敌，事情不再和美好的想像一样。但我不会忘记，我是活在过去的人，所以我不会忘记。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/04<br />\r\n相聚的时间不多了，结束的那一天一步步到来，我不能阻止这别离，也看不到未来的希望，渴望着更好的明天会到来，但不论我的期望如何混沌的未来终将如期而至，“正义会在正义的终点等着所有人”。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/05<br />\r\n现实不能靠勤劳致富，所以我想在游戏里满足一下这个心愿。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/06<br />\r\n今天是个沉重的日子，不仅因为分别的日子更近了，还有一位同系的同学和这个残酷的世界做了最后的悲惨的告别，生命的沉重和死亡的压抑在这一刻涌上来心头，强权和威压摧残了一条鲜活的生命，我曾想人终是要积极的面对生活，迎难而上的，即便结果是惨败，这样的冲锋至少能让自己以英雄的身份离开；然而残酷的现实是脆弱的身心可能根本抵不住生活的压力和强权的逼迫，稚嫩的生命所留存最后的坚强只有纵身的勇气。<br />\r\n我不配去理解，我只感到悲伤，希望每个人都能拥有美好的生活，希望每个人都能有幸福的明天。<br />\r\n也许之后，他们会给你看论文、帮你改PPT、平台审核第一时间进行，但这都是因为有鲜血来过这里。正义会\r\n找到的，一 直沿着海 滨找到他的终点。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/07<br />\r\n回到学校这几天总是打游戏，完全无心学习，明明自己的人生已经是一塌糊涂却还是一副等死的样子。我这样的人注定是一团垃圾。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/08<br />\r\n我以前一直不懂克苏鲁，现在我明白了我的克苏鲁就是生活当我看见他是，那无法用语言描绘的疯狂就充斥在我的大脑中。我处处低人一等没有人认可我，我就是一条处在社会底层的虫子，面对这样的现实我陷入深深的自卑，我想过改变却没有成效。这混乱疯狂的一切，血淋淋的才是现实，幻想和谎言所修饰的只是最悲惨的故事。</p>\r\n<p>2023/06/09<br />\r\n一切都要结束了，我最美好的过去就要画上一个句号。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/10<br />\r\n离别总是匆匆，形形色色的人各自奔向自己的前程，回想我的当今犹如一团烂泥，我做什么事都是半成不就，烂透了的样子，这样满身疮痍的我将要迎接一段注定会满是烂泥的人生，我想不如轰轰烈烈地死去来的痛快一点，在我这样胡思乱想时，离别的匆匆又渐渐地近了。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/11<br />\r\n我只能说个人的职业选择和社会环境密不可分，每个人的选择都情有可原，但是可悲的是九品中正制，各大门阀家族互相举荐，构成自己错综复杂的利益网络，朝廷官员冗余等问题，大清已经烂透了。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/12<br />\r\n我转过头去没有看他，我坐在共享单车的座垫上，看着这个颓唐的小镇中心，脑中不知道在想什么，却又感觉有万般思绪涌上心头，我盯着天空，不知不觉地就留下泪了，从此一别我想不会再见了，他会有新的朋友，新的美好生活，我的好朋友又一个离我远去了。我哭得更伤心了，我想这就是分别的感觉吧。今晚的小镇一如既往，没有什么新鲜的事发生，只有一场无可奈何的雨，在月光满轮的晴夜落下。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/13<br />\r\n所有年轻的人啊，不要长大，所有年轻的人啊，不要让生活夺走你的梦想，所有年轻的人啊，不要成为我这样的人。<br />\r\n所有年轻的人啊，长大是件悲伤又无可奈何的事，长大意味着你不再无所不能，曾经的无限活力都变为深深的无力，长大意味着生活很可能会夺走你的梦想，长大意味着你可能会不再是你自己，意味着你可能会成为自己最讨厌的人和那场美好祥和的梦越走越远。<br />\r\n所有年轻的人啊，不要长大。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/14<br />\r\n分别和重逢相冲突在这一刻我不知道是该悲伤还是快乐，我的心中充满无措，我其实一直都是个天真的孩子，本就没准备好去面对这一切，生活不像game那样有趣还可以重来，面对未卜的多艰和枯燥的死寂，我每每消沉，这欢聚只是短暂的，离别又近了一天，欢乐和悲伤浇筑出一杯苦涩的酒，我的脸上没有了表情。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/15<br />\r\n回到这最温馨的地方，我终于感到了放松，哪些令我烦恼的、令我悲伤的我仿佛都看不见、听不到了，在这短暂的快乐的时光中，我应格外珍惜，因为这美妙的一切都将要离我而去，这曾经最不以为然的平常，从今往后也许就是我最大的奢望，我爱你我的爸爸，我爱你我的妈妈，我厌恶它这可悲的生活。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/16<br />\r\n时间总是无情，岁月给心爱的人平添了伤痕，看到她瘦峋的样子和手背上青色的血管、白色的胶带，这个面露苍老的人已经不再年轻了，我所爱的人都回不去了，我最无忧无虑的快乐日子也不在了。每感时光飞逝的无力，才知亲情的可贵，回家的路上我想说“我大姑老了”，但我终究没说出口，我极力让自己不去思考、不去悲伤，我想我的父亲会说“别太愁了，儿子”，而我会回道“你也是”。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/17<br />\r\n有时提笔真不知道写些什么，但觉得这写些东西的习惯自是不能丢掉的，毕竟已经别无什么长处，唯有这一点还能作乐给自己些许的开脱，也算是一种倾诉，不过没有人聆听罢了。最近都在打王国之泪比较放松，没什么思考，没什么感伤。只是觉得王国之泪很有趣，玩起来很忘我，但是再也没有当初第一次玩旷野之息的震撼来的猛烈了，倒不是麻木我想，应是自己“脱敏”了，见识到的也有些了。所以智慧、快乐、财富对大多数人而言其实并不是能全部得到的，不过像我这样一无所有的倒也是少见，也许我可以领个勋章，毕竟在这个物欲横流的社会中，我也是个不小的珍稀物种。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/18<br />\r\n“公道不在人心，是非在乎实力”——《笑傲江湖·东方不败》，正义和公道只是小孩子的游戏，在这个世界上那只不过是可遇而不可求的奢望，在这波涛滚滚的江湖中，有太多的不公了。天下英雄又有几人能够笑傲江湖呢……<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/19<br />\r\n我喜欢下雨天，因为可以随便哭，雨落在脸上也没人知道那是我的眼泪。<br />\r\n每日Emo小短句，我们明天再见。<br />\r\n句子不在多寡，兵刃不在长短，功力一到，便可力通人心。</p>\r\n<p>2023/06/20<br />\r\n我知道的，在雨里能蒙混过关的只有我糟糕的人生，想流泪的话就放声哭泣吧，即便是阳光万丈的日子。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/21<br />\r\n我觉得自己再一次放松了，沉浸在混乱的日子中，这种生活就像是沼泽，不知不觉越陷越深，想改变却做不了什么。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/22<br />\r\n有时候隐瞒是一种让事情更混乱的方式。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/23<br />\r\n也许现要承认自己的无能不足才能更好的前进，每日的emo感觉更像是命题作文了，思考一些东西，然后记录下来，也算是一种对写作的锻炼吧，不过断然不是日记的，这种东西还是太……做作了，最近没有什么灵感，也很少思考，所以笔下也都是些鸡毛蒜皮了。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/24<br />\r\n一味地恐惧担忧未来是愚昧的，“不看当下而盼未来，不看未来而盼过去。”，恐惧来源于未知，而未来永远未知，原地踱步永远无法克服这种担忧，而解决这种忧虑的方法就是行动，基于当下去行动，总是思考担心并不能让我们认清未知，只有一步一步地向前迈进才能揭开未知的面纱，把曾经的忧虑变为当下或过去的不足为奇；当然不是说毫不思索上去蛮干，而是要有一个核心的思路方针，所有的行动都依赖于它，并在实践的过程中不断修正，我想大概应该是这样的。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/25不看当下而盼未来，不看未来而盼过去。<br />\r\n如雷灌顶，我就是一个怀旧的人，总是回忆过去，对现在麻木，对未来迷茫，我一直觉得我的生活充满了绝望，想做什么都不敢开始，也没有坚持，也不知道自己怎么就变成了这个样子。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/26<br />\r\n我终于知道梦想在生活面前是多么无力\r\n梦想只是自我的虚幻，而生活是庞大的真实，这份真实的重量无比沉重，它变成一个黑洞吞噬了所有的一切。<br />\r\n这是我在家的最后一个日子，也是我最后的无忧无虑的日子，面对我最爱的父母和未来未知的生活，我的眼泪止不住的流。<br />\r\n我不知道什么毁了这一切，然后把它灌满了悲伤。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/27<br />\r\n后来我才懂得那些我不曾理解的文字背后的含义，当再次回想时都有了不同的感觉，可惜的是人很难跨越地成长没有经历便没有体会，我终于明白了初读不识文中意，再看已是剧中人。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/28<br />\r\n我的父亲中午只点了一份白米饭加小葱拌豆腐，这洁白的一餐就如同他洁白的一生，我想说“你怎么不多点几个菜”，但我想我是没资格说的，彷佛他少吃了一些这个举步维艰的家就能多往前走上那么一步，我想了良久不知道说什么，只能打出一串省略号“……”。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/29<br />\r\n我来到这陌生的城市看见了不同的人，有暴躁吼人的大巴司机，和对我网开一面的保安，和提示我的路人，收留我过夜的华莱士服务员，帮助我使用优惠的店员以及想帮我省钱的打工小哥，和太阳下辛苦的外卖员，在这里我看见了各式各样的人，在这里我看到了那么多我不曾看到的。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/30<br />\r\nBefore was was was, was was is.<br />\r\n逝时曾是时。<br />\r\n一颗玻璃球在液压机的压力下可能会瞬间粉碎，但若是一把玻璃球那是击不碎的，一个人也许抵不住那可怕的压迫，但是千千万万的人民群众团结起来时一切的压迫都不足为惧怕。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/07/01<br />\r\n茫然地走在这陌生的街头，世界上的一切都和我息息相关却又毫无关联，我找不到未来，只觉得生活的悲哀。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/07/02<br />\r\n我不懂得这陌生的一切，我所了解的只有我卑微的生活，机遇被乌鸦叼走，苦难留我独自品尝，不甘和焦虑灌注满我的心头，我的泪已经不再流，时代飘落在人上的从来都不是一颗沙，只不过是有的人在山顶而我在五行山下。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/07/18<br />\r\n如果死亡，也许会有人为我流泪；<br />\r\n如果死亡，也许会有零星的人感伤；<br />\r\n如果死亡，也许会有人诧异；<br />\r\n但是，我仍苟延残喘，<br />\r\n活着，便没有人去关心；<br />\r\n活着，便没有人开始理解；<br />\r\n活着，便没有死亡。<br />\r\n活着，便是死亡；<br />\r\n所以死亡不必落泪，因为我曾获得了悲伤。<br />\r\n每日Emo小短句，我们会再见吗？</p>\r\n<p>2023/07/21<br />\r\n我小时候总是幻想未来的自己会穿越回来把我杀了，现在我才明白，如果我回到过去，可能会哀求小时候的我把长大的我杀掉。<br />\r\n每日一句emo小短句，我们有缘再见。</p>\r\n<p>2023/07/25<br />\r\n我走到路口，落日低垂和红色的灯光相得益彰，零散的人整齐地插在路旁，头垂进手机里。<br />\r\n在这规律的耕作旁倒也是有别样的风景，一辆黄色的环卫三轮，上面有四五个大叔，皮肤已经变得褐黄了，我偷偷看着他们，假意望向空荡的路口，目光触及到围栏里的楼，就在这落日下他们望着西边的远方，我望着繁华世界中的荒凉，然后灯变绿了。<br />\r\n每日一句emo小短句，我们有缘就会再见。 2023/08/04<br />\r\n初中读《我是猫》时倒也谈不上多么被惊艳到，现在唯一能回想起来的就是，那个在猫眼中一切祥和安适的氛围。<br />\r\n如今我却真真切切地想变成一只猫，我不知道我是否怀着和夏目漱石一样的心情，但我总会回想起那个夏日慵懒的午后，翻开那本厚厚的书一页一页地读着，那时候我应该没有那么多烦恼，回忆为房间铺满了温柔的阳光，眼中的一切只是宁静和美好，就像那只猫一样。<br />\r\n夏目漱石先生，我想变成猫。<br />\r\n每日一句emo小短句，希望陌生的你可以像猫一样，充满童真和快乐，我们会再见，哪怕你不记得我。</p>\r\n<p>2023/08/08<br />\r\n生活也许会欺骗你，也许会愚弄你，你可能对一切都感到绝望，但是别像我一样沉浸在悲伤中妄想活着的感觉，爱自己，我的朋友。<br />\r\n每日一句emo小短句，我们偶尔见上一面吧</p>\r\n<p>2023/08/11<br />\r\n苍天已死，黄天当立。<br />\r\n岁在甲子，天下大吉。<br />\r\n今天偶然看到了13年的一个交友贴，我仿佛能看到有一群拥有共同爱好的人聚在一起，那热闹的气氛，但9年过去曾经年轻的人可能已被生活催的岁月已老，不禁感叹这群互联网遗老会不会偶尔怀念过去，是否我们曾怀着同样的心情看过去、望未来。点开这崭新的古老链接时，能看到的也不过是独属于那个时期的一个又一个有趣的灵魂罢了。但是也可能由于重拳或压力，现在望去，曾经热闹的讨论版如今也不过是纷繁混乱的网络世界中，又一个少缺人烟、落满时代尘埃的犄角罢了。<br />\r\n每日一句emo小短句，神马都是浮云。 2023/08/20<br />\r\ncheems早就不是表面上那一只普通的柴犬了，<br />\r\n我认为这是一种文化现象或者浪潮，他已经成为了一种意象，其中最为珍贵的是cheems浪潮传递的那些思想和被人们带来的激励、感动。<br />\r\n当他被遗忘时，才是他真正死亡的时候。<br />\r\n存其意而忘其形，如果你活着你早晚都会死，如果你死了，你永远都活着。<br />\r\ncheems的离世无疑是一件让人悲伤的事，但是我会记住这一切。</p>\r\n<p>见过互联网的波涛汹涌后，已经习以为常，光怪陆离、充斥着荒诞的新世纪发生什么都不足为奇，在这个美妙而不知所向的时代里，我被赋予了一颗石之心，麻木地感受着无数的悲与喜。<br />\r\n每日一句emo小短句，今日突袭群友！劫营速战，措手不及。<img\r\nsrc=\"D:\\biancheng\\Blog\\source\\imgs\\每日Emo小短句\\F1SZC9%7DW%7D_XEA5S%5D5FCJM3.png\"\r\nalt=\"img\" /></p>\r\n<p>他们都太优秀了，优秀到被照到的我居然以为自己也能成为一颗星星，突然有那么一天就被随意的聊天惊醒了，什么星星啊，原来我还是那个在下水道里发臭的垃圾啊，如今切实地体会到那句话了“天才这种东西，常会不自觉地将周遭的人卷入，然后弄得遍体鳞伤。越是靠近，越会被撕裂成碎片。”，等回过神来时已经菠萝菠萝哒了。</p>\r\n<p>2023/09/01<br />\r\n\"我爱你。\"<br />\r\n你可能觉得奇怪，也可能感到突兀或者冒犯；但是有时人们之间确实会有那种莫名的憎恨，甚至没有任何理由，所以我想人和人之间也会有这种不需要理由的爱。可能这种爱并非是深入骨髓、刻骨铭心的海誓山盟，更像是一句寻常的关心，哪怕是一种冲动。<br />\r\n然而，如果这份爱是虚假的，那我希望那莫名其妙的恨也失去意义。<br />\r\n每日一句 emo 小短句，我们有缘再会。 2023/09/02<br />\r\n触不可及却刻骨铭心，生活的无奈就在每日的平凡中展开，<br />\r\n我们也许都在做着正确的事，但悲哀的是当我们彼此交汇，这本该在时间的河流上编织的诗歌如今只有混沌。<br />\r\n“如果我不直播了 我可能会突然上个厕所 然后再也不回来了”<br />\r\n“泥头车每天还是准点来，只是车上再也没有那个女孩的身影。如果当初知道，应该放下一切，上车，不再回来。”<br />\r\n“圣地亚哥在下雨，智利别为我哭泣”<br />\r\n每日一句 emo 小短句，我们有缘再会。 2023/09/04<br />\r\n狗彘食人食而不知检，途有饿殍而不知发<br />\r\n指望资本主义的走狗良心发现简直是异想天开，为自己徒增烦恼，要明白谁是敌人，谁是朋友。<br />\r\n团结一切可以团结的力量，打倒所有的敌人。 2023/09/29<br />\r\n爱而不得才是常态，充满遗憾就是人生；<br />\r\n壮志未酬不过稀松平常，苦海无涯乃是我的命运。<br />\r\n“试问天下英雄又有几人能够真正的笑傲江湖呢”<br />\r\n我原以为自己这卑劣的样貌不过是不讨喜，对于旁人也不过是稀松平常，没想到自己竟然如此的令人恶心。在这昭然的事实后展示出的是这场淘汰机制的生存竞争，从古至今一刻不停。可悲的是，无论你赋予生命怎样的意义，在这场追寻宇宙真理或生存真谛的比赛中，败者只能是一无所有，直至死亡，所有的思辨最后恐怕都是自我安慰，一次名为自我欺骗的“和自己和解”。<br />\r\n在这场比赛中，我从来没有获胜过，我只是个loser\r\n所以我恨，我的立场不是中立，因为我尝尽了悔恨、嫉妒、憎恶的滋味，那必定不是甘甜的也不是苦涩的，而是刺痛。<br />\r\n每日一句 emo 小短句，我们有缘再会。 2023/09/29<br />\r\n当我蜷缩在这大到无边城市里阴暗的一角时，我想起了那句台词<br />\r\n“我要这满城的人都来陪葬”<br />\r\n“千里皇城尽作焦土”|<br />\r\n我仿佛能理解李儒的焚城决策，但我没有那样的智慧，我只有偏执的疯狂。<br />\r\n每日一句 emo 小短句，我们有缘再会。 2023/10/06<br />\r\n有时候我们耗尽一切都得不到自己渴望的东西，其实这才是生活的常态，长大的世界就是求而不得、学着放手；不知不觉我们都不再是那个哭哭闹闹就能得到冰淇淋的小孩子了，那种无忧无虑的时光最后只能成为宝贵的回忆，让我们在痛苦的现实中去怀念、去流泪。<br />\r\n不过我没吃过冰淇淋。<br />\r\n如果不用上班是否所有的悲伤都会变作欢乐呢？<br />\r\n今日 emo 能量赞助来源，歌曲《Duvet》，演唱者 Bôa\r\n，别名《TVアニメ「serial experiments lain」OP1テーマ》，收录于《Tall\r\nSnake Ep》专辑中。(就是《Lain》的 OP 哦)<br />\r\n每日一句 emo 小短句，我们有缘再见。</p>\r\n<p>2023/10/15<br />\r\n从互联网文学，到农村纪实(在如今这个城市化程度很高的时代，还有人去关心乡村去记录现实，我是表示敬佩和珍惜的)，再到修正主义和牛鬼蛇神，再到过去的抗争记忆，再到古代新学和现代桎梧，还有当下未来的科幻，一切都与我无关，却都发生在我身边。<br />\r\n[图片] 已过期</p>\r\n<p>2023/11/02<br />\r\n清醒令人痛苦，麻木使人沉沦，人记性太好会很痛苦。<br />\r\n每日一句 emo 小短句，我们有缘再见。</p>\r\n<p>弱智吧小集合<br />\r\n敬老院的新人都是老人，这个世界的大人都是小人。<br />\r\n所有的桥都是温暖的，因为他们让河流不再难过。<br />\r\n从我确诊出生的那一刻，我的死亡就只是时间问题。<br />\r\n皱纹是时间吹过身体时泛起的涟漪。<br />\r\n月亮——摘自《星空》<br />\r\n看到花开放时，花就已经在枯萎了。<br />\r\n我的梦想是一对情侣，白天我压的她说不出话，晚上她压得我难以入眠。<br />\r\n我最新的照片是我最老的照片。<br />\r\n生鱼片是死鱼片。<br />\r\n世界是个大象，我们每个人都在盲人摸象，抽象是对世界最好的鞭笞。</p>\r\n<p>2023/11/19<br />\r\n我已经燃烧殆尽了，只剩下雪白的灰。<br />\r\n燃え尽きたぜ…真っ白にな…</p>\r\n<p>如果只能有一个李哥，为什么不能是我李元浩的李。<br />\r\n这可能是你唯一的机会了，小虎。<br />\r\n也就是说，现在是LPL苍蓝猛虎登场的时候了。<br />\r\n昼虎！夜凯！<br />\r\n地虎铠甲，合体！</p>\r\n<p>小虎需要这个冠军来证明自己。</p>\r\n<p>2023/12/15<br />\r\n害，卡姐真的是太惨了，幼年丧母，青年丧父，碰到了戈塔屎，以为是好人结果被坑了。<br />\r\n到博德之门后，她对死去的父母，以前的朋友都是在做死前的最后道别。<br />\r\n在饭店的夜里，她说干净床单的味道能让她想起妈妈，因为她妈妈是一个洗洁工，她畅想假如自己还有50年，未来会有多么美好……<br />\r\n但是这一切注定都是悲剧，逃窜到最不愿回首地狱也不过是在惨淡的命运驱使下痛苦地活着，“再见，大海。再见，太阳。再见。”<br />\r\n我爱你，卡菈克。</p>\r\n<p>203/12/17<br />\r\n如果没有遗憾，我是否还会爱你？</p>\r\n<p>2024/01/08<br />\r\n在最黑暗的晴空万里我为太阳哭泣，如果明天我不再升起，<br />\r\n请别为我忧郁，<br />\r\n如果明天我不再呼吸，<br />\r\n世界请为他人欢愉。<br />\r\n在麻木和壁垒中流浪，清醒让我渴望死亡。<br />\r\n如果懦弱是种疯狂，麻木是否已经渗入我的骨髓。<br />\r\n我渴望哭泣，我渴望结束，我渴望渴望。<br />\r\n每日一句 emo 小短句，我们有缘再见。</p>\r\n<p>2024/01/20<br />\r\n哦，妈妈请别为我哭泣，我们将回到故乡。<br />\r\n读哈马斯的勇敢有感。<br />\r\n每日一句 emo 小短句，我们有缘再见。<br />\r\n神只是人类美好的倒影，至少于我而言，最伟大的是人类历史中那些充满勇气的瞬间。</p>\r\n<p>2024/05/10<br />\r\n原来幻想中反派听到音乐被迷惑困住甚至感悟的情况是真实存在的。<br />\r\n当我听到童年熟悉的音乐才知道自己再也回不到那个，炎热却温暖，茫然却快乐的日子了。<br />\r\n我在熟悉的旋律在忘却了当下，只记得那个温和的午后，<br />\r\n我被这悠扬的笛声困在了过去，又逃不出现在，<br />\r\n这是一种奇妙的感觉，温馨快乐做了泪水的底料而悲伤洒在了我的脸颊。<br />\r\nhttps://www.bilibili.com/video/BV1dy42187pm<br />\r\n每日一句 emo 小短句，我们有缘再见。<br />\r\n对了，也许我的可可果已经熟了吧。<br />\r\n难道人生注定是一个塑造自己，丢失自己，怀念自己，找寻自己的过程吗……可悲的是我无法找回自己了，我只想杀死自己。</p>\r\n<p>2024/07/14<br />\r\n坐火车是一件挺有心理压力的事。<br />\r\n在车上能看见各个年龄段，和很多不同的人，从小孩到大人，再到老人，从体力工人再到脑力劳动者。<br />\r\n仿佛人生的大部分状态和未来的可能都被压缩到这一个狭窄的通往过去或未来的车型上。<br />\r\n在这里看到自己记忆中的过去，也能投射出自己些许的未来。<br />\r\n我为不能回到过去而感到悲伤，我为昏暗的未来感到悲伤。<br />\r\n我为座位如此接近，阶级差距却如此之大而感到悲伤。</p>\r\n<p>2024/07/15<br />\r\n在混杂的音响和众人的祝福中，我的思绪其实早已飞到过去，我只看得见一屡长发在我眼前拂过，<br />\r\n阳光顺着发间映出，仿佛发光的是她，而不是背后的太阳，我怯懦地用残缺把她的脸从回忆中抹去，<br />\r\n仿佛这样就不会悲伤。<br />\r\n于是我坐在喜宴的桌沿上，沐浴着礼炮的彩色飘带，大家都在笑，我也笑了，<br />\r\n“祝你幸福”。</p>\r\n<p>2024/09/14<br />\r\n难道人生就是一个被当下蹂躏，焦虑未来，怀念过去的体验吗？<br />\r\n如果一向如此，我美好的曾经是否子虚乌有，我的焦虑是否杞人忧天，我的现在是否镜花水月。<br />\r\n你好，我已经去了未来，如果你看到了这段信息，请在现在把我带到过去。</p>\r\n<p>2024/11/24<br />\r\n阳光好刺眼啊，仿佛要把我全身的潮湿和阴暗都蒸发掉一样，即便是这样的白日青天、朗朗乾坤，我的前程为何还是一片灰暗。<br />\r\n要何等的烈焰才能驱散笼罩在心头的阴霾。</p>\r\n<p>2024/10/25<br />\r\n为什么现实是这样复杂且痛苦的呢？<br />\r\n也许这个世界就是一口大锅里面炖着一切，当我品尝生活的滋味时，不是咸，也不是甜，那种味道很复杂，很多时候这种味道让我说不出话。<br />\r\n也许五味杂陈的意思我现在才理解吧。<br />\r\n我的现实是没有幸运星的。<br />\r\n也许一开始这就不是一个开心温暖的故事，不过虽然我开了一个糟糕的起承，但至少我还是作者，这个故事还不会封笔。<br />\r\n写到这里时不由得想到巴勒斯坦人民的遭遇，真是场卑劣的战争，悲怆和残忍正在这片土地上演，巴勒斯坦人民万岁。</p>\r\n<p>2024/11/01<br />\r\n我闭上眼睛，勇气没有增长。<br />\r\n这薄薄的无尽黑暗中，我看到了未来，<br />\r\n所以无需畏惧，大啖食粮之刻已至。</p>\r\n<p>2024/11/28<br />\r\n我只是在原地兜圈子的一个孩子，<br />\r\n我渴望有人主动跑过来爱我，<br />\r\n我希望有人能拉着我的手前进，<br />\r\n而现实是，不会有这样的人了，<br />\r\n而幼稚的我只知道坐在原地大哭，<br />\r\n这不是一场悲剧，只是我个人的丑态。</p>\r\n<p>2024/12/03<br />\r\n正义是杀不完的，无论是真的还是希望相信，正义都是杀不完的。<br />\r\n即便我们只能像“我们必须想象西西弗斯是幸福的”一样略带无奈和妥协地去相信自我价值。<br />\r\n正义是杀不完的。</p>\r\n<p>悲歌可以当泣，远望可以当归</p>\r\n<p>2024/12/05<br />\r\n望未来•娄山关<br />\r\n冬风裂，空留萧索孤影夜。孤影夜，霜飞雨泄，亭台幽咽。<br />\r\n崎岖闭路了无疟，今夕空作亡魂雀。亡魂雀，幽闭犹怨，寒玉犹泪。</p>\r\n<p>2024/12/05<br />\r\n我时常感到悲伤， 说悲伤是陪我之现在的朋友也不为过，\r\n所以我想既然我摆脱不了它，\r\n不如去享受这一刻，把我的感受和思考记下来，哪怕给人作为玩乐的笑料，\r\n渐渐的这也成为了我的一种习惯或者说乐趣。<br />\r\n人活一世也许真的会留下点什么。</p>\r\n<p>2024/12/11<br />\r\n雨打在外套上窸窸窣窣，上海的冬天，也不能说为冬天吧，比家乡来讲应是晚秋的气温，虽然如此但气温也低，寒冷的夜有些伤感，能听到只有汽车呼啸而过带起的水泽和雨滴滴答答。\r\n没有月亮，没有星星，就像没有太阳一样，我想不明白游戏行业为什么这样的，有的人已经金缕玉衣，而我能还在一堆烂泥淤成的潭里，不仅狼狈丑陋而且一无所有。\r\n每每想到这我都感到十分的伤心，甚至想大哭一场以此来发泄来麻痹这庞大的、痛苦的、无助的感觉。\r\n我想璀璨的人生我是不会拥有了，有的故事就是这样的能够扭扭歪歪地写出几个字就已经很不容易了，哪里还有什么美学或者意义呢。\r\n我的人生已经开始了，但是我的人生其实早就结束了。\r\n雨漏进了泥潭，天有些凉，我也有些冷了，但是我看不见月亮。</p>\r\n<p><em>注释：雨没有漏进泥潭，其实是笔者的眼泪在心窝中流转。</em></p>\r\n<p>2024/12/12</p>\r\n<ul>\r\n<li><p>分不清是被子冷，还是天气冷，还是世态炎凉。</p></li>\r\n<li><p>所以说人与人之间的隔阂就像at立场一样，我撞不开，强行撕开只会让人受伤。</p></li>\r\n<li><p>冷暖自知，能感受到的只会有冷。\r\n这是个最冰冷的词汇，因为不能和别人拥抱才只能自己窝在寒冷里幻想温暖。</p></li>\r\n<li><p>没人爱我。<br />\r\n倒不是说大家都不喜欢我，可能会有人喜欢我，但是是没有爱的勇气的，我也没有，我就是那个害怕幸福而逃走的胆小鬼。<br />\r\nxx，你戏谑的外表下藏着什么呢？<br />\r\n嘻嘻哈哈也金缮不了被生活伤害的残破的心。<br />\r\n我不要。<br />\r\n我要未来，我要希望，我想要爱，我想要真理。</p></li>\r\n<li><p>我所做的工作都是微不足道的，我只是把那个缤纷绚丽的世界搬到大家面前，除此之外别无他长。<br />\r\n只要用心观察世界，每个人都是伟大的作家。</p></li>\r\n</ul>\r\n<p>2024/12/19<br />\r\n你说得对。<br />\r\n我的一生确实是浪费了。<br />\r\n我不再是那个有所期望的人了，<br />\r\n在自己的软弱催使下，在见证一起冷漠的爱和爱抽象的人却转身向现实铡刀者之后，我不在爱人类了。</p>\r\n<p>所谓的博爱和温柔，只不过是披着抽象外衣的自我感动，卑劣至极罢了。\r\n我不再爱自己，在试着爱人类时，也失败了。 人所之人，非人哉。</p>\r\n<p>2024/12/25<br />\r\n前人之述备矣。<br />\r\n我每次有所感悟，有所表达时，特别是选题相近，比如对时间流逝的感悟，其实早有绝笔，所以总有些彷徨，我对着千古已定的命题还有所疑虑，仿佛我已经忘却了前人的教诲，有些羞愧。<br />\r\n但是我突然想到，所感前人之感，也并非说明我们遗忘了什么。<br />\r\n恰恰说明人类从未遗忘，对于相同的困境和问题，拥有了相同的感悟或表达抑或不同，恰恰说明人类没有忘却。<br />\r\n面对相同的问题，我相信这种重复思考会继续下去，直到它解决的那天。<br />\r\n虽然后人可能忘记我当下随感，但是当他们遇到相同的问题时这一切的思考会再次涌现。<br />\r\n也许对于人类而言，时间的流向已经固定，宇宙就是如此的残忍无情，那么如此脆弱的人类，所能拥有对抗这一切的、唯一的脆弱武器便是思想，唯有思想才能穿越时间。<br />\r\n我称之为，遗忘的记忆。</p>\r\n<p>去忘记吧，等你忘记所有招式你就练成了太极拳。</p>\r\n<p>2024/12/26<br />\r\n\"雪融\"，我看不见太阳升起了，我的雪在这里就要化了，只不过只能以泪水的方式了。<br />\r\n明年7月，如果你有时间的话，对风声说一句天气如何吧。</p>\r\n<p>2024/12/27<br />\r\n有时候做梦就梦见审死官里面那一幕，<br />\r\n星爷演的那个状师，拿着金元宝轻蔑地指着我，“做游戏啊！做游戏啊！”，<br />\r\n于是我也和他一起戏谑了。</p>\r\n<p>2025/01/07<br />\r\n昨天我大学同学的朋友问我，你读这么多年书现在加班那么晚，有没有后悔过，<br />\r\n当时没觉得什么只是说，还能怎么办想那么干啥，得生活啊。<br />\r\n现在冷静下来，想想心里突然有点东西放不下了。<br />\r\n我知道他是想问问我答案，但是我也不知道答案，<br />\r\n我其实和他一样，<br />\r\n至少在对人生的迷惘上，出奇的一致。</p>\r\n<p>2025/01/08 看一次哭一次，如果真的有爱情的话希望别是这个样子。<br />\r\n伤心莫采琵琶树，断魂不照小轩窗。</p>\r\n<p>2025/01/24<br />\r\n幸福是主观的，浮动的，不可定义的，同时也是无法衡量，不能经由测试的。<br />\r\n很多时候幸福可能是一瞬间的感觉，当然会有幸福存在。<br />\r\n然而从长远看人生更可能是一场悲剧，幸福也许是不存在的。<br />\r\n选择做一个无知的人欺骗自己是幸福的，或者做一个痛苦的人接受幸福是少数的。<br />\r\n很难说这两者是聪明的愚蠢，还是愚蠢的聪明。</p>\r\n<p>2025/02/21<br />\r\n你怎么开始怀念过去了？<br />\r\n你老了吗？可是你最多可能也就30岁，不太老也不太年轻。<br />\r\n我不知道，也许是……过得有点辛苦让我想起了从前。<br />\r\n你呢？朋友。</p>\r\n<p>2025/02/21<br />\r\n落叶魔音，见落叶而知深秋，<br />\r\n晓得盎然春日遥遥。<br />\r\n初听不觉何足道，十年邈邈，<br />\r\n再奏断万股愁肠，千滴泪。</p>\r\n<p>2025/02/26<br />\r\n牛马哥，我总是想起从前，<br />\r\n我现在生活地很痛苦，在夜深人静的时候，我努力回想小时候那些美好的时光，那些日子因为遥远反而显得格外温暖。<br />\r\n但是我的身心已经冰冷，只有在回忆中逃避当下的时，才能感受到什么叫生命。<br />\r\n在我去逐步认识这个世界的现实中，疫情又给了我沉重的打击，在哪个迷惘和无措的时光惶惶然，我被迫进入了社会，没有承担责任的勇气，没有敢于面对困难的魄力，有的只有对未来的迷惘和昨日的创伤。<br />\r\n于是我再次回忆，那个慵懒的躺在午后阳光里的孩子，那个和朋友有说有笑不知愁滋味的男孩。<br />\r\n对我而言过去是欢乐的，但是我站在原地往回跑的时候，却无论如何也追不上了。</p>\r\n<p>2025/03/18<br />\r\n就像我总怀念那年夏天的风，<br />\r\n我记得那是一个凉爽的下午，<br />\r\n它从窗户钻了进来，<br />\r\n卷起前桌黑色的长发，<br />\r\n来到我的桌前，<br />\r\n它给的感觉很轻快，仿佛在拖着我无拘无束，<br />\r\n它就这样的一阵阵来，一阵阵去，<br />\r\n直到那个夏天过去了，<br />\r\n我以为他还会回来，我也以为那个夏天会再来。<br />\r\n可是夏天总是，但是那股风再也没回来过。</p>\r\n<p>2025/03/30<br />\r\n如果严肃的文学作品消失那将是整个时代的悲剧，<br />\r\n在当下我们可以看到，文娱作品越来越轻量化，娱乐化，<br />\r\n表达内容浮于表面，过去的严肃叙事仿佛消失了，<br />\r\n那些曾经激烈探讨的问题不再成为作品创作的素材了，<br />\r\n可是那些问题就真的消失了吗？<br />\r\n尤其是在去政治化特别严重的某些国家，<br />\r\n甚至是谈之色变，政治和每个人的生活、权力、义务相关，<br />\r\n放弃严肃叙事，放弃政治讨论，等同于放弃思考，放弃社会权益。<br />\r\n我觉得这是可悲的、可怕的。</p>\r\n<p>2025/3/30<br />\r\n省流，匹配成功。 不过不用想这么多，玩游戏的时候感觉到开心就好了。<br />\r\n游戏作为文娱产品的目的就是取悦用户的。<br />\r\n有反思有向往是好事，但是个人的努力无法和时代的洪流抗争，<br />\r\n所以，去享受人生吧，在生活的痛苦中，给自己找一颗糖吧。</p>\r\n<p>2025/05/11<br />\r\n追寻梦想总是痛苦的，尤其是在这片土地上，现实太过沉重，把我们每个人拖向地狱，<br />\r\n为生活妥协无可指责，但是在回首过去时，总会心有不甘，人生就是抱着遗憾漫无目的踱步的过程。</p>\r\n<p>2025/05/21<br />\r\n仇恨就像螺旋一开始还有迹可循，可世事不能离散只有连续。</p>\r\n<blockquote>\r\n<ul>\r\n<li><p>Agent Ross, Pinkerton Detective Agency.</p></li>\r\n<li><p>Enjoy your fishing kid, while you still can.</p></li>\r\n<li><p>Excuse me! You Edgar Ross?</p></li>\r\n<li><p>Do I know you?</p></li>\r\n<li><p>Forgive me for startling you, sir. I have a message for you. My\r\nname is Jack Marston. You know my father.</p></li>\r\n<li><p>I see... I remember your father.</p></li>\r\n<li><p>I've come for you, Ross.</p></li>\r\n<li><p>And you, boy, have sure as shit found me.</p></li>\r\n<li><p>You killed my father. You shot him like a dog.</p></li>\r\n<li><p>Your father killed himself with the life he lived.</p></li>\r\n<li><p>You killed him! I saw you!</p></li>\r\n<li><p>You keep saying that.</p></li>\r\n<li><p>You sent him to do your dirty work, then you shot him like a\r\ndog!</p></li>\r\n<li><p>And I'll shoot you like one too, you little piece of trash! Now\r\nget out of here before I kill you as well!</p></li>\r\n<li><p>I ain't going nowhere, old man!</p></li>\r\n</ul>\r\n<p>RED DEAD REDEMPTION</p>\r\n</blockquote>\r\n<blockquote>\r\n<ul>\r\n<li>You can't erase the past, John. Killin' me, it won't make it go\r\naway. ...</li>\r\n<li>Hello again, John.</li>\r\n<li>Hello, Dutch.</li>\r\n<li>We gotta stop meeting like this!</li>\r\n<li>Sure.</li>\r\n<li>I've got a plan, John.</li>\r\n<li>You've always got a plan, Dutch.</li>\r\n<li>This is a good one.</li>\r\n<li>I don't doubt it.</li>\r\n<li>We can't always fight nature, John. We can't fight change. We can't\r\nfight gravirty. We can't fight nothing. My whole life, all I ever did\r\nwas fight.</li>\r\n<li>Then give up, Dutch.</li>\r\n<li>But I can't give up, neither. I can't fight my own nature. That's\r\nthe paradox, John. You see?</li>\r\n<li>Then I have to shoot you.</li>\r\n<li>When I'm gone, they'll just find another monster. They have to,\r\nbecause they have to justify their wages.</li>\r\n<li>That's their business.</li>\r\n<li>Out time is passed, John.</li>\r\n</ul>\r\n</blockquote>\r\n<p>2025/06/07<br />\r\n繁重的工作压得人喘不过气， 连打游戏作为消遣的动力都没有，\r\n在夜深人静放松思绪能够思考什么的时候，\r\n往日观看的asoul视频又浮现在眼前，已经很遥远了，但是有希望能够近一些。\r\n无论接受与否那都成了过去，必须学着接受， 这就是生活残酷的地方，\r\n我们漫无目的来到这个世界，遵从生存的本能，\r\n短短数十年在史书中不过寥寥几笔， 整个人类历史于宇宙而言不过尘烟，\r\n这一切真的有意义吗？宇宙存在所谓意义吗？\r\n我怀疑，但悲哀的是我只能相信，无所谓与否。</p>\r\n<p>清风乱弄两三页，提笔一拨百十年。 长叹飘渺江中月，落花点水了人间。</p>\r\n<p>2025/06/15<br />\r\n从《巴黎的忧郁》到《凉宫秋日的忧郁》他们的悲伤不及我的万分之一，<br />\r\n早在落笔之前忧郁已悄然而至，媒体所载至少有人同悲，而我的忧郁只属于我自己。</p>\r\n<p>摘抄自《知乎》，中华人民共和国的一款人民分享见闻观点，芝士的平台。</p>\r\n<p>2025/07/04<br />\r\n在21世纪还能看到联合小团体迫害一个人在网上发表言论的自由，这种情景也是少见了。\r\n当你在为同胞争取权益时，还要被倒打一耙，要怪罪你破坏了他们安定祥和的生活，<br />\r\n与之前其痛恨其作为资本家走狗的同事时的面孔截然相反，换了副面孔便高高在上，圣洁无暇了。<br />\r\n若是真的有罪便也受的没什么怨言，狺狺野狗也学起秦桧的手段了，真不得令人发笑。</p>\r\n<p>2025/07/08<br />\r\n树死叶落黄，飞沙填泥漳，<br />\r\n猢狲不可言秋凉，唯恐泣涕泪叶扬。</p>\r\n<p>2025/07/25<br />\r\n在某国你上班得忍受被压干最后一滴血的觉悟，<br />\r\n没有基本的人权保障，没有合理的假期安排，没有休息时间，<br />\r\n还要被当权者拿走产出，还得看着他们用你的辛勤劳动去花天酒地肆意挥霍。</p>\r\n<p>2025/07/25<br />\r\n回万古长夜月明，多少英雄不在，<br />\r\n哀一生前途晦暗，几许气概无存。<br />\r\n多少千百事，都做尘与土。</p>\r\n","site":{"data":{}},"excerpt":"<p>你能翻到这整明你很有耐心啊，说明你对我的Blog还是有一定兴趣的，或者是我直接发的链接。<br />\r\n这里记录一下自己在群里的每日Emo小短句，\"每日一句emo小短句，我们明日再见。\"<br />","more":"<br />\r\n温情提示偶尔伤痛文学一下舒缓压力可以理解，但是不能实际地跟本地解决问题，美好的生活需要自己创造。<br />\r\n还有如果你时常心情低落，难受，要注意心理健康，必要的时候要去看医生哦~<br />\r\n那么废话结束，我们开始Emo吧。<br />\r\n<span class=\"math display\">\\[\r\n我从未看透，我只想感受慷慨赴死的颤抖。\r\n\\]</span></p>\r\n<p>这里只有低级的思考和最卑劣的情绪宣泄，\r\n除此之外没有任何文学意义，我所述之一切，不过尘烟。</p>\r\n<h1 id=\"独油群每日emo小短句\">独油群每日Emo小短句</h1>\r\n<p>2023/04/09<br />\r\n“我好想问一问进入游戏行业打工的愿望就这么奢侈吗？”</p>\r\n<p>2023/04/10<br />\r\n虚拟的数据能分析出我真实的病情，为什么真实的世界却不能带给我一丝虚假的温暖呢？</p>\r\n<p>2023/04/11<br />\r\n人生最大的悲哀也许就是平庸的自己配不上远大的理想吧，纵有孟德之志，却无丞相之才啊。可是即便意识到也在名为平凡的泥潭中越陷越深……<br />\r\n这场名为人生的冒险好艰难啊。</p>\r\n<p>2023/04/12<br />\r\n今人又见古时月，古月不救今时人。<br />\r\n这里用救字，是我自己对外的求救，是一种直白的表述方法，我希望给读者更强烈的情感冲击，如果追求诗歌的美可以用别的字，比如照、抚、望。<br />\r\n<strong>今人又见古时月，古月已忘今时人。</strong><br />\r\n这里又想到一句更好的，不知道好不好。</p>\r\n<p>2023/04/13<br />\r\n无能是灼烧我的业火，他人的光辉刺痛我阴暗的鼠目，宏大的理想也变作狂妄。<br />\r\n每日一句emo小短句，我们明天日永别。</p>\r\n<p>2023/04/14<br />\r\n浑浑噩噩成了日常，萎靡颓废成了习惯。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/15<br />\r\n骑马跨栏的判定太阴间了，cnmd。<br />\r\n每日一句emo小短句，今天开始摆烂，我们明天再见。</p>\r\n<p>2023/04/16<br />\r\n小时候父母告诉我要有一颗，像铁一样坚强的心，但是他们没告诉我的是，这世界上磁铁太多了。<br />\r\n每日一句emo小短句，今天的emo比以往来的更早一些，我们明天再见。</p>\r\n<p>2023/04/17<br />\r\n好想回到过去，好想变成芝士面包。<br />\r\n每日一句emo小短句，我们明天再见。<br />\r\n是因为我早就死在了过去，所以灵魂索求着还阳吗？ 2023/04/18<br />\r\n我是一个怀旧的人，因为我的未来没什么希望，我在过往的欢乐中，种下了一棵在未来通向衰败的枯树，<br />\r\n当我茫然地走上自己铺就的幽暗小道时，我总是回头望去，我怀念那些欢乐的日子，我悔恨那些蹉跎的日子，<br />\r\n我在枯树旁的荆棘丛中哭泣，我在梦境的虚幻里沉沦，以忘却这痛苦的生活，在美丽的梦里，我是一个怀旧的人，因为我的未来充满希望。<br />\r\n每日一句emo小短句，我们明天再见。 2023/04/19<br />\r\n于我而言，生活的琐碎就是一个不断发现自己失败的过程，<br />\r\n我时常懊悔无助，但我想，发现自己的失败不应像我一样悲伤、自怨自艾，理当奋起直追、弥补不足，<br />\r\n可惜我是做不到的，因为我总是在发现新失败的伟大征程上，义无反顾地航行，<br />\r\n我是绘制不出五彩蓝图的幽灵，我已经同海底的死寂共赴沉默。<br />\r\n岸上的人不要上我这条残破不堪的船，去在广阔的大海上勇敢地航行吧，去开辟你的新航路吧，<br />\r\n鼓足你的风帆去禁受狂风的肆虐，不论前方是文兰或是礁石。<br />\r\n“面朝大海，春暖花开。”<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/20同理心是种可贵的品质，我好希望每个人都能有这种品质，这样大家就都会关心我了，可惜我只想着别人来关心我，这样看也许这种可贵的品质我自己是没有的，不知不觉又犯了宽于待己，严于律人的错误，我想我是不配这样的奢望的，渐渐地我便不再去幻想了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/21<br />\r\n看到你们美好的生活我真的很羡慕，我也好想和你们一样，虽然理想的工作和实际存在差距，但是能进入自己热爱的行业对目前的我来说就是最大的愿望了，但这愿望终究是小女孩划燃的火柴，在这寒冬中燃不久，便消失了。我蜷缩着身体彷佛看见自己坐在一家游戏公司里，同事都温柔可近，工作生活都很愉快，这样的梦好虚假啊，连我也意识到这是弥留的回光，人们渐渐围在了我的身边，对我指指点点，我依稀听到他们说“活该啊，冻死了吧”，随后我也指着自己说道“活该啊，冻死了吧”。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/22<br />\r\n躺在床上怅然若失的望着天空，青春的活力和萎靡的精神在我体内冲突，我同旧厂街过去的哪些青年一样，眼中充满对未来的迷茫，从梦幻中惊醒，面对的是生活残忍的另一面。<br />\r\n哪些在镜头前迷茫的青年曾经是一定存在过的，昏暗的室内和朦胧的镜头记录下他们短暂的一瞬，我希望未来别再有他们了，想到这，我再看向窗户映出的模糊倒影，越发清晰却渐渐的陌生了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/23<br />\r\n我想，把自己的痛苦与挣扎用矫情的文字表示出来，是不值得夸耀的、甚至是应当感到耻辱的；用人们共同的痛楚去博取同情未免有些太卑鄙了，但我一直都是这么做的。所以我常对自己感到厌恶、对他人感到羞愧；一个真正有爱的、坚强的人，我想应当是在痛苦之中感受、反思；在有所顿悟后，用爱和希望去鼓舞他人，带给他人力量！人们因生活的痛苦而困顿，却也因困顿而坚强，我在生活的沉沦中越陷越深，唯一能带给别人的就是一首赞歌，一首歌唱反抗平庸、超脱自我的赞歌。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/24<br />\r\n小短句总是越写越长，可能是因为压抑不住的表达欲和内心深处对于他人认同的渴望吧，写得越多自己向外暴露出的也就越多。向外表达的行为也是祈求认同的过程，是想被他人了解、关心的强烈渴望。<br />\r\n所以我决定继续写小作文。<br />\r\n我在行动的过程中内心总是充满怯懦，对于自己的目标总是处在一种迷茫的状态，找不到前进的方向，在光怪陆离的森林中不断地徘徊、观望他人的世界，美好的青春和时光就在自己的惘然中眼睁睁的溜走了，直到今日也未能触及心中的理想。如果说理想是名为文兰的陆地，抵达它的过程，就是一场被称为人生的伟大航行，我们时常同海上的漩涡斡旋，和水下的礁石战斗，而脆弱的风帆和桅杆已经在终日地雨打风吹中受伤磨损，但依旧看不见陆地，却常常听闻别人登陆文兰的讯息。有时我会想投入这广袤的海洋中结束我悲哀的航行，或是祈祷一场巨浪掀翻我的扁舟让我拥有退出的理由，但是在朝露打湿我干瘪的嘴唇，在凄冷的素晖映得海面粼光闪闪时，我又在幻想中看见了文兰的影子。<br />\r\n每日一句emo小短句，我们明天再见。 2023/04/25<br />\r\n孤独是上天赐予我的礼物，死亡是世界给我的解脱。<br />\r\n我是有意识的玩偶，在戏谑的闹剧中进行着荒诞的演出，宇宙和眼白是我变态的观众，平庸和愚蠢是他们最爱的戏码。广阔的舞台扭曲我的身体，我的精神不甘地嘶吼，软弱的躯体和颓唐的精神揉搓成一团混沌的烂泥，而这丑陋的模样就是他们解闷的笑料。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/26<br />\r\n今天一如既往的浑浑噩噩度过一天可是并没有感到快乐，没有休息也没有玩乐，也没有工作，但是一晃就到了晚上，心中更烦闷了，很疲惫。罗素曾说悲伤让人疲惫，我本不知如今倒是感同身受了，也许我应当痛下决断，去正常的生活。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/27<br />\r\n我靠着虚假的希望和混沌的疯狂来麻痹自己，这膨胀的幻想被他人用现实刺破，我沉浸在真实的伤痛里，我的诉说和抱怨都是无用的呻吟，在锋利的剃刀前迎接我的是毁灭的命运，在这口疯狂旋转的大染缸里我只是时代光鲜背后被丢弃的渣滓。我是一个失败者，我决定从这场残酷的战争中逃走，做一个懦弱的逃兵，于是在一个最美丽的清晨，我坐在冲入云霄的花托上，对着太阳说我的故事，和月亮谈我的理想，最后我和风自言自语道“我将走向死亡”。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/4/28<br />\r\n钟鼓磨灭了意志，平常让人麻木，在平静中一步步走向海的深处，意识到这毁灭的到来，却没有做出反抗，只是左顾右盼地张望，虽然激起朵朵的浪花可脚下的步伐并未停止，沙滩上的足迹被一袭又一袭的波涛卷走，海里的鱼对着断翅的海鸥说，别害怕，海啸会带走一切的。<br />\r\n每日一句emo小短句，我们明天再见。<br />\r\n生活是一场无法规避的战斗，<br />\r\n有的人轻松写意，有的人举步维艰，<br />\r\n无论是胜利还是溃败，世界并不在乎，<br />\r\n受伤的只有向着红色风车冲锋的傻鸟。<br />\r\n每日一句emo小短句被对线爆出金币了。(</p>\r\n<p>2023/04/29<br />\r\n有一条鱼拼命地往渔夫的网口里钻，渔夫把他拎起来看了看，肉少的可怜、长得又颇为难看，“浑身的腌臜味，一看就不好吃”，然后把他扔回了浑浊的泥潭，鱼想着要是自己是一只锦鲤就好了，这样渔夫们都会挣着捕获、是什么“濒危物种”也好啊，可笑的是这年头“濒危”也是要持证上岗的，像他这条只是快死了的鱼，是远远碰不上“濒危”的边的；他望着泥潭外的世界，万类霜天竞自由，飞禽走兽、奇珍异兽，可谓是无奇不有，从蒲公英的耳语中他也曾听闻隔壁池塘和远处大海的景象，那里的水更清澈、那里的水草更细腻，远是比这片小小的泥潭好得多的。他又沉下泥潭里，在他翻身休憩的过程中，他督见一条鱼摆在盘子里，浇上了些许酱汁，被筷子们分食着，“呸，这条鱼刺又多肉又少，还这么腥，真他妈难吃。”，少顷后，盘子里只有被开膛破肚的残羹，一片狼藉。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/04/30<br />\r\n现在这个世界真有趣，虚拟的东西越来越活灵活现，这块荧光屏幕里的小东西们总是那么动人，比外面的世界有趣多了，盯着这绚丽的光彩久了，现实的色彩便显得灰暗下来了，目之所及便没什么趣味，甚至感觉到些许的烦躁，也有投机倒把的人抓住这追求七彩祥云的心理，造出炫丽门面的假象吸引猎物上钩；也许离现实太久了，生命和精力融进了这块小小的屏幕中，等发觉才意识到，这发光的不是太阳，过于沉迷是会食人心血的。<br />\r\n是时候做出些改变了，因为该给手机充电了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/01<br />\r\n心中很烦很急，每次总是拖延，最后又是悔过，但是终究不改，为什么我的性格如此低劣。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/02<br />\r\n我常用宏伟的目标和理想主义者的虚伪躯壳来遮蔽我丑陋的容貌，然而在这重重伪装之下真实的内心中，是一个彻头彻尾的幻想主义者，我用这些东西来麻痹自我、达到精神世界的超脱，只是假借幻想来满足自我的私欲，就如刘森所言<strong>“你从未看透\r\n你只想感受 慷慨赴死的\r\n颤抖”</strong>，犹如一片落叶追寻着秋日的肃杀和远方坠落的夕阳，希望毁灭和宏伟能装饰自己蹉跎的一生。<br />\r\n面对这样的踌躇，我要抽出宝剑斩断这懒惰的羁绊，随着盖格计数的哒哒声，我要义无反顾地冲向那片红色的海阳。我想在每个人的生命旅程当中难免会有失败、会被路边美丽的风光所吸引，但是每个人都应该拥有鼓起勇气、提起胸膛去修正错误的机会，和对自己人生负责的义务，从今天十点钟开始我就要发奋图强，追回失去的光阴！<br />\r\n但是十点钟已经过了，那没关系……我不是今天的十点钟开始，我不定哪天的十点钟开始！<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/03<br />\r\n我看着他踉跄地走在铁道旁散乱着灰黄石头的小路上，他的步伐太慢，已经追不上这趟向前飞奔的火车了；他总是提着一瓶酒，那并非笑看生活洒脱自我的、潇洒的酒，而是为了麻痹自我逃避现实所依赖的毒药，最后一次我看见他走在秧歌队里，脸上带着些许的红晕，和花扇一起舞动，他的舞姿无法称为曼妙，只能说是灾难，这最后的放荡自我和追寻解脱的舞让我感到了毁灭和死亡的味道。后来直到今天，我再也没见他了，听说他害了病，也许他死了，不过我想虽然他迈上了死亡，但是终是没死绝的，我看了看镜子，再望了望太阳，我想大抵是如此的。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/5/4<br />\r\n好怀念小时候，稚嫩的画笔虽然绘制不出写实的画风，却充满着童趣，那是一幅粗糙的蜡笔画，阳光明媚、绿树成荫，背景里奏起的是悠扬的音乐，那时候不知道什么是烦恼，我只负责快乐就好，那个夏日的下午骄阳暖的正好，身上挎着清凉的背心，在可爱明艳的画面中我为了快乐而努力，我似乎还朦胧的记着那些我可爱的伙伴们，我还记得那个美丽奇幻的世界，我的脸上露出了开心的笑容。<br />\r\n那时候一切是那么的简单、一切是那么的美好，彷佛一切都是有希望的、一切都是光明的，我怀念那个时候。<br />\r\n快乐是怎么样消失的呢？那个无忧无虑的孩子到底去哪里了？我想不通，我不明白，我只觉得指尖有些疼痛，现在才知道快乐原来也是会伤人的，这天真的童趣在我这破败的一生中显得少见而珍贵，我想是不会再有了。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/05<br />\r\n自嘲也许也是自卑的一种吧，在别人指出自己的弱点之前先把自我贬低一番，这样他人的批评也就是“自我反思”的一剂辅药罢了，以此来宣誓自我的主导权，也免得自己不那么尴尬。这种自嘲就和舔舐伤口一样，实际上无用，但是甜蜜的鲜血流进唇齿之间时能品到一种满足的滋味，作为痛苦的调剂。自己虽然也知道有缺点、有问题，但是是难以去纠正的，便摆出一副“啊对对对”这般的态度，不过也是应该比被人指出便暴跳如雷要好得多的。极强的自尊也许会使自己很愤怒别人指出自身短板，在时间久了之后，发现自己终不能改正，这种自尊便化作一种自卑了吧，锋利的尖刺就在世故的雨水中慢慢的侵蚀掉了。<br />\r\n今天感觉没有那么emo，也许是回光返照吧，也可能是用一天虚假的努力欺骗了懒惰的自己，得到了一丝宽慰吧，所以也就随便写写，我想这事是不能放弃的，因为我已经蹉跎了太多，这小小的玩乐也许能作为我极少的坚持吧。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/06<br />\r\n如果我能开花，<br />\r\n我会在清晨和太阳耳语，<br />\r\n我会在夜晚和婵娟摇曳；</p>\r\n<p>如果我能开花，<br />\r\n我会把思念揉碎在风中，让他携着我的愿望，飘向远方；<br />\r\n我会把诗意溶化在雨中，让她裹着我的烂漫，浸入大地；</p>\r\n<p>如果我能开花，<br />\r\n我会把花瓣葬在泥土中，回馈他的恩德；<br />\r\n我会把芳香散在世界中，歌颂她的美丽；</p>\r\n<p>如果我能开花，我将带着马头骨一起葬在海中央；<br />\r\n如果我能开花，我将偕同蒲公英一起散在风中央；<br />\r\n如果我能开花，我将绽放一朵血色的玉英。</p>\r\n<p>每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/07<br />\r\n人类的SNP排除体外后通过马桶可以全部链接在一起，为什么人类内心的想法不能通过马桶连在一起呢？是因为其实人类只痴迷于肉体的链接，而不在乎心境的联通吗？<br />\r\n如果可以的话，我要造一个大大的马桶把所有的心理SNP收集起来，把大家全部连接到一起，就用这条链接彼此的管道，贯穿你我之间的壁垒吧。就算是为了我，对全人类的内心使用发光马桶吧。<br />\r\n补充：snp可能是最接近人内在的东西了，想要理解人的内心就去理解snp吧，比良坂曾云“你连心爱的女人的大便都不敢吃，还敢说爱她”，相必背后也是有着这样的哲思吧。(<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/08<br />\r\n生活大多都是苦闷，羊只顾着食草，至于草是经过怎样的艰难他是不顾的，在人生的创作中你我虽然是作者，但是很多时候剧情没办法自己做主，名叫老天的混蛋编辑总是喜欢安排一些稀奇古怪的操蛋情节，嘛，迫于种种的无奈，我们也许只能在这苦闷中自己去创造快乐了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/09<br />\r\n人生最大的痛苦不是整日都只能陷在悲伤之中不能自已，而是无悲无喜，面对残酷的现实精神和肉体都被摧残的麻木，一切的动荡都激不起涟漪，无论是福是祸都无动于衷。<br />\r\n在这样悲喜不加的琐碎平常中我已经渐渐看不清曾经的影像，他慢慢的从我枯燥的生活中消失，没和我道别。他也许就和我一样自私吧，自顾自地离开，而我自顾自地放他走了。我们在这无法言说的默契中被分离了，自他走后我常常忘记了这梦幻的过往，但我有时又会猛地记起，这段记忆就像夏日傍晚时映过窗户的那束橙黄的光——我是记住了的，但却真真地忘记了。<br />\r\n“1997年过去了，我很怀念他。”<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/10<br />\r\n上天曾赋予我天真的秉性让我能发现生活中的快乐，但是现在他想收回这份馈赠，于是便用残酷的现实一点一点磨灭我的心智，但是我不想放手，因为我会再也找不到快乐。<br />\r\n可无论我放不放手，都已经不再快乐了，这个世界有太多的难题我解不开了，有太多的问题我不会了。也许我真的不行，但是我不想承认，我知道认输很轻松，但是一旦低了头就再也抬不起来了，我的自信就像在一把锉刀下一点点的磨碎了。不能再像曾经的那个中二的少年一样冲着一无所有的广袤世界大喊了，那样豪言壮志的盛情已经不再了，如今只有被现实打败的萎靡和颓废了。<br />\r\n他朝着被夕阳映红的世界大喊，回应他的只有随风起伏的草场和远处寂静的校舍，但是其实他并不在乎有无回应，他只是想宣战罢了。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/11<br />\r\n我想喝可乐，碳酸充斥口腔很奇妙，因为很好喝所以很想喝，但是妈妈说不健康呢，而且已经很晚了，所以不能喝呢。如果我有钱的话我会买一瓶可乐，最好是冰的，但是我没有，所以我很想喝可乐。<br />\r\n我想如果我长大了就可以喝可乐了吧，但是浑身脏兮兮的大哥哥却说不要长大会很痛苦呢，大哥哥说话很有趣人也很好玩。有时大哥哥会拿一个红色的大罐子和我炫耀说多么好喝，但其实是我知道的，那是他在绿色箱子里找到的，因为我看见过别人偷偷把罐子塞进去，也许大家和大哥哥早就商量好了，在玩找宝藏游戏吧，但是大哥哥每次都不让我找，他总是一个人找，好贪心啊。大哥哥每次都会和我说可乐有多么好喝，但是我一次也没看过他喝过，大哥哥到底有没有喝过可乐呢？<br />\r\n大哥哥常常躺在广场上的长椅上，他总是给我看到他在绿色宝箱里发现的宝藏，有园的有方的，又蓝色的有白色的。他总能掏出我没见过的东西，我想他应该是个探险家吧，但是他很多时候总是阴沉沉的而且不准我叫他大叔；他有长长的头发却是大哥哥呢，好奇怪啊，但是却很有趣，可能长大的世界就是这么好玩吧，也许大哥哥是怕我和他抢可乐喝，才害怕我会长大吧，大哥哥好小气啊，我会分给他喝的，因为可乐很好喝所以没问题的。<br />\r\n不过妈妈不让我和大哥哥玩，说什么他很脏，可是他的眼睛明明很干净很漂亮啊，为什么妈妈会说很脏呢？妈妈说我长大就明白了，看来还是要长大的，但是大哥哥不想让我长大，为什么呢？这也要我长大之后才明白吗？那我还是快点长大吧，因为我想喝好喝的冰可乐啊。<br />\r\n我到底喝没喝过可乐呢……</p>\r\n<p>其实我就是大哥哥，而写下这些文字的也是我，充满童趣的我和沧桑的我是我的两面，最后一句是我和大哥哥一起的感叹。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/12<br />\r\n今天大哥哥没有来，我也没有喝可乐，大哥哥去哪了呢？大哥哥说过他曾经也是有梦想的，但是不知怎么的就变成浑身破破烂烂的样子了，然后梦想也走丢了，梦想是什么啊？我不太清楚，大哥哥是因为有梦想才会破破烂烂的吗？我也经常做梦，我也会变得破破烂烂吗？变得破破烂烂是不是可以变得和大哥哥一样去冒险了呢？<br />\r\n今天没见到大哥哥，心中有什么奇怪的感觉涌上来了，大哥哥今天应该是到新的地方去冒险了吧，不知道他明天会不会回来。<br />\r\n大哥哥今天还是没有来，是迷路了吗？还是被新的冒险吸引了？不会是一个人偷偷去喝可乐了吧？<br />\r\n……<br />\r\n大哥哥已经一周都没来了，也许他不会回来了。我想他可能是去找那个走丢了的梦想了，如果是这样那大哥哥就是我的梦想，因为他和梦想一样都走丢了，等有一天，我也去找大哥哥吧。<br />\r\n大哥哥究竟喝没喝过可乐呢？<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/13<br />\r\n大哥哥回来了，但是我没有问他前几天去了哪里，就像我没有问他从哪里来，他也没有说去了哪里。他没什么变化只是身上的衣服换的更轻便了，白色的短袖已经变得灰黄了，他好像很没有精神，我和他打招呼他也只是木讷的回应，他是怎么了呢？大哥哥变得和其他大人一样了，总是面无表情、无精打采的样子，可能只有拿红色的可乐罐才能把他明亮的眼睛变回来了。也许大哥哥只想快乐，但是繁重的现实令他无法超脱，难道源自内心的欢愉只能依借外物来所求吗，难道精神的享受只能由物质带来吗……我想不是的，但是精神的交流和思想的碰撞是难得的追求，所以我只能用物质的华丽和感官的疯狂哺乳我混沌的精神。<br />\r\n所以，我想喝可乐。<br />\r\n大哥哥究竟喝没喝过可乐呢？<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/14<br />\r\n今天是阴天，我一如既往的去广场找大哥哥，大哥哥一如既往的瘫坐在长椅上，他灰暗的眼睛里映着被天空压得蒙蒙的广场，蓝色的建材旁没有曾经嬉戏的孩子们，只有略带潮湿的风抚摸着我的脸。大哥哥没有理我，自顾自的唱起了歌，但我听不太清，不知道唱的什么，他萎靡地神往、我无措的徘徊，很快淅淅沥沥的雨散在我的肩头，我转头逃走了，我可耻的遁走，我又羞愧地回头望去，大哥哥已经不见了，我有些怅然地走在雨中，唱起了歌。<br />\r\n“没有花香，没有树高，我是一棵无人知道的小草……”<br />\r\n下雨天很凉，所以我自是又一天没有喝到可乐的。<br />\r\n大哥哥究竟喝没喝过可乐呢？<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/15<br />\r\n我是新时代出土的崭新古老废柴，在泥土捏住的废墟中起身后，在绚丽的装饰中不知所向。一面是小县城日趋衰败的丧钟，一面是城市钢筋的逼近和霓虹的威慑；一面是无所适从的现实破烂，一面是歌舞升平的虚拟狂欢；一面是家庭崩塌的通牒，一面是生存无计的惘然；我和马大帅一样在这个崭新的世界无处藏身，生活的琐碎片片地压在头上，无处藏身、无地自容；被迫在这个混沌的垃圾堆里左支右绌，希望能找到点活下去的办法，可迎来的只有广厦高楼里传出的欢乐，连一生讥笑都没有、没有回应就是世界给我最后的回应。我面对宏大时代产生的困窘太大了，大到我不知道怎么形容、我不知道怎么表述内心的感受，但是这种困窘又太小了，小到别人看不见他。<br />\r\n”而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。“<br />\r\n也许唯一幸运的是，迫于我的精神状态和身体原因，至少还有人能对我展露出一丝理解的姿态，不知是自愿还是出于道德的被迫，想到这里我更加悲伤了。如你所见，宽容和理解也可以作为伤心的利器，温柔和体贴也会带来痛苦，而咒骂和拳脚更不必言说。我想我病了，我在最嘈杂的时代失声，我在最杂乱的树丛迷路，我，一个崭新出土的时代废柴。<br />\r\n“那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。我来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。”<br />\r\n这一天，我23岁，在我一生的黄金时代，我有好多奢望——<strong>我渴望死亡</strong>。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/16<br />\r\n在无数次的失败中我知道的，其实是我自己的问题，怨不了天也怨不了地，“废话，你不过不是你的问题，还是我的问题吗”，也曾无数次的被讥笑过。人生也许就是这样吧，在浑浑噩噩中就突然直接没有了能前进的路，我的生活就像窗外黑沉沉的天气一样，已经走向了全部哒咩的end了。在这场没有鲜血的残酷竞技中，输家是没有发言的权利和表演的镜头的，我走在自我否定的螺旋中，在如海般的寂寥中下沉。我不害怕挑战，我畏惧失败；我不会失败，因为我总有借口。借口是一把刀，用它来逃避，用它割碎我的梦。我是人生的懦夫，我是战场的逃兵，我是竞技的输家，我是新时代鼓钟旁最丑陋的尸体。<br />\r\n我已经死亡。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/17<br />\r\n我好像做了一场梦，<br />\r\n在混沌的梦中我看见有人刨开垃圾堆寻找着残羹冷炙以求果腹，有人倒在街头红色点缀天空，<br />\r\n在糜乱的梦中我看见贵族门阀极尽奢华，<br />\r\n在无助的梦中我看见一个人茫然的站在风中眼神中无悲无喜，<br />\r\n在无尽的梦中我看见一个个荒诞的轮回，一股股鲜血浇筑这片大地，可是没有什么神迹，这炽热的血很快就被衣冠禽兽的虫豸吸食干净了，<br />\r\n在衰败的梦中我看见一个个消瘦的皮囊，<br />\r\n在梦中我看见了一场梦，在朦胧中我依稀听见不能言说的蛊惑。<br />\r\n在这荒诞的梦中我醒了过来，看见了一场真实的梦。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/18<br />\r\n梦幻的灯光在淅沥的雨水映衬下更外动人，<br />\r\n今夜天空没有月亮也没有星辰，面对这美丽的人类荣光，他们自然是羞愧的躲起来了，<br />\r\n水浸的马路映出如幻般的城市炫丽，耸入云宵的是无法逾越的高塔，<br />\r\n现代的奇迹循着古时的悲哀螺旋上前，<br />\r\n但这一切的磅礴都是他的背景，他从那灰暗的角落露出身来说<br />\r\n“城市的绚烂霓虹照不到我们的黑暗生活”<br />\r\n是的，无论远处的光多么妖艳，无论多少个日夜在天空上接力，这残破的窟洞也未曾见过一丝光明。<br />\r\n上个世纪一个孩子对父亲说想成为艺术家被暴打了一顿，这个世纪一个孩子想成为艺术家却没有道出，时间的分界就如同一面镜子照出相似的彼此，我们怀着同样对理想的执着，然后被生活打击到失去对一切的热爱，在无数的悲天悯人后激发出愤恨与悔过，昨日的夕阳是今朝的晨光，今日的余晖是明早的梦想。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/19<br />\r\n世界总是充满着变化，把自信好强变为偏执自卑，生活的作弊就在于把困苦转嫁旁人，在从襁褓中慢慢褪去外壳面对这疯狂的一切时，正常的精神认知早就沦为玩物，巨大的手抽离矫造着癫狂的心智，若如是亦无需置论，却有得意者假借他人的痛楚予以调味，痛苦后深层的哀伤他自然是不懂的，只觉得好玩消遣罢了，我的肉体、我的精神、我的心智都被这疯狂的世界夺走，而这躯空旷的泥瓦罐也只能装满癫狂的海水。<br />\r\n把我的一切还给我，还给我吧，那年轻的亲人，那些离去的人，那无忧无虑，那个没有丑陋伤痕的我，我会在那最美的瞬间按下暂停，哪怕这是永恒的死寂，也比这无尽的疯狂来的更有意义。<br />\r\n“因为再往后就是只有失去的现实”<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/20<br />\r\n坏了，把每日一句给忘了……就连这么重视的事情都在昏昏度日中忘却了，我想我没什么可以辩解的了，之前那么忙都想的起来，现在休息了一天反倒忘记了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/21<br />\r\n我不知道是我萎靡的精神导致我诸多的失败还是我那不顺的过往导致我失去活力，我唯一能确信的就是在这个疯狂而糟糕的社会中，我的失败和顿挫不会就此止步，目光所及的未来是一片狼藉，在他人蓬勃一生开始的年龄，我的生命已经所剩无多，迎来的并非接近疯狂的不甘，反倒有种解脱的释然——终于能从这混沌中离开了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/22<br />\r\n我的人生就和我破烂的电脑一样，也许在某一天，就突然开不了机了，光怪的屏幕里堆满着无用的别人毫不在意的垃圾，这狭小的窗口成了井底的死尸观望广阔天空的井口，可笑的是我的电脑可以因为莫名其妙的原因黑屏宕机，我却卑微地不敢指责他；而我荒诞的生活已经不能继续却仍要强撑，我却严格的咒骂着自己。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/22<br />\r\n我是如何的失败我自是清楚不过的了，我是如何的无能导致我这般的颓丧，在这场只有lost的游戏当中，会有人乐在其中吗？我只是找不到完美的退出方式，却又没有直接关闭电源的勇气罢了。<br />\r\n我当然知道自己多么可笑，我当然知道自己是如何的软弱，用结束去要挟一切就是我最大的勇气，我不过是一个疯狂的病人，在试验田的舞台上做最癫狂的表演，我不配在这个陆离的世界中拥有聚光灯，我只能在底层的泥泞中失去我曾假借的一切。<br />\r\n如果我这极致的失败、这几乎疯狂的精神是独一无二的，是否我也能说自己拥有过人之处，而显得不那么狼狈？如果曾有人和我一样，是否说明我不过如此，而我所相似的那个他是否比我更加悲哀，毕竟我只配做别人的影子，从来都是我像别人，我只不过是后来的低劣、无能地模仿着。我面对这一切真的累了，我想我的Quit就是电源键了。<br />\r\n每日一句emo小短句，我们明天再见。 2023/05/23<br />\r\n电脑因为C盘的爆满而黑屏宕机了，不过经过他自我的紧急修复又腾出几个G的空间，彷佛一切都可以继续，只是我不知道黑屏的时间里电脑失去了什么。<br />\r\n如果世界黑屏宕机了是不是第一个删除的就是我呢？之后的一切都会照常进行但是不会有我了，而世界应该也不会在乎。<br />\r\n电脑比我更会内存释放，也许他比我更配用电脑？那为什么是我在用电脑？还是我在被电脑使用着用电脑。我不知道，我只能借着胡乱的思考来假装对生活的深思，用故作高深来麻痹自己的浅薄。<br />\r\n电脑黑屏宕机能修好继续，我的生活可以吗？我能修好他吗？或许根本就没有修好只是出卖了什么东西而我并不自知罢了。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/24<br />\r\n人生的一切可能都会在平常和迷茫中渐渐磨灭，在物理角度看熵增的世界以混沌为食，所以一切的荒诞和疯狂似乎都理所当然，而在这如黑暗般的一切中是曾有过耀眼的光辉的，宛若一颗流行划破漆黑的夜幕，似乎是黎明的到来，而那光亮往往被周围的雾霭所吞噬，“面对我们的骨灰高尚的人挥洒下热泪”，我并不高尚，我的泪是因为惋惜和痛恨。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/25<br />\r\n浸润着都市淅淅沥沥的夏雨，朦胧的雾气蒙上了我失明的双眼，<br />\r\n肉体和灵魂在此刻分割，我昏昏的青春倒进这炫丽的城，<br />\r\n外边是奔波的迫切，里面是梦寐的挣扎，<br />\r\n我在月光铺就的路上疯狂的向前奔跑，<br />\r\n甩开身体、甩开安睡、甩开梦想、甩开月亮，<br />\r\n在这个千年之月和都市夜灯共同辉耀的雨夜，<br />\r\n我甩开自我，奔向月亮。<br />\r\n在月亮上，我抱着干瘪的红薯，离月亮越来越远。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/26<br />\r\n原来快乐也使人堕落，所谓生活就是在一团混乱不堪的琐事之中挣扎，最终结束的过程。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/27<br />\r\n生活的痛苦就在于，处在毫无新鲜的平静中疲于奔命。人们渴望改变却又不希望动荡，人们希望安慰却又不希望枯燥平常，每天的生活就像一条可以看见的、逐渐平缓的线，渐渐的没有波澜、没有改变的可能，一切都走向热寂。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/28<br />\r\n在不舍和茫然中踏上了旅途，途中我看见拉满羊的货车，货车上的羊在想什么呢？我和羊有什么区别呢？我们都在无形的压力下被迫登上这辆不知终点何方的列车。最终的结局都是被残酷的刀屠戮殆尽，我想我和羊是没有区别的，想到这我不仅的发出”咩“的一声。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/29<br />\r\n我悲哀的一生还未开始就已经结束，别人的起点是我一生都难以企及的高度，人生就在一个个不知不觉慢慢的错开了，等意识到时已经无可挽回，别人都在一步一步的积累着成功而我一步一步地迈向失败，面对我一团乱麻的生活我只觉得悲哀和无助。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/30<br />\r\n在旁人每日的伟大进度推进时，我无忧无虑的快乐时光就一天天消耗了。我曾经是开放世界里那个无忧无虑的孩子，每日在和煦的阳光下踏上去学校的乡间小路，但是残酷的勇者一天天坐着篝火，我不多的童年急速地消失了，我只能看着我变得不再快乐，烦恼和忧愁日益增多，但我什么都做不了，因为这个过程叫做长大，在长大的过程中我要独自面对一个藏在安全屋外数年的劲敌叫生活。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/05/31<br />\r\n人与人之间的差距实在是太大了，这巨大的鸿沟令我难以逾越，他人数倍、百倍于我的智慧和实力地位，我所有的一切别人只不过弹指之间，而我唯一的成就只有拼命地活着。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/01<br />\r\n第一步:沉淀。<br />\r\n第二步:那场寒冬毁了我的游戏梦。<br />\r\n第三步:黑作坊也能做游戏。<br />\r\n第四步:两年换皮游，一生氪金情。<br />\r\n第五步:游手好闲也是游！<br />\r\n第六步:Steam我想你了。<br />\r\n第七步:独油炒粉。<br />\r\n第八步:城管太凶了，独油地摊。<br />\r\n第九步:经济不景气，独油代驾。<br />\r\n第十步:吊销驾驶证，碧桂园五星上将<br />\r\n第十一步：指点天天打游戏的业主，欺负骗氪的策划狗，遇到危险全身而退。<br />\r\n第十二步：若Jam召必回。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/02<br />\r\n我好像丢了什么东西，或者缺了什么东西，但是我不知道那是什么，我想我找到它一切都会好起来，但是我都不知道那是什么，我只是茫然。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/03<br />\r\n分别的日子日渐近了，我不想那一天到来，却无法阻止，这就是生活、这就是长大，不再无敌，事情不再和美好的想像一样。但我不会忘记，我是活在过去的人，所以我不会忘记。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/04<br />\r\n相聚的时间不多了，结束的那一天一步步到来，我不能阻止这别离，也看不到未来的希望，渴望着更好的明天会到来，但不论我的期望如何混沌的未来终将如期而至，“正义会在正义的终点等着所有人”。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/05<br />\r\n现实不能靠勤劳致富，所以我想在游戏里满足一下这个心愿。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/06<br />\r\n今天是个沉重的日子，不仅因为分别的日子更近了，还有一位同系的同学和这个残酷的世界做了最后的悲惨的告别，生命的沉重和死亡的压抑在这一刻涌上来心头，强权和威压摧残了一条鲜活的生命，我曾想人终是要积极的面对生活，迎难而上的，即便结果是惨败，这样的冲锋至少能让自己以英雄的身份离开；然而残酷的现实是脆弱的身心可能根本抵不住生活的压力和强权的逼迫，稚嫩的生命所留存最后的坚强只有纵身的勇气。<br />\r\n我不配去理解，我只感到悲伤，希望每个人都能拥有美好的生活，希望每个人都能有幸福的明天。<br />\r\n也许之后，他们会给你看论文、帮你改PPT、平台审核第一时间进行，但这都是因为有鲜血来过这里。正义会\r\n找到的，一 直沿着海 滨找到他的终点。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/07<br />\r\n回到学校这几天总是打游戏，完全无心学习，明明自己的人生已经是一塌糊涂却还是一副等死的样子。我这样的人注定是一团垃圾。<br />\r\n每日一句emo小短句，我们明天再见。</p>\r\n<p>2023/06/08<br />\r\n我以前一直不懂克苏鲁，现在我明白了我的克苏鲁就是生活当我看见他是，那无法用语言描绘的疯狂就充斥在我的大脑中。我处处低人一等没有人认可我，我就是一条处在社会底层的虫子，面对这样的现实我陷入深深的自卑，我想过改变却没有成效。这混乱疯狂的一切，血淋淋的才是现实，幻想和谎言所修饰的只是最悲惨的故事。</p>\r\n<p>2023/06/09<br />\r\n一切都要结束了，我最美好的过去就要画上一个句号。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/10<br />\r\n离别总是匆匆，形形色色的人各自奔向自己的前程，回想我的当今犹如一团烂泥，我做什么事都是半成不就，烂透了的样子，这样满身疮痍的我将要迎接一段注定会满是烂泥的人生，我想不如轰轰烈烈地死去来的痛快一点，在我这样胡思乱想时，离别的匆匆又渐渐地近了。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/11<br />\r\n我只能说个人的职业选择和社会环境密不可分，每个人的选择都情有可原，但是可悲的是九品中正制，各大门阀家族互相举荐，构成自己错综复杂的利益网络，朝廷官员冗余等问题，大清已经烂透了。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/12<br />\r\n我转过头去没有看他，我坐在共享单车的座垫上，看着这个颓唐的小镇中心，脑中不知道在想什么，却又感觉有万般思绪涌上心头，我盯着天空，不知不觉地就留下泪了，从此一别我想不会再见了，他会有新的朋友，新的美好生活，我的好朋友又一个离我远去了。我哭得更伤心了，我想这就是分别的感觉吧。今晚的小镇一如既往，没有什么新鲜的事发生，只有一场无可奈何的雨，在月光满轮的晴夜落下。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/13<br />\r\n所有年轻的人啊，不要长大，所有年轻的人啊，不要让生活夺走你的梦想，所有年轻的人啊，不要成为我这样的人。<br />\r\n所有年轻的人啊，长大是件悲伤又无可奈何的事，长大意味着你不再无所不能，曾经的无限活力都变为深深的无力，长大意味着生活很可能会夺走你的梦想，长大意味着你可能会不再是你自己，意味着你可能会成为自己最讨厌的人和那场美好祥和的梦越走越远。<br />\r\n所有年轻的人啊，不要长大。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/14<br />\r\n分别和重逢相冲突在这一刻我不知道是该悲伤还是快乐，我的心中充满无措，我其实一直都是个天真的孩子，本就没准备好去面对这一切，生活不像game那样有趣还可以重来，面对未卜的多艰和枯燥的死寂，我每每消沉，这欢聚只是短暂的，离别又近了一天，欢乐和悲伤浇筑出一杯苦涩的酒，我的脸上没有了表情。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/15<br />\r\n回到这最温馨的地方，我终于感到了放松，哪些令我烦恼的、令我悲伤的我仿佛都看不见、听不到了，在这短暂的快乐的时光中，我应格外珍惜，因为这美妙的一切都将要离我而去，这曾经最不以为然的平常，从今往后也许就是我最大的奢望，我爱你我的爸爸，我爱你我的妈妈，我厌恶它这可悲的生活。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/16<br />\r\n时间总是无情，岁月给心爱的人平添了伤痕，看到她瘦峋的样子和手背上青色的血管、白色的胶带，这个面露苍老的人已经不再年轻了，我所爱的人都回不去了，我最无忧无虑的快乐日子也不在了。每感时光飞逝的无力，才知亲情的可贵，回家的路上我想说“我大姑老了”，但我终究没说出口，我极力让自己不去思考、不去悲伤，我想我的父亲会说“别太愁了，儿子”，而我会回道“你也是”。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/17<br />\r\n有时提笔真不知道写些什么，但觉得这写些东西的习惯自是不能丢掉的，毕竟已经别无什么长处，唯有这一点还能作乐给自己些许的开脱，也算是一种倾诉，不过没有人聆听罢了。最近都在打王国之泪比较放松，没什么思考，没什么感伤。只是觉得王国之泪很有趣，玩起来很忘我，但是再也没有当初第一次玩旷野之息的震撼来的猛烈了，倒不是麻木我想，应是自己“脱敏”了，见识到的也有些了。所以智慧、快乐、财富对大多数人而言其实并不是能全部得到的，不过像我这样一无所有的倒也是少见，也许我可以领个勋章，毕竟在这个物欲横流的社会中，我也是个不小的珍稀物种。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/18<br />\r\n“公道不在人心，是非在乎实力”——《笑傲江湖·东方不败》，正义和公道只是小孩子的游戏，在这个世界上那只不过是可遇而不可求的奢望，在这波涛滚滚的江湖中，有太多的不公了。天下英雄又有几人能够笑傲江湖呢……<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/19<br />\r\n我喜欢下雨天，因为可以随便哭，雨落在脸上也没人知道那是我的眼泪。<br />\r\n每日Emo小短句，我们明天再见。<br />\r\n句子不在多寡，兵刃不在长短，功力一到，便可力通人心。</p>\r\n<p>2023/06/20<br />\r\n我知道的，在雨里能蒙混过关的只有我糟糕的人生，想流泪的话就放声哭泣吧，即便是阳光万丈的日子。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/21<br />\r\n我觉得自己再一次放松了，沉浸在混乱的日子中，这种生活就像是沼泽，不知不觉越陷越深，想改变却做不了什么。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/22<br />\r\n有时候隐瞒是一种让事情更混乱的方式。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/23<br />\r\n也许现要承认自己的无能不足才能更好的前进，每日的emo感觉更像是命题作文了，思考一些东西，然后记录下来，也算是一种对写作的锻炼吧，不过断然不是日记的，这种东西还是太……做作了，最近没有什么灵感，也很少思考，所以笔下也都是些鸡毛蒜皮了。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/24<br />\r\n一味地恐惧担忧未来是愚昧的，“不看当下而盼未来，不看未来而盼过去。”，恐惧来源于未知，而未来永远未知，原地踱步永远无法克服这种担忧，而解决这种忧虑的方法就是行动，基于当下去行动，总是思考担心并不能让我们认清未知，只有一步一步地向前迈进才能揭开未知的面纱，把曾经的忧虑变为当下或过去的不足为奇；当然不是说毫不思索上去蛮干，而是要有一个核心的思路方针，所有的行动都依赖于它，并在实践的过程中不断修正，我想大概应该是这样的。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/25不看当下而盼未来，不看未来而盼过去。<br />\r\n如雷灌顶，我就是一个怀旧的人，总是回忆过去，对现在麻木，对未来迷茫，我一直觉得我的生活充满了绝望，想做什么都不敢开始，也没有坚持，也不知道自己怎么就变成了这个样子。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/26<br />\r\n我终于知道梦想在生活面前是多么无力\r\n梦想只是自我的虚幻，而生活是庞大的真实，这份真实的重量无比沉重，它变成一个黑洞吞噬了所有的一切。<br />\r\n这是我在家的最后一个日子，也是我最后的无忧无虑的日子，面对我最爱的父母和未来未知的生活，我的眼泪止不住的流。<br />\r\n我不知道什么毁了这一切，然后把它灌满了悲伤。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/27<br />\r\n后来我才懂得那些我不曾理解的文字背后的含义，当再次回想时都有了不同的感觉，可惜的是人很难跨越地成长没有经历便没有体会，我终于明白了初读不识文中意，再看已是剧中人。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/28<br />\r\n我的父亲中午只点了一份白米饭加小葱拌豆腐，这洁白的一餐就如同他洁白的一生，我想说“你怎么不多点几个菜”，但我想我是没资格说的，彷佛他少吃了一些这个举步维艰的家就能多往前走上那么一步，我想了良久不知道说什么，只能打出一串省略号“……”。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/29<br />\r\n我来到这陌生的城市看见了不同的人，有暴躁吼人的大巴司机，和对我网开一面的保安，和提示我的路人，收留我过夜的华莱士服务员，帮助我使用优惠的店员以及想帮我省钱的打工小哥，和太阳下辛苦的外卖员，在这里我看见了各式各样的人，在这里我看到了那么多我不曾看到的。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/06/30<br />\r\nBefore was was was, was was is.<br />\r\n逝时曾是时。<br />\r\n一颗玻璃球在液压机的压力下可能会瞬间粉碎，但若是一把玻璃球那是击不碎的，一个人也许抵不住那可怕的压迫，但是千千万万的人民群众团结起来时一切的压迫都不足为惧怕。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/07/01<br />\r\n茫然地走在这陌生的街头，世界上的一切都和我息息相关却又毫无关联，我找不到未来，只觉得生活的悲哀。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/07/02<br />\r\n我不懂得这陌生的一切，我所了解的只有我卑微的生活，机遇被乌鸦叼走，苦难留我独自品尝，不甘和焦虑灌注满我的心头，我的泪已经不再流，时代飘落在人上的从来都不是一颗沙，只不过是有的人在山顶而我在五行山下。<br />\r\n每日Emo小短句，我们明天再见。</p>\r\n<p>2023/07/18<br />\r\n如果死亡，也许会有人为我流泪；<br />\r\n如果死亡，也许会有零星的人感伤；<br />\r\n如果死亡，也许会有人诧异；<br />\r\n但是，我仍苟延残喘，<br />\r\n活着，便没有人去关心；<br />\r\n活着，便没有人开始理解；<br />\r\n活着，便没有死亡。<br />\r\n活着，便是死亡；<br />\r\n所以死亡不必落泪，因为我曾获得了悲伤。<br />\r\n每日Emo小短句，我们会再见吗？</p>\r\n<p>2023/07/21<br />\r\n我小时候总是幻想未来的自己会穿越回来把我杀了，现在我才明白，如果我回到过去，可能会哀求小时候的我把长大的我杀掉。<br />\r\n每日一句emo小短句，我们有缘再见。</p>\r\n<p>2023/07/25<br />\r\n我走到路口，落日低垂和红色的灯光相得益彰，零散的人整齐地插在路旁，头垂进手机里。<br />\r\n在这规律的耕作旁倒也是有别样的风景，一辆黄色的环卫三轮，上面有四五个大叔，皮肤已经变得褐黄了，我偷偷看着他们，假意望向空荡的路口，目光触及到围栏里的楼，就在这落日下他们望着西边的远方，我望着繁华世界中的荒凉，然后灯变绿了。<br />\r\n每日一句emo小短句，我们有缘就会再见。 2023/08/04<br />\r\n初中读《我是猫》时倒也谈不上多么被惊艳到，现在唯一能回想起来的就是，那个在猫眼中一切祥和安适的氛围。<br />\r\n如今我却真真切切地想变成一只猫，我不知道我是否怀着和夏目漱石一样的心情，但我总会回想起那个夏日慵懒的午后，翻开那本厚厚的书一页一页地读着，那时候我应该没有那么多烦恼，回忆为房间铺满了温柔的阳光，眼中的一切只是宁静和美好，就像那只猫一样。<br />\r\n夏目漱石先生，我想变成猫。<br />\r\n每日一句emo小短句，希望陌生的你可以像猫一样，充满童真和快乐，我们会再见，哪怕你不记得我。</p>\r\n<p>2023/08/08<br />\r\n生活也许会欺骗你，也许会愚弄你，你可能对一切都感到绝望，但是别像我一样沉浸在悲伤中妄想活着的感觉，爱自己，我的朋友。<br />\r\n每日一句emo小短句，我们偶尔见上一面吧</p>\r\n<p>2023/08/11<br />\r\n苍天已死，黄天当立。<br />\r\n岁在甲子，天下大吉。<br />\r\n今天偶然看到了13年的一个交友贴，我仿佛能看到有一群拥有共同爱好的人聚在一起，那热闹的气氛，但9年过去曾经年轻的人可能已被生活催的岁月已老，不禁感叹这群互联网遗老会不会偶尔怀念过去，是否我们曾怀着同样的心情看过去、望未来。点开这崭新的古老链接时，能看到的也不过是独属于那个时期的一个又一个有趣的灵魂罢了。但是也可能由于重拳或压力，现在望去，曾经热闹的讨论版如今也不过是纷繁混乱的网络世界中，又一个少缺人烟、落满时代尘埃的犄角罢了。<br />\r\n每日一句emo小短句，神马都是浮云。 2023/08/20<br />\r\ncheems早就不是表面上那一只普通的柴犬了，<br />\r\n我认为这是一种文化现象或者浪潮，他已经成为了一种意象，其中最为珍贵的是cheems浪潮传递的那些思想和被人们带来的激励、感动。<br />\r\n当他被遗忘时，才是他真正死亡的时候。<br />\r\n存其意而忘其形，如果你活着你早晚都会死，如果你死了，你永远都活着。<br />\r\ncheems的离世无疑是一件让人悲伤的事，但是我会记住这一切。</p>\r\n<p>见过互联网的波涛汹涌后，已经习以为常，光怪陆离、充斥着荒诞的新世纪发生什么都不足为奇，在这个美妙而不知所向的时代里，我被赋予了一颗石之心，麻木地感受着无数的悲与喜。<br />\r\n每日一句emo小短句，今日突袭群友！劫营速战，措手不及。<img\r\nsrc=\"D:\\biancheng\\Blog\\source\\imgs\\每日Emo小短句\\F1SZC9%7DW%7D_XEA5S%5D5FCJM3.png\"\r\nalt=\"img\" /></p>\r\n<p>他们都太优秀了，优秀到被照到的我居然以为自己也能成为一颗星星，突然有那么一天就被随意的聊天惊醒了，什么星星啊，原来我还是那个在下水道里发臭的垃圾啊，如今切实地体会到那句话了“天才这种东西，常会不自觉地将周遭的人卷入，然后弄得遍体鳞伤。越是靠近，越会被撕裂成碎片。”，等回过神来时已经菠萝菠萝哒了。</p>\r\n<p>2023/09/01<br />\r\n\"我爱你。\"<br />\r\n你可能觉得奇怪，也可能感到突兀或者冒犯；但是有时人们之间确实会有那种莫名的憎恨，甚至没有任何理由，所以我想人和人之间也会有这种不需要理由的爱。可能这种爱并非是深入骨髓、刻骨铭心的海誓山盟，更像是一句寻常的关心，哪怕是一种冲动。<br />\r\n然而，如果这份爱是虚假的，那我希望那莫名其妙的恨也失去意义。<br />\r\n每日一句 emo 小短句，我们有缘再会。 2023/09/02<br />\r\n触不可及却刻骨铭心，生活的无奈就在每日的平凡中展开，<br />\r\n我们也许都在做着正确的事，但悲哀的是当我们彼此交汇，这本该在时间的河流上编织的诗歌如今只有混沌。<br />\r\n“如果我不直播了 我可能会突然上个厕所 然后再也不回来了”<br />\r\n“泥头车每天还是准点来，只是车上再也没有那个女孩的身影。如果当初知道，应该放下一切，上车，不再回来。”<br />\r\n“圣地亚哥在下雨，智利别为我哭泣”<br />\r\n每日一句 emo 小短句，我们有缘再会。 2023/09/04<br />\r\n狗彘食人食而不知检，途有饿殍而不知发<br />\r\n指望资本主义的走狗良心发现简直是异想天开，为自己徒增烦恼，要明白谁是敌人，谁是朋友。<br />\r\n团结一切可以团结的力量，打倒所有的敌人。 2023/09/29<br />\r\n爱而不得才是常态，充满遗憾就是人生；<br />\r\n壮志未酬不过稀松平常，苦海无涯乃是我的命运。<br />\r\n“试问天下英雄又有几人能够真正的笑傲江湖呢”<br />\r\n我原以为自己这卑劣的样貌不过是不讨喜，对于旁人也不过是稀松平常，没想到自己竟然如此的令人恶心。在这昭然的事实后展示出的是这场淘汰机制的生存竞争，从古至今一刻不停。可悲的是，无论你赋予生命怎样的意义，在这场追寻宇宙真理或生存真谛的比赛中，败者只能是一无所有，直至死亡，所有的思辨最后恐怕都是自我安慰，一次名为自我欺骗的“和自己和解”。<br />\r\n在这场比赛中，我从来没有获胜过，我只是个loser\r\n所以我恨，我的立场不是中立，因为我尝尽了悔恨、嫉妒、憎恶的滋味，那必定不是甘甜的也不是苦涩的，而是刺痛。<br />\r\n每日一句 emo 小短句，我们有缘再会。 2023/09/29<br />\r\n当我蜷缩在这大到无边城市里阴暗的一角时，我想起了那句台词<br />\r\n“我要这满城的人都来陪葬”<br />\r\n“千里皇城尽作焦土”|<br />\r\n我仿佛能理解李儒的焚城决策，但我没有那样的智慧，我只有偏执的疯狂。<br />\r\n每日一句 emo 小短句，我们有缘再会。 2023/10/06<br />\r\n有时候我们耗尽一切都得不到自己渴望的东西，其实这才是生活的常态，长大的世界就是求而不得、学着放手；不知不觉我们都不再是那个哭哭闹闹就能得到冰淇淋的小孩子了，那种无忧无虑的时光最后只能成为宝贵的回忆，让我们在痛苦的现实中去怀念、去流泪。<br />\r\n不过我没吃过冰淇淋。<br />\r\n如果不用上班是否所有的悲伤都会变作欢乐呢？<br />\r\n今日 emo 能量赞助来源，歌曲《Duvet》，演唱者 Bôa\r\n，别名《TVアニメ「serial experiments lain」OP1テーマ》，收录于《Tall\r\nSnake Ep》专辑中。(就是《Lain》的 OP 哦)<br />\r\n每日一句 emo 小短句，我们有缘再见。</p>\r\n<p>2023/10/15<br />\r\n从互联网文学，到农村纪实(在如今这个城市化程度很高的时代，还有人去关心乡村去记录现实，我是表示敬佩和珍惜的)，再到修正主义和牛鬼蛇神，再到过去的抗争记忆，再到古代新学和现代桎梧，还有当下未来的科幻，一切都与我无关，却都发生在我身边。<br />\r\n[图片] 已过期</p>\r\n<p>2023/11/02<br />\r\n清醒令人痛苦，麻木使人沉沦，人记性太好会很痛苦。<br />\r\n每日一句 emo 小短句，我们有缘再见。</p>\r\n<p>弱智吧小集合<br />\r\n敬老院的新人都是老人，这个世界的大人都是小人。<br />\r\n所有的桥都是温暖的，因为他们让河流不再难过。<br />\r\n从我确诊出生的那一刻，我的死亡就只是时间问题。<br />\r\n皱纹是时间吹过身体时泛起的涟漪。<br />\r\n月亮——摘自《星空》<br />\r\n看到花开放时，花就已经在枯萎了。<br />\r\n我的梦想是一对情侣，白天我压的她说不出话，晚上她压得我难以入眠。<br />\r\n我最新的照片是我最老的照片。<br />\r\n生鱼片是死鱼片。<br />\r\n世界是个大象，我们每个人都在盲人摸象，抽象是对世界最好的鞭笞。</p>\r\n<p>2023/11/19<br />\r\n我已经燃烧殆尽了，只剩下雪白的灰。<br />\r\n燃え尽きたぜ…真っ白にな…</p>\r\n<p>如果只能有一个李哥，为什么不能是我李元浩的李。<br />\r\n这可能是你唯一的机会了，小虎。<br />\r\n也就是说，现在是LPL苍蓝猛虎登场的时候了。<br />\r\n昼虎！夜凯！<br />\r\n地虎铠甲，合体！</p>\r\n<p>小虎需要这个冠军来证明自己。</p>\r\n<p>2023/12/15<br />\r\n害，卡姐真的是太惨了，幼年丧母，青年丧父，碰到了戈塔屎，以为是好人结果被坑了。<br />\r\n到博德之门后，她对死去的父母，以前的朋友都是在做死前的最后道别。<br />\r\n在饭店的夜里，她说干净床单的味道能让她想起妈妈，因为她妈妈是一个洗洁工，她畅想假如自己还有50年，未来会有多么美好……<br />\r\n但是这一切注定都是悲剧，逃窜到最不愿回首地狱也不过是在惨淡的命运驱使下痛苦地活着，“再见，大海。再见，太阳。再见。”<br />\r\n我爱你，卡菈克。</p>\r\n<p>203/12/17<br />\r\n如果没有遗憾，我是否还会爱你？</p>\r\n<p>2024/01/08<br />\r\n在最黑暗的晴空万里我为太阳哭泣，如果明天我不再升起，<br />\r\n请别为我忧郁，<br />\r\n如果明天我不再呼吸，<br />\r\n世界请为他人欢愉。<br />\r\n在麻木和壁垒中流浪，清醒让我渴望死亡。<br />\r\n如果懦弱是种疯狂，麻木是否已经渗入我的骨髓。<br />\r\n我渴望哭泣，我渴望结束，我渴望渴望。<br />\r\n每日一句 emo 小短句，我们有缘再见。</p>\r\n<p>2024/01/20<br />\r\n哦，妈妈请别为我哭泣，我们将回到故乡。<br />\r\n读哈马斯的勇敢有感。<br />\r\n每日一句 emo 小短句，我们有缘再见。<br />\r\n神只是人类美好的倒影，至少于我而言，最伟大的是人类历史中那些充满勇气的瞬间。</p>\r\n<p>2024/05/10<br />\r\n原来幻想中反派听到音乐被迷惑困住甚至感悟的情况是真实存在的。<br />\r\n当我听到童年熟悉的音乐才知道自己再也回不到那个，炎热却温暖，茫然却快乐的日子了。<br />\r\n我在熟悉的旋律在忘却了当下，只记得那个温和的午后，<br />\r\n我被这悠扬的笛声困在了过去，又逃不出现在，<br />\r\n这是一种奇妙的感觉，温馨快乐做了泪水的底料而悲伤洒在了我的脸颊。<br />\r\nhttps://www.bilibili.com/video/BV1dy42187pm<br />\r\n每日一句 emo 小短句，我们有缘再见。<br />\r\n对了，也许我的可可果已经熟了吧。<br />\r\n难道人生注定是一个塑造自己，丢失自己，怀念自己，找寻自己的过程吗……可悲的是我无法找回自己了，我只想杀死自己。</p>\r\n<p>2024/07/14<br />\r\n坐火车是一件挺有心理压力的事。<br />\r\n在车上能看见各个年龄段，和很多不同的人，从小孩到大人，再到老人，从体力工人再到脑力劳动者。<br />\r\n仿佛人生的大部分状态和未来的可能都被压缩到这一个狭窄的通往过去或未来的车型上。<br />\r\n在这里看到自己记忆中的过去，也能投射出自己些许的未来。<br />\r\n我为不能回到过去而感到悲伤，我为昏暗的未来感到悲伤。<br />\r\n我为座位如此接近，阶级差距却如此之大而感到悲伤。</p>\r\n<p>2024/07/15<br />\r\n在混杂的音响和众人的祝福中，我的思绪其实早已飞到过去，我只看得见一屡长发在我眼前拂过，<br />\r\n阳光顺着发间映出，仿佛发光的是她，而不是背后的太阳，我怯懦地用残缺把她的脸从回忆中抹去，<br />\r\n仿佛这样就不会悲伤。<br />\r\n于是我坐在喜宴的桌沿上，沐浴着礼炮的彩色飘带，大家都在笑，我也笑了，<br />\r\n“祝你幸福”。</p>\r\n<p>2024/09/14<br />\r\n难道人生就是一个被当下蹂躏，焦虑未来，怀念过去的体验吗？<br />\r\n如果一向如此，我美好的曾经是否子虚乌有，我的焦虑是否杞人忧天，我的现在是否镜花水月。<br />\r\n你好，我已经去了未来，如果你看到了这段信息，请在现在把我带到过去。</p>\r\n<p>2024/11/24<br />\r\n阳光好刺眼啊，仿佛要把我全身的潮湿和阴暗都蒸发掉一样，即便是这样的白日青天、朗朗乾坤，我的前程为何还是一片灰暗。<br />\r\n要何等的烈焰才能驱散笼罩在心头的阴霾。</p>\r\n<p>2024/10/25<br />\r\n为什么现实是这样复杂且痛苦的呢？<br />\r\n也许这个世界就是一口大锅里面炖着一切，当我品尝生活的滋味时，不是咸，也不是甜，那种味道很复杂，很多时候这种味道让我说不出话。<br />\r\n也许五味杂陈的意思我现在才理解吧。<br />\r\n我的现实是没有幸运星的。<br />\r\n也许一开始这就不是一个开心温暖的故事，不过虽然我开了一个糟糕的起承，但至少我还是作者，这个故事还不会封笔。<br />\r\n写到这里时不由得想到巴勒斯坦人民的遭遇，真是场卑劣的战争，悲怆和残忍正在这片土地上演，巴勒斯坦人民万岁。</p>\r\n<p>2024/11/01<br />\r\n我闭上眼睛，勇气没有增长。<br />\r\n这薄薄的无尽黑暗中，我看到了未来，<br />\r\n所以无需畏惧，大啖食粮之刻已至。</p>\r\n<p>2024/11/28<br />\r\n我只是在原地兜圈子的一个孩子，<br />\r\n我渴望有人主动跑过来爱我，<br />\r\n我希望有人能拉着我的手前进，<br />\r\n而现实是，不会有这样的人了，<br />\r\n而幼稚的我只知道坐在原地大哭，<br />\r\n这不是一场悲剧，只是我个人的丑态。</p>\r\n<p>2024/12/03<br />\r\n正义是杀不完的，无论是真的还是希望相信，正义都是杀不完的。<br />\r\n即便我们只能像“我们必须想象西西弗斯是幸福的”一样略带无奈和妥协地去相信自我价值。<br />\r\n正义是杀不完的。</p>\r\n<p>悲歌可以当泣，远望可以当归</p>\r\n<p>2024/12/05<br />\r\n望未来•娄山关<br />\r\n冬风裂，空留萧索孤影夜。孤影夜，霜飞雨泄，亭台幽咽。<br />\r\n崎岖闭路了无疟，今夕空作亡魂雀。亡魂雀，幽闭犹怨，寒玉犹泪。</p>\r\n<p>2024/12/05<br />\r\n我时常感到悲伤， 说悲伤是陪我之现在的朋友也不为过，\r\n所以我想既然我摆脱不了它，\r\n不如去享受这一刻，把我的感受和思考记下来，哪怕给人作为玩乐的笑料，\r\n渐渐的这也成为了我的一种习惯或者说乐趣。<br />\r\n人活一世也许真的会留下点什么。</p>\r\n<p>2024/12/11<br />\r\n雨打在外套上窸窸窣窣，上海的冬天，也不能说为冬天吧，比家乡来讲应是晚秋的气温，虽然如此但气温也低，寒冷的夜有些伤感，能听到只有汽车呼啸而过带起的水泽和雨滴滴答答。\r\n没有月亮，没有星星，就像没有太阳一样，我想不明白游戏行业为什么这样的，有的人已经金缕玉衣，而我能还在一堆烂泥淤成的潭里，不仅狼狈丑陋而且一无所有。\r\n每每想到这我都感到十分的伤心，甚至想大哭一场以此来发泄来麻痹这庞大的、痛苦的、无助的感觉。\r\n我想璀璨的人生我是不会拥有了，有的故事就是这样的能够扭扭歪歪地写出几个字就已经很不容易了，哪里还有什么美学或者意义呢。\r\n我的人生已经开始了，但是我的人生其实早就结束了。\r\n雨漏进了泥潭，天有些凉，我也有些冷了，但是我看不见月亮。</p>\r\n<p><em>注释：雨没有漏进泥潭，其实是笔者的眼泪在心窝中流转。</em></p>\r\n<p>2024/12/12</p>\r\n<ul>\r\n<li><p>分不清是被子冷，还是天气冷，还是世态炎凉。</p></li>\r\n<li><p>所以说人与人之间的隔阂就像at立场一样，我撞不开，强行撕开只会让人受伤。</p></li>\r\n<li><p>冷暖自知，能感受到的只会有冷。\r\n这是个最冰冷的词汇，因为不能和别人拥抱才只能自己窝在寒冷里幻想温暖。</p></li>\r\n<li><p>没人爱我。<br />\r\n倒不是说大家都不喜欢我，可能会有人喜欢我，但是是没有爱的勇气的，我也没有，我就是那个害怕幸福而逃走的胆小鬼。<br />\r\nxx，你戏谑的外表下藏着什么呢？<br />\r\n嘻嘻哈哈也金缮不了被生活伤害的残破的心。<br />\r\n我不要。<br />\r\n我要未来，我要希望，我想要爱，我想要真理。</p></li>\r\n<li><p>我所做的工作都是微不足道的，我只是把那个缤纷绚丽的世界搬到大家面前，除此之外别无他长。<br />\r\n只要用心观察世界，每个人都是伟大的作家。</p></li>\r\n</ul>\r\n<p>2024/12/19<br />\r\n你说得对。<br />\r\n我的一生确实是浪费了。<br />\r\n我不再是那个有所期望的人了，<br />\r\n在自己的软弱催使下，在见证一起冷漠的爱和爱抽象的人却转身向现实铡刀者之后，我不在爱人类了。</p>\r\n<p>所谓的博爱和温柔，只不过是披着抽象外衣的自我感动，卑劣至极罢了。\r\n我不再爱自己，在试着爱人类时，也失败了。 人所之人，非人哉。</p>\r\n<p>2024/12/25<br />\r\n前人之述备矣。<br />\r\n我每次有所感悟，有所表达时，特别是选题相近，比如对时间流逝的感悟，其实早有绝笔，所以总有些彷徨，我对着千古已定的命题还有所疑虑，仿佛我已经忘却了前人的教诲，有些羞愧。<br />\r\n但是我突然想到，所感前人之感，也并非说明我们遗忘了什么。<br />\r\n恰恰说明人类从未遗忘，对于相同的困境和问题，拥有了相同的感悟或表达抑或不同，恰恰说明人类没有忘却。<br />\r\n面对相同的问题，我相信这种重复思考会继续下去，直到它解决的那天。<br />\r\n虽然后人可能忘记我当下随感，但是当他们遇到相同的问题时这一切的思考会再次涌现。<br />\r\n也许对于人类而言，时间的流向已经固定，宇宙就是如此的残忍无情，那么如此脆弱的人类，所能拥有对抗这一切的、唯一的脆弱武器便是思想，唯有思想才能穿越时间。<br />\r\n我称之为，遗忘的记忆。</p>\r\n<p>去忘记吧，等你忘记所有招式你就练成了太极拳。</p>\r\n<p>2024/12/26<br />\r\n\"雪融\"，我看不见太阳升起了，我的雪在这里就要化了，只不过只能以泪水的方式了。<br />\r\n明年7月，如果你有时间的话，对风声说一句天气如何吧。</p>\r\n<p>2024/12/27<br />\r\n有时候做梦就梦见审死官里面那一幕，<br />\r\n星爷演的那个状师，拿着金元宝轻蔑地指着我，“做游戏啊！做游戏啊！”，<br />\r\n于是我也和他一起戏谑了。</p>\r\n<p>2025/01/07<br />\r\n昨天我大学同学的朋友问我，你读这么多年书现在加班那么晚，有没有后悔过，<br />\r\n当时没觉得什么只是说，还能怎么办想那么干啥，得生活啊。<br />\r\n现在冷静下来，想想心里突然有点东西放不下了。<br />\r\n我知道他是想问问我答案，但是我也不知道答案，<br />\r\n我其实和他一样，<br />\r\n至少在对人生的迷惘上，出奇的一致。</p>\r\n<p>2025/01/08 看一次哭一次，如果真的有爱情的话希望别是这个样子。<br />\r\n伤心莫采琵琶树，断魂不照小轩窗。</p>\r\n<p>2025/01/24<br />\r\n幸福是主观的，浮动的，不可定义的，同时也是无法衡量，不能经由测试的。<br />\r\n很多时候幸福可能是一瞬间的感觉，当然会有幸福存在。<br />\r\n然而从长远看人生更可能是一场悲剧，幸福也许是不存在的。<br />\r\n选择做一个无知的人欺骗自己是幸福的，或者做一个痛苦的人接受幸福是少数的。<br />\r\n很难说这两者是聪明的愚蠢，还是愚蠢的聪明。</p>\r\n<p>2025/02/21<br />\r\n你怎么开始怀念过去了？<br />\r\n你老了吗？可是你最多可能也就30岁，不太老也不太年轻。<br />\r\n我不知道，也许是……过得有点辛苦让我想起了从前。<br />\r\n你呢？朋友。</p>\r\n<p>2025/02/21<br />\r\n落叶魔音，见落叶而知深秋，<br />\r\n晓得盎然春日遥遥。<br />\r\n初听不觉何足道，十年邈邈，<br />\r\n再奏断万股愁肠，千滴泪。</p>\r\n<p>2025/02/26<br />\r\n牛马哥，我总是想起从前，<br />\r\n我现在生活地很痛苦，在夜深人静的时候，我努力回想小时候那些美好的时光，那些日子因为遥远反而显得格外温暖。<br />\r\n但是我的身心已经冰冷，只有在回忆中逃避当下的时，才能感受到什么叫生命。<br />\r\n在我去逐步认识这个世界的现实中，疫情又给了我沉重的打击，在哪个迷惘和无措的时光惶惶然，我被迫进入了社会，没有承担责任的勇气，没有敢于面对困难的魄力，有的只有对未来的迷惘和昨日的创伤。<br />\r\n于是我再次回忆，那个慵懒的躺在午后阳光里的孩子，那个和朋友有说有笑不知愁滋味的男孩。<br />\r\n对我而言过去是欢乐的，但是我站在原地往回跑的时候，却无论如何也追不上了。</p>\r\n<p>2025/03/18<br />\r\n就像我总怀念那年夏天的风，<br />\r\n我记得那是一个凉爽的下午，<br />\r\n它从窗户钻了进来，<br />\r\n卷起前桌黑色的长发，<br />\r\n来到我的桌前，<br />\r\n它给的感觉很轻快，仿佛在拖着我无拘无束，<br />\r\n它就这样的一阵阵来，一阵阵去，<br />\r\n直到那个夏天过去了，<br />\r\n我以为他还会回来，我也以为那个夏天会再来。<br />\r\n可是夏天总是，但是那股风再也没回来过。</p>\r\n<p>2025/03/30<br />\r\n如果严肃的文学作品消失那将是整个时代的悲剧，<br />\r\n在当下我们可以看到，文娱作品越来越轻量化，娱乐化，<br />\r\n表达内容浮于表面，过去的严肃叙事仿佛消失了，<br />\r\n那些曾经激烈探讨的问题不再成为作品创作的素材了，<br />\r\n可是那些问题就真的消失了吗？<br />\r\n尤其是在去政治化特别严重的某些国家，<br />\r\n甚至是谈之色变，政治和每个人的生活、权力、义务相关，<br />\r\n放弃严肃叙事，放弃政治讨论，等同于放弃思考，放弃社会权益。<br />\r\n我觉得这是可悲的、可怕的。</p>\r\n<p>2025/3/30<br />\r\n省流，匹配成功。 不过不用想这么多，玩游戏的时候感觉到开心就好了。<br />\r\n游戏作为文娱产品的目的就是取悦用户的。<br />\r\n有反思有向往是好事，但是个人的努力无法和时代的洪流抗争，<br />\r\n所以，去享受人生吧，在生活的痛苦中，给自己找一颗糖吧。</p>\r\n<p>2025/05/11<br />\r\n追寻梦想总是痛苦的，尤其是在这片土地上，现实太过沉重，把我们每个人拖向地狱，<br />\r\n为生活妥协无可指责，但是在回首过去时，总会心有不甘，人生就是抱着遗憾漫无目的踱步的过程。</p>\r\n<p>2025/05/21<br />\r\n仇恨就像螺旋一开始还有迹可循，可世事不能离散只有连续。</p>\r\n<blockquote>\r\n<ul>\r\n<li><p>Agent Ross, Pinkerton Detective Agency.</p></li>\r\n<li><p>Enjoy your fishing kid, while you still can.</p></li>\r\n<li><p>Excuse me! You Edgar Ross?</p></li>\r\n<li><p>Do I know you?</p></li>\r\n<li><p>Forgive me for startling you, sir. I have a message for you. My\r\nname is Jack Marston. You know my father.</p></li>\r\n<li><p>I see... I remember your father.</p></li>\r\n<li><p>I've come for you, Ross.</p></li>\r\n<li><p>And you, boy, have sure as shit found me.</p></li>\r\n<li><p>You killed my father. You shot him like a dog.</p></li>\r\n<li><p>Your father killed himself with the life he lived.</p></li>\r\n<li><p>You killed him! I saw you!</p></li>\r\n<li><p>You keep saying that.</p></li>\r\n<li><p>You sent him to do your dirty work, then you shot him like a\r\ndog!</p></li>\r\n<li><p>And I'll shoot you like one too, you little piece of trash! Now\r\nget out of here before I kill you as well!</p></li>\r\n<li><p>I ain't going nowhere, old man!</p></li>\r\n</ul>\r\n<p>RED DEAD REDEMPTION</p>\r\n</blockquote>\r\n<blockquote>\r\n<ul>\r\n<li>You can't erase the past, John. Killin' me, it won't make it go\r\naway. ...</li>\r\n<li>Hello again, John.</li>\r\n<li>Hello, Dutch.</li>\r\n<li>We gotta stop meeting like this!</li>\r\n<li>Sure.</li>\r\n<li>I've got a plan, John.</li>\r\n<li>You've always got a plan, Dutch.</li>\r\n<li>This is a good one.</li>\r\n<li>I don't doubt it.</li>\r\n<li>We can't always fight nature, John. We can't fight change. We can't\r\nfight gravirty. We can't fight nothing. My whole life, all I ever did\r\nwas fight.</li>\r\n<li>Then give up, Dutch.</li>\r\n<li>But I can't give up, neither. I can't fight my own nature. That's\r\nthe paradox, John. You see?</li>\r\n<li>Then I have to shoot you.</li>\r\n<li>When I'm gone, they'll just find another monster. They have to,\r\nbecause they have to justify their wages.</li>\r\n<li>That's their business.</li>\r\n<li>Out time is passed, John.</li>\r\n</ul>\r\n</blockquote>\r\n<p>2025/06/07<br />\r\n繁重的工作压得人喘不过气， 连打游戏作为消遣的动力都没有，\r\n在夜深人静放松思绪能够思考什么的时候，\r\n往日观看的asoul视频又浮现在眼前，已经很遥远了，但是有希望能够近一些。\r\n无论接受与否那都成了过去，必须学着接受， 这就是生活残酷的地方，\r\n我们漫无目的来到这个世界，遵从生存的本能，\r\n短短数十年在史书中不过寥寥几笔， 整个人类历史于宇宙而言不过尘烟，\r\n这一切真的有意义吗？宇宙存在所谓意义吗？\r\n我怀疑，但悲哀的是我只能相信，无所谓与否。</p>\r\n<p>清风乱弄两三页，提笔一拨百十年。 长叹飘渺江中月，落花点水了人间。</p>\r\n<p>2025/06/15<br />\r\n从《巴黎的忧郁》到《凉宫秋日的忧郁》他们的悲伤不及我的万分之一，<br />\r\n早在落笔之前忧郁已悄然而至，媒体所载至少有人同悲，而我的忧郁只属于我自己。</p>\r\n<p>摘抄自《知乎》，中华人民共和国的一款人民分享见闻观点，芝士的平台。</p>\r\n<p>2025/07/04<br />\r\n在21世纪还能看到联合小团体迫害一个人在网上发表言论的自由，这种情景也是少见了。\r\n当你在为同胞争取权益时，还要被倒打一耙，要怪罪你破坏了他们安定祥和的生活，<br />\r\n与之前其痛恨其作为资本家走狗的同事时的面孔截然相反，换了副面孔便高高在上，圣洁无暇了。<br />\r\n若是真的有罪便也受的没什么怨言，狺狺野狗也学起秦桧的手段了，真不得令人发笑。</p>\r\n<p>2025/07/08<br />\r\n树死叶落黄，飞沙填泥漳，<br />\r\n猢狲不可言秋凉，唯恐泣涕泪叶扬。</p>\r\n<p>2025/07/25<br />\r\n在某国你上班得忍受被压干最后一滴血的觉悟，<br />\r\n没有基本的人权保障，没有合理的假期安排，没有休息时间，<br />\r\n还要被当权者拿走产出，还得看着他们用你的辛勤劳动去花天酒地肆意挥霍。</p>\r\n<p>2025/07/25<br />\r\n回万古长夜月明，多少英雄不在，<br />\r\n哀一生前途晦暗，几许气概无存。<br />\r\n多少千百事，都做尘与土。</p>"},{"title":"已修复","date":"2021-12-31T16:00:00.000Z","_content":"\n# 紧急通知\n\n因为本人玩 `hexo-renderer-markdown-it-plus`，玩崩了，所以本Blog处于不稳定状态，很多文章图片加载不出来。目前看来是什么神秘的插件缺失了吧，大概。  ","source":"_posts/紧急说明.md","raw":"---\ntitle: 已修复\ndate: 2022-01-01\n---\n\n# 紧急通知\n\n因为本人玩 `hexo-renderer-markdown-it-plus`，玩崩了，所以本Blog处于不稳定状态，很多文章图片加载不出来。目前看来是什么神秘的插件缺失了吧，大概。  ","slug":"紧急说明","published":1,"updated":"2025-08-12T15:41:47.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti50017bkbwak5v2pkt","content":"<h1 id=\"紧急通知\">紧急通知</h1>\r\n<p>因为本人玩\r\n<code>hexo-renderer-markdown-it-plus</code>，玩崩了，所以本Blog处于不稳定状态，很多文章图片加载不出来。目前看来是什么神秘的插件缺失了吧，大概。</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"紧急通知\">紧急通知</h1>\r\n<p>因为本人玩\r\n<code>hexo-renderer-markdown-it-plus</code>，玩崩了，所以本Blog处于不稳定状态，很多文章图片加载不出来。目前看来是什么神秘的插件缺失了吧，大概。</p>\r\n"},{"typora-root-url":"./..","_content":"\n一个字符串删除n位，使结果最小，相对位置不变，不能有前导零。\n例子：90001删除2位，结果900\nRemoves n bits of a number so that it is minimal\n[类似的题目](https://www.geeksforgeeks.org/build-lowest-number-by-removing-n-digits-from-a-given-number/)\n\n## [戳气球(数组、动态规划)](https://blog.51cto.com/zhanjq/6054073)\n\n有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。\n现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。\n求所能获得硬币的最大数量。\n\n示例 1：\n输入：nums = [3,1,5,8] 输出：167 解释： nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] `coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 15 + 120 + 24 + 8 = 167`\n\n### [Leetcode题解](https://leetcode.cn/problems/burst-balloons/)\n\n`dp[i][j]表示填满开区间(i,j)能得到的最大数`\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> nums(n);\n    for(int i = 0; i < n; ++i)\n    {\n        cin >> nums[i];\n    }\n    vector<int> tmp(n+2);\n    for(int i = 0; i < n; ++i)\n    {\n        tmp[i+1] = nums[i];\n    }\n    tmp[0] = tmp[n+1] = 1;\n    vector<vector<int>> dp(n+2,vector<int>(n+2));\n    for(int k = 1; k <= n; ++k)\n    {\n        for(int i = 1; i <= n - k + 1; ++i)\n        {\n            int j = i+k-1;\n            for(int x = i; x <= j; ++x)\n            {\n                dp[i][j] = max(dp[i][j], \n                dp[i][x-1] + tmp[i-1]*tmp[x]*tmp[j+1]+dp[x+1][j]);\n            }\n        }\n    }\n    cout << dp[1][n];\n    return 0;\n}\n```\n\n# 状态压缩DP\n\n# [祖玛游戏](https://leetcode.cn/problems/zuma-game/solutions/)\n\n\n\n# [省份数量](https://leetcode.cn/problems/number-of-provinces/description/)\n\n\n\n# [N皇后]()\n\n规则和N皇后一样，但是输入一个棋盘上有若干旗子，问最多还能放多少棋子\n","source":"_drafts/AlgorithmNote.md","raw":"---\ntypora-root-url: ./..\n---\n\n一个字符串删除n位，使结果最小，相对位置不变，不能有前导零。\n例子：90001删除2位，结果900\nRemoves n bits of a number so that it is minimal\n[类似的题目](https://www.geeksforgeeks.org/build-lowest-number-by-removing-n-digits-from-a-given-number/)\n\n## [戳气球(数组、动态规划)](https://blog.51cto.com/zhanjq/6054073)\n\n有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。\n现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。\n求所能获得硬币的最大数量。\n\n示例 1：\n输入：nums = [3,1,5,8] 输出：167 解释： nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] `coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 15 + 120 + 24 + 8 = 167`\n\n### [Leetcode题解](https://leetcode.cn/problems/burst-balloons/)\n\n`dp[i][j]表示填满开区间(i,j)能得到的最大数`\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> nums(n);\n    for(int i = 0; i < n; ++i)\n    {\n        cin >> nums[i];\n    }\n    vector<int> tmp(n+2);\n    for(int i = 0; i < n; ++i)\n    {\n        tmp[i+1] = nums[i];\n    }\n    tmp[0] = tmp[n+1] = 1;\n    vector<vector<int>> dp(n+2,vector<int>(n+2));\n    for(int k = 1; k <= n; ++k)\n    {\n        for(int i = 1; i <= n - k + 1; ++i)\n        {\n            int j = i+k-1;\n            for(int x = i; x <= j; ++x)\n            {\n                dp[i][j] = max(dp[i][j], \n                dp[i][x-1] + tmp[i-1]*tmp[x]*tmp[j+1]+dp[x+1][j]);\n            }\n        }\n    }\n    cout << dp[1][n];\n    return 0;\n}\n```\n\n# 状态压缩DP\n\n# [祖玛游戏](https://leetcode.cn/problems/zuma-game/solutions/)\n\n\n\n# [省份数量](https://leetcode.cn/problems/number-of-provinces/description/)\n\n\n\n# [N皇后]()\n\n规则和N皇后一样，但是输入一个棋盘上有若干旗子，问最多还能放多少棋子\n","slug":"AlgorithmNote","published":0,"date":"2024-01-14T08:13:08.468Z","updated":"2024-01-14T08:13:08.468Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti60019bkbwgt12bht4","content":"<p>一个字符串删除n位，使结果最小，相对位置不变，不能有前导零。\r\n例子：90001删除2位，结果900 Removes n bits of a number so that it is\r\nminimal <a\r\nhref=\"https://www.geeksforgeeks.org/build-lowest-number-by-removing-n-digits-from-a-given-number/\">类似的题目</a></p>\r\n<h2 id=\"戳气球数组动态规划\"><a\r\nhref=\"https://blog.51cto.com/zhanjq/6054073\">戳气球(数组、动态规划)</a></h2>\r\n<p>有 n 个气球，编号为0 到 n -\r\n1，每个气球上都标有一个数字，这些数字存在数组 nums 中。\r\n现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] *\r\nnums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i\r\n相邻的两个气球的序号。如果 i - 1或 i + 1\r\n超出了数组的边界，那么就当它是一个数字为 1 的气球。\r\n求所能获得硬币的最大数量。</p>\r\n<p>示例 1： 输入：nums = [3,1,5,8] 输出：167 解释： nums = [3,1,5,8]\r\n--&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []\r\n<code>coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 15 + 120 + 24 + 8 = 167</code></p>\r\n<h3 id=\"leetcode题解\"><a\r\nhref=\"https://leetcode.cn/problems/burst-balloons/\">Leetcode题解</a></h3>\r\n<p><code>dp[i][j]表示填满开区间(i,j)能得到的最大数</code></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">nums</span><span class=\"hljs-params\">(n)</span></span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(n+<span class=\"hljs-number\">2</span>)</span></span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        tmp[i+<span class=\"hljs-number\">1</span>] = nums[i];<br>    &#125;<br>    tmp[<span class=\"hljs-number\">0</span>] = tmp[n+<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;<br>    vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">dp</span>(n+<span class=\"hljs-number\">2</span>,<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(n+<span class=\"hljs-number\">2</span>));<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">1</span>; k &lt;= n; ++k)<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= n - k + <span class=\"hljs-number\">1</span>; ++i)<br>        &#123;<br>            <span class=\"hljs-type\">int</span> j = i+k<span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> x = i; x &lt;= j; ++x)<br>            &#123;<br>                dp[i][j] = <span class=\"hljs-built_in\">max</span>(dp[i][j], <br>                dp[i][x<span class=\"hljs-number\">-1</span>] + tmp[i<span class=\"hljs-number\">-1</span>]*tmp[x]*tmp[j+<span class=\"hljs-number\">1</span>]+dp[x+<span class=\"hljs-number\">1</span>][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[<span class=\"hljs-number\">1</span>][n];<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h1 id=\"状态压缩dp\">状态压缩DP</h1>\r\n<h1 id=\"祖玛游戏\"><a\r\nhref=\"https://leetcode.cn/problems/zuma-game/solutions/\">祖玛游戏</a></h1>\r\n<h1 id=\"省份数量\"><a\r\nhref=\"https://leetcode.cn/problems/number-of-provinces/description/\">省份数量</a></h1>\r\n<h1 id=\"n皇后\"><a href=\"\">N皇后</a></h1>\r\n<p>规则和N皇后一样，但是输入一个棋盘上有若干旗子，问最多还能放多少棋子</p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>一个字符串删除n位，使结果最小，相对位置不变，不能有前导零。\r\n例子：90001删除2位，结果900 Removes n bits of a number so that it is\r\nminimal <a\r\nhref=\"https://www.geeksforgeeks.org/build-lowest-number-by-removing-n-digits-from-a-given-number/\">类似的题目</a></p>\r\n<h2 id=\"戳气球数组动态规划\"><a\r\nhref=\"https://blog.51cto.com/zhanjq/6054073\">戳气球(数组、动态规划)</a></h2>\r\n<p>有 n 个气球，编号为0 到 n -\r\n1，每个气球上都标有一个数字，这些数字存在数组 nums 中。\r\n现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] *\r\nnums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i\r\n相邻的两个气球的序号。如果 i - 1或 i + 1\r\n超出了数组的边界，那么就当它是一个数字为 1 的气球。\r\n求所能获得硬币的最大数量。</p>\r\n<p>示例 1： 输入：nums = [3,1,5,8] 输出：167 解释： nums = [3,1,5,8]\r\n--&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []\r\n<code>coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 15 + 120 + 24 + 8 = 167</code></p>\r\n<h3 id=\"leetcode题解\"><a\r\nhref=\"https://leetcode.cn/problems/burst-balloons/\">Leetcode题解</a></h3>\r\n<p><code>dp[i][j]表示填满开区间(i,j)能得到的最大数</code></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdio&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">nums</span><span class=\"hljs-params\">(n)</span></span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(n+<span class=\"hljs-number\">2</span>)</span></span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i)<br>    &#123;<br>        tmp[i+<span class=\"hljs-number\">1</span>] = nums[i];<br>    &#125;<br>    tmp[<span class=\"hljs-number\">0</span>] = tmp[n+<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;<br>    vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">dp</span>(n+<span class=\"hljs-number\">2</span>,<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(n+<span class=\"hljs-number\">2</span>));<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">1</span>; k &lt;= n; ++k)<br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= n - k + <span class=\"hljs-number\">1</span>; ++i)<br>        &#123;<br>            <span class=\"hljs-type\">int</span> j = i+k<span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> x = i; x &lt;= j; ++x)<br>            &#123;<br>                dp[i][j] = <span class=\"hljs-built_in\">max</span>(dp[i][j], <br>                dp[i][x<span class=\"hljs-number\">-1</span>] + tmp[i<span class=\"hljs-number\">-1</span>]*tmp[x]*tmp[j+<span class=\"hljs-number\">1</span>]+dp[x+<span class=\"hljs-number\">1</span>][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[<span class=\"hljs-number\">1</span>][n];<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<h1 id=\"状态压缩dp\">状态压缩DP</h1>\r\n<h1 id=\"祖玛游戏\"><a\r\nhref=\"https://leetcode.cn/problems/zuma-game/solutions/\">祖玛游戏</a></h1>\r\n<h1 id=\"省份数量\"><a\r\nhref=\"https://leetcode.cn/problems/number-of-provinces/description/\">省份数量</a></h1>\r\n<h1 id=\"n皇后\"><a href=\"\">N皇后</a></h1>\r\n<p>规则和N皇后一样，但是输入一个棋盘上有若干旗子，问最多还能放多少棋子</p>\r\n"},{"title":"读刘盆子传","math":true,"index_img":"/imgs/读刘盆子传/zzpbzb.JPG","banner_img":"/imgs/读刘盆子传/zzpbzb.JPG","date":"2020-04-15T16:00:00.000Z","typora-root-url":"../","_content":"\n话不多说，只是看看刘盆子传。\n<!--more-->\n\n<img src=\"/imgs/读刘盆子传/zzpbzb.JPG\" style=\"zoom:200%;\" >\n\n# 刘盆子传\n\n## 原文\n\n[《后汉书·刘盆子传》原文及翻译--在线文言文 (5156edu.com)](http://wyw.5156edu.com/html/z5710m8368j7539.html)\n\n​\t刘盆子者，太山式人，城阳景王章之后也。祖父宪，元帝时封为式侯，父萌嗣。王莽篡位，国除，因为式人焉。\n\n​\t天凤年，琅邪人樊崇起兵于莒。时寇贼蜂起，众盗以崇勇猛，皆附之，一岁间至万余人。崇同郡人逄安、东海人徐宣等各起兵，合数万人，复引从崇。初，崇等以困穷为寇，无攻城徇地之计。众既浸盛，乃相与为约：杀人者死，伤人者偿创。以言辞为约束，无文书、旌旗。王莽遣军击之，崇等欲战，恐其众与莽兵乱，乃皆朱其眉以相识别，由是号曰赤眉。遂大破之。\n\n​\t初，赤眉过式，掠盆子及二兄恭、茂，皆在军中。及恭随崇等降更始，即封为式侯。恭以明经数言事，拜侍中，从更始居长安。盆子与茂留军中，主刍牧牛，号曰牛吏。及崇等欲立帝，求军中景王后者，得七十余人，唯盆子与茂及前西安侯刘孝最为近属。崇尝闻古天子将兵称上将军，乃书札为符曰“上将军”，又以两空札置笥中，列盆子等三人以年次探札。盆子探得符，诸将乃皆称臣拜。盆子时年十五，被发徒跣，敝衣赭汗，见众拜，恐畏欲啼。茂谓曰：“善藏符。”盆子即啮折弃之，而犹从牧儿遨。\n\n​\t军及高陵，入长安城，更始来降。盆子居长乐宫，诸将日会论功，争言讙呼，拔剑击柱，不能相一。又数虏暴吏民，百姓保壁，由是皆复固守。盆子惶恐，日夜啼泣。刘恭见赤眉众乱，知其必败，自恐兄弟俱祸，密教盆子归玺绶，习为辞让之言。建武二年正月朔，崇等大会，盆子下床解玺绶，叩头曰：“今设置县官而为贼如故。此皆立非其人所致，愿乞骸骨，避贤圣。”因涕泣嘘唏。崇等及会者数百人，莫不哀怜之，乃皆避席顿首曰：“臣无状，负陛下。请自今已后，不敢复放纵。”既罢出，各闭营自守，三辅翕然，百姓争还长安，市里且满。后二十余日，赤眉贪财物，复出大掠。城中粮食尽，遂收载珍宝，因大纵火烧宫室，引兵而西。\n\n​\t光武遣军分为二道，以要其还路。赤眉忽遇大军，惊震不知所为。樊崇竟将盆子及丞相徐宣以下三十余人肉袒降。上所得传国玺绶、更始七尺宝剑及玉璧各一。明旦，大陈兵马临洛水，令盆子君臣列而观之。谓盆子曰：“自知当死不？”对曰：“罪当应死，犹幸上怜赦之耳。”帝又谓崇等曰：“卿所谓铁中铮铮，庸中佼佼者也。”\n\n​\t帝怜盆子，赏赐甚厚，以为赵王郎中。后病失明，赐荥阳均输官地，以为列肆，使食其税终身。\n（取材于《后汉书·刘玄刘盆子列传》） \n\n## 翻译\n\n​\t刘盆子，太山郡式县人，是城阳景王刘章的后代。他的祖父刘宪，在元帝时被封为式侯，父亲刘萌继承了爵位。王莽篡夺了王位后，封国被取消，刘盆子就成了式县人了。\n\n​\t王莽天凤年间，琅邪人樊崇在莒县起兵，当时盗匪四起，许多盗贼因为樊崇勇猛，都依附他，一年之内发展到了一万多人 。樊崇的同郡人逄安、东海人徐宣等人各自起兵，一共有几万人，又率众前来跟从樊崇。起初，樊崇等人只是因为穷困窘迫才去做盗匪的，并没有攻占城池掠取土地的计划。现在人马日渐壮大，就一起约定：杀人者偿命，打伤人要抵罪。只有口头的约束，而没有文书、旌旗。王莽派遣部队攻打他们，樊崇等要和他们交战，又怕手下的人和王莽的士兵混在一起，就把他们的眉毛全部染红用来区别，因此称为赤眉军。于是赤眉军大败王莽军队。\n\n​\t当初，赤眉军经过式县，劫掠了刘盆子以及他的两个兄长刘恭、刘茂，都安置在军中。到刘恭跟随樊崇等归顺更始帝，即被封为式侯。刘恭因为精通经书多次进言论事，被封为侍中，在长安中侍奉更始帝。刘盆子与刘茂留在军中，负责割草牧牛，被称为牛吏。到了樊崇想要拥立新皇帝时，在军中寻找景王的后代，一共找到七十多个人，只有刘盆子、刘茂以及前西安侯刘孝是最近的后裔。樊崇曾经听说古代天子带兵时称为上将军，于是就在竹简上写上“上将军”作为符书，又拿了两个空竹简放在竹筐里，让刘盆子等三个人站在中间，按年纪长幼顺序抽取竹简。刘盆子拿到了符书，将领们都向他称臣跪拜。刘盆子当时只有十五岁，披头散发，光着两只脚，穿着破衣服，涨红了脸，满头大汗，看到大家都向他跪拜，吓得快要哭出来。刘茂对他说：“好好保管符书。”刘盆子将符书咬破，胡乱折叠，然后扔掉，还是跟着牧童们一起嬉戏。\n\n​\t赤眉军到了高陵，进入长安城，更始帝投降。刘盆子住进长乐宫，将领们天天聚在一起争论战功，经常喧哗呼叫，拔出剑来砍柱子，难以达成一致。他们还屡次掠夺施暴于官民，百姓关紧门户，从此又都各自坚守。刘盆子十分惊恐，日夜哭泣。刘恭眼看赤眉军中混乱，知道他们必将失败，担心兄弟们要一起惹上灾祸，就偷偷地教刘盆子交还玺绶，学会讲推让之辞。建武二年正月初一，樊崇等举行大集会，刘盆子从坐榻上下来，解下玺绶，叩头说：“如今设置了天子但还是像过去一样做盗贼的事情。这都是你们拥立了不合适的人所导致的，希望让我保存自己的一把骨头，让位给圣贤之人。”说完就涕泪交加，欷歔不止。樊崇及在座的几百个人，没有人不同情他的，都离开座席磕头说：“臣等不守规矩，辜负了陛下。从今以后，我们保证不再放纵。”集会结束大家出宫后，各自坚守军营，三辅地区安然无事，百姓争相回到长安，市场街里又拥挤起来。过了二十几天，赤眉军因贪图财物，又出来大肆抢掠。城中的粮食吃光了，就收罗装载珍宝，又放大火烧了宫殿房屋，带着兵马向西进发。\n\n​\t光武帝派遣部队分两路，切断赤眉军的退路。赤眉突然遭遇大军，惊慌恐惧不知所措。樊崇最终带着刘盆子以及丞相徐宣以下的三十多个人赤膊前去投降。献上得到的传国玺绶、更始帝的七尺宝剑以及玉璧各一个。第二天，光武帝在洛水边上陈列兵马，让刘盆子及他的臣子们站在一旁列队观看。对刘盆子说：“自己觉得应当被处死吗？”刘盆子回答说：“臣论罪本该被处死，还希望皇上怜悯饶恕我。”光武帝又对樊崇等人说：“你们可以说是铁中的铮铮上品，平庸之辈中才华出众的人。”\n\n​\t光武帝可怜刘盆子，给他很丰厚的赏赐，让他做赵王的郎中。后来刘盆子因病失明，赐给他荥阳县的均输官地，作为商铺区，让他终生享用这里的官税。 \n\n## 关于刘盆子\n\n这传记是明显的告诫，刘盆子被选为赤眉军首领，而实际上只是一个傀儡，  \n刘盆子在众功臣宿将面前只是一个“小孩子”，所以挑选你，选你不是因为你功绩滔天，刘盆子只是一个15岁的孩子自是没什么功绩的，但刘盆子还是有的。  \n说回来还是因为你年轻想培养你，坐到这个位置别自以为了不起，天下无敌；  \n能不能在这个位子上坐住，要看你能不能处理好当初起兵的功臣宿将们，  \n既要处理好他们，还要拜他们为师。  \n赤眉军败后，刘盆子自然当不了皇帝了，但是“帝怜盆子，赏赐甚厚”，后因病失明还是被受了赏赐，还得了终身享用官税的商铺区，汉光武既没让他坐牢，也没砍他的头，结局好像不错。  \n但刘盆子的结局是悲剧的，因为他驾驭不住这样一支军队，这样一群的功臣宿将。  \n这支军队后来西入长安，弄得天下大乱。\n\n农民起义军进城是一个考验，纪律约束只是一时的，没有觉悟便不能持久。  \n刘盆子后来是被刘秀养老死去的。  \n读 刘盆子传 目的是为了告诫，可能成功、可能失败，希望你好自为之。\n\n## 下期预告\n\n洛水河阴白马陈桥。","source":"_posts/读刘盆子传.md","raw":"---\ntitle: 读刘盆子传\ntags: 文学\nmath: true\nindex_img: /imgs/读刘盆子传/zzpbzb.JPG\nbanner_img: /imgs/读刘盆子传/zzpbzb.JPG\ndate: 2020-04-16\ntypora-root-url: ../\n---\n\n话不多说，只是看看刘盆子传。\n<!--more-->\n\n<img src=\"/imgs/读刘盆子传/zzpbzb.JPG\" style=\"zoom:200%;\" >\n\n# 刘盆子传\n\n## 原文\n\n[《后汉书·刘盆子传》原文及翻译--在线文言文 (5156edu.com)](http://wyw.5156edu.com/html/z5710m8368j7539.html)\n\n​\t刘盆子者，太山式人，城阳景王章之后也。祖父宪，元帝时封为式侯，父萌嗣。王莽篡位，国除，因为式人焉。\n\n​\t天凤年，琅邪人樊崇起兵于莒。时寇贼蜂起，众盗以崇勇猛，皆附之，一岁间至万余人。崇同郡人逄安、东海人徐宣等各起兵，合数万人，复引从崇。初，崇等以困穷为寇，无攻城徇地之计。众既浸盛，乃相与为约：杀人者死，伤人者偿创。以言辞为约束，无文书、旌旗。王莽遣军击之，崇等欲战，恐其众与莽兵乱，乃皆朱其眉以相识别，由是号曰赤眉。遂大破之。\n\n​\t初，赤眉过式，掠盆子及二兄恭、茂，皆在军中。及恭随崇等降更始，即封为式侯。恭以明经数言事，拜侍中，从更始居长安。盆子与茂留军中，主刍牧牛，号曰牛吏。及崇等欲立帝，求军中景王后者，得七十余人，唯盆子与茂及前西安侯刘孝最为近属。崇尝闻古天子将兵称上将军，乃书札为符曰“上将军”，又以两空札置笥中，列盆子等三人以年次探札。盆子探得符，诸将乃皆称臣拜。盆子时年十五，被发徒跣，敝衣赭汗，见众拜，恐畏欲啼。茂谓曰：“善藏符。”盆子即啮折弃之，而犹从牧儿遨。\n\n​\t军及高陵，入长安城，更始来降。盆子居长乐宫，诸将日会论功，争言讙呼，拔剑击柱，不能相一。又数虏暴吏民，百姓保壁，由是皆复固守。盆子惶恐，日夜啼泣。刘恭见赤眉众乱，知其必败，自恐兄弟俱祸，密教盆子归玺绶，习为辞让之言。建武二年正月朔，崇等大会，盆子下床解玺绶，叩头曰：“今设置县官而为贼如故。此皆立非其人所致，愿乞骸骨，避贤圣。”因涕泣嘘唏。崇等及会者数百人，莫不哀怜之，乃皆避席顿首曰：“臣无状，负陛下。请自今已后，不敢复放纵。”既罢出，各闭营自守，三辅翕然，百姓争还长安，市里且满。后二十余日，赤眉贪财物，复出大掠。城中粮食尽，遂收载珍宝，因大纵火烧宫室，引兵而西。\n\n​\t光武遣军分为二道，以要其还路。赤眉忽遇大军，惊震不知所为。樊崇竟将盆子及丞相徐宣以下三十余人肉袒降。上所得传国玺绶、更始七尺宝剑及玉璧各一。明旦，大陈兵马临洛水，令盆子君臣列而观之。谓盆子曰：“自知当死不？”对曰：“罪当应死，犹幸上怜赦之耳。”帝又谓崇等曰：“卿所谓铁中铮铮，庸中佼佼者也。”\n\n​\t帝怜盆子，赏赐甚厚，以为赵王郎中。后病失明，赐荥阳均输官地，以为列肆，使食其税终身。\n（取材于《后汉书·刘玄刘盆子列传》） \n\n## 翻译\n\n​\t刘盆子，太山郡式县人，是城阳景王刘章的后代。他的祖父刘宪，在元帝时被封为式侯，父亲刘萌继承了爵位。王莽篡夺了王位后，封国被取消，刘盆子就成了式县人了。\n\n​\t王莽天凤年间，琅邪人樊崇在莒县起兵，当时盗匪四起，许多盗贼因为樊崇勇猛，都依附他，一年之内发展到了一万多人 。樊崇的同郡人逄安、东海人徐宣等人各自起兵，一共有几万人，又率众前来跟从樊崇。起初，樊崇等人只是因为穷困窘迫才去做盗匪的，并没有攻占城池掠取土地的计划。现在人马日渐壮大，就一起约定：杀人者偿命，打伤人要抵罪。只有口头的约束，而没有文书、旌旗。王莽派遣部队攻打他们，樊崇等要和他们交战，又怕手下的人和王莽的士兵混在一起，就把他们的眉毛全部染红用来区别，因此称为赤眉军。于是赤眉军大败王莽军队。\n\n​\t当初，赤眉军经过式县，劫掠了刘盆子以及他的两个兄长刘恭、刘茂，都安置在军中。到刘恭跟随樊崇等归顺更始帝，即被封为式侯。刘恭因为精通经书多次进言论事，被封为侍中，在长安中侍奉更始帝。刘盆子与刘茂留在军中，负责割草牧牛，被称为牛吏。到了樊崇想要拥立新皇帝时，在军中寻找景王的后代，一共找到七十多个人，只有刘盆子、刘茂以及前西安侯刘孝是最近的后裔。樊崇曾经听说古代天子带兵时称为上将军，于是就在竹简上写上“上将军”作为符书，又拿了两个空竹简放在竹筐里，让刘盆子等三个人站在中间，按年纪长幼顺序抽取竹简。刘盆子拿到了符书，将领们都向他称臣跪拜。刘盆子当时只有十五岁，披头散发，光着两只脚，穿着破衣服，涨红了脸，满头大汗，看到大家都向他跪拜，吓得快要哭出来。刘茂对他说：“好好保管符书。”刘盆子将符书咬破，胡乱折叠，然后扔掉，还是跟着牧童们一起嬉戏。\n\n​\t赤眉军到了高陵，进入长安城，更始帝投降。刘盆子住进长乐宫，将领们天天聚在一起争论战功，经常喧哗呼叫，拔出剑来砍柱子，难以达成一致。他们还屡次掠夺施暴于官民，百姓关紧门户，从此又都各自坚守。刘盆子十分惊恐，日夜哭泣。刘恭眼看赤眉军中混乱，知道他们必将失败，担心兄弟们要一起惹上灾祸，就偷偷地教刘盆子交还玺绶，学会讲推让之辞。建武二年正月初一，樊崇等举行大集会，刘盆子从坐榻上下来，解下玺绶，叩头说：“如今设置了天子但还是像过去一样做盗贼的事情。这都是你们拥立了不合适的人所导致的，希望让我保存自己的一把骨头，让位给圣贤之人。”说完就涕泪交加，欷歔不止。樊崇及在座的几百个人，没有人不同情他的，都离开座席磕头说：“臣等不守规矩，辜负了陛下。从今以后，我们保证不再放纵。”集会结束大家出宫后，各自坚守军营，三辅地区安然无事，百姓争相回到长安，市场街里又拥挤起来。过了二十几天，赤眉军因贪图财物，又出来大肆抢掠。城中的粮食吃光了，就收罗装载珍宝，又放大火烧了宫殿房屋，带着兵马向西进发。\n\n​\t光武帝派遣部队分两路，切断赤眉军的退路。赤眉突然遭遇大军，惊慌恐惧不知所措。樊崇最终带着刘盆子以及丞相徐宣以下的三十多个人赤膊前去投降。献上得到的传国玺绶、更始帝的七尺宝剑以及玉璧各一个。第二天，光武帝在洛水边上陈列兵马，让刘盆子及他的臣子们站在一旁列队观看。对刘盆子说：“自己觉得应当被处死吗？”刘盆子回答说：“臣论罪本该被处死，还希望皇上怜悯饶恕我。”光武帝又对樊崇等人说：“你们可以说是铁中的铮铮上品，平庸之辈中才华出众的人。”\n\n​\t光武帝可怜刘盆子，给他很丰厚的赏赐，让他做赵王的郎中。后来刘盆子因病失明，赐给他荥阳县的均输官地，作为商铺区，让他终生享用这里的官税。 \n\n## 关于刘盆子\n\n这传记是明显的告诫，刘盆子被选为赤眉军首领，而实际上只是一个傀儡，  \n刘盆子在众功臣宿将面前只是一个“小孩子”，所以挑选你，选你不是因为你功绩滔天，刘盆子只是一个15岁的孩子自是没什么功绩的，但刘盆子还是有的。  \n说回来还是因为你年轻想培养你，坐到这个位置别自以为了不起，天下无敌；  \n能不能在这个位子上坐住，要看你能不能处理好当初起兵的功臣宿将们，  \n既要处理好他们，还要拜他们为师。  \n赤眉军败后，刘盆子自然当不了皇帝了，但是“帝怜盆子，赏赐甚厚”，后因病失明还是被受了赏赐，还得了终身享用官税的商铺区，汉光武既没让他坐牢，也没砍他的头，结局好像不错。  \n但刘盆子的结局是悲剧的，因为他驾驭不住这样一支军队，这样一群的功臣宿将。  \n这支军队后来西入长安，弄得天下大乱。\n\n农民起义军进城是一个考验，纪律约束只是一时的，没有觉悟便不能持久。  \n刘盆子后来是被刘秀养老死去的。  \n读 刘盆子传 目的是为了告诫，可能成功、可能失败，希望你好自为之。\n\n## 下期预告\n\n洛水河阴白马陈桥。","slug":"读刘盆子传","published":1,"updated":"2024-04-27T03:59:51.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti6001abkbwbpuhgzjh","content":"<p>话不多说，只是看看刘盆子传。 <span id=\"more\"></span></p>\r\n<p><img src=\"/imgs/读刘盆子传/zzpbzb.JPG\" style=\"zoom:200%;\" ></p>\r\n<h1 id=\"刘盆子传\">刘盆子传</h1>\r\n<h2 id=\"原文\">原文</h2>\r\n<p><a\r\nhref=\"http://wyw.5156edu.com/html/z5710m8368j7539.html\">《后汉书·刘盆子传》原文及翻译--在线文言文\r\n(5156edu.com)</a></p>\r\n<p>​\r\n刘盆子者，太山式人，城阳景王章之后也。祖父宪，元帝时封为式侯，父萌嗣。王莽篡位，国除，因为式人焉。</p>\r\n<p>​\r\n天凤年，琅邪人樊崇起兵于莒。时寇贼蜂起，众盗以崇勇猛，皆附之，一岁间至万余人。崇同郡人逄安、东海人徐宣等各起兵，合数万人，复引从崇。初，崇等以困穷为寇，无攻城徇地之计。众既浸盛，乃相与为约：杀人者死，伤人者偿创。以言辞为约束，无文书、旌旗。王莽遣军击之，崇等欲战，恐其众与莽兵乱，乃皆朱其眉以相识别，由是号曰赤眉。遂大破之。</p>\r\n<p>​\r\n初，赤眉过式，掠盆子及二兄恭、茂，皆在军中。及恭随崇等降更始，即封为式侯。恭以明经数言事，拜侍中，从更始居长安。盆子与茂留军中，主刍牧牛，号曰牛吏。及崇等欲立帝，求军中景王后者，得七十余人，唯盆子与茂及前西安侯刘孝最为近属。崇尝闻古天子将兵称上将军，乃书札为符曰“上将军”，又以两空札置笥中，列盆子等三人以年次探札。盆子探得符，诸将乃皆称臣拜。盆子时年十五，被发徒跣，敝衣赭汗，见众拜，恐畏欲啼。茂谓曰：“善藏符。”盆子即啮折弃之，而犹从牧儿遨。</p>\r\n<p>​\r\n军及高陵，入长安城，更始来降。盆子居长乐宫，诸将日会论功，争言讙呼，拔剑击柱，不能相一。又数虏暴吏民，百姓保壁，由是皆复固守。盆子惶恐，日夜啼泣。刘恭见赤眉众乱，知其必败，自恐兄弟俱祸，密教盆子归玺绶，习为辞让之言。建武二年正月朔，崇等大会，盆子下床解玺绶，叩头曰：“今设置县官而为贼如故。此皆立非其人所致，愿乞骸骨，避贤圣。”因涕泣嘘唏。崇等及会者数百人，莫不哀怜之，乃皆避席顿首曰：“臣无状，负陛下。请自今已后，不敢复放纵。”既罢出，各闭营自守，三辅翕然，百姓争还长安，市里且满。后二十余日，赤眉贪财物，复出大掠。城中粮食尽，遂收载珍宝，因大纵火烧宫室，引兵而西。</p>\r\n<p>​\r\n光武遣军分为二道，以要其还路。赤眉忽遇大军，惊震不知所为。樊崇竟将盆子及丞相徐宣以下三十余人肉袒降。上所得传国玺绶、更始七尺宝剑及玉璧各一。明旦，大陈兵马临洛水，令盆子君臣列而观之。谓盆子曰：“自知当死不？”对曰：“罪当应死，犹幸上怜赦之耳。”帝又谓崇等曰：“卿所谓铁中铮铮，庸中佼佼者也。”</p>\r\n<p>​\r\n帝怜盆子，赏赐甚厚，以为赵王郎中。后病失明，赐荥阳均输官地，以为列肆，使食其税终身。\r\n（取材于《后汉书·刘玄刘盆子列传》）</p>\r\n<h2 id=\"翻译\">翻译</h2>\r\n<p>​\r\n刘盆子，太山郡式县人，是城阳景王刘章的后代。他的祖父刘宪，在元帝时被封为式侯，父亲刘萌继承了爵位。王莽篡夺了王位后，封国被取消，刘盆子就成了式县人了。</p>\r\n<p>​\r\n王莽天凤年间，琅邪人樊崇在莒县起兵，当时盗匪四起，许多盗贼因为樊崇勇猛，都依附他，一年之内发展到了一万多人\r\n。樊崇的同郡人逄安、东海人徐宣等人各自起兵，一共有几万人，又率众前来跟从樊崇。起初，樊崇等人只是因为穷困窘迫才去做盗匪的，并没有攻占城池掠取土地的计划。现在人马日渐壮大，就一起约定：杀人者偿命，打伤人要抵罪。只有口头的约束，而没有文书、旌旗。王莽派遣部队攻打他们，樊崇等要和他们交战，又怕手下的人和王莽的士兵混在一起，就把他们的眉毛全部染红用来区别，因此称为赤眉军。于是赤眉军大败王莽军队。</p>\r\n<p>​\r\n当初，赤眉军经过式县，劫掠了刘盆子以及他的两个兄长刘恭、刘茂，都安置在军中。到刘恭跟随樊崇等归顺更始帝，即被封为式侯。刘恭因为精通经书多次进言论事，被封为侍中，在长安中侍奉更始帝。刘盆子与刘茂留在军中，负责割草牧牛，被称为牛吏。到了樊崇想要拥立新皇帝时，在军中寻找景王的后代，一共找到七十多个人，只有刘盆子、刘茂以及前西安侯刘孝是最近的后裔。樊崇曾经听说古代天子带兵时称为上将军，于是就在竹简上写上“上将军”作为符书，又拿了两个空竹简放在竹筐里，让刘盆子等三个人站在中间，按年纪长幼顺序抽取竹简。刘盆子拿到了符书，将领们都向他称臣跪拜。刘盆子当时只有十五岁，披头散发，光着两只脚，穿着破衣服，涨红了脸，满头大汗，看到大家都向他跪拜，吓得快要哭出来。刘茂对他说：“好好保管符书。”刘盆子将符书咬破，胡乱折叠，然后扔掉，还是跟着牧童们一起嬉戏。</p>\r\n<p>​\r\n赤眉军到了高陵，进入长安城，更始帝投降。刘盆子住进长乐宫，将领们天天聚在一起争论战功，经常喧哗呼叫，拔出剑来砍柱子，难以达成一致。他们还屡次掠夺施暴于官民，百姓关紧门户，从此又都各自坚守。刘盆子十分惊恐，日夜哭泣。刘恭眼看赤眉军中混乱，知道他们必将失败，担心兄弟们要一起惹上灾祸，就偷偷地教刘盆子交还玺绶，学会讲推让之辞。建武二年正月初一，樊崇等举行大集会，刘盆子从坐榻上下来，解下玺绶，叩头说：“如今设置了天子但还是像过去一样做盗贼的事情。这都是你们拥立了不合适的人所导致的，希望让我保存自己的一把骨头，让位给圣贤之人。”说完就涕泪交加，欷歔不止。樊崇及在座的几百个人，没有人不同情他的，都离开座席磕头说：“臣等不守规矩，辜负了陛下。从今以后，我们保证不再放纵。”集会结束大家出宫后，各自坚守军营，三辅地区安然无事，百姓争相回到长安，市场街里又拥挤起来。过了二十几天，赤眉军因贪图财物，又出来大肆抢掠。城中的粮食吃光了，就收罗装载珍宝，又放大火烧了宫殿房屋，带着兵马向西进发。</p>\r\n<p>​\r\n光武帝派遣部队分两路，切断赤眉军的退路。赤眉突然遭遇大军，惊慌恐惧不知所措。樊崇最终带着刘盆子以及丞相徐宣以下的三十多个人赤膊前去投降。献上得到的传国玺绶、更始帝的七尺宝剑以及玉璧各一个。第二天，光武帝在洛水边上陈列兵马，让刘盆子及他的臣子们站在一旁列队观看。对刘盆子说：“自己觉得应当被处死吗？”刘盆子回答说：“臣论罪本该被处死，还希望皇上怜悯饶恕我。”光武帝又对樊崇等人说：“你们可以说是铁中的铮铮上品，平庸之辈中才华出众的人。”</p>\r\n<p>​\r\n光武帝可怜刘盆子，给他很丰厚的赏赐，让他做赵王的郎中。后来刘盆子因病失明，赐给他荥阳县的均输官地，作为商铺区，让他终生享用这里的官税。</p>\r\n<h2 id=\"关于刘盆子\">关于刘盆子</h2>\r\n<p>这传记是明显的告诫，刘盆子被选为赤眉军首领，而实际上只是一个傀儡，<br />\r\n刘盆子在众功臣宿将面前只是一个“小孩子”，所以挑选你，选你不是因为你功绩滔天，刘盆子只是一个15岁的孩子自是没什么功绩的，但刘盆子还是有的。<br />\r\n说回来还是因为你年轻想培养你，坐到这个位置别自以为了不起，天下无敌；<br />\r\n能不能在这个位子上坐住，要看你能不能处理好当初起兵的功臣宿将们，<br />\r\n既要处理好他们，还要拜他们为师。<br />\r\n赤眉军败后，刘盆子自然当不了皇帝了，但是“帝怜盆子，赏赐甚厚”，后因病失明还是被受了赏赐，还得了终身享用官税的商铺区，汉光武既没让他坐牢，也没砍他的头，结局好像不错。<br />\r\n但刘盆子的结局是悲剧的，因为他驾驭不住这样一支军队，这样一群的功臣宿将。<br />\r\n这支军队后来西入长安，弄得天下大乱。</p>\r\n<p>农民起义军进城是一个考验，纪律约束只是一时的，没有觉悟便不能持久。<br />\r\n刘盆子后来是被刘秀养老死去的。<br />\r\n读 刘盆子传 目的是为了告诫，可能成功、可能失败，希望你好自为之。</p>\r\n<h2 id=\"下期预告\">下期预告</h2>\r\n<p>洛水河阴白马陈桥。</p>\r\n","site":{"data":{}},"excerpt":"<p>话不多说，只是看看刘盆子传。","more":"</p>\r\n<p><img src=\"/imgs/读刘盆子传/zzpbzb.JPG\" style=\"zoom:200%;\" ></p>\r\n<h1 id=\"刘盆子传\">刘盆子传</h1>\r\n<h2 id=\"原文\">原文</h2>\r\n<p><a\r\nhref=\"http://wyw.5156edu.com/html/z5710m8368j7539.html\">《后汉书·刘盆子传》原文及翻译--在线文言文\r\n(5156edu.com)</a></p>\r\n<p>​\r\n刘盆子者，太山式人，城阳景王章之后也。祖父宪，元帝时封为式侯，父萌嗣。王莽篡位，国除，因为式人焉。</p>\r\n<p>​\r\n天凤年，琅邪人樊崇起兵于莒。时寇贼蜂起，众盗以崇勇猛，皆附之，一岁间至万余人。崇同郡人逄安、东海人徐宣等各起兵，合数万人，复引从崇。初，崇等以困穷为寇，无攻城徇地之计。众既浸盛，乃相与为约：杀人者死，伤人者偿创。以言辞为约束，无文书、旌旗。王莽遣军击之，崇等欲战，恐其众与莽兵乱，乃皆朱其眉以相识别，由是号曰赤眉。遂大破之。</p>\r\n<p>​\r\n初，赤眉过式，掠盆子及二兄恭、茂，皆在军中。及恭随崇等降更始，即封为式侯。恭以明经数言事，拜侍中，从更始居长安。盆子与茂留军中，主刍牧牛，号曰牛吏。及崇等欲立帝，求军中景王后者，得七十余人，唯盆子与茂及前西安侯刘孝最为近属。崇尝闻古天子将兵称上将军，乃书札为符曰“上将军”，又以两空札置笥中，列盆子等三人以年次探札。盆子探得符，诸将乃皆称臣拜。盆子时年十五，被发徒跣，敝衣赭汗，见众拜，恐畏欲啼。茂谓曰：“善藏符。”盆子即啮折弃之，而犹从牧儿遨。</p>\r\n<p>​\r\n军及高陵，入长安城，更始来降。盆子居长乐宫，诸将日会论功，争言讙呼，拔剑击柱，不能相一。又数虏暴吏民，百姓保壁，由是皆复固守。盆子惶恐，日夜啼泣。刘恭见赤眉众乱，知其必败，自恐兄弟俱祸，密教盆子归玺绶，习为辞让之言。建武二年正月朔，崇等大会，盆子下床解玺绶，叩头曰：“今设置县官而为贼如故。此皆立非其人所致，愿乞骸骨，避贤圣。”因涕泣嘘唏。崇等及会者数百人，莫不哀怜之，乃皆避席顿首曰：“臣无状，负陛下。请自今已后，不敢复放纵。”既罢出，各闭营自守，三辅翕然，百姓争还长安，市里且满。后二十余日，赤眉贪财物，复出大掠。城中粮食尽，遂收载珍宝，因大纵火烧宫室，引兵而西。</p>\r\n<p>​\r\n光武遣军分为二道，以要其还路。赤眉忽遇大军，惊震不知所为。樊崇竟将盆子及丞相徐宣以下三十余人肉袒降。上所得传国玺绶、更始七尺宝剑及玉璧各一。明旦，大陈兵马临洛水，令盆子君臣列而观之。谓盆子曰：“自知当死不？”对曰：“罪当应死，犹幸上怜赦之耳。”帝又谓崇等曰：“卿所谓铁中铮铮，庸中佼佼者也。”</p>\r\n<p>​\r\n帝怜盆子，赏赐甚厚，以为赵王郎中。后病失明，赐荥阳均输官地，以为列肆，使食其税终身。\r\n（取材于《后汉书·刘玄刘盆子列传》）</p>\r\n<h2 id=\"翻译\">翻译</h2>\r\n<p>​\r\n刘盆子，太山郡式县人，是城阳景王刘章的后代。他的祖父刘宪，在元帝时被封为式侯，父亲刘萌继承了爵位。王莽篡夺了王位后，封国被取消，刘盆子就成了式县人了。</p>\r\n<p>​\r\n王莽天凤年间，琅邪人樊崇在莒县起兵，当时盗匪四起，许多盗贼因为樊崇勇猛，都依附他，一年之内发展到了一万多人\r\n。樊崇的同郡人逄安、东海人徐宣等人各自起兵，一共有几万人，又率众前来跟从樊崇。起初，樊崇等人只是因为穷困窘迫才去做盗匪的，并没有攻占城池掠取土地的计划。现在人马日渐壮大，就一起约定：杀人者偿命，打伤人要抵罪。只有口头的约束，而没有文书、旌旗。王莽派遣部队攻打他们，樊崇等要和他们交战，又怕手下的人和王莽的士兵混在一起，就把他们的眉毛全部染红用来区别，因此称为赤眉军。于是赤眉军大败王莽军队。</p>\r\n<p>​\r\n当初，赤眉军经过式县，劫掠了刘盆子以及他的两个兄长刘恭、刘茂，都安置在军中。到刘恭跟随樊崇等归顺更始帝，即被封为式侯。刘恭因为精通经书多次进言论事，被封为侍中，在长安中侍奉更始帝。刘盆子与刘茂留在军中，负责割草牧牛，被称为牛吏。到了樊崇想要拥立新皇帝时，在军中寻找景王的后代，一共找到七十多个人，只有刘盆子、刘茂以及前西安侯刘孝是最近的后裔。樊崇曾经听说古代天子带兵时称为上将军，于是就在竹简上写上“上将军”作为符书，又拿了两个空竹简放在竹筐里，让刘盆子等三个人站在中间，按年纪长幼顺序抽取竹简。刘盆子拿到了符书，将领们都向他称臣跪拜。刘盆子当时只有十五岁，披头散发，光着两只脚，穿着破衣服，涨红了脸，满头大汗，看到大家都向他跪拜，吓得快要哭出来。刘茂对他说：“好好保管符书。”刘盆子将符书咬破，胡乱折叠，然后扔掉，还是跟着牧童们一起嬉戏。</p>\r\n<p>​\r\n赤眉军到了高陵，进入长安城，更始帝投降。刘盆子住进长乐宫，将领们天天聚在一起争论战功，经常喧哗呼叫，拔出剑来砍柱子，难以达成一致。他们还屡次掠夺施暴于官民，百姓关紧门户，从此又都各自坚守。刘盆子十分惊恐，日夜哭泣。刘恭眼看赤眉军中混乱，知道他们必将失败，担心兄弟们要一起惹上灾祸，就偷偷地教刘盆子交还玺绶，学会讲推让之辞。建武二年正月初一，樊崇等举行大集会，刘盆子从坐榻上下来，解下玺绶，叩头说：“如今设置了天子但还是像过去一样做盗贼的事情。这都是你们拥立了不合适的人所导致的，希望让我保存自己的一把骨头，让位给圣贤之人。”说完就涕泪交加，欷歔不止。樊崇及在座的几百个人，没有人不同情他的，都离开座席磕头说：“臣等不守规矩，辜负了陛下。从今以后，我们保证不再放纵。”集会结束大家出宫后，各自坚守军营，三辅地区安然无事，百姓争相回到长安，市场街里又拥挤起来。过了二十几天，赤眉军因贪图财物，又出来大肆抢掠。城中的粮食吃光了，就收罗装载珍宝，又放大火烧了宫殿房屋，带着兵马向西进发。</p>\r\n<p>​\r\n光武帝派遣部队分两路，切断赤眉军的退路。赤眉突然遭遇大军，惊慌恐惧不知所措。樊崇最终带着刘盆子以及丞相徐宣以下的三十多个人赤膊前去投降。献上得到的传国玺绶、更始帝的七尺宝剑以及玉璧各一个。第二天，光武帝在洛水边上陈列兵马，让刘盆子及他的臣子们站在一旁列队观看。对刘盆子说：“自己觉得应当被处死吗？”刘盆子回答说：“臣论罪本该被处死，还希望皇上怜悯饶恕我。”光武帝又对樊崇等人说：“你们可以说是铁中的铮铮上品，平庸之辈中才华出众的人。”</p>\r\n<p>​\r\n光武帝可怜刘盆子，给他很丰厚的赏赐，让他做赵王的郎中。后来刘盆子因病失明，赐给他荥阳县的均输官地，作为商铺区，让他终生享用这里的官税。</p>\r\n<h2 id=\"关于刘盆子\">关于刘盆子</h2>\r\n<p>这传记是明显的告诫，刘盆子被选为赤眉军首领，而实际上只是一个傀儡，<br />\r\n刘盆子在众功臣宿将面前只是一个“小孩子”，所以挑选你，选你不是因为你功绩滔天，刘盆子只是一个15岁的孩子自是没什么功绩的，但刘盆子还是有的。<br />\r\n说回来还是因为你年轻想培养你，坐到这个位置别自以为了不起，天下无敌；<br />\r\n能不能在这个位子上坐住，要看你能不能处理好当初起兵的功臣宿将们，<br />\r\n既要处理好他们，还要拜他们为师。<br />\r\n赤眉军败后，刘盆子自然当不了皇帝了，但是“帝怜盆子，赏赐甚厚”，后因病失明还是被受了赏赐，还得了终身享用官税的商铺区，汉光武既没让他坐牢，也没砍他的头，结局好像不错。<br />\r\n但刘盆子的结局是悲剧的，因为他驾驭不住这样一支军队，这样一群的功臣宿将。<br />\r\n这支军队后来西入长安，弄得天下大乱。</p>\r\n<p>农民起义军进城是一个考验，纪律约束只是一时的，没有觉悟便不能持久。<br />\r\n刘盆子后来是被刘秀养老死去的。<br />\r\n读 刘盆子传 目的是为了告诫，可能成功、可能失败，希望你好自为之。</p>\r\n<h2 id=\"下期预告\">下期预告</h2>\r\n<p>洛水河阴白马陈桥。</p>"},{"title":"C++ 多线程学习","date":"2023-03-22T02:38:22.000Z","_content":"\nC++多线程一直是我未开启的话题，也是我的薄弱部分，但是是程序之路进阶一步的绕不开的话题，所以我觉得很有必要展开系统的学习，虽然我学起来可能很混乱，完全不系统！但是这不重要，少说话，多学，多写！\n\n<!--more-->\n\n# C++ Threading 学习\n\n[知乎:想接触C++多线程编程，需要从哪方面入手，有没有推荐的书籍或教程？ - 程序喵大人的回答 ](https://www.zhihu.com/question/43959555/answer/2620620079)","source":"_drafts/C++-Threading.md","raw":"---\ntitle: C++ 多线程学习\ndate: 2023-03-22 10:38:22\ntags: \n---\n\nC++多线程一直是我未开启的话题，也是我的薄弱部分，但是是程序之路进阶一步的绕不开的话题，所以我觉得很有必要展开系统的学习，虽然我学起来可能很混乱，完全不系统！但是这不重要，少说话，多学，多写！\n\n<!--more-->\n\n# C++ Threading 学习\n\n[知乎:想接触C++多线程编程，需要从哪方面入手，有没有推荐的书籍或教程？ - 程序喵大人的回答 ](https://www.zhihu.com/question/43959555/answer/2620620079)","slug":"C++-Threading","published":0,"updated":"2024-01-14T08:13:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti6001bbkbw4zeg322m","content":"<p>C++多线程一直是我未开启的话题，也是我的薄弱部分，但是是程序之路进阶一步的绕不开的话题，所以我觉得很有必要展开系统的学习，虽然我学起来可能很混乱，完全不系统！但是这不重要，少说话，多学，多写！</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"c-threading-学习\">C++ Threading 学习</h1>\r\n<p><a\r\nhref=\"https://www.zhihu.com/question/43959555/answer/2620620079\">知乎:想接触C++多线程编程，需要从哪方面入手，有没有推荐的书籍或教程？\r\n- 程序喵大人的回答</a></p>\r\n","site":{"data":{}},"excerpt":"<p>C++多线程一直是我未开启的话题，也是我的薄弱部分，但是是程序之路进阶一步的绕不开的话题，所以我觉得很有必要展开系统的学习，虽然我学起来可能很混乱，完全不系统！但是这不重要，少说话，多学，多写！</p>","more":"<h1 id=\"c-threading-学习\">C++ Threading 学习</h1>\r\n<p><a\r\nhref=\"https://www.zhihu.com/question/43959555/answer/2620620079\">知乎:想接触C++多线程编程，需要从哪方面入手，有没有推荐的书籍或教程？\r\n- 程序喵大人的回答</a></p>"},{"title":"透明和earlyZ","date":"2022-05-31T12:52:39.000Z","typora-root-url":"./..","_content":"  \n白天和群友吹水，发现自己对于透明测试和透明混合，包括earlyZ和PreZ理解不够，所以记录一下，方便自己复习巩固。\n  \n<!--more-->\n  \n# 透明和Early Z、Pre Z\n  \n## Early Z\n  \n提到Early Z就不得不提深度测试，深度测试简单来说就是解决物体前后遮挡的一直技术。  \n具体就不展开了，根据物体的深度信息与深度缓存区的深度信息进行对比，决定该像素是否绘制，如深度更小即该像素更靠前就覆写深度信息。\n  \n深度测试有一个问题就是如果已经绘制的像素被遮挡了，那么我们只能舍弃，但是之前绘制被遮挡像素的工作就白做了，造成了资源的消耗，那么为了解决或者说减少这种问题，就有了提前深度测试Early Z，来解决过度不必要的片元着色计算。\n  \n<img src=\"/imgs/透明和Early Z、Pre Z/渲染流程.png\" alt=\"来源百人计划\">\n  \nEarly Z将在片元着色器前一个阶段进行，进行Early Z会直接进行深度判断，不进行计算直接进行舍弃(*在Early Z不仅判断深度通常也会写入深度*)，这样就节省了不必要计算量，通常Early Z由硬件进行，并且Early Z还可以添加模板测试。\n  \n### Early Z失效\n  \n* 开启Alpha Test 或者手动丢弃片元等操作，如clip  \n  因为Early Z也会写入深度，如果深度较浅的像素在shader中被丢弃了，后续的像素如果深度大于该像素，就都被舍弃了，但是我们在alpha test中本应该仍对后续的片元进行透明度测试，所以由于Early Z我们没有得到预期的结果。( Alpha Test 中如果透明度 alpha 越低表示越透明，当达到我们要的阈值就舍弃该片元达到透明的效果 )\n  \n* 手动修改GPU插值得到的深度值  \n  和上述情况类似。\n  \n* 开启透明混合(Alpha Blend)  \n  这里是针对关闭深度写入(`ZWrite Off`)的Alpha Blend\n  \n* 关闭深度测试(Depth Test)  \n  就是关闭了深度测试，因为Early Z也是一种深度测试，自然无法进行。\n  \n**如果从远向近渲染Early Z就白做了，因为所渲染的片元都可以通过测试，但是后续还是会被舍弃，并没有节省不必要的计算**\n  \n### 高效利用\n  \n可以用CPU对物体从近到远排序就可最大利用，但是如果场景过于复杂性能消耗就很大而且严格的从近道远很难应用批处理这种优化手段。\n  \n## Z PrePass\n  \n### 使用两个Pass：\n  \n* 在第一个Pass(Prepass)仅仅只写入深度，关闭颜色写入，我们就可以得到场景的物体深度信息。\n  \n* 在第二个Pass中关闭深度写入，并且深度比较设置为相等，这样基于第一个Pass的深度信息我们就能得到想要的效果。 \n  \n#### 问题\n  \n动态批处理问题：因为运用多个pass所以无法运用动态批处理。  \n所以会进一步带来Draw Call问题，运用了Z-Prepass会导致Draw Call增加，会造成一定的性能损失。\n  \n### 提前分离PrePass\n  \n仍然使用两个Pass，但是是两个Shader\n  \n* 将原来用以深度信息的Pass(Z-Prepass)单独作为一个Shader，用此Shader对整个场景的Opaque物体进行一次渲染，得到深度信息。\n  \n* 而原本的材质只保留第二个Pass，但是依旧需要关闭深度写入，并且将深度比较函数设置为相等。\n  \nZ-Prepass也通常用于透明混合，解决了透明物体前后错误的问题，因为透明混合往往要关闭深度写入；但是这样看不到物体背面，如果想要背面，我们可以**先渲染背面剔除正面，再渲染正面剔除背面**，这样就可以正常混合。\n  \n### 谨慎使用Z-Prepass\n  \n是否使用Z-Prepass要视我们的场景而定，如果场景overdraw过多又不能很好的进行远近排序，那么Z-Prepass带来的优化效果会比overdraw的消耗小很多，所以使用与否也需要我们来权衡，也是很依赖经验的过程。\n  \n## 透明\n  \n### 两种透明方式\n  \n* 透明度测试(alpha test): 一般会根据alpha通道的值即透明度进行片元的剔除，不满足条件便直接舍弃，通过则按正常片元处理，所以透明度测试**不需要关闭深度写入，由于直接舍弃所以展现出来的效果很极端。\n  \n  ```  \n  // 剔除片元  \n  fixed4 frag(v2f i) : SV_Target  \n  {  \n      fixed4 col = tex2D(_MainTex, i.uv);  \n      clip(col.a - _CutOff)  \n  }  \n  ```\n  \n* 透明度混合(alpha blend): 这个是我们在现实世界看到的透明效果，一般会根据片元的透明度，透明度混合需要我们关闭深度写入，因为我们需要根据颜色缓存区中的颜色来进行混合，**如果不关闭深度写入假如在一个透明物体背后有一个不透明物体，就会导致在后面的不透明物体被剔除**，我们想要的本应该能透过透明物体观察到不透明物体。同时如果开启深度写入，透明物体如果有🍌的情况，会造成原本能被看见物体因为object level的排序被剔除的问题。\n  \n#### 关于透明混合渲染顺序\n  \n因为我们在透明混合中关闭了深度写入，破坏了深度缓存工作机制，所以渲染顺序十分重要。在关闭深度写入后对于深度缓存区就是只读的状态，假设我们的场景中有一个透明物体在前、不透明物体之后。\n  \n<div style=\"margin:;width:30%\"><img src=\"/imgs/透明和Early Z、Pre Z/BT.jpg\" alt=\"一个透明物体在前、不透明物体之后\"></div>\n  \n如果先渲染不透明物体，再渲染透明物体，看起来效果很正常。\n  \n<div style=\"margin:right;width:30%\"><img src=\"/imgs/透明和Early Z、Pre Z/TB.jpg\" alt=\"先渲染透明物体，再渲染不透明物体\"></div>\n  \n但是如果先渲染透明物体，再渲染不透明物体我们就会看到场景中不透明物体部分被剔除了。\n  \n所以在应用透明技术时，要格外注意渲染顺序。通常我们的渲染顺序是：  \n1、正常渲染所有不透明物体，保持深度测试和深度写入；  \n2、把透明物体按从远及近的顺序渲染，**开启深度测试，但是要关闭深度写入**。  \n      有个问题是我们怎样界定物体的先后，这个和深度测试需要做区分，深度测试是针对像素的，而我们渲染是一个物体一个物体这样进行绘制的，我们需要的绘制顺序是针对物体而言的。很多时候我们场景中的物体不是有着绝对明确的前后关系，而会有着交错的关系。我们很难确定一个点来明确物体合适的前后关系，解决问题的方法通常是使用分割网格，并且为了减少错误尽量保持模型为凸多边形，并进行合理的子模型划分。\n  \n<div style=\"margin:auto;width:30%\"><img src=\"imgs/透明和Early Z、Pre Z/qh.jpg\" alt=\"前后关系\"></div>\n  \n#### 开启深度写入的半透明\n  \n这种方法往往是针对一个半透明物体内部前后关系错误的问题，就会用到我们介绍的Z-prePass，注意我们现在在渲染透明物体其他不透明物体已经绘制过了，换句话说缓存中已经有颜色我们是做混合，在第一个pass中写入透明物体的深度值，在第二个根据深度信息进行透明混合的渲染，这样就可以得到前后关系正确的半透明效果。(但是看不到透明物体的背面)\n  \n#### 双面透明\n  \n对于透明物体只能观测到正面的问题，我们可以用一个Pass先渲染背面剔除正面，然后再用一个Pass渲染正面剔除背面，这种情况只需关闭深度写入的透明混合即可，不需要上面的Z-prepass，我之前老是有些分不清。\n  \n透明和early z就先写到这吧，做一些复习用所以只概述了技术的大体思路，没有贴什么代码和具体细节，其实我GitHub上有，不过懒得贴了(  \n关于透明物体顺序问题还有OIT技术。  ","source":"_posts/透明和Early Z、Pre Z.md","raw":"---\ntitle: 透明和earlyZ\ndate: 2022-05-31 20:52:39\ntags: \ntypora-root-url: ./..\n---\n  \n白天和群友吹水，发现自己对于透明测试和透明混合，包括earlyZ和PreZ理解不够，所以记录一下，方便自己复习巩固。\n  \n<!--more-->\n  \n# 透明和Early Z、Pre Z\n  \n## Early Z\n  \n提到Early Z就不得不提深度测试，深度测试简单来说就是解决物体前后遮挡的一直技术。  \n具体就不展开了，根据物体的深度信息与深度缓存区的深度信息进行对比，决定该像素是否绘制，如深度更小即该像素更靠前就覆写深度信息。\n  \n深度测试有一个问题就是如果已经绘制的像素被遮挡了，那么我们只能舍弃，但是之前绘制被遮挡像素的工作就白做了，造成了资源的消耗，那么为了解决或者说减少这种问题，就有了提前深度测试Early Z，来解决过度不必要的片元着色计算。\n  \n<img src=\"/imgs/透明和Early Z、Pre Z/渲染流程.png\" alt=\"来源百人计划\">\n  \nEarly Z将在片元着色器前一个阶段进行，进行Early Z会直接进行深度判断，不进行计算直接进行舍弃(*在Early Z不仅判断深度通常也会写入深度*)，这样就节省了不必要计算量，通常Early Z由硬件进行，并且Early Z还可以添加模板测试。\n  \n### Early Z失效\n  \n* 开启Alpha Test 或者手动丢弃片元等操作，如clip  \n  因为Early Z也会写入深度，如果深度较浅的像素在shader中被丢弃了，后续的像素如果深度大于该像素，就都被舍弃了，但是我们在alpha test中本应该仍对后续的片元进行透明度测试，所以由于Early Z我们没有得到预期的结果。( Alpha Test 中如果透明度 alpha 越低表示越透明，当达到我们要的阈值就舍弃该片元达到透明的效果 )\n  \n* 手动修改GPU插值得到的深度值  \n  和上述情况类似。\n  \n* 开启透明混合(Alpha Blend)  \n  这里是针对关闭深度写入(`ZWrite Off`)的Alpha Blend\n  \n* 关闭深度测试(Depth Test)  \n  就是关闭了深度测试，因为Early Z也是一种深度测试，自然无法进行。\n  \n**如果从远向近渲染Early Z就白做了，因为所渲染的片元都可以通过测试，但是后续还是会被舍弃，并没有节省不必要的计算**\n  \n### 高效利用\n  \n可以用CPU对物体从近到远排序就可最大利用，但是如果场景过于复杂性能消耗就很大而且严格的从近道远很难应用批处理这种优化手段。\n  \n## Z PrePass\n  \n### 使用两个Pass：\n  \n* 在第一个Pass(Prepass)仅仅只写入深度，关闭颜色写入，我们就可以得到场景的物体深度信息。\n  \n* 在第二个Pass中关闭深度写入，并且深度比较设置为相等，这样基于第一个Pass的深度信息我们就能得到想要的效果。 \n  \n#### 问题\n  \n动态批处理问题：因为运用多个pass所以无法运用动态批处理。  \n所以会进一步带来Draw Call问题，运用了Z-Prepass会导致Draw Call增加，会造成一定的性能损失。\n  \n### 提前分离PrePass\n  \n仍然使用两个Pass，但是是两个Shader\n  \n* 将原来用以深度信息的Pass(Z-Prepass)单独作为一个Shader，用此Shader对整个场景的Opaque物体进行一次渲染，得到深度信息。\n  \n* 而原本的材质只保留第二个Pass，但是依旧需要关闭深度写入，并且将深度比较函数设置为相等。\n  \nZ-Prepass也通常用于透明混合，解决了透明物体前后错误的问题，因为透明混合往往要关闭深度写入；但是这样看不到物体背面，如果想要背面，我们可以**先渲染背面剔除正面，再渲染正面剔除背面**，这样就可以正常混合。\n  \n### 谨慎使用Z-Prepass\n  \n是否使用Z-Prepass要视我们的场景而定，如果场景overdraw过多又不能很好的进行远近排序，那么Z-Prepass带来的优化效果会比overdraw的消耗小很多，所以使用与否也需要我们来权衡，也是很依赖经验的过程。\n  \n## 透明\n  \n### 两种透明方式\n  \n* 透明度测试(alpha test): 一般会根据alpha通道的值即透明度进行片元的剔除，不满足条件便直接舍弃，通过则按正常片元处理，所以透明度测试**不需要关闭深度写入，由于直接舍弃所以展现出来的效果很极端。\n  \n  ```  \n  // 剔除片元  \n  fixed4 frag(v2f i) : SV_Target  \n  {  \n      fixed4 col = tex2D(_MainTex, i.uv);  \n      clip(col.a - _CutOff)  \n  }  \n  ```\n  \n* 透明度混合(alpha blend): 这个是我们在现实世界看到的透明效果，一般会根据片元的透明度，透明度混合需要我们关闭深度写入，因为我们需要根据颜色缓存区中的颜色来进行混合，**如果不关闭深度写入假如在一个透明物体背后有一个不透明物体，就会导致在后面的不透明物体被剔除**，我们想要的本应该能透过透明物体观察到不透明物体。同时如果开启深度写入，透明物体如果有🍌的情况，会造成原本能被看见物体因为object level的排序被剔除的问题。\n  \n#### 关于透明混合渲染顺序\n  \n因为我们在透明混合中关闭了深度写入，破坏了深度缓存工作机制，所以渲染顺序十分重要。在关闭深度写入后对于深度缓存区就是只读的状态，假设我们的场景中有一个透明物体在前、不透明物体之后。\n  \n<div style=\"margin:;width:30%\"><img src=\"/imgs/透明和Early Z、Pre Z/BT.jpg\" alt=\"一个透明物体在前、不透明物体之后\"></div>\n  \n如果先渲染不透明物体，再渲染透明物体，看起来效果很正常。\n  \n<div style=\"margin:right;width:30%\"><img src=\"/imgs/透明和Early Z、Pre Z/TB.jpg\" alt=\"先渲染透明物体，再渲染不透明物体\"></div>\n  \n但是如果先渲染透明物体，再渲染不透明物体我们就会看到场景中不透明物体部分被剔除了。\n  \n所以在应用透明技术时，要格外注意渲染顺序。通常我们的渲染顺序是：  \n1、正常渲染所有不透明物体，保持深度测试和深度写入；  \n2、把透明物体按从远及近的顺序渲染，**开启深度测试，但是要关闭深度写入**。  \n      有个问题是我们怎样界定物体的先后，这个和深度测试需要做区分，深度测试是针对像素的，而我们渲染是一个物体一个物体这样进行绘制的，我们需要的绘制顺序是针对物体而言的。很多时候我们场景中的物体不是有着绝对明确的前后关系，而会有着交错的关系。我们很难确定一个点来明确物体合适的前后关系，解决问题的方法通常是使用分割网格，并且为了减少错误尽量保持模型为凸多边形，并进行合理的子模型划分。\n  \n<div style=\"margin:auto;width:30%\"><img src=\"imgs/透明和Early Z、Pre Z/qh.jpg\" alt=\"前后关系\"></div>\n  \n#### 开启深度写入的半透明\n  \n这种方法往往是针对一个半透明物体内部前后关系错误的问题，就会用到我们介绍的Z-prePass，注意我们现在在渲染透明物体其他不透明物体已经绘制过了，换句话说缓存中已经有颜色我们是做混合，在第一个pass中写入透明物体的深度值，在第二个根据深度信息进行透明混合的渲染，这样就可以得到前后关系正确的半透明效果。(但是看不到透明物体的背面)\n  \n#### 双面透明\n  \n对于透明物体只能观测到正面的问题，我们可以用一个Pass先渲染背面剔除正面，然后再用一个Pass渲染正面剔除背面，这种情况只需关闭深度写入的透明混合即可，不需要上面的Z-prepass，我之前老是有些分不清。\n  \n透明和early z就先写到这吧，做一些复习用所以只概述了技术的大体思路，没有贴什么代码和具体细节，其实我GitHub上有，不过懒得贴了(  \n关于透明物体顺序问题还有OIT技术。  ","slug":"透明和Early Z、Pre Z","published":1,"updated":"2024-01-14T08:13:08.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti6001dbkbwebkzap8c","content":"<p>白天和群友吹水，发现自己对于透明测试和透明混合，包括earlyZ和PreZ理解不够，所以记录一下，方便自己复习巩固。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"透明和early-zpre-z\">透明和Early Z、Pre Z</h1>\r\n<h2 id=\"early-z\">Early Z</h2>\r\n<p>提到Early\r\nZ就不得不提深度测试，深度测试简单来说就是解决物体前后遮挡的一直技术。<br />\r\n具体就不展开了，根据物体的深度信息与深度缓存区的深度信息进行对比，决定该像素是否绘制，如深度更小即该像素更靠前就覆写深度信息。</p>\r\n<p>深度测试有一个问题就是如果已经绘制的像素被遮挡了，那么我们只能舍弃，但是之前绘制被遮挡像素的工作就白做了，造成了资源的消耗，那么为了解决或者说减少这种问题，就有了提前深度测试Early\r\nZ，来解决过度不必要的片元着色计算。</p>\r\n<p><img src=\"/imgs/透明和Early Z、Pre Z/渲染流程.png\" alt=\"来源百人计划\"></p>\r\n<p>Early Z将在片元着色器前一个阶段进行，进行Early\r\nZ会直接进行深度判断，不进行计算直接进行舍弃(<em>在Early\r\nZ不仅判断深度通常也会写入深度</em>)，这样就节省了不必要计算量，通常Early\r\nZ由硬件进行，并且Early Z还可以添加模板测试。</p>\r\n<h3 id=\"early-z失效\">Early Z失效</h3>\r\n<ul>\r\n<li><p>开启Alpha Test 或者手动丢弃片元等操作，如clip<br />\r\n因为Early\r\nZ也会写入深度，如果深度较浅的像素在shader中被丢弃了，后续的像素如果深度大于该像素，就都被舍弃了，但是我们在alpha\r\ntest中本应该仍对后续的片元进行透明度测试，所以由于Early\r\nZ我们没有得到预期的结果。( Alpha Test 中如果透明度 alpha\r\n越低表示越透明，当达到我们要的阈值就舍弃该片元达到透明的效果 )</p></li>\r\n<li><p>手动修改GPU插值得到的深度值<br />\r\n和上述情况类似。</p></li>\r\n<li><p>开启透明混合(Alpha Blend)<br />\r\n这里是针对关闭深度写入(<code>ZWrite Off</code>)的Alpha Blend</p></li>\r\n<li><p>关闭深度测试(Depth Test)<br />\r\n就是关闭了深度测试，因为Early Z也是一种深度测试，自然无法进行。</p></li>\r\n</ul>\r\n<p><strong>如果从远向近渲染Early\r\nZ就白做了，因为所渲染的片元都可以通过测试，但是后续还是会被舍弃，并没有节省不必要的计算</strong></p>\r\n<h3 id=\"高效利用\">高效利用</h3>\r\n<p>可以用CPU对物体从近到远排序就可最大利用，但是如果场景过于复杂性能消耗就很大而且严格的从近道远很难应用批处理这种优化手段。</p>\r\n<h2 id=\"z-prepass\">Z PrePass</h2>\r\n<h3 id=\"使用两个pass\">使用两个Pass：</h3>\r\n<ul>\r\n<li><p>在第一个Pass(Prepass)仅仅只写入深度，关闭颜色写入，我们就可以得到场景的物体深度信息。</p></li>\r\n<li><p>在第二个Pass中关闭深度写入，并且深度比较设置为相等，这样基于第一个Pass的深度信息我们就能得到想要的效果。</p></li>\r\n</ul>\r\n<h4 id=\"问题\">问题</h4>\r\n<p>动态批处理问题：因为运用多个pass所以无法运用动态批处理。<br />\r\n所以会进一步带来Draw Call问题，运用了Z-Prepass会导致Draw\r\nCall增加，会造成一定的性能损失。</p>\r\n<h3 id=\"提前分离prepass\">提前分离PrePass</h3>\r\n<p>仍然使用两个Pass，但是是两个Shader</p>\r\n<ul>\r\n<li><p>将原来用以深度信息的Pass(Z-Prepass)单独作为一个Shader，用此Shader对整个场景的Opaque物体进行一次渲染，得到深度信息。</p></li>\r\n<li><p>而原本的材质只保留第二个Pass，但是依旧需要关闭深度写入，并且将深度比较函数设置为相等。</p></li>\r\n</ul>\r\n<p>Z-Prepass也通常用于透明混合，解决了透明物体前后错误的问题，因为透明混合往往要关闭深度写入；但是这样看不到物体背面，如果想要背面，我们可以<strong>先渲染背面剔除正面，再渲染正面剔除背面</strong>，这样就可以正常混合。</p>\r\n<h3 id=\"谨慎使用z-prepass\">谨慎使用Z-Prepass</h3>\r\n<p>是否使用Z-Prepass要视我们的场景而定，如果场景overdraw过多又不能很好的进行远近排序，那么Z-Prepass带来的优化效果会比overdraw的消耗小很多，所以使用与否也需要我们来权衡，也是很依赖经验的过程。</p>\r\n<h2 id=\"透明\">透明</h2>\r\n<h3 id=\"两种透明方式\">两种透明方式</h3>\r\n<ul>\r\n<li><p>透明度测试(alpha test):\r\n一般会根据alpha通道的值即透明度进行片元的剔除，不满足条件便直接舍弃，通过则按正常片元处理，所以透明度测试**不需要关闭深度写入，由于直接舍弃所以展现出来的效果很极端。</p>\r\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-comment\">// 剔除片元  </span><br>fixed<span class=\"hljs-number\">4</span> frag<span class=\"hljs-comment\">(v2f i)</span> : SV_Target  <br>&#123;  <br>    fixed<span class=\"hljs-number\">4</span> col = tex<span class=\"hljs-number\">2</span>D<span class=\"hljs-comment\">(_MainTex, i.uv)</span>;  <br>    clip<span class=\"hljs-comment\">(col.a - _CutOff)</span>  <br>&#125;  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>透明度混合(alpha blend):\r\n这个是我们在现实世界看到的透明效果，一般会根据片元的透明度，透明度混合需要我们关闭深度写入，因为我们需要根据颜色缓存区中的颜色来进行混合，<strong>如果不关闭深度写入假如在一个透明物体背后有一个不透明物体，就会导致在后面的不透明物体被剔除</strong>，我们想要的本应该能透过透明物体观察到不透明物体。同时如果开启深度写入，透明物体如果有🍌的情况，会造成原本能被看见物体因为object\r\nlevel的排序被剔除的问题。</p></li>\r\n</ul>\r\n<h4 id=\"关于透明混合渲染顺序\">关于透明混合渲染顺序</h4>\r\n<p>因为我们在透明混合中关闭了深度写入，破坏了深度缓存工作机制，所以渲染顺序十分重要。在关闭深度写入后对于深度缓存区就是只读的状态，假设我们的场景中有一个透明物体在前、不透明物体之后。</p>\r\n<div style=\"margin:;width:30%\">\r\n<img src=\"/imgs/透明和Early Z、Pre Z/BT.jpg\" alt=\"一个透明物体在前、不透明物体之后\">\r\n</div>\r\n<p>如果先渲染不透明物体，再渲染透明物体，看起来效果很正常。</p>\r\n<div style=\"margin:right;width:30%\">\r\n<img src=\"/imgs/透明和Early Z、Pre Z/TB.jpg\" alt=\"先渲染透明物体，再渲染不透明物体\">\r\n</div>\r\n<p>但是如果先渲染透明物体，再渲染不透明物体我们就会看到场景中不透明物体部分被剔除了。</p>\r\n<p>所以在应用透明技术时，要格外注意渲染顺序。通常我们的渲染顺序是：<br />\r\n1、正常渲染所有不透明物体，保持深度测试和深度写入；<br />\r\n2、把透明物体按从远及近的顺序渲染，<strong>开启深度测试，但是要关闭深度写入</strong>。<br />\r\n      有个问题是我们怎样界定物体的先后，这个和深度测试需要做区分，深度测试是针对像素的，而我们渲染是一个物体一个物体这样进行绘制的，我们需要的绘制顺序是针对物体而言的。很多时候我们场景中的物体不是有着绝对明确的前后关系，而会有着交错的关系。我们很难确定一个点来明确物体合适的前后关系，解决问题的方法通常是使用分割网格，并且为了减少错误尽量保持模型为凸多边形，并进行合理的子模型划分。</p>\r\n<div style=\"margin:auto;width:30%\">\r\n<img src=\"imgs/透明和Early Z、Pre Z/qh.jpg\" alt=\"前后关系\">\r\n</div>\r\n<h4 id=\"开启深度写入的半透明\">开启深度写入的半透明</h4>\r\n<p>这种方法往往是针对一个半透明物体内部前后关系错误的问题，就会用到我们介绍的Z-prePass，注意我们现在在渲染透明物体其他不透明物体已经绘制过了，换句话说缓存中已经有颜色我们是做混合，在第一个pass中写入透明物体的深度值，在第二个根据深度信息进行透明混合的渲染，这样就可以得到前后关系正确的半透明效果。(但是看不到透明物体的背面)</p>\r\n<h4 id=\"双面透明\">双面透明</h4>\r\n<p>对于透明物体只能观测到正面的问题，我们可以用一个Pass先渲染背面剔除正面，然后再用一个Pass渲染正面剔除背面，这种情况只需关闭深度写入的透明混合即可，不需要上面的Z-prepass，我之前老是有些分不清。</p>\r\n<p>透明和early\r\nz就先写到这吧，做一些复习用所以只概述了技术的大体思路，没有贴什么代码和具体细节，其实我GitHub上有，不过懒得贴了(<br />\r\n关于透明物体顺序问题还有OIT技术。</p>\r\n","site":{"data":{}},"excerpt":"<p>白天和群友吹水，发现自己对于透明测试和透明混合，包括earlyZ和PreZ理解不够，所以记录一下，方便自己复习巩固。</p>","more":"<h1 id=\"透明和early-zpre-z\">透明和Early Z、Pre Z</h1>\r\n<h2 id=\"early-z\">Early Z</h2>\r\n<p>提到Early\r\nZ就不得不提深度测试，深度测试简单来说就是解决物体前后遮挡的一直技术。<br />\r\n具体就不展开了，根据物体的深度信息与深度缓存区的深度信息进行对比，决定该像素是否绘制，如深度更小即该像素更靠前就覆写深度信息。</p>\r\n<p>深度测试有一个问题就是如果已经绘制的像素被遮挡了，那么我们只能舍弃，但是之前绘制被遮挡像素的工作就白做了，造成了资源的消耗，那么为了解决或者说减少这种问题，就有了提前深度测试Early\r\nZ，来解决过度不必要的片元着色计算。</p>\r\n<p><img src=\"/imgs/透明和Early Z、Pre Z/渲染流程.png\" alt=\"来源百人计划\"></p>\r\n<p>Early Z将在片元着色器前一个阶段进行，进行Early\r\nZ会直接进行深度判断，不进行计算直接进行舍弃(<em>在Early\r\nZ不仅判断深度通常也会写入深度</em>)，这样就节省了不必要计算量，通常Early\r\nZ由硬件进行，并且Early Z还可以添加模板测试。</p>\r\n<h3 id=\"early-z失效\">Early Z失效</h3>\r\n<ul>\r\n<li><p>开启Alpha Test 或者手动丢弃片元等操作，如clip<br />\r\n因为Early\r\nZ也会写入深度，如果深度较浅的像素在shader中被丢弃了，后续的像素如果深度大于该像素，就都被舍弃了，但是我们在alpha\r\ntest中本应该仍对后续的片元进行透明度测试，所以由于Early\r\nZ我们没有得到预期的结果。( Alpha Test 中如果透明度 alpha\r\n越低表示越透明，当达到我们要的阈值就舍弃该片元达到透明的效果 )</p></li>\r\n<li><p>手动修改GPU插值得到的深度值<br />\r\n和上述情况类似。</p></li>\r\n<li><p>开启透明混合(Alpha Blend)<br />\r\n这里是针对关闭深度写入(<code>ZWrite Off</code>)的Alpha Blend</p></li>\r\n<li><p>关闭深度测试(Depth Test)<br />\r\n就是关闭了深度测试，因为Early Z也是一种深度测试，自然无法进行。</p></li>\r\n</ul>\r\n<p><strong>如果从远向近渲染Early\r\nZ就白做了，因为所渲染的片元都可以通过测试，但是后续还是会被舍弃，并没有节省不必要的计算</strong></p>\r\n<h3 id=\"高效利用\">高效利用</h3>\r\n<p>可以用CPU对物体从近到远排序就可最大利用，但是如果场景过于复杂性能消耗就很大而且严格的从近道远很难应用批处理这种优化手段。</p>\r\n<h2 id=\"z-prepass\">Z PrePass</h2>\r\n<h3 id=\"使用两个pass\">使用两个Pass：</h3>\r\n<ul>\r\n<li><p>在第一个Pass(Prepass)仅仅只写入深度，关闭颜色写入，我们就可以得到场景的物体深度信息。</p></li>\r\n<li><p>在第二个Pass中关闭深度写入，并且深度比较设置为相等，这样基于第一个Pass的深度信息我们就能得到想要的效果。</p></li>\r\n</ul>\r\n<h4 id=\"问题\">问题</h4>\r\n<p>动态批处理问题：因为运用多个pass所以无法运用动态批处理。<br />\r\n所以会进一步带来Draw Call问题，运用了Z-Prepass会导致Draw\r\nCall增加，会造成一定的性能损失。</p>\r\n<h3 id=\"提前分离prepass\">提前分离PrePass</h3>\r\n<p>仍然使用两个Pass，但是是两个Shader</p>\r\n<ul>\r\n<li><p>将原来用以深度信息的Pass(Z-Prepass)单独作为一个Shader，用此Shader对整个场景的Opaque物体进行一次渲染，得到深度信息。</p></li>\r\n<li><p>而原本的材质只保留第二个Pass，但是依旧需要关闭深度写入，并且将深度比较函数设置为相等。</p></li>\r\n</ul>\r\n<p>Z-Prepass也通常用于透明混合，解决了透明物体前后错误的问题，因为透明混合往往要关闭深度写入；但是这样看不到物体背面，如果想要背面，我们可以<strong>先渲染背面剔除正面，再渲染正面剔除背面</strong>，这样就可以正常混合。</p>\r\n<h3 id=\"谨慎使用z-prepass\">谨慎使用Z-Prepass</h3>\r\n<p>是否使用Z-Prepass要视我们的场景而定，如果场景overdraw过多又不能很好的进行远近排序，那么Z-Prepass带来的优化效果会比overdraw的消耗小很多，所以使用与否也需要我们来权衡，也是很依赖经验的过程。</p>\r\n<h2 id=\"透明\">透明</h2>\r\n<h3 id=\"两种透明方式\">两种透明方式</h3>\r\n<ul>\r\n<li><p>透明度测试(alpha test):\r\n一般会根据alpha通道的值即透明度进行片元的剔除，不满足条件便直接舍弃，通过则按正常片元处理，所以透明度测试**不需要关闭深度写入，由于直接舍弃所以展现出来的效果很极端。</p>\r\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-comment\">// 剔除片元  </span><br>fixed<span class=\"hljs-number\">4</span> frag<span class=\"hljs-comment\">(v2f i)</span> : SV_Target  <br>&#123;  <br>    fixed<span class=\"hljs-number\">4</span> col = tex<span class=\"hljs-number\">2</span>D<span class=\"hljs-comment\">(_MainTex, i.uv)</span>;  <br>    clip<span class=\"hljs-comment\">(col.a - _CutOff)</span>  <br>&#125;  <br></code></pre></td></tr></table></figure></li>\r\n<li><p>透明度混合(alpha blend):\r\n这个是我们在现实世界看到的透明效果，一般会根据片元的透明度，透明度混合需要我们关闭深度写入，因为我们需要根据颜色缓存区中的颜色来进行混合，<strong>如果不关闭深度写入假如在一个透明物体背后有一个不透明物体，就会导致在后面的不透明物体被剔除</strong>，我们想要的本应该能透过透明物体观察到不透明物体。同时如果开启深度写入，透明物体如果有🍌的情况，会造成原本能被看见物体因为object\r\nlevel的排序被剔除的问题。</p></li>\r\n</ul>\r\n<h4 id=\"关于透明混合渲染顺序\">关于透明混合渲染顺序</h4>\r\n<p>因为我们在透明混合中关闭了深度写入，破坏了深度缓存工作机制，所以渲染顺序十分重要。在关闭深度写入后对于深度缓存区就是只读的状态，假设我们的场景中有一个透明物体在前、不透明物体之后。</p>\r\n<div style=\"margin:;width:30%\">\r\n<img src=\"/imgs/透明和Early Z、Pre Z/BT.jpg\" alt=\"一个透明物体在前、不透明物体之后\">\r\n</div>\r\n<p>如果先渲染不透明物体，再渲染透明物体，看起来效果很正常。</p>\r\n<div style=\"margin:right;width:30%\">\r\n<img src=\"/imgs/透明和Early Z、Pre Z/TB.jpg\" alt=\"先渲染透明物体，再渲染不透明物体\">\r\n</div>\r\n<p>但是如果先渲染透明物体，再渲染不透明物体我们就会看到场景中不透明物体部分被剔除了。</p>\r\n<p>所以在应用透明技术时，要格外注意渲染顺序。通常我们的渲染顺序是：<br />\r\n1、正常渲染所有不透明物体，保持深度测试和深度写入；<br />\r\n2、把透明物体按从远及近的顺序渲染，<strong>开启深度测试，但是要关闭深度写入</strong>。<br />\r\n      有个问题是我们怎样界定物体的先后，这个和深度测试需要做区分，深度测试是针对像素的，而我们渲染是一个物体一个物体这样进行绘制的，我们需要的绘制顺序是针对物体而言的。很多时候我们场景中的物体不是有着绝对明确的前后关系，而会有着交错的关系。我们很难确定一个点来明确物体合适的前后关系，解决问题的方法通常是使用分割网格，并且为了减少错误尽量保持模型为凸多边形，并进行合理的子模型划分。</p>\r\n<div style=\"margin:auto;width:30%\">\r\n<img src=\"imgs/透明和Early Z、Pre Z/qh.jpg\" alt=\"前后关系\">\r\n</div>\r\n<h4 id=\"开启深度写入的半透明\">开启深度写入的半透明</h4>\r\n<p>这种方法往往是针对一个半透明物体内部前后关系错误的问题，就会用到我们介绍的Z-prePass，注意我们现在在渲染透明物体其他不透明物体已经绘制过了，换句话说缓存中已经有颜色我们是做混合，在第一个pass中写入透明物体的深度值，在第二个根据深度信息进行透明混合的渲染，这样就可以得到前后关系正确的半透明效果。(但是看不到透明物体的背面)</p>\r\n<h4 id=\"双面透明\">双面透明</h4>\r\n<p>对于透明物体只能观测到正面的问题，我们可以用一个Pass先渲染背面剔除正面，然后再用一个Pass渲染正面剔除背面，这种情况只需关闭深度写入的透明混合即可，不需要上面的Z-prepass，我之前老是有些分不清。</p>\r\n<p>透明和early\r\nz就先写到这吧，做一些复习用所以只概述了技术的大体思路，没有贴什么代码和具体细节，其实我GitHub上有，不过懒得贴了(<br />\r\n关于透明物体顺序问题还有OIT技术。</p>"},{"_content":"## Lua-OOP\n\nhttps://renatomaia.github.io/loop/index.html\nlua prog lang那本书+这个+lua热更方案，基本能解决所有gp lua需求","source":"_drafts/Lua学习.md","raw":"## Lua-OOP\n\nhttps://renatomaia.github.io/loop/index.html\nlua prog lang那本书+这个+lua热更方案，基本能解决所有gp lua需求","slug":"Lua学习","published":0,"date":"2024-01-14T08:13:08.469Z","updated":"2024-01-14T08:13:08.469Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti6001ebkbwctcs7l9a","content":"<h2 id=\"lua-oop\">Lua-OOP</h2>\r\n<p>https://renatomaia.github.io/loop/index.html lua prog\r\nlang那本书+这个+lua热更方案，基本能解决所有gp lua需求</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"lua-oop\">Lua-OOP</h2>\r\n<p>https://renatomaia.github.io/loop/index.html lua prog\r\nlang那本书+这个+lua热更方案，基本能解决所有gp lua需求</p>\r\n"},{"_content":"---\n\n---\n\n问题是这样的写代码的时候定义了结构体，然后套了一层vector，想作为元素，再套一层vector，然后就出错了。虽然可以改回去用vector，但是我想知道哪里出错了。\n\n<!--more-->\n\n# Vector的push_back\n\n","source":"_drafts/C++VectorPush_back.md","raw":"---\n\n---\n\n问题是这样的写代码的时候定义了结构体，然后套了一层vector，想作为元素，再套一层vector，然后就出错了。虽然可以改回去用vector，但是我想知道哪里出错了。\n\n<!--more-->\n\n# Vector的push_back\n\n","slug":"C++VectorPush_back","published":0,"date":"2024-01-14T08:13:08.469Z","updated":"2024-01-14T08:13:08.469Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti7001fbkbwbaki4pxk","content":"<hr />\r\n<hr />\r\n<p>问题是这样的写代码的时候定义了结构体，然后套了一层vector，想作为元素，再套一层vector，然后就出错了。虽然可以改回去用vector，但是我想知道哪里出错了。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"vector的push_back\">Vector的push_back</h1>\r\n","site":{"data":{}},"excerpt":"<hr />\r\n<hr />\r\n<p>问题是这样的写代码的时候定义了结构体，然后套了一层vector，想作为元素，再套一层vector，然后就出错了。虽然可以改回去用vector，但是我想知道哪里出错了。</p>","more":"<h1 id=\"vector的push_back\">Vector的push_back</h1>"},{"title":"ZumaGame","typora-root-url":"./..","date":"2023-03-03T07:47:23.000Z","_content":"\n\n# ZumaGame\n\n经典的困难题\nBFS或者记忆化搜索\n\n<!--more-->\n\n## 题目\n\n<img src=\"/imgs/ZumaGame/question.png\">\n\n## 例子\n\n* **输入**：board = \"WRRBBW\", hand = \"RB\"\n\n* **输出**：-1\n* **解释**：无法消除所有球，最好解是\n  -插入‘R’，WRRRBBW->WBBW\n  -插入‘B’，WBBBW->WW\n  没有球，结束。\n","source":"_drafts/ZumaGame.md","raw":"---\ntitle: ZumaGame\ntypora-root-url: ./..\ndate: 2023-03-03 15:47:23\ntags:\n---\n\n\n# ZumaGame\n\n经典的困难题\nBFS或者记忆化搜索\n\n<!--more-->\n\n## 题目\n\n<img src=\"/imgs/ZumaGame/question.png\">\n\n## 例子\n\n* **输入**：board = \"WRRBBW\", hand = \"RB\"\n\n* **输出**：-1\n* **解释**：无法消除所有球，最好解是\n  -插入‘R’，WRRRBBW->WBBW\n  -插入‘B’，WBBBW->WW\n  没有球，结束。\n","slug":"ZumaGame","published":0,"updated":"2024-01-14T08:13:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti7001hbkbw4rdl4ct8","content":"<h1 id=\"zumagame\">ZumaGame</h1>\r\n<p>经典的困难题 BFS或者记忆化搜索</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"题目\">题目</h2>\r\n<p><img src=\"/imgs/ZumaGame/question.png\"></p>\r\n<h2 id=\"例子\">例子</h2>\r\n<ul>\r\n<li><p><strong>输入</strong>：board = \"WRRBBW\", hand = \"RB\"</p></li>\r\n<li><p><strong>输出</strong>：-1</p></li>\r\n<li><p><strong>解释</strong>：无法消除所有球，最好解是\r\n-插入‘R’，WRRRBBW-&gt;WBBW -插入‘B’，WBBBW-&gt;WW\r\n没有球，结束。</p></li>\r\n</ul>\r\n","site":{"data":{}},"excerpt":"<h1 id=\"zumagame\">ZumaGame</h1>\r\n<p>经典的困难题 BFS或者记忆化搜索</p>","more":"<h2 id=\"题目\">题目</h2>\r\n<p><img src=\"/imgs/ZumaGame/question.png\"></p>\r\n<h2 id=\"例子\">例子</h2>\r\n<ul>\r\n<li><p><strong>输入</strong>：board = \"WRRBBW\", hand = \"RB\"</p></li>\r\n<li><p><strong>输出</strong>：-1</p></li>\r\n<li><p><strong>解释</strong>：无法消除所有球，最好解是\r\n-插入‘R’，WRRRBBW-&gt;WBBW -插入‘B’，WBBBW-&gt;WW\r\n没有球，结束。</p></li>\r\n</ul>"},{"title":"C++多线程学习","date":"2023-04-20T11:40:11.000Z","_content":"\n多线程开发一直是我薄弱的地方，或者说我没接触过的地方，但是却是一个重要的话题，自己记录一下学习过程，随时做补足说明吧。\n\n<!--more-->\n\n# C++多线程学习\n\n## 学习路线\n\n1. 首先，你需要了解c++多线程编程的基本原理和概念。可以参考一些教程或者书籍，如C++ Concurrency in Action，C++ 线程编程等。另外，网上也有众多的学习资源供你参考。\n2. 掌握c++中提供的多线程库，例如C++11 中新增的 thread、mutex、condition_variable 等头文件，以及 chrono 头文件下的时间函数等。这些库提供了基本的操作多线程所需的方法和工具，通过实践和阅读文档，逐渐掌握和熟练使用这些工具。\n3. 开始实践，可以先从简单的多线程程序入手，例如创建两个线程执行不同的任务，然后尝试对线程进行同步控制，保证对共享资源的访问正确性。可以通过操作系统的性能工具，例如 top 和 perf（Linux） 或者 Task Manager（Windows）来观察线程的运行情况和性能瓶颈。\n4. 加深对多线程应用的理解，例如线程池、消息队列等应用方式，可以通过一些高质量的开源项目来参考实现，例如 Poco C++ Libraries、 folly 等。\n5. 了解c++多线程开发的一些实践技巧和注意事项，例如如何避免死锁，如何提高线程的性能等。\n\n## 一些学C++的网站\n\n1. [GeeksforGeeks](https://www.geeksforgeeks.org/): GeeksforGeeks是一个面向编程人员的计算机科学门户网站，主要包含各种编程语言、数据结构、算法、操作系统等方面的教程。其中也包括了 C++ 的相关内容。\n\n2. [LearnCpp.com](https://www.learncpp.com/): 这是一个专门针对C++语言的在线学习网站，提供了由浅入深、系统全面的C++教程。\n\n3. [Cplusplus.com](http://www.cplusplus.com/): 这是一个专门针对C++语言的网站，提供了大量的C++参考资料和教程，同时也拥有活跃的论坛社区。\n\n4. [Codecademy](https://www.codecademy.com/catalog/language/cpp): Codecademy是一个在线编程学习网站，旨在帮助初学者快速掌握编程基础和流行编程语言，其中也包括 C++。","source":"_drafts/C++多线程.md","raw":"---\ntitle: C++多线程学习\ndate: 2023-4-20 19:40:11\ntags:\n---\n\n多线程开发一直是我薄弱的地方，或者说我没接触过的地方，但是却是一个重要的话题，自己记录一下学习过程，随时做补足说明吧。\n\n<!--more-->\n\n# C++多线程学习\n\n## 学习路线\n\n1. 首先，你需要了解c++多线程编程的基本原理和概念。可以参考一些教程或者书籍，如C++ Concurrency in Action，C++ 线程编程等。另外，网上也有众多的学习资源供你参考。\n2. 掌握c++中提供的多线程库，例如C++11 中新增的 thread、mutex、condition_variable 等头文件，以及 chrono 头文件下的时间函数等。这些库提供了基本的操作多线程所需的方法和工具，通过实践和阅读文档，逐渐掌握和熟练使用这些工具。\n3. 开始实践，可以先从简单的多线程程序入手，例如创建两个线程执行不同的任务，然后尝试对线程进行同步控制，保证对共享资源的访问正确性。可以通过操作系统的性能工具，例如 top 和 perf（Linux） 或者 Task Manager（Windows）来观察线程的运行情况和性能瓶颈。\n4. 加深对多线程应用的理解，例如线程池、消息队列等应用方式，可以通过一些高质量的开源项目来参考实现，例如 Poco C++ Libraries、 folly 等。\n5. 了解c++多线程开发的一些实践技巧和注意事项，例如如何避免死锁，如何提高线程的性能等。\n\n## 一些学C++的网站\n\n1. [GeeksforGeeks](https://www.geeksforgeeks.org/): GeeksforGeeks是一个面向编程人员的计算机科学门户网站，主要包含各种编程语言、数据结构、算法、操作系统等方面的教程。其中也包括了 C++ 的相关内容。\n\n2. [LearnCpp.com](https://www.learncpp.com/): 这是一个专门针对C++语言的在线学习网站，提供了由浅入深、系统全面的C++教程。\n\n3. [Cplusplus.com](http://www.cplusplus.com/): 这是一个专门针对C++语言的网站，提供了大量的C++参考资料和教程，同时也拥有活跃的论坛社区。\n\n4. [Codecademy](https://www.codecademy.com/catalog/language/cpp): Codecademy是一个在线编程学习网站，旨在帮助初学者快速掌握编程基础和流行编程语言，其中也包括 C++。","slug":"C++多线程","published":0,"updated":"2024-01-14T08:13:08.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti7001ibkbw5cffew9l","content":"<p>多线程开发一直是我薄弱的地方，或者说我没接触过的地方，但是却是一个重要的话题，自己记录一下学习过程，随时做补足说明吧。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"c多线程学习\">C++多线程学习</h1>\r\n<h2 id=\"学习路线\">学习路线</h2>\r\n<ol type=\"1\">\r\n<li>首先，你需要了解c++多线程编程的基本原理和概念。可以参考一些教程或者书籍，如C++\r\nConcurrency in Action，C++\r\n线程编程等。另外，网上也有众多的学习资源供你参考。</li>\r\n<li>掌握c++中提供的多线程库，例如C++11 中新增的\r\nthread、mutex、condition_variable 等头文件，以及 chrono\r\n头文件下的时间函数等。这些库提供了基本的操作多线程所需的方法和工具，通过实践和阅读文档，逐渐掌握和熟练使用这些工具。</li>\r\n<li>开始实践，可以先从简单的多线程程序入手，例如创建两个线程执行不同的任务，然后尝试对线程进行同步控制，保证对共享资源的访问正确性。可以通过操作系统的性能工具，例如\r\ntop 和 perf（Linux） 或者 Task\r\nManager（Windows）来观察线程的运行情况和性能瓶颈。</li>\r\n<li>加深对多线程应用的理解，例如线程池、消息队列等应用方式，可以通过一些高质量的开源项目来参考实现，例如\r\nPoco C++ Libraries、 folly 等。</li>\r\n<li>了解c++多线程开发的一些实践技巧和注意事项，例如如何避免死锁，如何提高线程的性能等。</li>\r\n</ol>\r\n<h2 id=\"一些学c的网站\">一些学C++的网站</h2>\r\n<ol type=\"1\">\r\n<li><p><a href=\"https://www.geeksforgeeks.org/\">GeeksforGeeks</a>:\r\nGeeksforGeeks是一个面向编程人员的计算机科学门户网站，主要包含各种编程语言、数据结构、算法、操作系统等方面的教程。其中也包括了\r\nC++ 的相关内容。</p></li>\r\n<li><p><a href=\"https://www.learncpp.com/\">LearnCpp.com</a>:\r\n这是一个专门针对C++语言的在线学习网站，提供了由浅入深、系统全面的C++教程。</p></li>\r\n<li><p><a href=\"http://www.cplusplus.com/\">Cplusplus.com</a>:\r\n这是一个专门针对C++语言的网站，提供了大量的C++参考资料和教程，同时也拥有活跃的论坛社区。</p></li>\r\n<li><p><a\r\nhref=\"https://www.codecademy.com/catalog/language/cpp\">Codecademy</a>:\r\nCodecademy是一个在线编程学习网站，旨在帮助初学者快速掌握编程基础和流行编程语言，其中也包括\r\nC++。</p></li>\r\n</ol>\r\n","site":{"data":{}},"excerpt":"<p>多线程开发一直是我薄弱的地方，或者说我没接触过的地方，但是却是一个重要的话题，自己记录一下学习过程，随时做补足说明吧。</p>","more":"<h1 id=\"c多线程学习\">C++多线程学习</h1>\r\n<h2 id=\"学习路线\">学习路线</h2>\r\n<ol type=\"1\">\r\n<li>首先，你需要了解c++多线程编程的基本原理和概念。可以参考一些教程或者书籍，如C++\r\nConcurrency in Action，C++\r\n线程编程等。另外，网上也有众多的学习资源供你参考。</li>\r\n<li>掌握c++中提供的多线程库，例如C++11 中新增的\r\nthread、mutex、condition_variable 等头文件，以及 chrono\r\n头文件下的时间函数等。这些库提供了基本的操作多线程所需的方法和工具，通过实践和阅读文档，逐渐掌握和熟练使用这些工具。</li>\r\n<li>开始实践，可以先从简单的多线程程序入手，例如创建两个线程执行不同的任务，然后尝试对线程进行同步控制，保证对共享资源的访问正确性。可以通过操作系统的性能工具，例如\r\ntop 和 perf（Linux） 或者 Task\r\nManager（Windows）来观察线程的运行情况和性能瓶颈。</li>\r\n<li>加深对多线程应用的理解，例如线程池、消息队列等应用方式，可以通过一些高质量的开源项目来参考实现，例如\r\nPoco C++ Libraries、 folly 等。</li>\r\n<li>了解c++多线程开发的一些实践技巧和注意事项，例如如何避免死锁，如何提高线程的性能等。</li>\r\n</ol>\r\n<h2 id=\"一些学c的网站\">一些学C++的网站</h2>\r\n<ol type=\"1\">\r\n<li><p><a href=\"https://www.geeksforgeeks.org/\">GeeksforGeeks</a>:\r\nGeeksforGeeks是一个面向编程人员的计算机科学门户网站，主要包含各种编程语言、数据结构、算法、操作系统等方面的教程。其中也包括了\r\nC++ 的相关内容。</p></li>\r\n<li><p><a href=\"https://www.learncpp.com/\">LearnCpp.com</a>:\r\n这是一个专门针对C++语言的在线学习网站，提供了由浅入深、系统全面的C++教程。</p></li>\r\n<li><p><a href=\"http://www.cplusplus.com/\">Cplusplus.com</a>:\r\n这是一个专门针对C++语言的网站，提供了大量的C++参考资料和教程，同时也拥有活跃的论坛社区。</p></li>\r\n<li><p><a\r\nhref=\"https://www.codecademy.com/catalog/language/cpp\">Codecademy</a>:\r\nCodecademy是一个在线编程学习网站，旨在帮助初学者快速掌握编程基础和流行编程语言，其中也包括\r\nC++。</p></li>\r\n</ol>"},{"title":"Subsurface Scattering","math":true,"index_img":"/imgs/LearnPBR/pbr.png","banner_img":"/imgs/LearnPBR/pbr.png","date":"2024-05-03T16:00:00.000Z","typora-root-url":"../","_content":"\n次表面散射学习\n\n# Subsurface Scattring\n\n\n\n## 参考\n\n[基于物理着色（四）- 次表面散射 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/21247702)\n\nGems：[Chapter 16. Real-Time Approximations to Subsurface | NVIDIA Developer](https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-16-real-time-approximations-subsurface-scattering)\n\n模拟：[Fast Subsurface Scattering in Unity (Part 1) - Alan Zucconi](https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/)  \n[Fast Subsurface Scattering in Unity (Part 2) - Alan Zucconi](https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-2/)","source":"_drafts/SubsurfaceScattering.md","raw":"---\ntitle: Subsurface Scattering\ntags: 图形学\nmath: true\nindex_img: /imgs/LearnPBR/pbr.png\nbanner_img: /imgs/LearnPBR/pbr.png\ndate: 2024-05-04\ntypora-root-url: ../\n---\n\n次表面散射学习\n\n# Subsurface Scattring\n\n\n\n## 参考\n\n[基于物理着色（四）- 次表面散射 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/21247702)\n\nGems：[Chapter 16. Real-Time Approximations to Subsurface | NVIDIA Developer](https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-16-real-time-approximations-subsurface-scattering)\n\n模拟：[Fast Subsurface Scattering in Unity (Part 1) - Alan Zucconi](https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/)  \n[Fast Subsurface Scattering in Unity (Part 2) - Alan Zucconi](https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-2/)","slug":"SubsurfaceScattering","published":0,"updated":"2024-05-04T12:48:17.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti7001jbkbw9nqthfz5","content":"<p>次表面散射学习</p>\r\n<h1 id=\"subsurface-scattring\">Subsurface Scattring</h1>\r\n<h2 id=\"参考\">参考</h2>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/21247702\">基于物理着色（四）-\r\n次表面散射 - 知乎 (zhihu.com)</a></p>\r\n<p>Gems：<a\r\nhref=\"https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-16-real-time-approximations-subsurface-scattering\">Chapter\r\n16. Real-Time Approximations to Subsurface | NVIDIA Developer</a></p>\r\n<p>模拟：<a\r\nhref=\"https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/\">Fast\r\nSubsurface Scattering in Unity (Part 1) - Alan Zucconi</a><br />\r\n<a\r\nhref=\"https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-2/\">Fast\r\nSubsurface Scattering in Unity (Part 2) - Alan Zucconi</a></p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>次表面散射学习</p>\r\n<h1 id=\"subsurface-scattring\">Subsurface Scattring</h1>\r\n<h2 id=\"参考\">参考</h2>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/21247702\">基于物理着色（四）-\r\n次表面散射 - 知乎 (zhihu.com)</a></p>\r\n<p>Gems：<a\r\nhref=\"https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-16-real-time-approximations-subsurface-scattering\">Chapter\r\n16. Real-Time Approximations to Subsurface | NVIDIA Developer</a></p>\r\n<p>模拟：<a\r\nhref=\"https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/\">Fast\r\nSubsurface Scattering in Unity (Part 1) - Alan Zucconi</a><br />\r\n<a\r\nhref=\"https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-2/\">Fast\r\nSubsurface Scattering in Unity (Part 2) - Alan Zucconi</a></p>\r\n"},{"title":"Unity 动态修改 Volume","math":true,"index_img":"/imgs/LearnPBR/pbr.png","banner_img":"/imgs/LearnPBR/pbr.png","date":"2024-05-01T16:00:00.000Z","typora-root-url":"../","_content":"\n如何在代码中动态修改 Unity Volume 的参数\n\n# Unity 动态修改 Volume 参数\n\n## 尝试直接改 Volume 参数\n\n失败了，只有那一行有效，后面又被重写为之前设置的 0了\n\n~~~C#\nusing System.Collections;\nusing System.Collections.Generic;\nusing Unity.VisualScripting;\nusing UnityEngine;\nusing UnityEngine.Playables;\nusing UnityEngine.Rendering;\n\npublic class EffectController : MonoBehaviour\n{\n    public GameObject daoguang;\n    public PlayableDirector effPd;\n    public VolumeStack volumeStack;\n    public CutScreenVolume cutScreenVolume;\n    public bool cut = false;\n    // Start is called before the first frame update\n    void Start()\n    {\n        volumeStack = VolumeManager.instance.stack;\n        cutScreenVolume = volumeStack.GetComponent<CutScreenVolume>();\n        if (daoguang != null)\n        {\n            daoguang.SetActive(true);\n            effPd = daoguang.GetComponent<PlayableDirector>();\n            effPd.paused += SetCutScreenState;\n            effPd.stopped += SetCutScreenState;\n        }\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        //Debug.Log(effPd.state.ToString());\n        Debug.Log(\"EffController\" + cutScreenVolume.Intensity.value);\n        if(cut && effPd.state == PlayState.Paused)\n        {\n            //SetCutScreen();\n        }\n    }\n\n    void SetCutScreenState(PlayableDirector aDirector)\n    {\n        this.cut = true;\n        Debug.Log(aDirector.state.ToString());\n        cutScreenVolume.Intensity.value = 1.0f;\t// 这行有用，但是只有一次\n        Debug.Log(cutScreenVolume.Intensity.value);\n    }\n\n    IEnumerator SetCutScreen()\n    {\n        cutScreenVolume.Intensity.value = 1.0f;\n        while(cutScreenVolume.Intensity.value > 0.0f)\n        {\n            cutScreenVolume.Intensity.value -= Time.deltaTime * 0.5f;\n            if(cutScreenVolume.Intensity.value <= 0.0f)\n            {\n                cut = false;\n            }\n            yield return null;\n        }\n    }\n}\n~~~\n\n","source":"_drafts/动态修改Volume.md","raw":"---\ntitle: Unity 动态修改 Volume\ntags: Unity\nmath: true\nindex_img: /imgs/LearnPBR/pbr.png\nbanner_img: /imgs/LearnPBR/pbr.png\ndate: 2024-05-02\ntypora-root-url: ../\n---\n\n如何在代码中动态修改 Unity Volume 的参数\n\n# Unity 动态修改 Volume 参数\n\n## 尝试直接改 Volume 参数\n\n失败了，只有那一行有效，后面又被重写为之前设置的 0了\n\n~~~C#\nusing System.Collections;\nusing System.Collections.Generic;\nusing Unity.VisualScripting;\nusing UnityEngine;\nusing UnityEngine.Playables;\nusing UnityEngine.Rendering;\n\npublic class EffectController : MonoBehaviour\n{\n    public GameObject daoguang;\n    public PlayableDirector effPd;\n    public VolumeStack volumeStack;\n    public CutScreenVolume cutScreenVolume;\n    public bool cut = false;\n    // Start is called before the first frame update\n    void Start()\n    {\n        volumeStack = VolumeManager.instance.stack;\n        cutScreenVolume = volumeStack.GetComponent<CutScreenVolume>();\n        if (daoguang != null)\n        {\n            daoguang.SetActive(true);\n            effPd = daoguang.GetComponent<PlayableDirector>();\n            effPd.paused += SetCutScreenState;\n            effPd.stopped += SetCutScreenState;\n        }\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n        //Debug.Log(effPd.state.ToString());\n        Debug.Log(\"EffController\" + cutScreenVolume.Intensity.value);\n        if(cut && effPd.state == PlayState.Paused)\n        {\n            //SetCutScreen();\n        }\n    }\n\n    void SetCutScreenState(PlayableDirector aDirector)\n    {\n        this.cut = true;\n        Debug.Log(aDirector.state.ToString());\n        cutScreenVolume.Intensity.value = 1.0f;\t// 这行有用，但是只有一次\n        Debug.Log(cutScreenVolume.Intensity.value);\n    }\n\n    IEnumerator SetCutScreen()\n    {\n        cutScreenVolume.Intensity.value = 1.0f;\n        while(cutScreenVolume.Intensity.value > 0.0f)\n        {\n            cutScreenVolume.Intensity.value -= Time.deltaTime * 0.5f;\n            if(cutScreenVolume.Intensity.value <= 0.0f)\n            {\n                cut = false;\n            }\n            yield return null;\n        }\n    }\n}\n~~~\n\n","slug":"动态修改Volume","published":0,"updated":"2024-05-02T09:54:57.899Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti7001kbkbwen6q1xbf","content":"<p>如何在代码中动态修改 Unity Volume 的参数</p>\r\n<h1 id=\"unity-动态修改-volume-参数\">Unity 动态修改 Volume 参数</h1>\r\n<h2 id=\"尝试直接改-volume-参数\">尝试直接改 Volume 参数</h2>\r\n<p>失败了，只有那一行有效，后面又被重写为之前设置的 0了</p>\r\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-keyword\">using</span> System.Collections;<br><span class=\"hljs-keyword\">using</span> System.Collections.Generic;<br><span class=\"hljs-keyword\">using</span> Unity.VisualScripting;<br><span class=\"hljs-keyword\">using</span> UnityEngine;<br><span class=\"hljs-keyword\">using</span> UnityEngine.Playables;<br><span class=\"hljs-keyword\">using</span> UnityEngine.Rendering;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EffectController</span> : <span class=\"hljs-title\">MonoBehaviour</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> GameObject daoguang;<br>    <span class=\"hljs-keyword\">public</span> PlayableDirector effPd;<br>    <span class=\"hljs-keyword\">public</span> VolumeStack volumeStack;<br>    <span class=\"hljs-keyword\">public</span> CutScreenVolume cutScreenVolume;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">bool</span> cut = <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-comment\">// Start is called before the first frame update</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Start</span>()</span><br>    &#123;<br>        volumeStack = VolumeManager.instance.stack;<br>        cutScreenVolume = volumeStack.GetComponent&lt;CutScreenVolume&gt;();<br>        <span class=\"hljs-keyword\">if</span> (daoguang != <span class=\"hljs-literal\">null</span>)<br>        &#123;<br>            daoguang.SetActive(<span class=\"hljs-literal\">true</span>);<br>            effPd = daoguang.GetComponent&lt;PlayableDirector&gt;();<br>            effPd.paused += SetCutScreenState;<br>            effPd.stopped += SetCutScreenState;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// Update is called once per frame</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Update</span>()</span><br>    &#123;<br>        <span class=\"hljs-comment\">//Debug.Log(effPd.state.ToString());</span><br>        Debug.Log(<span class=\"hljs-string\">&quot;EffController&quot;</span> + cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span>);<br>        <span class=\"hljs-keyword\">if</span>(cut &amp;&amp; effPd.state == PlayState.Paused)<br>        &#123;<br>            <span class=\"hljs-comment\">//SetCutScreen();</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SetCutScreenState</span>(<span class=\"hljs-params\">PlayableDirector aDirector</span>)</span><br>    &#123;<br>        <span class=\"hljs-keyword\">this</span>.cut = <span class=\"hljs-literal\">true</span>;<br>        Debug.Log(aDirector.state.ToString());<br>        cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span> = <span class=\"hljs-number\">1.0f</span>;\t<span class=\"hljs-comment\">// 这行有用，但是只有一次</span><br>        Debug.Log(cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span>);<br>    &#125;<br><br>    <span class=\"hljs-function\">IEnumerator <span class=\"hljs-title\">SetCutScreen</span>()</span><br>    &#123;<br>        cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span> = <span class=\"hljs-number\">1.0f</span>;<br>        <span class=\"hljs-keyword\">while</span>(cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span> &gt; <span class=\"hljs-number\">0.0f</span>)<br>        &#123;<br>            cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span> -= Time.deltaTime * <span class=\"hljs-number\">0.5f</span>;<br>            <span class=\"hljs-keyword\">if</span>(cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span> &lt;= <span class=\"hljs-number\">0.0f</span>)<br>            &#123;<br>                cut = <span class=\"hljs-literal\">false</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n","site":{"data":{}},"excerpt":"","more":"<p>如何在代码中动态修改 Unity Volume 的参数</p>\r\n<h1 id=\"unity-动态修改-volume-参数\">Unity 动态修改 Volume 参数</h1>\r\n<h2 id=\"尝试直接改-volume-参数\">尝试直接改 Volume 参数</h2>\r\n<p>失败了，只有那一行有效，后面又被重写为之前设置的 0了</p>\r\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-keyword\">using</span> System.Collections;<br><span class=\"hljs-keyword\">using</span> System.Collections.Generic;<br><span class=\"hljs-keyword\">using</span> Unity.VisualScripting;<br><span class=\"hljs-keyword\">using</span> UnityEngine;<br><span class=\"hljs-keyword\">using</span> UnityEngine.Playables;<br><span class=\"hljs-keyword\">using</span> UnityEngine.Rendering;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EffectController</span> : <span class=\"hljs-title\">MonoBehaviour</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span> GameObject daoguang;<br>    <span class=\"hljs-keyword\">public</span> PlayableDirector effPd;<br>    <span class=\"hljs-keyword\">public</span> VolumeStack volumeStack;<br>    <span class=\"hljs-keyword\">public</span> CutScreenVolume cutScreenVolume;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">bool</span> cut = <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-comment\">// Start is called before the first frame update</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Start</span>()</span><br>    &#123;<br>        volumeStack = VolumeManager.instance.stack;<br>        cutScreenVolume = volumeStack.GetComponent&lt;CutScreenVolume&gt;();<br>        <span class=\"hljs-keyword\">if</span> (daoguang != <span class=\"hljs-literal\">null</span>)<br>        &#123;<br>            daoguang.SetActive(<span class=\"hljs-literal\">true</span>);<br>            effPd = daoguang.GetComponent&lt;PlayableDirector&gt;();<br>            effPd.paused += SetCutScreenState;<br>            effPd.stopped += SetCutScreenState;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// Update is called once per frame</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Update</span>()</span><br>    &#123;<br>        <span class=\"hljs-comment\">//Debug.Log(effPd.state.ToString());</span><br>        Debug.Log(<span class=\"hljs-string\">&quot;EffController&quot;</span> + cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span>);<br>        <span class=\"hljs-keyword\">if</span>(cut &amp;&amp; effPd.state == PlayState.Paused)<br>        &#123;<br>            <span class=\"hljs-comment\">//SetCutScreen();</span><br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SetCutScreenState</span>(<span class=\"hljs-params\">PlayableDirector aDirector</span>)</span><br>    &#123;<br>        <span class=\"hljs-keyword\">this</span>.cut = <span class=\"hljs-literal\">true</span>;<br>        Debug.Log(aDirector.state.ToString());<br>        cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span> = <span class=\"hljs-number\">1.0f</span>;\t<span class=\"hljs-comment\">// 这行有用，但是只有一次</span><br>        Debug.Log(cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span>);<br>    &#125;<br><br>    <span class=\"hljs-function\">IEnumerator <span class=\"hljs-title\">SetCutScreen</span>()</span><br>    &#123;<br>        cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span> = <span class=\"hljs-number\">1.0f</span>;<br>        <span class=\"hljs-keyword\">while</span>(cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span> &gt; <span class=\"hljs-number\">0.0f</span>)<br>        &#123;<br>            cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span> -= Time.deltaTime * <span class=\"hljs-number\">0.5f</span>;<br>            <span class=\"hljs-keyword\">if</span>(cutScreenVolume.Intensity.<span class=\"hljs-keyword\">value</span> &lt;= <span class=\"hljs-number\">0.0f</span>)<br>            &#123;<br>                cut = <span class=\"hljs-literal\">false</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n"},{"title":"八股复习2","math":true,"index_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","banner_img":"/imgs/水面模拟/InterstellarSeaWave.png","date":"2024-04-30T16:00:00.000Z","typora-root-url":"../","_content":"\n主要是 C++ 和 图形学吧\n\n# C++\n\n## 1.1 多态和虚函数\n\n多态：\n\n* 编译时多态也称为为静态联编，通过重载和模板来实现\n\n* 运行时多态称为动态联编，通过继承和虚函数来实现。\n\n**虚函数的实现机制是什么？**\n\n虚函数是通过虚函数表来实现的\n\n\n### 父类子类指针\n\n#### static_cast\n\nstatic_cast 可以将子类指针 向上 转换为 父类指针（安全  \n如果将父类向下转换成子类指针就不安全\n\n#### 父子函数\n\n父类指针指向子类的话，调用函数，如果不是虚函数，会根据指针类型决定，  \n如果是虚函数，就会调用子类的函数。","source":"_drafts/八股复习2.md","raw":"---\ntitle: 八股复习2\nmath: true\ntags: 图形学, unity, C++\nindex_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\nbanner_img: /imgs/水面模拟/InterstellarSeaWave.png\ndate: 2024-05-01\ntypora-root-url: ../\n---\n\n主要是 C++ 和 图形学吧\n\n# C++\n\n## 1.1 多态和虚函数\n\n多态：\n\n* 编译时多态也称为为静态联编，通过重载和模板来实现\n\n* 运行时多态称为动态联编，通过继承和虚函数来实现。\n\n**虚函数的实现机制是什么？**\n\n虚函数是通过虚函数表来实现的\n\n\n### 父类子类指针\n\n#### static_cast\n\nstatic_cast 可以将子类指针 向上 转换为 父类指针（安全  \n如果将父类向下转换成子类指针就不安全\n\n#### 父子函数\n\n父类指针指向子类的话，调用函数，如果不是虚函数，会根据指针类型决定，  \n如果是虚函数，就会调用子类的函数。","slug":"八股复习2","published":0,"updated":"2024-05-22T09:43:18.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti8001nbkbw6l697l0u","content":"<p>主要是 C++ 和 图形学吧</p>\r\n<h1 id=\"c\">C++</h1>\r\n<h2 id=\"多态和虚函数\">1.1 多态和虚函数</h2>\r\n<p>多态：</p>\r\n<ul>\r\n<li><p>编译时多态也称为为静态联编，通过重载和模板来实现</p></li>\r\n<li><p>运行时多态称为动态联编，通过继承和虚函数来实现。</p></li>\r\n</ul>\r\n<p><strong>虚函数的实现机制是什么？</strong></p>\r\n<p>虚函数是通过虚函数表来实现的</p>\r\n<h3 id=\"父类子类指针\">父类子类指针</h3>\r\n<h4 id=\"static_cast\">static_cast</h4>\r\n<p>static_cast 可以将子类指针 向上 转换为 父类指针（安全<br />\r\n如果将父类向下转换成子类指针就不安全</p>\r\n<h4 id=\"父子函数\">父子函数</h4>\r\n<p>父类指针指向子类的话，调用函数，如果不是虚函数，会根据指针类型决定，<br />\r\n如果是虚函数，就会调用子类的函数。</p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>主要是 C++ 和 图形学吧</p>\r\n<h1 id=\"c\">C++</h1>\r\n<h2 id=\"多态和虚函数\">1.1 多态和虚函数</h2>\r\n<p>多态：</p>\r\n<ul>\r\n<li><p>编译时多态也称为为静态联编，通过重载和模板来实现</p></li>\r\n<li><p>运行时多态称为动态联编，通过继承和虚函数来实现。</p></li>\r\n</ul>\r\n<p><strong>虚函数的实现机制是什么？</strong></p>\r\n<p>虚函数是通过虚函数表来实现的</p>\r\n<h3 id=\"父类子类指针\">父类子类指针</h3>\r\n<h4 id=\"static_cast\">static_cast</h4>\r\n<p>static_cast 可以将子类指针 向上 转换为 父类指针（安全<br />\r\n如果将父类向下转换成子类指针就不安全</p>\r\n<h4 id=\"父子函数\">父子函数</h4>\r\n<p>父类指针指向子类的话，调用函数，如果不是虚函数，会根据指针类型决定，<br />\r\n如果是虚函数，就会调用子类的函数。</p>\r\n"},{"title":"Unity FFT 水面模拟","math":true,"index_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","banner_img":"/imgs/水面模拟/InterstellarSeaWave.png","date":"2024-04-30T16:00:00.000Z","typora-root-url":"../","_content":"\nUnity 水面模拟\n\n# 浪\n\n[海浪01](https://www.bilibili.com/video/BV18v4y1P7Ne)  \n[海浪02](https://www.bilibili.com/video/BV1u7411K7MR)\n[星际穿越实拍海浪](https://www.bilibili.com/video/BV1U54y1C7YG)  \n![InterstellarSeaWave](/imgs/水面模拟/InterstellarSeaWave.png)\n\n# GPU 精粹 波相关\n\n我说实话翻译版真的是太抽象了……\n\n## 1.2 正弦波\n\n首先对于波的模拟有两个部分，一个是网格的几何波动(顶点偏移)，另一个就是网格上法线的扰动。\n主要是用周期波叠加实现，先看简单的正弦函数。\n\n这里主要在数学定义上了解波的模拟\n\n### 1.2.1 波的选择\n\n 需要一个参数组来定义波，如下\n\n* 波长($L$) : 世界空间中波峰之间的距离。波长 $L$ 和 角频率 $\\omega$ 的关系为 $\\omega =2\\pi/L$\n  这里的角频率就是平时我们说的频率\n* 振幅($A$) : 水平面到波峰的距离，决定了波的高低。\n* 速度($S$) : 因为波是会动的，表示每秒钟波的移动距离。通常表示为常数项 $\\phi=S*2\\pi/L$\n* 方向($D$) : 垂直于波阵面的水平向量。\n  所谓波阵面是指波峰沿着它运动的面，比如 y=sin(x)，D=(1,0)。\n\n波的状态定义为水平位置 (x, y) 和 时间 (t) 的函数：\n$$\n\\begin{aligned}\n\tW_i(x,y,t)=A_i*\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)\n\\end{aligned}\n$$\n\n\n我们可以用多个波叠加模拟总表面\n$$\n\\begin{aligned}\n\tH(x,y,t)=\\sum(A_i*\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i))\n\\end{aligned}\n$$\n\n![waveparameters](/imgs/水面模拟/waveparameters.png)\n\n### 1.2.2 法线和切线\n\n因为我们上面用正弦函数表示波，所以是一个显式函数，也就是说能在任意给定点直接计算表面方向，不用使用差分算法计算。\n副法线 $B$ 和 切线 $T$ 向量分别为 $x$ 和 $y$ 方向的偏导数。对在 2D 水平面中的任何点 $(x, y)$​，其在表面的三维位置是( 3D 空间表示 )：\n$$\n\\begin{aligned}\n\tP(x,y,t)=(x,y,H(x,y,t))\n\\end{aligned}\n$$\n对于副法线 $x$ 的偏导是 : \n$$\n\\begin{aligned}\n\tB(x,y)=[\\frac{\\delta x}{\\delta x},\\frac{\\delta y}{\\delta x},\n\t\\frac{\\delta }{\\delta x}(H(x,y,t))]\\\\\n\tB(x,y)=(1,0,\\frac{\\delta }{\\delta x}(H(x,y,t)))\n\\end{aligned}\n$$\n同理切线为：\n$$\n\\begin{aligned}\n\tT(x,y)=[\\frac{\\delta x}{\\delta y},\\frac{\\delta y}{\\delta y},\n\t\\frac{\\delta }{\\delta y}(H(x,y,t))]\\\\\n\tT(x,y)=(0,1,\\frac{\\delta }{\\delta y}(H(x,y,t)))\n\\end{aligned}\n$$\n法线由 $B,T$ 叉乘得到：\n$$\n\\begin{aligned}\n\tN(x,y)=B(x,y)\\times T(x,y)\\\\\n\tN(x,y)=[-\\frac{\\delta}{\\delta x}(H(x,y,t)),-\\frac{\\delta}{\\delta y}(H(x,y,t)),1]\n\\end{aligned}\n$$\n计算偏导(以 对x求偏导为例)：\n$$\n\\begin{aligned}\n\t\\frac{\\delta}{\\delta x}(H(x,y,t))&=\\sum[\\frac{\\delta}{\\delta x}(W_i(x,y,t))]\\\\\n\t&=\\sum(\\omega_i*D_i.x*A_i*\\cos(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i))\n\\end{aligned}\n$$\n但是这样单纯叠加的波缺少真实感，真实的波波峰是尖的，而波谷会更宽。\n这里将正弦函数修改为非负状态，并赋予指数k。\n$$\n\\begin{aligned}\n\tW_i(x,y,t)=&2A_i*[\\frac{\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)+1}{2}]^k\\\\\n\t\\frac{\\delta}{\\delta x}(W_i(x,y,t))=&k*D_i.x*\\omega_i*A_i[\\frac{\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)+1}{2}]^{k-1}\\\\\n\t&*\\cos(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)\n\\end{aligned}\n$$\n![kWave](/imgs/水面模拟/kWave.png)\n\n### 1.2.3 几何波\n\n#### 方向波或圆形波\n\n对于方向波，每个 $D_i$ 都是波寿命常数，其实就是*常数*。  \n对于圆形波，方向必须在每个顶点计算，它是从波中心到顶点的规范化向量：\n$$\nD_i(x,y)=[\\frac{(x,y)-C_i}{|(x,y)-C_i|}]\n$$\n大水体一般用方向波比如海洋。  \n小水体一般用圆形波比如池塘。\n\n#### Gerstner 波\n\n正弦波还是太圆润，Gerstner 波能够模拟浪头更尖锐的波\n$$\n\\begin{aligned}\n\tP(x,y,t)=\n\t\\left\\{\\begin{array}{}\n\tx+\\sum(Q_iA_i*D_i.x*\\cos(\\omega_iD_i\\cdot(x,y)+\\phi_it))\\\\\n\ty+\\sum(Q_iA_i*D_i.y*\\cos(\\omega_iD_i\\cdot(x,y)+\\phi_it))\\\\\n\t\\sum(A_i\\sin(\\omega_iD_i\\cdot(x,y)+\\phi_it))\n\t\\end{array}\n\t\\right.\n\\end{aligned}\n$$\n$Q_i$ 是控制波陡度的参数，如果 $Q_i=0$ 就是正常的叠加正弦波，而 $Q_i=1$ 是尖峰的波形。  \n但是如果 $Q_i$​ 过大会导致波形成环，这点需要注意。\n\n法线切线也有变化：\n$$\n\\begin{aligned}\n\t&WA=\\omega_i*A_i\\\\\n\t&S()=\\sin(\\omega_i*D_i\\cdot P+\\phi_it)\\\\\n\t&C()=cos(\\omega_i*D_i\\cdot P+\\phi_it)\\\\\n\t&B=\\left\\{\n\t\t\\begin{array}{}\n\t\t1-\\sum(Q_i*D_i.x^2*WA*S())\\\\\n\t\t-\\sum(Q_i*D_i.x*D_i.y*WA*S())\\\\\n\t\t\\sum(D_i.y*WA*C())\n\t\t\\end{array}\n\t\\right.\\\\\n\t&T=\n\t\\left\\{\n\t\t\\begin{array}{}\n\t\t\t-\\sum(Q_i*D_i.x*D_i.y*WA*S())\\\\\n\t\t\t1-\\sum(Q_i*D_i.y^2*WA*S())\\\\\n\t\t\t\\sum(D_i.y*WA*C())\n\t\t\\end{array}\n\t\\right.\n\\end{aligned}\n$$\n\n# FFT 海洋\n\n这部分内容都是抄的：[【学习笔记】Unity 基于GPU FFT海洋的实现-理论篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/95482541)\n\n>离散傅里叶变换(Discrete Fourier Transform, DFT)  \n>逆离散傅里叶变换(Inverse Discrete Fourier Transform, IDFT)\n\nDFT 的公式，如果$f(x)$ 为一个长度为 $N$ 的数字序列，则其 DFT $f(\\mu)$ 为\n$$\n\\begin{aligned}\n\t\\textstyle F(\\mu)=\\sum^{N-1}_{x=0}f(x)e^{-i\\frac{2\\pi\\mu x}{N}}\n\\end{aligned}\n$$\n\n* $F(\\mu)$ 为转换后的**频域函数**。  \n* $\\mu$​ 是频率。\n  DFT 做的就是把时域函数中一个复杂的波形展开为多个正弦波。\n* $f(x)$​ 是时域函数\n* $e^{-i\\frac{2\\pi\\mu x}{N}}$​ 是一个复数\n  利用欧拉公式：$e^{ix}=\\cos(x)+i\\sin(x)$\n\n$$\n\\begin{aligned}\n\tF(\\mu)=\\textstyle \\sum^{N-1}_{x=0}f(x)\\cos(\\frac{2\\pi\\mu x}{N})-i\\sum^{N-1}_{x=0}f(x)\\sin(\\frac{2\\pi\\mu x}{N})\n\\end{aligned}\n$$\n\n逆傅里叶变换 IDFT\n$$\n\\begin{aligned}\n\tf(x)=\\frac{1}{N}\\textstyle\\sum^{N-1}_{\\mu=0}F(\\mu)e^{i\\frac{2\\pi\\mu x}{N}}\n\\end{aligned}\n$$\n\n## FFT 海洋公式\n\n如果我们需要一个复杂的海面，可以生产一个频谱( 也就是在频域 pick 多个函数 )，然后通过 IDFT 就能够得到 由多个不同频率、振幅的波 叠加的复杂海面。  \n这样频谱决定了海面形状。\n\n### Simulating Ocean Water-Jerry Tessendorf\n\n这里还需要再研究一下这个paper……\n\nSimulating Ocean Water-Jerry Tessendorf 的海洋公式：\n$$\n\\begin{aligned}\n\th(\\vec{x},t)=\\textstyle\\sum_k\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\n\\end{aligned}\n$$\n这个其实就是逆离散傅里叶变换变换的形式。\n\n其中参数 $\\vec{x}=(x,z)$ 是水平方向的坐标，$t$ 是时间，函数 $h$ 可以返回在时间 $t$ , $\\vec{x}$ 处的海面高度。   \n$\\vec{k}$ 为波矢量，$\\vec{k}=(k_x,k_z)=(\\frac{2\\pi n}{L_x},\\frac{2\\pi m}{L_z})$\n$$\n\\begin{aligned}\n\t-\\frac{N}{2}\\le n < \\frac{N}{2}\\\\\n\t-\\frac{M}{2}\\le m < \\frac{M}{2}\n\\end{aligned}\n$$\n$\\vec{k}$ 为波矢量，$L_x$ 和 $L_y$ 是海平面的大小，$N$ 和 $M$ 是采样离散点的数量。  \n如果 $N$ 和 $M$ 越大波就越精细，叠加的波就更多，但是计算时间也会增加。\n\n所以现在需要计算出频谱，然后按照 $h(\\vec{x},t)$ 函数就可以得到海面的高度，  \n现在观察 频谱函数 $\\tilde{h}(\\vec{k},t)$  \n$\\tilde{h}(\\vec{k},t)=\\tilde{h_0}(\\vec{k})e^{i\\omega(k)t}+\\tilde{h_0^*}(-\\vec{k})e^{-i\\omega(k)t}$  \n$\\tilde{h^*_0}$ 是 $\\tilde{h_0}$ 的共轭复数，$k$ 是 $\\vec{k}$​ 的模。\n\n#### From Simulating Ocean Water : 4.2  AnimatingWaves:TheDispersionRelation\n\n$\\omega(k)$ 是 角频率 $\\omega$ 和 波长 $k$ 的 弥散函数。\n\n* 在深水区，关系为 $\\omega^2(k)=gk$  \n  $g=9.8m/{sec}^2$ 是重力参数\n* 当水较浅的时候，底部对波浪有延缓作用，对于在平均水位以下深度为 $D$ 处的底部，弥散关系为：  \n  $\\omega^2(k)=gk\\tanh(kD)$​  \n  [双曲正切函数（Tanh函数） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/520861532)\n* 除了水的深度外，表面张力也有影响，波长为 1cm 或者 更短的非常小的波 有附加项：  \n  $\\omega^2(k)=gk(1+k^2L^2)$  \n  参数 $L$ 是标准长度，其大小是对表面张力有影响的尺度。\n\n#### From Simulating Ocean Water : 4.4  BuildingaRandomOceanWaveHeightField\n\n> 水波高度是由目前所述的原理模拟的：具有规定形式的空间谱的高斯随机数。  \n> 对于傅里叶域这是非常有效的。波高场的傅里叶振幅可以被表示为：\n\n$\\tilde{h}_0(\\vec{k})=\\frac{1}{\\sqrt{2}}(\\xi_r+i\\xi_i)\\sqrt{P_h(\\vec{k})}$\n\n$\\xi_r$ 和 $\\xi_i$ 为来自 *高斯随机数生成器*的普通独立随机数，均值为 0，标准差为 1.\n\n$P_h(\\vec{k})$ 是我们的方向波谱，方向波谱一般描述为 $S(\\omega,\\theta)$ ,这和我们前面的参数不太一样，其实他们之间可以相互转换，有兴趣可以看**Empirical Directional Wave Spectra for Computer Graphics**这篇论文。(暂时没找到这篇paper的资源，就没看)  \n方向波谱  $S(\\omega,\\theta)$ 是非定向波谱 $S(\\omega)$ 和方向拓展函数 $D(\\omega,\\theta)$ 的乘积.   \n$S(\\omega,\\theta)=S(\\omega)D(\\omega,\\theta)$  \n$\\omega$ 是我们提到的角频率，$\\theta$ 是波矢量相对于风向的角度。\n\n#### From Simulating Ocean Water : 4.3 Statistical Wave Models and the Fourier Transform\n\n波浪谱有几种解析的经验模型，其中有一个风驱动模型，Phillips spectrum：  \n$P_h(\\vec{k})=A\\frac{\\exp(-1/(kL)^2)}{k^4}|\\hat{\\vec{k}}\\cdot\\hat{\\vec{\\omega}}|$  \n其中 $L=V^2/g$ 为 <u>速度是 $V$ 的风可能产生的最大波</u>，$g$ 为重力常数，$\\omega$ 为风的方向，$A$ 是一个数值常数。  \nPhillips 的余弦系数 $|\\hat{k}\\cdot\\hat{\\omega}|$ 消除了垂直风向移动的波，模型简单，但是在波数 $|k|$ 较高时收敛性差，一种修复方式是抑制 长度$\\mathscr{l}$( $\\mathscr{l}\\ll L$ ) 小的波，并通过乘因子 $\\exp(-k^2\\mathscr{l}^2)$ 修改 Phillips \n\n前面都是海洋高度公式，额，看不太明白……\n\n还有水平偏移公式：  \n$\\vec{D}(\\vec{x},t)=\\sum_k-i\\frac{\\vec{k}}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}$  \n\n和高度函数有些类似，把频谱改变一下，这个是的 $x$ 和 $z$ 总体描述，拆开得到 $x$ 和 $z$ 的单独描述\n$$\n\\begin{aligned}\n\tD_x(\\vec{x},t)=\\textstyle\\sum_k-i\\frac{k_x}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\\\\\n\tD_z(\\vec{x},t)=\\textstyle\\sum_k-i\\frac{k_z}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\\\\\n\\end{aligned}\n$$\n\n## 公式的计算流程\n\n![waveNV1](/imgs/水面模拟/waveNV1.png)\n\n* 首先，根据公式生成 Phillips 频谱(↖)；\n* 然后再计算两个相互独立服从均值为 0，标准差为 1的高斯函数。(↙)\n* 之后根据公式结合完成了第一步，得到了一个初始的频谱  \n  这里频谱计算一次即可，除非风 $L=V^2/g$​  会每帧变化，其他的随机数计算一次即可。\n\n![waveNV2](/imgs/水面模拟/waveNV2.png)\n\n* 得到初始频谱后，使用其计算 高度频谱 $\\tilde{h}(\\vec{k},t)$，$\\tilde{H}(\\vec{k})\\rightarrow \\tilde{H}(\\vec{k},t)$\n* 再使用高度函数就能得到 两个偏移频谱 $D_x(\\vec{x},t)$ 和 $D_z(\\vec{x},t)$，$\\tilde{H}(\\vec{k},t) \\rightarrow D_x(\\vec{x},t),D_z(\\vec{x},t)$​\n\n拿到频谱后，分别进行 IDFT， 就会得到水平 $x$、$z$ 以及高度 $y$ 的偏移图( $z$​ 为高度)。\n\n将计算得到的图放在一起就能得到偏移纹理( Displacement )，再通过偏移纹理( Displacement ) 可以计算 法线 和 泡沫 贴图，这样我们所有的纹理就能够拿到了，然后进行渲染。\n\n如果直接进行 IDFT 效率太低，\n\n## FFT 推导\n\n计算效率低的问题在哪？\n\n先看一下海洋的公式\n$$\n\\begin{aligned}\n\th(\\vec{x},t)=\\textstyle\\sum_k\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\n\\end{aligned}\n$$\n\n这个是二维 IDFT，将 $h(\\vec{x},t)$ 展开后得到\n$$\n\\begin{aligned}\n\t&\\vec{k}=(k_x,k_z)=(\\frac{2\\pi n}{L_x},\\frac{2\\pi m}{L_z})\\\\\n\t&\\vec{x}=(x,z)\\\\\n\t&h(x,z,t)=\\textstyle\\sum^{\\frac{M}{2}-1}_{m=-\\frac{M}{2}}\\sum^{\\frac{N}{2}-1}_{m=-\\frac{N}{2}}\\tilde h(\\frac{2\\pi n}{L_x},\\frac{2\\pi m}{L_z},t)e^{i(\\frac{2\\pi n}{L_x}+\\frac{2\\pi m}{L_z})}\n\\end{aligned}\n$$\n这样的复杂度就是 一个位置的海面是 $O(NM)$，如果是所有位置大概就是 $O(N^2M^2)$\n\n所以可以用 FFT 快速傅里叶变换的思想，进行快速傅里叶逆变换(IFFT)\n\n为了推导先设(其实是为了把求和号归零吧)\n$$\n\\begin{aligned}\n&0\\le n'\\le N,n'\\in(0,1,...,N-1)\\\\\n&0\\le m'\\le M,m'\\in(0,1,...,M-1)\\\\\n&n=n'-\\frac{N}{2}\\\\\n&m=m'-\\frac{M}{2}\\\\\n&k_x=\\frac{2\\pi(n'-\\frac{N}{2})}{L_x}=\\frac{2\\pi n'-\\pi N}{L_x}\\\\\n&k_z=\\frac{2\\pi(n'-\\frac{M}{2})}{L_z}=\\frac{2\\pi m'-\\pi M}{L_z}\\\\\n\\end{aligned}\n$$\n则，有\n$$\n\\begin{aligned}\nh'(x,z,t)=\\textstyle\\sum^{M-1}_{m'=0}\\sum^{N-1}_{n'=0}\\tilde{h}(n',m',t)\n\\end{aligned}\n$$\n\n\n# Unity 水面模拟\n\n## 参考\n\n[【学习笔记】Unity 基于GPU FFT海洋的实现-理论篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/95482541)  \n[FFT海洋学习笔记（一） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/335045713)  \n[FFT海洋水体渲染学习笔记（二） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/335946333)  \n[傅里叶分析之掐死教程（完整版）更新于2014.06.06 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/19763358)  \n[真实感水体渲染技术总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/95917609)  \n[扩散（diffusion）和弥散（dispersion）有什么区别？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/23914350)  \n[Simulating Ocean Water-Jerry Tessendorf Paper - ResearchGate](https://www.researchgate.net/publication/264839743_Simulating_Ocean_Water/link/5ba8ecb0a6fdccd3cb6f6ffd/download?_tp=eyJjb250ZXh0Ijp7ImZpcnN0UGFnZSI6InB1YmxpY2F0aW9uIiwicGFnZSI6InB1YmxpY2F0aW9uIn19)  \n[$\\tanh$双曲正切函数（Tanh函数） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/520861532)  \n[OceanCS_Slides.pdf (nvidia.cn)](https://developer.download.nvidia.cn/assets/gamedev/files/sdk/11/OceanCS_Slides.pdf)\n\n","source":"_drafts/水面模拟.md","raw":"---\ntitle: Unity FFT 水面模拟\nmath: true\ntags: 图形学, unity\nindex_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\nbanner_img: /imgs/水面模拟/InterstellarSeaWave.png\ndate: 2024-05-01\ntypora-root-url: ../\n---\n\nUnity 水面模拟\n\n# 浪\n\n[海浪01](https://www.bilibili.com/video/BV18v4y1P7Ne)  \n[海浪02](https://www.bilibili.com/video/BV1u7411K7MR)\n[星际穿越实拍海浪](https://www.bilibili.com/video/BV1U54y1C7YG)  \n![InterstellarSeaWave](/imgs/水面模拟/InterstellarSeaWave.png)\n\n# GPU 精粹 波相关\n\n我说实话翻译版真的是太抽象了……\n\n## 1.2 正弦波\n\n首先对于波的模拟有两个部分，一个是网格的几何波动(顶点偏移)，另一个就是网格上法线的扰动。\n主要是用周期波叠加实现，先看简单的正弦函数。\n\n这里主要在数学定义上了解波的模拟\n\n### 1.2.1 波的选择\n\n 需要一个参数组来定义波，如下\n\n* 波长($L$) : 世界空间中波峰之间的距离。波长 $L$ 和 角频率 $\\omega$ 的关系为 $\\omega =2\\pi/L$\n  这里的角频率就是平时我们说的频率\n* 振幅($A$) : 水平面到波峰的距离，决定了波的高低。\n* 速度($S$) : 因为波是会动的，表示每秒钟波的移动距离。通常表示为常数项 $\\phi=S*2\\pi/L$\n* 方向($D$) : 垂直于波阵面的水平向量。\n  所谓波阵面是指波峰沿着它运动的面，比如 y=sin(x)，D=(1,0)。\n\n波的状态定义为水平位置 (x, y) 和 时间 (t) 的函数：\n$$\n\\begin{aligned}\n\tW_i(x,y,t)=A_i*\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)\n\\end{aligned}\n$$\n\n\n我们可以用多个波叠加模拟总表面\n$$\n\\begin{aligned}\n\tH(x,y,t)=\\sum(A_i*\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i))\n\\end{aligned}\n$$\n\n![waveparameters](/imgs/水面模拟/waveparameters.png)\n\n### 1.2.2 法线和切线\n\n因为我们上面用正弦函数表示波，所以是一个显式函数，也就是说能在任意给定点直接计算表面方向，不用使用差分算法计算。\n副法线 $B$ 和 切线 $T$ 向量分别为 $x$ 和 $y$ 方向的偏导数。对在 2D 水平面中的任何点 $(x, y)$​，其在表面的三维位置是( 3D 空间表示 )：\n$$\n\\begin{aligned}\n\tP(x,y,t)=(x,y,H(x,y,t))\n\\end{aligned}\n$$\n对于副法线 $x$ 的偏导是 : \n$$\n\\begin{aligned}\n\tB(x,y)=[\\frac{\\delta x}{\\delta x},\\frac{\\delta y}{\\delta x},\n\t\\frac{\\delta }{\\delta x}(H(x,y,t))]\\\\\n\tB(x,y)=(1,0,\\frac{\\delta }{\\delta x}(H(x,y,t)))\n\\end{aligned}\n$$\n同理切线为：\n$$\n\\begin{aligned}\n\tT(x,y)=[\\frac{\\delta x}{\\delta y},\\frac{\\delta y}{\\delta y},\n\t\\frac{\\delta }{\\delta y}(H(x,y,t))]\\\\\n\tT(x,y)=(0,1,\\frac{\\delta }{\\delta y}(H(x,y,t)))\n\\end{aligned}\n$$\n法线由 $B,T$ 叉乘得到：\n$$\n\\begin{aligned}\n\tN(x,y)=B(x,y)\\times T(x,y)\\\\\n\tN(x,y)=[-\\frac{\\delta}{\\delta x}(H(x,y,t)),-\\frac{\\delta}{\\delta y}(H(x,y,t)),1]\n\\end{aligned}\n$$\n计算偏导(以 对x求偏导为例)：\n$$\n\\begin{aligned}\n\t\\frac{\\delta}{\\delta x}(H(x,y,t))&=\\sum[\\frac{\\delta}{\\delta x}(W_i(x,y,t))]\\\\\n\t&=\\sum(\\omega_i*D_i.x*A_i*\\cos(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i))\n\\end{aligned}\n$$\n但是这样单纯叠加的波缺少真实感，真实的波波峰是尖的，而波谷会更宽。\n这里将正弦函数修改为非负状态，并赋予指数k。\n$$\n\\begin{aligned}\n\tW_i(x,y,t)=&2A_i*[\\frac{\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)+1}{2}]^k\\\\\n\t\\frac{\\delta}{\\delta x}(W_i(x,y,t))=&k*D_i.x*\\omega_i*A_i[\\frac{\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)+1}{2}]^{k-1}\\\\\n\t&*\\cos(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)\n\\end{aligned}\n$$\n![kWave](/imgs/水面模拟/kWave.png)\n\n### 1.2.3 几何波\n\n#### 方向波或圆形波\n\n对于方向波，每个 $D_i$ 都是波寿命常数，其实就是*常数*。  \n对于圆形波，方向必须在每个顶点计算，它是从波中心到顶点的规范化向量：\n$$\nD_i(x,y)=[\\frac{(x,y)-C_i}{|(x,y)-C_i|}]\n$$\n大水体一般用方向波比如海洋。  \n小水体一般用圆形波比如池塘。\n\n#### Gerstner 波\n\n正弦波还是太圆润，Gerstner 波能够模拟浪头更尖锐的波\n$$\n\\begin{aligned}\n\tP(x,y,t)=\n\t\\left\\{\\begin{array}{}\n\tx+\\sum(Q_iA_i*D_i.x*\\cos(\\omega_iD_i\\cdot(x,y)+\\phi_it))\\\\\n\ty+\\sum(Q_iA_i*D_i.y*\\cos(\\omega_iD_i\\cdot(x,y)+\\phi_it))\\\\\n\t\\sum(A_i\\sin(\\omega_iD_i\\cdot(x,y)+\\phi_it))\n\t\\end{array}\n\t\\right.\n\\end{aligned}\n$$\n$Q_i$ 是控制波陡度的参数，如果 $Q_i=0$ 就是正常的叠加正弦波，而 $Q_i=1$ 是尖峰的波形。  \n但是如果 $Q_i$​ 过大会导致波形成环，这点需要注意。\n\n法线切线也有变化：\n$$\n\\begin{aligned}\n\t&WA=\\omega_i*A_i\\\\\n\t&S()=\\sin(\\omega_i*D_i\\cdot P+\\phi_it)\\\\\n\t&C()=cos(\\omega_i*D_i\\cdot P+\\phi_it)\\\\\n\t&B=\\left\\{\n\t\t\\begin{array}{}\n\t\t1-\\sum(Q_i*D_i.x^2*WA*S())\\\\\n\t\t-\\sum(Q_i*D_i.x*D_i.y*WA*S())\\\\\n\t\t\\sum(D_i.y*WA*C())\n\t\t\\end{array}\n\t\\right.\\\\\n\t&T=\n\t\\left\\{\n\t\t\\begin{array}{}\n\t\t\t-\\sum(Q_i*D_i.x*D_i.y*WA*S())\\\\\n\t\t\t1-\\sum(Q_i*D_i.y^2*WA*S())\\\\\n\t\t\t\\sum(D_i.y*WA*C())\n\t\t\\end{array}\n\t\\right.\n\\end{aligned}\n$$\n\n# FFT 海洋\n\n这部分内容都是抄的：[【学习笔记】Unity 基于GPU FFT海洋的实现-理论篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/95482541)\n\n>离散傅里叶变换(Discrete Fourier Transform, DFT)  \n>逆离散傅里叶变换(Inverse Discrete Fourier Transform, IDFT)\n\nDFT 的公式，如果$f(x)$ 为一个长度为 $N$ 的数字序列，则其 DFT $f(\\mu)$ 为\n$$\n\\begin{aligned}\n\t\\textstyle F(\\mu)=\\sum^{N-1}_{x=0}f(x)e^{-i\\frac{2\\pi\\mu x}{N}}\n\\end{aligned}\n$$\n\n* $F(\\mu)$ 为转换后的**频域函数**。  \n* $\\mu$​ 是频率。\n  DFT 做的就是把时域函数中一个复杂的波形展开为多个正弦波。\n* $f(x)$​ 是时域函数\n* $e^{-i\\frac{2\\pi\\mu x}{N}}$​ 是一个复数\n  利用欧拉公式：$e^{ix}=\\cos(x)+i\\sin(x)$\n\n$$\n\\begin{aligned}\n\tF(\\mu)=\\textstyle \\sum^{N-1}_{x=0}f(x)\\cos(\\frac{2\\pi\\mu x}{N})-i\\sum^{N-1}_{x=0}f(x)\\sin(\\frac{2\\pi\\mu x}{N})\n\\end{aligned}\n$$\n\n逆傅里叶变换 IDFT\n$$\n\\begin{aligned}\n\tf(x)=\\frac{1}{N}\\textstyle\\sum^{N-1}_{\\mu=0}F(\\mu)e^{i\\frac{2\\pi\\mu x}{N}}\n\\end{aligned}\n$$\n\n## FFT 海洋公式\n\n如果我们需要一个复杂的海面，可以生产一个频谱( 也就是在频域 pick 多个函数 )，然后通过 IDFT 就能够得到 由多个不同频率、振幅的波 叠加的复杂海面。  \n这样频谱决定了海面形状。\n\n### Simulating Ocean Water-Jerry Tessendorf\n\n这里还需要再研究一下这个paper……\n\nSimulating Ocean Water-Jerry Tessendorf 的海洋公式：\n$$\n\\begin{aligned}\n\th(\\vec{x},t)=\\textstyle\\sum_k\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\n\\end{aligned}\n$$\n这个其实就是逆离散傅里叶变换变换的形式。\n\n其中参数 $\\vec{x}=(x,z)$ 是水平方向的坐标，$t$ 是时间，函数 $h$ 可以返回在时间 $t$ , $\\vec{x}$ 处的海面高度。   \n$\\vec{k}$ 为波矢量，$\\vec{k}=(k_x,k_z)=(\\frac{2\\pi n}{L_x},\\frac{2\\pi m}{L_z})$\n$$\n\\begin{aligned}\n\t-\\frac{N}{2}\\le n < \\frac{N}{2}\\\\\n\t-\\frac{M}{2}\\le m < \\frac{M}{2}\n\\end{aligned}\n$$\n$\\vec{k}$ 为波矢量，$L_x$ 和 $L_y$ 是海平面的大小，$N$ 和 $M$ 是采样离散点的数量。  \n如果 $N$ 和 $M$ 越大波就越精细，叠加的波就更多，但是计算时间也会增加。\n\n所以现在需要计算出频谱，然后按照 $h(\\vec{x},t)$ 函数就可以得到海面的高度，  \n现在观察 频谱函数 $\\tilde{h}(\\vec{k},t)$  \n$\\tilde{h}(\\vec{k},t)=\\tilde{h_0}(\\vec{k})e^{i\\omega(k)t}+\\tilde{h_0^*}(-\\vec{k})e^{-i\\omega(k)t}$  \n$\\tilde{h^*_0}$ 是 $\\tilde{h_0}$ 的共轭复数，$k$ 是 $\\vec{k}$​ 的模。\n\n#### From Simulating Ocean Water : 4.2  AnimatingWaves:TheDispersionRelation\n\n$\\omega(k)$ 是 角频率 $\\omega$ 和 波长 $k$ 的 弥散函数。\n\n* 在深水区，关系为 $\\omega^2(k)=gk$  \n  $g=9.8m/{sec}^2$ 是重力参数\n* 当水较浅的时候，底部对波浪有延缓作用，对于在平均水位以下深度为 $D$ 处的底部，弥散关系为：  \n  $\\omega^2(k)=gk\\tanh(kD)$​  \n  [双曲正切函数（Tanh函数） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/520861532)\n* 除了水的深度外，表面张力也有影响，波长为 1cm 或者 更短的非常小的波 有附加项：  \n  $\\omega^2(k)=gk(1+k^2L^2)$  \n  参数 $L$ 是标准长度，其大小是对表面张力有影响的尺度。\n\n#### From Simulating Ocean Water : 4.4  BuildingaRandomOceanWaveHeightField\n\n> 水波高度是由目前所述的原理模拟的：具有规定形式的空间谱的高斯随机数。  \n> 对于傅里叶域这是非常有效的。波高场的傅里叶振幅可以被表示为：\n\n$\\tilde{h}_0(\\vec{k})=\\frac{1}{\\sqrt{2}}(\\xi_r+i\\xi_i)\\sqrt{P_h(\\vec{k})}$\n\n$\\xi_r$ 和 $\\xi_i$ 为来自 *高斯随机数生成器*的普通独立随机数，均值为 0，标准差为 1.\n\n$P_h(\\vec{k})$ 是我们的方向波谱，方向波谱一般描述为 $S(\\omega,\\theta)$ ,这和我们前面的参数不太一样，其实他们之间可以相互转换，有兴趣可以看**Empirical Directional Wave Spectra for Computer Graphics**这篇论文。(暂时没找到这篇paper的资源，就没看)  \n方向波谱  $S(\\omega,\\theta)$ 是非定向波谱 $S(\\omega)$ 和方向拓展函数 $D(\\omega,\\theta)$ 的乘积.   \n$S(\\omega,\\theta)=S(\\omega)D(\\omega,\\theta)$  \n$\\omega$ 是我们提到的角频率，$\\theta$ 是波矢量相对于风向的角度。\n\n#### From Simulating Ocean Water : 4.3 Statistical Wave Models and the Fourier Transform\n\n波浪谱有几种解析的经验模型，其中有一个风驱动模型，Phillips spectrum：  \n$P_h(\\vec{k})=A\\frac{\\exp(-1/(kL)^2)}{k^4}|\\hat{\\vec{k}}\\cdot\\hat{\\vec{\\omega}}|$  \n其中 $L=V^2/g$ 为 <u>速度是 $V$ 的风可能产生的最大波</u>，$g$ 为重力常数，$\\omega$ 为风的方向，$A$ 是一个数值常数。  \nPhillips 的余弦系数 $|\\hat{k}\\cdot\\hat{\\omega}|$ 消除了垂直风向移动的波，模型简单，但是在波数 $|k|$ 较高时收敛性差，一种修复方式是抑制 长度$\\mathscr{l}$( $\\mathscr{l}\\ll L$ ) 小的波，并通过乘因子 $\\exp(-k^2\\mathscr{l}^2)$ 修改 Phillips \n\n前面都是海洋高度公式，额，看不太明白……\n\n还有水平偏移公式：  \n$\\vec{D}(\\vec{x},t)=\\sum_k-i\\frac{\\vec{k}}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}$  \n\n和高度函数有些类似，把频谱改变一下，这个是的 $x$ 和 $z$ 总体描述，拆开得到 $x$ 和 $z$ 的单独描述\n$$\n\\begin{aligned}\n\tD_x(\\vec{x},t)=\\textstyle\\sum_k-i\\frac{k_x}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\\\\\n\tD_z(\\vec{x},t)=\\textstyle\\sum_k-i\\frac{k_z}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\\\\\n\\end{aligned}\n$$\n\n## 公式的计算流程\n\n![waveNV1](/imgs/水面模拟/waveNV1.png)\n\n* 首先，根据公式生成 Phillips 频谱(↖)；\n* 然后再计算两个相互独立服从均值为 0，标准差为 1的高斯函数。(↙)\n* 之后根据公式结合完成了第一步，得到了一个初始的频谱  \n  这里频谱计算一次即可，除非风 $L=V^2/g$​  会每帧变化，其他的随机数计算一次即可。\n\n![waveNV2](/imgs/水面模拟/waveNV2.png)\n\n* 得到初始频谱后，使用其计算 高度频谱 $\\tilde{h}(\\vec{k},t)$，$\\tilde{H}(\\vec{k})\\rightarrow \\tilde{H}(\\vec{k},t)$\n* 再使用高度函数就能得到 两个偏移频谱 $D_x(\\vec{x},t)$ 和 $D_z(\\vec{x},t)$，$\\tilde{H}(\\vec{k},t) \\rightarrow D_x(\\vec{x},t),D_z(\\vec{x},t)$​\n\n拿到频谱后，分别进行 IDFT， 就会得到水平 $x$、$z$ 以及高度 $y$ 的偏移图( $z$​ 为高度)。\n\n将计算得到的图放在一起就能得到偏移纹理( Displacement )，再通过偏移纹理( Displacement ) 可以计算 法线 和 泡沫 贴图，这样我们所有的纹理就能够拿到了，然后进行渲染。\n\n如果直接进行 IDFT 效率太低，\n\n## FFT 推导\n\n计算效率低的问题在哪？\n\n先看一下海洋的公式\n$$\n\\begin{aligned}\n\th(\\vec{x},t)=\\textstyle\\sum_k\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\n\\end{aligned}\n$$\n\n这个是二维 IDFT，将 $h(\\vec{x},t)$ 展开后得到\n$$\n\\begin{aligned}\n\t&\\vec{k}=(k_x,k_z)=(\\frac{2\\pi n}{L_x},\\frac{2\\pi m}{L_z})\\\\\n\t&\\vec{x}=(x,z)\\\\\n\t&h(x,z,t)=\\textstyle\\sum^{\\frac{M}{2}-1}_{m=-\\frac{M}{2}}\\sum^{\\frac{N}{2}-1}_{m=-\\frac{N}{2}}\\tilde h(\\frac{2\\pi n}{L_x},\\frac{2\\pi m}{L_z},t)e^{i(\\frac{2\\pi n}{L_x}+\\frac{2\\pi m}{L_z})}\n\\end{aligned}\n$$\n这样的复杂度就是 一个位置的海面是 $O(NM)$，如果是所有位置大概就是 $O(N^2M^2)$\n\n所以可以用 FFT 快速傅里叶变换的思想，进行快速傅里叶逆变换(IFFT)\n\n为了推导先设(其实是为了把求和号归零吧)\n$$\n\\begin{aligned}\n&0\\le n'\\le N,n'\\in(0,1,...,N-1)\\\\\n&0\\le m'\\le M,m'\\in(0,1,...,M-1)\\\\\n&n=n'-\\frac{N}{2}\\\\\n&m=m'-\\frac{M}{2}\\\\\n&k_x=\\frac{2\\pi(n'-\\frac{N}{2})}{L_x}=\\frac{2\\pi n'-\\pi N}{L_x}\\\\\n&k_z=\\frac{2\\pi(n'-\\frac{M}{2})}{L_z}=\\frac{2\\pi m'-\\pi M}{L_z}\\\\\n\\end{aligned}\n$$\n则，有\n$$\n\\begin{aligned}\nh'(x,z,t)=\\textstyle\\sum^{M-1}_{m'=0}\\sum^{N-1}_{n'=0}\\tilde{h}(n',m',t)\n\\end{aligned}\n$$\n\n\n# Unity 水面模拟\n\n## 参考\n\n[【学习笔记】Unity 基于GPU FFT海洋的实现-理论篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/95482541)  \n[FFT海洋学习笔记（一） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/335045713)  \n[FFT海洋水体渲染学习笔记（二） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/335946333)  \n[傅里叶分析之掐死教程（完整版）更新于2014.06.06 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/19763358)  \n[真实感水体渲染技术总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/95917609)  \n[扩散（diffusion）和弥散（dispersion）有什么区别？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/23914350)  \n[Simulating Ocean Water-Jerry Tessendorf Paper - ResearchGate](https://www.researchgate.net/publication/264839743_Simulating_Ocean_Water/link/5ba8ecb0a6fdccd3cb6f6ffd/download?_tp=eyJjb250ZXh0Ijp7ImZpcnN0UGFnZSI6InB1YmxpY2F0aW9uIiwicGFnZSI6InB1YmxpY2F0aW9uIn19)  \n[$\\tanh$双曲正切函数（Tanh函数） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/520861532)  \n[OceanCS_Slides.pdf (nvidia.cn)](https://developer.download.nvidia.cn/assets/gamedev/files/sdk/11/OceanCS_Slides.pdf)\n\n","slug":"水面模拟","published":0,"updated":"2024-05-21T18:54:17.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti8001obkbw735wb1ue","content":"<p>Unity 水面模拟</p>\r\n<h1 id=\"浪\">浪</h1>\r\n<p><a\r\nhref=\"https://www.bilibili.com/video/BV18v4y1P7Ne\">海浪01</a><br />\r\n<a href=\"https://www.bilibili.com/video/BV1u7411K7MR\">海浪02</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1U54y1C7YG\">星际穿越实拍海浪</a><br />\r\n<img src=\"/imgs/水面模拟/InterstellarSeaWave.png\"\r\nalt=\"InterstellarSeaWave\" /></p>\r\n<h1 id=\"gpu-精粹-波相关\">GPU 精粹 波相关</h1>\r\n<p>我说实话翻译版真的是太抽象了……</p>\r\n<h2 id=\"正弦波\">1.2 正弦波</h2>\r\n<p>首先对于波的模拟有两个部分，一个是网格的几何波动(顶点偏移)，另一个就是网格上法线的扰动。\r\n主要是用周期波叠加实现，先看简单的正弦函数。</p>\r\n<p>这里主要在数学定义上了解波的模拟</p>\r\n<h3 id=\"波的选择\">1.2.1 波的选择</h3>\r\n<p>需要一个参数组来定义波，如下</p>\r\n<ul>\r\n<li>波长(<span class=\"math inline\">\\(L\\)</span>) :\r\n世界空间中波峰之间的距离。波长 <span class=\"math inline\">\\(L\\)</span> 和\r\n角频率 <span class=\"math inline\">\\(\\omega\\)</span> 的关系为 <span\r\nclass=\"math inline\">\\(\\omega =2\\pi/L\\)</span>\r\n这里的角频率就是平时我们说的频率</li>\r\n<li>振幅(<span class=\"math inline\">\\(A\\)</span>) :\r\n水平面到波峰的距离，决定了波的高低。</li>\r\n<li>速度(<span class=\"math inline\">\\(S\\)</span>) :\r\n因为波是会动的，表示每秒钟波的移动距离。通常表示为常数项 <span\r\nclass=\"math inline\">\\(\\phi=S*2\\pi/L\\)</span></li>\r\n<li>方向(<span class=\"math inline\">\\(D\\)</span>) :\r\n垂直于波阵面的水平向量。 所谓波阵面是指波峰沿着它运动的面，比如\r\ny=sin(x)，D=(1,0)。</li>\r\n</ul>\r\n<p>波的状态定义为水平位置 (x, y) 和 时间 (t) 的函数： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    W_i(x,y,t)=A_i*\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>我们可以用多个波叠加模拟总表面 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    H(x,y,t)=\\sum(A_i*\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i))\r\n\\end{aligned}\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/水面模拟/waveparameters.png\" alt=\"waveparameters\" />\r\n<figcaption aria-hidden=\"true\">waveparameters</figcaption>\r\n</figure>\r\n<h3 id=\"法线和切线\">1.2.2 法线和切线</h3>\r\n<p>因为我们上面用正弦函数表示波，所以是一个显式函数，也就是说能在任意给定点直接计算表面方向，不用使用差分算法计算。\r\n副法线 <span class=\"math inline\">\\(B\\)</span> 和 切线 <span\r\nclass=\"math inline\">\\(T\\)</span> 向量分别为 <span\r\nclass=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(y\\)</span> 方向的偏导数。对在 2D 水平面中的任何点\r\n<span class=\"math inline\">\\((x, y)\\)</span>​，其在表面的三维位置是( 3D\r\n空间表示 )： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    P(x,y,t)=(x,y,H(x,y,t))\r\n\\end{aligned}\r\n\\]</span> 对于副法线 <span class=\"math inline\">\\(x\\)</span> 的偏导是 :\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    B(x,y)=[\\frac{\\delta x}{\\delta x},\\frac{\\delta y}{\\delta x},\r\n    \\frac{\\delta }{\\delta x}(H(x,y,t))]\\\\\r\n    B(x,y)=(1,0,\\frac{\\delta }{\\delta x}(H(x,y,t)))\r\n\\end{aligned}\r\n\\]</span> 同理切线为： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    T(x,y)=[\\frac{\\delta x}{\\delta y},\\frac{\\delta y}{\\delta y},\r\n    \\frac{\\delta }{\\delta y}(H(x,y,t))]\\\\\r\n    T(x,y)=(0,1,\\frac{\\delta }{\\delta y}(H(x,y,t)))\r\n\\end{aligned}\r\n\\]</span> 法线由 <span class=\"math inline\">\\(B,T\\)</span> 叉乘得到：\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    N(x,y)=B(x,y)\\times T(x,y)\\\\\r\n    N(x,y)=[-\\frac{\\delta}{\\delta x}(H(x,y,t)),-\\frac{\\delta}{\\delta\r\ny}(H(x,y,t)),1]\r\n\\end{aligned}\r\n\\]</span> 计算偏导(以 对x求偏导为例)： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    \\frac{\\delta}{\\delta x}(H(x,y,t))&amp;=\\sum[\\frac{\\delta}{\\delta\r\nx}(W_i(x,y,t))]\\\\\r\n    &amp;=\\sum(\\omega_i*D_i.x*A_i*\\cos(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i))\r\n\\end{aligned}\r\n\\]</span>\r\n但是这样单纯叠加的波缺少真实感，真实的波波峰是尖的，而波谷会更宽。\r\n这里将正弦函数修改为非负状态，并赋予指数k。 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    W_i(x,y,t)=&amp;2A_i*[\\frac{\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)+1}{2}]^k\\\\\r\n    \\frac{\\delta}{\\delta\r\nx}(W_i(x,y,t))=&amp;k*D_i.x*\\omega_i*A_i[\\frac{\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)+1}{2}]^{k-1}\\\\\r\n    &amp;*\\cos(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)\r\n\\end{aligned}\r\n\\]</span> <img src=\"/imgs/水面模拟/kWave.png\" alt=\"kWave\" /></p>\r\n<h3 id=\"几何波\">1.2.3 几何波</h3>\r\n<h4 id=\"方向波或圆形波\">方向波或圆形波</h4>\r\n<p>对于方向波，每个 <span class=\"math inline\">\\(D_i\\)</span>\r\n都是波寿命常数，其实就是<em>常数</em>。<br />\r\n对于圆形波，方向必须在每个顶点计算，它是从波中心到顶点的规范化向量：\r\n<span class=\"math display\">\\[\r\nD_i(x,y)=[\\frac{(x,y)-C_i}{|(x,y)-C_i|}]\r\n\\]</span> 大水体一般用方向波比如海洋。<br />\r\n小水体一般用圆形波比如池塘。</p>\r\n<h4 id=\"gerstner-波\">Gerstner 波</h4>\r\n<p>正弦波还是太圆润，Gerstner 波能够模拟浪头更尖锐的波 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    P(x,y,t)=\r\n    \\left\\{\\begin{array}{}\r\n    x+\\sum(Q_iA_i*D_i.x*\\cos(\\omega_iD_i\\cdot(x,y)+\\phi_it))\\\\\r\n    y+\\sum(Q_iA_i*D_i.y*\\cos(\\omega_iD_i\\cdot(x,y)+\\phi_it))\\\\\r\n    \\sum(A_i\\sin(\\omega_iD_i\\cdot(x,y)+\\phi_it))\r\n    \\end{array}\r\n    \\right.\r\n\\end{aligned}\r\n\\]</span> <span class=\"math inline\">\\(Q_i\\)</span>\r\n是控制波陡度的参数，如果 <span class=\"math inline\">\\(Q_i=0\\)</span>\r\n就是正常的叠加正弦波，而 <span class=\"math inline\">\\(Q_i=1\\)</span>\r\n是尖峰的波形。<br />\r\n但是如果 <span class=\"math inline\">\\(Q_i\\)</span>​\r\n过大会导致波形成环，这点需要注意。</p>\r\n<p>法线切线也有变化： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    &amp;WA=\\omega_i*A_i\\\\\r\n    &amp;S()=\\sin(\\omega_i*D_i\\cdot P+\\phi_it)\\\\\r\n    &amp;C()=cos(\\omega_i*D_i\\cdot P+\\phi_it)\\\\\r\n    &amp;B=\\left\\{\r\n        \\begin{array}{}\r\n        1-\\sum(Q_i*D_i.x^2*WA*S())\\\\\r\n        -\\sum(Q_i*D_i.x*D_i.y*WA*S())\\\\\r\n        \\sum(D_i.y*WA*C())\r\n        \\end{array}\r\n    \\right.\\\\\r\n    &amp;T=\r\n    \\left\\{\r\n        \\begin{array}{}\r\n            -\\sum(Q_i*D_i.x*D_i.y*WA*S())\\\\\r\n            1-\\sum(Q_i*D_i.y^2*WA*S())\\\\\r\n            \\sum(D_i.y*WA*C())\r\n        \\end{array}\r\n    \\right.\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h1 id=\"fft-海洋\">FFT 海洋</h1>\r\n<p>这部分内容都是抄的：<a\r\nhref=\"https://zhuanlan.zhihu.com/p/95482541\">【学习笔记】Unity 基于GPU\r\nFFT海洋的实现-理论篇 - 知乎 (zhihu.com)</a></p>\r\n<blockquote>\r\n<p>离散傅里叶变换(Discrete Fourier Transform, DFT)<br />\r\n逆离散傅里叶变换(Inverse Discrete Fourier Transform, IDFT)</p>\r\n</blockquote>\r\n<p>DFT 的公式，如果<span class=\"math inline\">\\(f(x)\\)</span>\r\n为一个长度为 <span class=\"math inline\">\\(N\\)</span> 的数字序列，则其 DFT\r\n<span class=\"math inline\">\\(f(\\mu)\\)</span> 为 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    \\textstyle F(\\mu)=\\sum^{N-1}_{x=0}f(x)e^{-i\\frac{2\\pi\\mu x}{N}}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(F(\\mu)\\)</span>\r\n为转换后的<strong>频域函数</strong>。<br />\r\n</li>\r\n<li><span class=\"math inline\">\\(\\mu\\)</span>​ 是频率。 DFT\r\n做的就是把时域函数中一个复杂的波形展开为多个正弦波。</li>\r\n<li><span class=\"math inline\">\\(f(x)\\)</span>​ 是时域函数</li>\r\n<li><span class=\"math inline\">\\(e^{-i\\frac{2\\pi\\mu x}{N}}\\)</span>​\r\n是一个复数 利用欧拉公式：<span\r\nclass=\"math inline\">\\(e^{ix}=\\cos(x)+i\\sin(x)\\)</span></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    F(\\mu)=\\textstyle \\sum^{N-1}_{x=0}f(x)\\cos(\\frac{2\\pi\\mu\r\nx}{N})-i\\sum^{N-1}_{x=0}f(x)\\sin(\\frac{2\\pi\\mu x}{N})\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>逆傅里叶变换 IDFT <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    f(x)=\\frac{1}{N}\\textstyle\\sum^{N-1}_{\\mu=0}F(\\mu)e^{i\\frac{2\\pi\\mu\r\nx}{N}}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h2 id=\"fft-海洋公式\">FFT 海洋公式</h2>\r\n<p>如果我们需要一个复杂的海面，可以生产一个频谱( 也就是在频域 pick\r\n多个函数 )，然后通过 IDFT 就能够得到 由多个不同频率、振幅的波\r\n叠加的复杂海面。<br />\r\n这样频谱决定了海面形状。</p>\r\n<h3 id=\"simulating-ocean-water-jerry-tessendorf\">Simulating Ocean\r\nWater-Jerry Tessendorf</h3>\r\n<p>这里还需要再研究一下这个paper……</p>\r\n<p>Simulating Ocean Water-Jerry Tessendorf 的海洋公式： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    h(\\vec{x},t)=\\textstyle\\sum_k\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\r\n\\end{aligned}\r\n\\]</span> 这个其实就是逆离散傅里叶变换变换的形式。</p>\r\n<p>其中参数 <span class=\"math inline\">\\(\\vec{x}=(x,z)\\)</span>\r\n是水平方向的坐标，<span class=\"math inline\">\\(t\\)</span> 是时间，函数\r\n<span class=\"math inline\">\\(h\\)</span> 可以返回在时间 <span\r\nclass=\"math inline\">\\(t\\)</span> , <span\r\nclass=\"math inline\">\\(\\vec{x}\\)</span> 处的海面高度。<br />\r\n<span class=\"math inline\">\\(\\vec{k}\\)</span> 为波矢量，<span\r\nclass=\"math inline\">\\(\\vec{k}=(k_x,k_z)=(\\frac{2\\pi n}{L_x},\\frac{2\\pi\r\nm}{L_z})\\)</span> <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    -\\frac{N}{2}\\le n &lt; \\frac{N}{2}\\\\\r\n    -\\frac{M}{2}\\le m &lt; \\frac{M}{2}\r\n\\end{aligned}\r\n\\]</span> <span class=\"math inline\">\\(\\vec{k}\\)</span> 为波矢量，<span\r\nclass=\"math inline\">\\(L_x\\)</span> 和 <span\r\nclass=\"math inline\">\\(L_y\\)</span> 是海平面的大小，<span\r\nclass=\"math inline\">\\(N\\)</span> 和 <span\r\nclass=\"math inline\">\\(M\\)</span> 是采样离散点的数量。<br />\r\n如果 <span class=\"math inline\">\\(N\\)</span> 和 <span\r\nclass=\"math inline\">\\(M\\)</span>\r\n越大波就越精细，叠加的波就更多，但是计算时间也会增加。</p>\r\n<p>所以现在需要计算出频谱，然后按照 <span\r\nclass=\"math inline\">\\(h(\\vec{x},t)\\)</span>\r\n函数就可以得到海面的高度，<br />\r\n现在观察 频谱函数 <span\r\nclass=\"math inline\">\\(\\tilde{h}(\\vec{k},t)\\)</span><br />\r\n<span\r\nclass=\"math inline\">\\(\\tilde{h}(\\vec{k},t)=\\tilde{h_0}(\\vec{k})e^{i\\omega(k)t}+\\tilde{h_0^*}(-\\vec{k})e^{-i\\omega(k)t}\\)</span><br />\r\n<span class=\"math inline\">\\(\\tilde{h^*_0}\\)</span> 是 <span\r\nclass=\"math inline\">\\(\\tilde{h_0}\\)</span> 的共轭复数，<span\r\nclass=\"math inline\">\\(k\\)</span> 是 <span\r\nclass=\"math inline\">\\(\\vec{k}\\)</span>​ 的模。</p>\r\n<h4\r\nid=\"from-simulating-ocean-water-4.2-animatingwavesthedispersionrelation\">From\r\nSimulating Ocean Water : 4.2 AnimatingWaves:TheDispersionRelation</h4>\r\n<p><span class=\"math inline\">\\(\\omega(k)\\)</span> 是 角频率 <span\r\nclass=\"math inline\">\\(\\omega\\)</span> 和 波长 <span\r\nclass=\"math inline\">\\(k\\)</span> 的 弥散函数。</p>\r\n<ul>\r\n<li>在深水区，关系为 <span\r\nclass=\"math inline\">\\(\\omega^2(k)=gk\\)</span><br />\r\n<span class=\"math inline\">\\(g=9.8m/{sec}^2\\)</span> 是重力参数</li>\r\n<li>当水较浅的时候，底部对波浪有延缓作用，对于在平均水位以下深度为 <span\r\nclass=\"math inline\">\\(D\\)</span> 处的底部，弥散关系为：<br />\r\n<span class=\"math inline\">\\(\\omega^2(k)=gk\\tanh(kD)\\)</span>​<br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/520861532\">双曲正切函数（Tanh函数） -\r\n知乎 (zhihu.com)</a></li>\r\n<li>除了水的深度外，表面张力也有影响，波长为 1cm 或者 更短的非常小的波\r\n有附加项：<br />\r\n<span class=\"math inline\">\\(\\omega^2(k)=gk(1+k^2L^2)\\)</span><br />\r\n参数 <span class=\"math inline\">\\(L\\)</span>\r\n是标准长度，其大小是对表面张力有影响的尺度。</li>\r\n</ul>\r\n<h4\r\nid=\"from-simulating-ocean-water-4.4-buildingarandomoceanwaveheightfield\">From\r\nSimulating Ocean Water : 4.4 BuildingaRandomOceanWaveHeightField</h4>\r\n<blockquote>\r\n<p>水波高度是由目前所述的原理模拟的：具有规定形式的空间谱的高斯随机数。<br />\r\n对于傅里叶域这是非常有效的。波高场的傅里叶振幅可以被表示为：</p>\r\n</blockquote>\r\n<p><span\r\nclass=\"math inline\">\\(\\tilde{h}_0(\\vec{k})=\\frac{1}{\\sqrt{2}}(\\xi_r+i\\xi_i)\\sqrt{P_h(\\vec{k})}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\xi_r\\)</span> 和 <span\r\nclass=\"math inline\">\\(\\xi_i\\)</span> 为来自\r\n<em>高斯随机数生成器</em>的普通独立随机数，均值为 0，标准差为 1.</p>\r\n<p><span class=\"math inline\">\\(P_h(\\vec{k})\\)</span>\r\n是我们的方向波谱，方向波谱一般描述为 <span\r\nclass=\"math inline\">\\(S(\\omega,\\theta)\\)</span>\r\n,这和我们前面的参数不太一样，其实他们之间可以相互转换，有兴趣可以看<strong>Empirical\r\nDirectional Wave Spectra for Computer\r\nGraphics</strong>这篇论文。(暂时没找到这篇paper的资源，就没看)<br />\r\n方向波谱 <span class=\"math inline\">\\(S(\\omega,\\theta)\\)</span>\r\n是非定向波谱 <span class=\"math inline\">\\(S(\\omega)\\)</span>\r\n和方向拓展函数 <span class=\"math inline\">\\(D(\\omega,\\theta)\\)</span>\r\n的乘积.<br />\r\n<span\r\nclass=\"math inline\">\\(S(\\omega,\\theta)=S(\\omega)D(\\omega,\\theta)\\)</span><br />\r\n<span class=\"math inline\">\\(\\omega\\)</span> 是我们提到的角频率，<span\r\nclass=\"math inline\">\\(\\theta\\)</span> 是波矢量相对于风向的角度。</p>\r\n<h4\r\nid=\"from-simulating-ocean-water-4.3-statistical-wave-models-and-the-fourier-transform\">From\r\nSimulating Ocean Water : 4.3 Statistical Wave Models and the Fourier\r\nTransform</h4>\r\n<p>波浪谱有几种解析的经验模型，其中有一个风驱动模型，Phillips\r\nspectrum：<br />\r\n<span\r\nclass=\"math inline\">\\(P_h(\\vec{k})=A\\frac{\\exp(-1/(kL)^2)}{k^4}|\\hat{\\vec{k}}\\cdot\\hat{\\vec{\\omega}}|\\)</span><br />\r\n其中 <span class=\"math inline\">\\(L=V^2/g\\)</span> 为 <u>速度是 <span\r\nclass=\"math inline\">\\(V\\)</span> 的风可能产生的最大波</u>，<span\r\nclass=\"math inline\">\\(g\\)</span> 为重力常数，<span\r\nclass=\"math inline\">\\(\\omega\\)</span> 为风的方向，<span\r\nclass=\"math inline\">\\(A\\)</span> 是一个数值常数。<br />\r\nPhillips 的余弦系数 <span\r\nclass=\"math inline\">\\(|\\hat{k}\\cdot\\hat{\\omega}|\\)</span>\r\n消除了垂直风向移动的波，模型简单，但是在波数 <span\r\nclass=\"math inline\">\\(|k|\\)</span> 较高时收敛性差，一种修复方式是抑制\r\n长度<span class=\"math inline\">\\(\\mathscr{l}\\)</span>( <span\r\nclass=\"math inline\">\\(\\mathscr{l}\\ll L\\)</span> ) 小的波，并通过乘因子\r\n<span class=\"math inline\">\\(\\exp(-k^2\\mathscr{l}^2)\\)</span> 修改\r\nPhillips</p>\r\n<p>前面都是海洋高度公式，额，看不太明白……</p>\r\n<p>还有水平偏移公式：<br />\r\n<span\r\nclass=\"math inline\">\\(\\vec{D}(\\vec{x},t)=\\sum_k-i\\frac{\\vec{k}}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\\)</span></p>\r\n<p>和高度函数有些类似，把频谱改变一下，这个是的 <span\r\nclass=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span> 总体描述，拆开得到 <span\r\nclass=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span> 的单独描述 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    D_x(\\vec{x},t)=\\textstyle\\sum_k-i\\frac{k_x}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\\\\\r\n    D_z(\\vec{x},t)=\\textstyle\\sum_k-i\\frac{k_z}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\\\\\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h2 id=\"公式的计算流程\">公式的计算流程</h2>\r\n<figure>\r\n<img src=\"/imgs/水面模拟/waveNV1.png\" alt=\"waveNV1\" />\r\n<figcaption aria-hidden=\"true\">waveNV1</figcaption>\r\n</figure>\r\n<ul>\r\n<li>首先，根据公式生成 Phillips 频谱(↖)；</li>\r\n<li>然后再计算两个相互独立服从均值为 0，标准差为 1的高斯函数。(↙)</li>\r\n<li>之后根据公式结合完成了第一步，得到了一个初始的频谱<br />\r\n这里频谱计算一次即可，除非风 <span\r\nclass=\"math inline\">\\(L=V^2/g\\)</span>​\r\n会每帧变化，其他的随机数计算一次即可。</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/imgs/水面模拟/waveNV2.png\" alt=\"waveNV2\" />\r\n<figcaption aria-hidden=\"true\">waveNV2</figcaption>\r\n</figure>\r\n<ul>\r\n<li>得到初始频谱后，使用其计算 高度频谱 <span\r\nclass=\"math inline\">\\(\\tilde{h}(\\vec{k},t)\\)</span>，<span\r\nclass=\"math inline\">\\(\\tilde{H}(\\vec{k})\\rightarrow\r\n\\tilde{H}(\\vec{k},t)\\)</span></li>\r\n<li>再使用高度函数就能得到 两个偏移频谱 <span\r\nclass=\"math inline\">\\(D_x(\\vec{x},t)\\)</span> 和 <span\r\nclass=\"math inline\">\\(D_z(\\vec{x},t)\\)</span>，<span\r\nclass=\"math inline\">\\(\\tilde{H}(\\vec{k},t) \\rightarrow\r\nD_x(\\vec{x},t),D_z(\\vec{x},t)\\)</span>​</li>\r\n</ul>\r\n<p>拿到频谱后，分别进行 IDFT， 就会得到水平 <span\r\nclass=\"math inline\">\\(x\\)</span>、<span class=\"math inline\">\\(z\\)</span>\r\n以及高度 <span class=\"math inline\">\\(y\\)</span> 的偏移图( <span\r\nclass=\"math inline\">\\(z\\)</span>​ 为高度)。</p>\r\n<p>将计算得到的图放在一起就能得到偏移纹理( Displacement\r\n)，再通过偏移纹理( Displacement ) 可以计算 法线 和 泡沫\r\n贴图，这样我们所有的纹理就能够拿到了，然后进行渲染。</p>\r\n<p>如果直接进行 IDFT 效率太低，</p>\r\n<h2 id=\"fft-推导\">FFT 推导</h2>\r\n<p>计算效率低的问题在哪？</p>\r\n<p>先看一下海洋的公式 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    h(\\vec{x},t)=\\textstyle\\sum_k\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>这个是二维 IDFT，将 <span class=\"math inline\">\\(h(\\vec{x},t)\\)</span>\r\n展开后得到 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    &amp;\\vec{k}=(k_x,k_z)=(\\frac{2\\pi n}{L_x},\\frac{2\\pi m}{L_z})\\\\\r\n    &amp;\\vec{x}=(x,z)\\\\\r\n    &amp;h(x,z,t)=\\textstyle\\sum^{\\frac{M}{2}-1}_{m=-\\frac{M}{2}}\\sum^{\\frac{N}{2}-1}_{m=-\\frac{N}{2}}\\tilde\r\nh(\\frac{2\\pi n}{L_x},\\frac{2\\pi m}{L_z},t)e^{i(\\frac{2\\pi\r\nn}{L_x}+\\frac{2\\pi m}{L_z})}\r\n\\end{aligned}\r\n\\]</span> 这样的复杂度就是 一个位置的海面是 <span\r\nclass=\"math inline\">\\(O(NM)\\)</span>，如果是所有位置大概就是 <span\r\nclass=\"math inline\">\\(O(N^2M^2)\\)</span></p>\r\n<p>所以可以用 FFT 快速傅里叶变换的思想，进行快速傅里叶逆变换(IFFT)</p>\r\n<p>为了推导先设(其实是为了把求和号归零吧) <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;0\\le n&#39;\\le N,n&#39;\\in(0,1,...,N-1)\\\\\r\n&amp;0\\le m&#39;\\le M,m&#39;\\in(0,1,...,M-1)\\\\\r\n&amp;n=n&#39;-\\frac{N}{2}\\\\\r\n&amp;m=m&#39;-\\frac{M}{2}\\\\\r\n&amp;k_x=\\frac{2\\pi(n&#39;-\\frac{N}{2})}{L_x}=\\frac{2\\pi n&#39;-\\pi\r\nN}{L_x}\\\\\r\n&amp;k_z=\\frac{2\\pi(n&#39;-\\frac{M}{2})}{L_z}=\\frac{2\\pi m&#39;-\\pi\r\nM}{L_z}\\\\\r\n\\end{aligned}\r\n\\]</span> 则，有 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\nh&#39;(x,z,t)=\\textstyle\\sum^{M-1}_{m&#39;=0}\\sum^{N-1}_{n&#39;=0}\\tilde{h}(n&#39;,m&#39;,t)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h1 id=\"unity-水面模拟\">Unity 水面模拟</h1>\r\n<h2 id=\"参考\">参考</h2>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/95482541\">【学习笔记】Unity\r\n基于GPU FFT海洋的实现-理论篇 - 知乎 (zhihu.com)</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/335045713\">FFT海洋学习笔记（一） -\r\n知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/335946333\">FFT海洋水体渲染学习笔记（二）\r\n- 知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/19763358\">傅里叶分析之掐死教程（完整版）更新于2014.06.06\r\n- 知乎 (zhihu.com)</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/95917609\">真实感水体渲染技术总结 -\r\n知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://www.zhihu.com/question/23914350\">扩散（diffusion）和弥散（dispersion）有什么区别？\r\n- 知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://www.researchgate.net/publication/264839743_Simulating_Ocean_Water/link/5ba8ecb0a6fdccd3cb6f6ffd/download?_tp=eyJjb250ZXh0Ijp7ImZpcnN0UGFnZSI6InB1YmxpY2F0aW9uIiwicGFnZSI6InB1YmxpY2F0aW9uIn19\">Simulating\r\nOcean Water-Jerry Tessendorf Paper - ResearchGate</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/520861532\"><span\r\nclass=\"math inline\">\\(\\tanh\\)</span>双曲正切函数（Tanh函数） - 知乎\r\n(zhihu.com)</a><br />\r\n<a\r\nhref=\"https://developer.download.nvidia.cn/assets/gamedev/files/sdk/11/OceanCS_Slides.pdf\">OceanCS_Slides.pdf\r\n(nvidia.cn)</a></p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>Unity 水面模拟</p>\r\n<h1 id=\"浪\">浪</h1>\r\n<p><a\r\nhref=\"https://www.bilibili.com/video/BV18v4y1P7Ne\">海浪01</a><br />\r\n<a href=\"https://www.bilibili.com/video/BV1u7411K7MR\">海浪02</a> <a\r\nhref=\"https://www.bilibili.com/video/BV1U54y1C7YG\">星际穿越实拍海浪</a><br />\r\n<img src=\"/imgs/水面模拟/InterstellarSeaWave.png\"\r\nalt=\"InterstellarSeaWave\" /></p>\r\n<h1 id=\"gpu-精粹-波相关\">GPU 精粹 波相关</h1>\r\n<p>我说实话翻译版真的是太抽象了……</p>\r\n<h2 id=\"正弦波\">1.2 正弦波</h2>\r\n<p>首先对于波的模拟有两个部分，一个是网格的几何波动(顶点偏移)，另一个就是网格上法线的扰动。\r\n主要是用周期波叠加实现，先看简单的正弦函数。</p>\r\n<p>这里主要在数学定义上了解波的模拟</p>\r\n<h3 id=\"波的选择\">1.2.1 波的选择</h3>\r\n<p>需要一个参数组来定义波，如下</p>\r\n<ul>\r\n<li>波长(<span class=\"math inline\">\\(L\\)</span>) :\r\n世界空间中波峰之间的距离。波长 <span class=\"math inline\">\\(L\\)</span> 和\r\n角频率 <span class=\"math inline\">\\(\\omega\\)</span> 的关系为 <span\r\nclass=\"math inline\">\\(\\omega =2\\pi/L\\)</span>\r\n这里的角频率就是平时我们说的频率</li>\r\n<li>振幅(<span class=\"math inline\">\\(A\\)</span>) :\r\n水平面到波峰的距离，决定了波的高低。</li>\r\n<li>速度(<span class=\"math inline\">\\(S\\)</span>) :\r\n因为波是会动的，表示每秒钟波的移动距离。通常表示为常数项 <span\r\nclass=\"math inline\">\\(\\phi=S*2\\pi/L\\)</span></li>\r\n<li>方向(<span class=\"math inline\">\\(D\\)</span>) :\r\n垂直于波阵面的水平向量。 所谓波阵面是指波峰沿着它运动的面，比如\r\ny=sin(x)，D=(1,0)。</li>\r\n</ul>\r\n<p>波的状态定义为水平位置 (x, y) 和 时间 (t) 的函数： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    W_i(x,y,t)=A_i*\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>我们可以用多个波叠加模拟总表面 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    H(x,y,t)=\\sum(A_i*\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i))\r\n\\end{aligned}\r\n\\]</span></p>\r\n<figure>\r\n<img src=\"/imgs/水面模拟/waveparameters.png\" alt=\"waveparameters\" />\r\n<figcaption aria-hidden=\"true\">waveparameters</figcaption>\r\n</figure>\r\n<h3 id=\"法线和切线\">1.2.2 法线和切线</h3>\r\n<p>因为我们上面用正弦函数表示波，所以是一个显式函数，也就是说能在任意给定点直接计算表面方向，不用使用差分算法计算。\r\n副法线 <span class=\"math inline\">\\(B\\)</span> 和 切线 <span\r\nclass=\"math inline\">\\(T\\)</span> 向量分别为 <span\r\nclass=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(y\\)</span> 方向的偏导数。对在 2D 水平面中的任何点\r\n<span class=\"math inline\">\\((x, y)\\)</span>​，其在表面的三维位置是( 3D\r\n空间表示 )： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    P(x,y,t)=(x,y,H(x,y,t))\r\n\\end{aligned}\r\n\\]</span> 对于副法线 <span class=\"math inline\">\\(x\\)</span> 的偏导是 :\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    B(x,y)=[\\frac{\\delta x}{\\delta x},\\frac{\\delta y}{\\delta x},\r\n    \\frac{\\delta }{\\delta x}(H(x,y,t))]\\\\\r\n    B(x,y)=(1,0,\\frac{\\delta }{\\delta x}(H(x,y,t)))\r\n\\end{aligned}\r\n\\]</span> 同理切线为： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    T(x,y)=[\\frac{\\delta x}{\\delta y},\\frac{\\delta y}{\\delta y},\r\n    \\frac{\\delta }{\\delta y}(H(x,y,t))]\\\\\r\n    T(x,y)=(0,1,\\frac{\\delta }{\\delta y}(H(x,y,t)))\r\n\\end{aligned}\r\n\\]</span> 法线由 <span class=\"math inline\">\\(B,T\\)</span> 叉乘得到：\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    N(x,y)=B(x,y)\\times T(x,y)\\\\\r\n    N(x,y)=[-\\frac{\\delta}{\\delta x}(H(x,y,t)),-\\frac{\\delta}{\\delta\r\ny}(H(x,y,t)),1]\r\n\\end{aligned}\r\n\\]</span> 计算偏导(以 对x求偏导为例)： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    \\frac{\\delta}{\\delta x}(H(x,y,t))&amp;=\\sum[\\frac{\\delta}{\\delta\r\nx}(W_i(x,y,t))]\\\\\r\n    &amp;=\\sum(\\omega_i*D_i.x*A_i*\\cos(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i))\r\n\\end{aligned}\r\n\\]</span>\r\n但是这样单纯叠加的波缺少真实感，真实的波波峰是尖的，而波谷会更宽。\r\n这里将正弦函数修改为非负状态，并赋予指数k。 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    W_i(x,y,t)=&amp;2A_i*[\\frac{\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)+1}{2}]^k\\\\\r\n    \\frac{\\delta}{\\delta\r\nx}(W_i(x,y,t))=&amp;k*D_i.x*\\omega_i*A_i[\\frac{\\sin(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)+1}{2}]^{k-1}\\\\\r\n    &amp;*\\cos(D_i\\cdot(x,y)*\\omega_i+t*\\phi_i)\r\n\\end{aligned}\r\n\\]</span> <img src=\"/imgs/水面模拟/kWave.png\" alt=\"kWave\" /></p>\r\n<h3 id=\"几何波\">1.2.3 几何波</h3>\r\n<h4 id=\"方向波或圆形波\">方向波或圆形波</h4>\r\n<p>对于方向波，每个 <span class=\"math inline\">\\(D_i\\)</span>\r\n都是波寿命常数，其实就是<em>常数</em>。<br />\r\n对于圆形波，方向必须在每个顶点计算，它是从波中心到顶点的规范化向量：\r\n<span class=\"math display\">\\[\r\nD_i(x,y)=[\\frac{(x,y)-C_i}{|(x,y)-C_i|}]\r\n\\]</span> 大水体一般用方向波比如海洋。<br />\r\n小水体一般用圆形波比如池塘。</p>\r\n<h4 id=\"gerstner-波\">Gerstner 波</h4>\r\n<p>正弦波还是太圆润，Gerstner 波能够模拟浪头更尖锐的波 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    P(x,y,t)=\r\n    \\left\\{\\begin{array}{}\r\n    x+\\sum(Q_iA_i*D_i.x*\\cos(\\omega_iD_i\\cdot(x,y)+\\phi_it))\\\\\r\n    y+\\sum(Q_iA_i*D_i.y*\\cos(\\omega_iD_i\\cdot(x,y)+\\phi_it))\\\\\r\n    \\sum(A_i\\sin(\\omega_iD_i\\cdot(x,y)+\\phi_it))\r\n    \\end{array}\r\n    \\right.\r\n\\end{aligned}\r\n\\]</span> <span class=\"math inline\">\\(Q_i\\)</span>\r\n是控制波陡度的参数，如果 <span class=\"math inline\">\\(Q_i=0\\)</span>\r\n就是正常的叠加正弦波，而 <span class=\"math inline\">\\(Q_i=1\\)</span>\r\n是尖峰的波形。<br />\r\n但是如果 <span class=\"math inline\">\\(Q_i\\)</span>​\r\n过大会导致波形成环，这点需要注意。</p>\r\n<p>法线切线也有变化： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    &amp;WA=\\omega_i*A_i\\\\\r\n    &amp;S()=\\sin(\\omega_i*D_i\\cdot P+\\phi_it)\\\\\r\n    &amp;C()=cos(\\omega_i*D_i\\cdot P+\\phi_it)\\\\\r\n    &amp;B=\\left\\{\r\n        \\begin{array}{}\r\n        1-\\sum(Q_i*D_i.x^2*WA*S())\\\\\r\n        -\\sum(Q_i*D_i.x*D_i.y*WA*S())\\\\\r\n        \\sum(D_i.y*WA*C())\r\n        \\end{array}\r\n    \\right.\\\\\r\n    &amp;T=\r\n    \\left\\{\r\n        \\begin{array}{}\r\n            -\\sum(Q_i*D_i.x*D_i.y*WA*S())\\\\\r\n            1-\\sum(Q_i*D_i.y^2*WA*S())\\\\\r\n            \\sum(D_i.y*WA*C())\r\n        \\end{array}\r\n    \\right.\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h1 id=\"fft-海洋\">FFT 海洋</h1>\r\n<p>这部分内容都是抄的：<a\r\nhref=\"https://zhuanlan.zhihu.com/p/95482541\">【学习笔记】Unity 基于GPU\r\nFFT海洋的实现-理论篇 - 知乎 (zhihu.com)</a></p>\r\n<blockquote>\r\n<p>离散傅里叶变换(Discrete Fourier Transform, DFT)<br />\r\n逆离散傅里叶变换(Inverse Discrete Fourier Transform, IDFT)</p>\r\n</blockquote>\r\n<p>DFT 的公式，如果<span class=\"math inline\">\\(f(x)\\)</span>\r\n为一个长度为 <span class=\"math inline\">\\(N\\)</span> 的数字序列，则其 DFT\r\n<span class=\"math inline\">\\(f(\\mu)\\)</span> 为 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    \\textstyle F(\\mu)=\\sum^{N-1}_{x=0}f(x)e^{-i\\frac{2\\pi\\mu x}{N}}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(F(\\mu)\\)</span>\r\n为转换后的<strong>频域函数</strong>。<br />\r\n</li>\r\n<li><span class=\"math inline\">\\(\\mu\\)</span>​ 是频率。 DFT\r\n做的就是把时域函数中一个复杂的波形展开为多个正弦波。</li>\r\n<li><span class=\"math inline\">\\(f(x)\\)</span>​ 是时域函数</li>\r\n<li><span class=\"math inline\">\\(e^{-i\\frac{2\\pi\\mu x}{N}}\\)</span>​\r\n是一个复数 利用欧拉公式：<span\r\nclass=\"math inline\">\\(e^{ix}=\\cos(x)+i\\sin(x)\\)</span></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    F(\\mu)=\\textstyle \\sum^{N-1}_{x=0}f(x)\\cos(\\frac{2\\pi\\mu\r\nx}{N})-i\\sum^{N-1}_{x=0}f(x)\\sin(\\frac{2\\pi\\mu x}{N})\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>逆傅里叶变换 IDFT <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    f(x)=\\frac{1}{N}\\textstyle\\sum^{N-1}_{\\mu=0}F(\\mu)e^{i\\frac{2\\pi\\mu\r\nx}{N}}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h2 id=\"fft-海洋公式\">FFT 海洋公式</h2>\r\n<p>如果我们需要一个复杂的海面，可以生产一个频谱( 也就是在频域 pick\r\n多个函数 )，然后通过 IDFT 就能够得到 由多个不同频率、振幅的波\r\n叠加的复杂海面。<br />\r\n这样频谱决定了海面形状。</p>\r\n<h3 id=\"simulating-ocean-water-jerry-tessendorf\">Simulating Ocean\r\nWater-Jerry Tessendorf</h3>\r\n<p>这里还需要再研究一下这个paper……</p>\r\n<p>Simulating Ocean Water-Jerry Tessendorf 的海洋公式： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    h(\\vec{x},t)=\\textstyle\\sum_k\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\r\n\\end{aligned}\r\n\\]</span> 这个其实就是逆离散傅里叶变换变换的形式。</p>\r\n<p>其中参数 <span class=\"math inline\">\\(\\vec{x}=(x,z)\\)</span>\r\n是水平方向的坐标，<span class=\"math inline\">\\(t\\)</span> 是时间，函数\r\n<span class=\"math inline\">\\(h\\)</span> 可以返回在时间 <span\r\nclass=\"math inline\">\\(t\\)</span> , <span\r\nclass=\"math inline\">\\(\\vec{x}\\)</span> 处的海面高度。<br />\r\n<span class=\"math inline\">\\(\\vec{k}\\)</span> 为波矢量，<span\r\nclass=\"math inline\">\\(\\vec{k}=(k_x,k_z)=(\\frac{2\\pi n}{L_x},\\frac{2\\pi\r\nm}{L_z})\\)</span> <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    -\\frac{N}{2}\\le n &lt; \\frac{N}{2}\\\\\r\n    -\\frac{M}{2}\\le m &lt; \\frac{M}{2}\r\n\\end{aligned}\r\n\\]</span> <span class=\"math inline\">\\(\\vec{k}\\)</span> 为波矢量，<span\r\nclass=\"math inline\">\\(L_x\\)</span> 和 <span\r\nclass=\"math inline\">\\(L_y\\)</span> 是海平面的大小，<span\r\nclass=\"math inline\">\\(N\\)</span> 和 <span\r\nclass=\"math inline\">\\(M\\)</span> 是采样离散点的数量。<br />\r\n如果 <span class=\"math inline\">\\(N\\)</span> 和 <span\r\nclass=\"math inline\">\\(M\\)</span>\r\n越大波就越精细，叠加的波就更多，但是计算时间也会增加。</p>\r\n<p>所以现在需要计算出频谱，然后按照 <span\r\nclass=\"math inline\">\\(h(\\vec{x},t)\\)</span>\r\n函数就可以得到海面的高度，<br />\r\n现在观察 频谱函数 <span\r\nclass=\"math inline\">\\(\\tilde{h}(\\vec{k},t)\\)</span><br />\r\n<span\r\nclass=\"math inline\">\\(\\tilde{h}(\\vec{k},t)=\\tilde{h_0}(\\vec{k})e^{i\\omega(k)t}+\\tilde{h_0^*}(-\\vec{k})e^{-i\\omega(k)t}\\)</span><br />\r\n<span class=\"math inline\">\\(\\tilde{h^*_0}\\)</span> 是 <span\r\nclass=\"math inline\">\\(\\tilde{h_0}\\)</span> 的共轭复数，<span\r\nclass=\"math inline\">\\(k\\)</span> 是 <span\r\nclass=\"math inline\">\\(\\vec{k}\\)</span>​ 的模。</p>\r\n<h4\r\nid=\"from-simulating-ocean-water-4.2-animatingwavesthedispersionrelation\">From\r\nSimulating Ocean Water : 4.2 AnimatingWaves:TheDispersionRelation</h4>\r\n<p><span class=\"math inline\">\\(\\omega(k)\\)</span> 是 角频率 <span\r\nclass=\"math inline\">\\(\\omega\\)</span> 和 波长 <span\r\nclass=\"math inline\">\\(k\\)</span> 的 弥散函数。</p>\r\n<ul>\r\n<li>在深水区，关系为 <span\r\nclass=\"math inline\">\\(\\omega^2(k)=gk\\)</span><br />\r\n<span class=\"math inline\">\\(g=9.8m/{sec}^2\\)</span> 是重力参数</li>\r\n<li>当水较浅的时候，底部对波浪有延缓作用，对于在平均水位以下深度为 <span\r\nclass=\"math inline\">\\(D\\)</span> 处的底部，弥散关系为：<br />\r\n<span class=\"math inline\">\\(\\omega^2(k)=gk\\tanh(kD)\\)</span>​<br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/520861532\">双曲正切函数（Tanh函数） -\r\n知乎 (zhihu.com)</a></li>\r\n<li>除了水的深度外，表面张力也有影响，波长为 1cm 或者 更短的非常小的波\r\n有附加项：<br />\r\n<span class=\"math inline\">\\(\\omega^2(k)=gk(1+k^2L^2)\\)</span><br />\r\n参数 <span class=\"math inline\">\\(L\\)</span>\r\n是标准长度，其大小是对表面张力有影响的尺度。</li>\r\n</ul>\r\n<h4\r\nid=\"from-simulating-ocean-water-4.4-buildingarandomoceanwaveheightfield\">From\r\nSimulating Ocean Water : 4.4 BuildingaRandomOceanWaveHeightField</h4>\r\n<blockquote>\r\n<p>水波高度是由目前所述的原理模拟的：具有规定形式的空间谱的高斯随机数。<br />\r\n对于傅里叶域这是非常有效的。波高场的傅里叶振幅可以被表示为：</p>\r\n</blockquote>\r\n<p><span\r\nclass=\"math inline\">\\(\\tilde{h}_0(\\vec{k})=\\frac{1}{\\sqrt{2}}(\\xi_r+i\\xi_i)\\sqrt{P_h(\\vec{k})}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\xi_r\\)</span> 和 <span\r\nclass=\"math inline\">\\(\\xi_i\\)</span> 为来自\r\n<em>高斯随机数生成器</em>的普通独立随机数，均值为 0，标准差为 1.</p>\r\n<p><span class=\"math inline\">\\(P_h(\\vec{k})\\)</span>\r\n是我们的方向波谱，方向波谱一般描述为 <span\r\nclass=\"math inline\">\\(S(\\omega,\\theta)\\)</span>\r\n,这和我们前面的参数不太一样，其实他们之间可以相互转换，有兴趣可以看<strong>Empirical\r\nDirectional Wave Spectra for Computer\r\nGraphics</strong>这篇论文。(暂时没找到这篇paper的资源，就没看)<br />\r\n方向波谱 <span class=\"math inline\">\\(S(\\omega,\\theta)\\)</span>\r\n是非定向波谱 <span class=\"math inline\">\\(S(\\omega)\\)</span>\r\n和方向拓展函数 <span class=\"math inline\">\\(D(\\omega,\\theta)\\)</span>\r\n的乘积.<br />\r\n<span\r\nclass=\"math inline\">\\(S(\\omega,\\theta)=S(\\omega)D(\\omega,\\theta)\\)</span><br />\r\n<span class=\"math inline\">\\(\\omega\\)</span> 是我们提到的角频率，<span\r\nclass=\"math inline\">\\(\\theta\\)</span> 是波矢量相对于风向的角度。</p>\r\n<h4\r\nid=\"from-simulating-ocean-water-4.3-statistical-wave-models-and-the-fourier-transform\">From\r\nSimulating Ocean Water : 4.3 Statistical Wave Models and the Fourier\r\nTransform</h4>\r\n<p>波浪谱有几种解析的经验模型，其中有一个风驱动模型，Phillips\r\nspectrum：<br />\r\n<span\r\nclass=\"math inline\">\\(P_h(\\vec{k})=A\\frac{\\exp(-1/(kL)^2)}{k^4}|\\hat{\\vec{k}}\\cdot\\hat{\\vec{\\omega}}|\\)</span><br />\r\n其中 <span class=\"math inline\">\\(L=V^2/g\\)</span> 为 <u>速度是 <span\r\nclass=\"math inline\">\\(V\\)</span> 的风可能产生的最大波</u>，<span\r\nclass=\"math inline\">\\(g\\)</span> 为重力常数，<span\r\nclass=\"math inline\">\\(\\omega\\)</span> 为风的方向，<span\r\nclass=\"math inline\">\\(A\\)</span> 是一个数值常数。<br />\r\nPhillips 的余弦系数 <span\r\nclass=\"math inline\">\\(|\\hat{k}\\cdot\\hat{\\omega}|\\)</span>\r\n消除了垂直风向移动的波，模型简单，但是在波数 <span\r\nclass=\"math inline\">\\(|k|\\)</span> 较高时收敛性差，一种修复方式是抑制\r\n长度<span class=\"math inline\">\\(\\mathscr{l}\\)</span>( <span\r\nclass=\"math inline\">\\(\\mathscr{l}\\ll L\\)</span> ) 小的波，并通过乘因子\r\n<span class=\"math inline\">\\(\\exp(-k^2\\mathscr{l}^2)\\)</span> 修改\r\nPhillips</p>\r\n<p>前面都是海洋高度公式，额，看不太明白……</p>\r\n<p>还有水平偏移公式：<br />\r\n<span\r\nclass=\"math inline\">\\(\\vec{D}(\\vec{x},t)=\\sum_k-i\\frac{\\vec{k}}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\\)</span></p>\r\n<p>和高度函数有些类似，把频谱改变一下，这个是的 <span\r\nclass=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span> 总体描述，拆开得到 <span\r\nclass=\"math inline\">\\(x\\)</span> 和 <span\r\nclass=\"math inline\">\\(z\\)</span> 的单独描述 <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n    D_x(\\vec{x},t)=\\textstyle\\sum_k-i\\frac{k_x}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\\\\\r\n    D_z(\\vec{x},t)=\\textstyle\\sum_k-i\\frac{k_z}{k}\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\\\\\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h2 id=\"公式的计算流程\">公式的计算流程</h2>\r\n<figure>\r\n<img src=\"/imgs/水面模拟/waveNV1.png\" alt=\"waveNV1\" />\r\n<figcaption aria-hidden=\"true\">waveNV1</figcaption>\r\n</figure>\r\n<ul>\r\n<li>首先，根据公式生成 Phillips 频谱(↖)；</li>\r\n<li>然后再计算两个相互独立服从均值为 0，标准差为 1的高斯函数。(↙)</li>\r\n<li>之后根据公式结合完成了第一步，得到了一个初始的频谱<br />\r\n这里频谱计算一次即可，除非风 <span\r\nclass=\"math inline\">\\(L=V^2/g\\)</span>​\r\n会每帧变化，其他的随机数计算一次即可。</li>\r\n</ul>\r\n<figure>\r\n<img src=\"/imgs/水面模拟/waveNV2.png\" alt=\"waveNV2\" />\r\n<figcaption aria-hidden=\"true\">waveNV2</figcaption>\r\n</figure>\r\n<ul>\r\n<li>得到初始频谱后，使用其计算 高度频谱 <span\r\nclass=\"math inline\">\\(\\tilde{h}(\\vec{k},t)\\)</span>，<span\r\nclass=\"math inline\">\\(\\tilde{H}(\\vec{k})\\rightarrow\r\n\\tilde{H}(\\vec{k},t)\\)</span></li>\r\n<li>再使用高度函数就能得到 两个偏移频谱 <span\r\nclass=\"math inline\">\\(D_x(\\vec{x},t)\\)</span> 和 <span\r\nclass=\"math inline\">\\(D_z(\\vec{x},t)\\)</span>，<span\r\nclass=\"math inline\">\\(\\tilde{H}(\\vec{k},t) \\rightarrow\r\nD_x(\\vec{x},t),D_z(\\vec{x},t)\\)</span>​</li>\r\n</ul>\r\n<p>拿到频谱后，分别进行 IDFT， 就会得到水平 <span\r\nclass=\"math inline\">\\(x\\)</span>、<span class=\"math inline\">\\(z\\)</span>\r\n以及高度 <span class=\"math inline\">\\(y\\)</span> 的偏移图( <span\r\nclass=\"math inline\">\\(z\\)</span>​ 为高度)。</p>\r\n<p>将计算得到的图放在一起就能得到偏移纹理( Displacement\r\n)，再通过偏移纹理( Displacement ) 可以计算 法线 和 泡沫\r\n贴图，这样我们所有的纹理就能够拿到了，然后进行渲染。</p>\r\n<p>如果直接进行 IDFT 效率太低，</p>\r\n<h2 id=\"fft-推导\">FFT 推导</h2>\r\n<p>计算效率低的问题在哪？</p>\r\n<p>先看一下海洋的公式 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    h(\\vec{x},t)=\\textstyle\\sum_k\\tilde{h}(\\vec{k},t)e^{i\\vec{k}\\cdot\\vec{x}}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>这个是二维 IDFT，将 <span class=\"math inline\">\\(h(\\vec{x},t)\\)</span>\r\n展开后得到 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n    &amp;\\vec{k}=(k_x,k_z)=(\\frac{2\\pi n}{L_x},\\frac{2\\pi m}{L_z})\\\\\r\n    &amp;\\vec{x}=(x,z)\\\\\r\n    &amp;h(x,z,t)=\\textstyle\\sum^{\\frac{M}{2}-1}_{m=-\\frac{M}{2}}\\sum^{\\frac{N}{2}-1}_{m=-\\frac{N}{2}}\\tilde\r\nh(\\frac{2\\pi n}{L_x},\\frac{2\\pi m}{L_z},t)e^{i(\\frac{2\\pi\r\nn}{L_x}+\\frac{2\\pi m}{L_z})}\r\n\\end{aligned}\r\n\\]</span> 这样的复杂度就是 一个位置的海面是 <span\r\nclass=\"math inline\">\\(O(NM)\\)</span>，如果是所有位置大概就是 <span\r\nclass=\"math inline\">\\(O(N^2M^2)\\)</span></p>\r\n<p>所以可以用 FFT 快速傅里叶变换的思想，进行快速傅里叶逆变换(IFFT)</p>\r\n<p>为了推导先设(其实是为了把求和号归零吧) <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;0\\le n&#39;\\le N,n&#39;\\in(0,1,...,N-1)\\\\\r\n&amp;0\\le m&#39;\\le M,m&#39;\\in(0,1,...,M-1)\\\\\r\n&amp;n=n&#39;-\\frac{N}{2}\\\\\r\n&amp;m=m&#39;-\\frac{M}{2}\\\\\r\n&amp;k_x=\\frac{2\\pi(n&#39;-\\frac{N}{2})}{L_x}=\\frac{2\\pi n&#39;-\\pi\r\nN}{L_x}\\\\\r\n&amp;k_z=\\frac{2\\pi(n&#39;-\\frac{M}{2})}{L_z}=\\frac{2\\pi m&#39;-\\pi\r\nM}{L_z}\\\\\r\n\\end{aligned}\r\n\\]</span> 则，有 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\nh&#39;(x,z,t)=\\textstyle\\sum^{M-1}_{m&#39;=0}\\sum^{N-1}_{n&#39;=0}\\tilde{h}(n&#39;,m&#39;,t)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h1 id=\"unity-水面模拟\">Unity 水面模拟</h1>\r\n<h2 id=\"参考\">参考</h2>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/95482541\">【学习笔记】Unity\r\n基于GPU FFT海洋的实现-理论篇 - 知乎 (zhihu.com)</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/335045713\">FFT海洋学习笔记（一） -\r\n知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/335946333\">FFT海洋水体渲染学习笔记（二）\r\n- 知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/19763358\">傅里叶分析之掐死教程（完整版）更新于2014.06.06\r\n- 知乎 (zhihu.com)</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/95917609\">真实感水体渲染技术总结 -\r\n知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://www.zhihu.com/question/23914350\">扩散（diffusion）和弥散（dispersion）有什么区别？\r\n- 知乎 (zhihu.com)</a><br />\r\n<a\r\nhref=\"https://www.researchgate.net/publication/264839743_Simulating_Ocean_Water/link/5ba8ecb0a6fdccd3cb6f6ffd/download?_tp=eyJjb250ZXh0Ijp7ImZpcnN0UGFnZSI6InB1YmxpY2F0aW9uIiwicGFnZSI6InB1YmxpY2F0aW9uIn19\">Simulating\r\nOcean Water-Jerry Tessendorf Paper - ResearchGate</a><br />\r\n<a href=\"https://zhuanlan.zhihu.com/p/520861532\"><span\r\nclass=\"math inline\">\\(\\tanh\\)</span>双曲正切函数（Tanh函数） - 知乎\r\n(zhihu.com)</a><br />\r\n<a\r\nhref=\"https://developer.download.nvidia.cn/assets/gamedev/files/sdk/11/OceanCS_Slides.pdf\">OceanCS_Slides.pdf\r\n(nvidia.cn)</a></p>\r\n"},{"title":"求救信","date":"2023-04-03T13:47:16.000Z","_content":"\n这其实是一封求救信，我写下这些文字时，是准备自杀的，我已经有了自杀的想法，但是最终如何实施我还没有想法。但我内心深处还是不想死的所以这是一封求救信，如果你看到了这份信我很抱歉，没给你带去好心情，不过如果你是个残酷的人以我的死亡为乐那么咱们想必也没什么好说的。\n\n<!--more-->\n\n# 序\n\n没怎么写过信，也不知道谁会看到，从哪里说起呢……既然我都要从这个世界离开了，那这应该是我最后一次的表达了吧，那我就说的详细一点吧，我还是希望你好好听的，因为你再想听我讲可能就听不到了。\n\n# 我大概的一生\n\n我和大多数人一样都是一个普通的人，生在一个普通的东北县城，一个普通的家庭，普通的爱我的父母，小学时候应该还是很快乐的吧，但是我已经记不起来了，从小我就是一个性格古怪的孩子，家里人都叫我倔驴，平常就爱争强好胜，什么都喜欢当第一，因为我是独生子女，在家里没有别的参赛选手只有我一个人所以我总是第一。说起性格的缺点嘛，小时候最不服训，是一个刺头，别人来训我，我总是不服的，至今还记得为了好玩躲在粮食垛下，听家长急慌慌的样子，最后过了好久才出来，家里人很是生气训了我一顿，但是那时候还小不理解所以完全不服呢，哈哈哈，现在回想起来真是很危险。总之就是一个性格乖张的小孩子，同时也有着刚正不阿，嫉恶如仇的缺点，看电视时看到坏蛋干坏事会很气愤呢，希望有人狠狠地惩罚他们，声张正义。总之就是这样一个普通的小孩吧，想来性格的这些都是家里人的宠爱和在幼儿园无法无天塑造的，真是个不怎么样的孩子。\n但是即便这样也还是能交到几个好朋友的，至少在我如今的心里，他们还是我童年的好友，可惜自我转学之后就没怎么见过他们了，希望他们过得还好吧。在县城的小学读了几年后，家里为了更好的教育条件就去了城里，我和那片我快乐成长的土地基本上就分离了。到了城里后就是普通的接受教育、接受生活，认识到了很多和乡下不同的地方，因为我个人很好强，所以一个人上下学，母亲还因为这个很自豪，夸过我。在小学里就平平常常的读书，看坏同学欺负别人然后在内心深处瞧不起他们，但是没有出手，现在想想根本不嫉恶如仇呢，应该出手呢！说起来，因为性格比较古怪，别人欺负我或者我朋友，我一定会当场打回去绝对不会吃一点亏，老师在同学面前还郑重其事的开会说：“你们能和xxx玩的就玩，不能和他玩的就不要玩。”，我还为此伤心了好久，而且还流泪了。对了，前面忘说了我不知怎么是一个天生很敏感很感性的人，但是我不知道怎么表达我的情绪我就只好哭，所以我经常哭鼻子……小孩子都会这样吧……但是我的哪些好朋友并没有抛弃我，其中有一个还和我说“没事的，xxx，他们不和你玩，我和你玩！”他还指着一群人说“我带他们一起和你玩”，真的很令我感动，我现在也很想他，他现在看见我这样消沉会和我说什么呢？我希望他和我说“没事的，xxx，来，我帮你”。虽然老师那样孤立我，但是大家还是和我一起玩，我想是因为小孩子都比较单纯，而且善良大家不会拒绝我，而且因为我会帮他们“声张正义”吧，这里就让我小小的骄傲一下吧，因为我实在没什么成就了。我觉得我还是交到了不错的好朋友，里面还有后来我的初中同学，我们应该是好朋友吧，那时候肯定是，现在我也希望是但是我不知道和他说什么了……但是在我心中他是我的朋友，因为我们两个是朋友，我们两个的妈妈也成为了朋友，我妈妈还认识了他妈妈的其他朋友(虽然只认识了那一个，应该是一个吧)，我妈妈还感谢了我。这么一回想我倒是不缺朋友的，哈哈哈，应该是随了我父亲的优良特质。\n后来就上了初中，我的快乐就逐渐减少了，我的烦恼就慢慢的增加了，在初中我就开始思考了一些问题，我就开始思考人生，我开始思考人生的意义，将来自己该怎么办，人类是不是全部毁灭了会好一点……总之就会胡思乱想了，上了初中也从为了和同学找共同话题才看火影的一个人变成了二次元，那时候的二次元真好啊，我还记得我看命运石之门的感觉，二次元真的很美好啊。因为初中的课程比较简单我从这时候就养成了分心的坏习惯，校内作业没什么压力，整天就想着怎么玩，所以就是个中不溜的水准，在初中也是认识新朋友，其中印象深刻就是刚才提到的“朋友-妈妈”，还有一个家境不错的朋友，他父母对他期待很高，因为他家里算是暴发户吧，他父亲希望他学业有成能靠自己的知识创造财富，我们俩时常一起讨论二次元，在初二初三还一起讨论学习，他十分喜欢泰拳，不过我很瘦弱，这方面就只有听他再给我科普一样的感觉，他现在的泰拳我看打的应该不错吧，前几年见他都是一身的腱子肉了，明明个子很矮却十分强壮！还有一位是在大家面前宣布我是他最好的朋友，从那时候开始他就在我心中是最好的朋友了，额，我到现在还是这样一个幼稚的人哦，不然也不会落得这样一个下场吧，哈哈哈。额，怎么全是在讲朋友啊！因为实在想不起别的什么了，每天都是很无聊，面对没有师德的班主任，对学生的人生毫不在意，甚至残害，所以我也不知道说什么好，后来初中毕业没有听从班主任的建议，顺着我自己的心意去了全市最好的高中，在初二的时候我的父母就会让我自己做决定了，上哪个高中，读文读理都是我自己选的，现在想来我一塌糊涂的人生都是我自命不凡的自大选择所造就的可笑悲剧罢了。\n然后就上了高中，在这样一个流水线上，只有沉闷的工厂气氛，我熬夜打游戏上午睡觉，上课走神，思考人生的哲学问题，人的目标，生命的意义，我一边是课业一边是自己的天马行空，因为我之前的人生没有什么失败，所以在高中是个骄兵，我分心的坏习惯也在这里得到了最大的放大，自高二以后我上课就总是不能专心，同时因为初中的启蒙，我是一个富有正义感的人，对自己和他人有着较高的道德标准要求，我总是以着这个标准来要求自己和别人而我自己那时候并不自知，这样的行为准则令我很痛苦，令我周围的人不满，但是这是我的理想状态，我在其中得到满足，后来我的语文老师发现了我的这一系列行为，并点醒了我，后来为了缓解自己的痛苦我开始试着放松对别人的要求，但我唯独不能放过自己，因为我不甘心做一个腐儒。我面对世界和社会常常处于一种悲观的思考，我审视自己，审视别人，从社会热点事件中进行自我反思，社会思考，但我只是臆想，我想和实际应该是大相径庭的。\n我整日在萎靡的精神状态和疲惫的身体条件下，进行着流水线的分神，陷入自责，然后进行天马行空不着边际的胡思乱想，我看着窗框仿佛铁窗，我幻想自己在天空自由自在的飞翔，我幻想自己作为生命种群的微小个体同大我一同跨越漫长的宇宙银河探索生命的意义，就在我对传统文明的野蛮归训的思考反叛中，就在我疯狂绚丽的精神世界里，我看着自己的人生理想不能实现，我不能接受自己的失败，我倒下了，我开始郁郁寡欢，最后我在高三时没去上学，我病了。\n在我病的期间我放纵自己，我忘却了一切，我还是去参加了那场可以改变命运的高考，但是它什么都没有改变，只是终结了我的命运。\n上了大学，浪费四年，找不到工作，破防准备自杀！\n下棋休刊！","source":"_drafts/求救信.md","raw":"---\ntitle: 求救信\ndate: 2023-04-03 21:47:16\ntags:\n---\n\n这其实是一封求救信，我写下这些文字时，是准备自杀的，我已经有了自杀的想法，但是最终如何实施我还没有想法。但我内心深处还是不想死的所以这是一封求救信，如果你看到了这份信我很抱歉，没给你带去好心情，不过如果你是个残酷的人以我的死亡为乐那么咱们想必也没什么好说的。\n\n<!--more-->\n\n# 序\n\n没怎么写过信，也不知道谁会看到，从哪里说起呢……既然我都要从这个世界离开了，那这应该是我最后一次的表达了吧，那我就说的详细一点吧，我还是希望你好好听的，因为你再想听我讲可能就听不到了。\n\n# 我大概的一生\n\n我和大多数人一样都是一个普通的人，生在一个普通的东北县城，一个普通的家庭，普通的爱我的父母，小学时候应该还是很快乐的吧，但是我已经记不起来了，从小我就是一个性格古怪的孩子，家里人都叫我倔驴，平常就爱争强好胜，什么都喜欢当第一，因为我是独生子女，在家里没有别的参赛选手只有我一个人所以我总是第一。说起性格的缺点嘛，小时候最不服训，是一个刺头，别人来训我，我总是不服的，至今还记得为了好玩躲在粮食垛下，听家长急慌慌的样子，最后过了好久才出来，家里人很是生气训了我一顿，但是那时候还小不理解所以完全不服呢，哈哈哈，现在回想起来真是很危险。总之就是一个性格乖张的小孩子，同时也有着刚正不阿，嫉恶如仇的缺点，看电视时看到坏蛋干坏事会很气愤呢，希望有人狠狠地惩罚他们，声张正义。总之就是这样一个普通的小孩吧，想来性格的这些都是家里人的宠爱和在幼儿园无法无天塑造的，真是个不怎么样的孩子。\n但是即便这样也还是能交到几个好朋友的，至少在我如今的心里，他们还是我童年的好友，可惜自我转学之后就没怎么见过他们了，希望他们过得还好吧。在县城的小学读了几年后，家里为了更好的教育条件就去了城里，我和那片我快乐成长的土地基本上就分离了。到了城里后就是普通的接受教育、接受生活，认识到了很多和乡下不同的地方，因为我个人很好强，所以一个人上下学，母亲还因为这个很自豪，夸过我。在小学里就平平常常的读书，看坏同学欺负别人然后在内心深处瞧不起他们，但是没有出手，现在想想根本不嫉恶如仇呢，应该出手呢！说起来，因为性格比较古怪，别人欺负我或者我朋友，我一定会当场打回去绝对不会吃一点亏，老师在同学面前还郑重其事的开会说：“你们能和xxx玩的就玩，不能和他玩的就不要玩。”，我还为此伤心了好久，而且还流泪了。对了，前面忘说了我不知怎么是一个天生很敏感很感性的人，但是我不知道怎么表达我的情绪我就只好哭，所以我经常哭鼻子……小孩子都会这样吧……但是我的哪些好朋友并没有抛弃我，其中有一个还和我说“没事的，xxx，他们不和你玩，我和你玩！”他还指着一群人说“我带他们一起和你玩”，真的很令我感动，我现在也很想他，他现在看见我这样消沉会和我说什么呢？我希望他和我说“没事的，xxx，来，我帮你”。虽然老师那样孤立我，但是大家还是和我一起玩，我想是因为小孩子都比较单纯，而且善良大家不会拒绝我，而且因为我会帮他们“声张正义”吧，这里就让我小小的骄傲一下吧，因为我实在没什么成就了。我觉得我还是交到了不错的好朋友，里面还有后来我的初中同学，我们应该是好朋友吧，那时候肯定是，现在我也希望是但是我不知道和他说什么了……但是在我心中他是我的朋友，因为我们两个是朋友，我们两个的妈妈也成为了朋友，我妈妈还认识了他妈妈的其他朋友(虽然只认识了那一个，应该是一个吧)，我妈妈还感谢了我。这么一回想我倒是不缺朋友的，哈哈哈，应该是随了我父亲的优良特质。\n后来就上了初中，我的快乐就逐渐减少了，我的烦恼就慢慢的增加了，在初中我就开始思考了一些问题，我就开始思考人生，我开始思考人生的意义，将来自己该怎么办，人类是不是全部毁灭了会好一点……总之就会胡思乱想了，上了初中也从为了和同学找共同话题才看火影的一个人变成了二次元，那时候的二次元真好啊，我还记得我看命运石之门的感觉，二次元真的很美好啊。因为初中的课程比较简单我从这时候就养成了分心的坏习惯，校内作业没什么压力，整天就想着怎么玩，所以就是个中不溜的水准，在初中也是认识新朋友，其中印象深刻就是刚才提到的“朋友-妈妈”，还有一个家境不错的朋友，他父母对他期待很高，因为他家里算是暴发户吧，他父亲希望他学业有成能靠自己的知识创造财富，我们俩时常一起讨论二次元，在初二初三还一起讨论学习，他十分喜欢泰拳，不过我很瘦弱，这方面就只有听他再给我科普一样的感觉，他现在的泰拳我看打的应该不错吧，前几年见他都是一身的腱子肉了，明明个子很矮却十分强壮！还有一位是在大家面前宣布我是他最好的朋友，从那时候开始他就在我心中是最好的朋友了，额，我到现在还是这样一个幼稚的人哦，不然也不会落得这样一个下场吧，哈哈哈。额，怎么全是在讲朋友啊！因为实在想不起别的什么了，每天都是很无聊，面对没有师德的班主任，对学生的人生毫不在意，甚至残害，所以我也不知道说什么好，后来初中毕业没有听从班主任的建议，顺着我自己的心意去了全市最好的高中，在初二的时候我的父母就会让我自己做决定了，上哪个高中，读文读理都是我自己选的，现在想来我一塌糊涂的人生都是我自命不凡的自大选择所造就的可笑悲剧罢了。\n然后就上了高中，在这样一个流水线上，只有沉闷的工厂气氛，我熬夜打游戏上午睡觉，上课走神，思考人生的哲学问题，人的目标，生命的意义，我一边是课业一边是自己的天马行空，因为我之前的人生没有什么失败，所以在高中是个骄兵，我分心的坏习惯也在这里得到了最大的放大，自高二以后我上课就总是不能专心，同时因为初中的启蒙，我是一个富有正义感的人，对自己和他人有着较高的道德标准要求，我总是以着这个标准来要求自己和别人而我自己那时候并不自知，这样的行为准则令我很痛苦，令我周围的人不满，但是这是我的理想状态，我在其中得到满足，后来我的语文老师发现了我的这一系列行为，并点醒了我，后来为了缓解自己的痛苦我开始试着放松对别人的要求，但我唯独不能放过自己，因为我不甘心做一个腐儒。我面对世界和社会常常处于一种悲观的思考，我审视自己，审视别人，从社会热点事件中进行自我反思，社会思考，但我只是臆想，我想和实际应该是大相径庭的。\n我整日在萎靡的精神状态和疲惫的身体条件下，进行着流水线的分神，陷入自责，然后进行天马行空不着边际的胡思乱想，我看着窗框仿佛铁窗，我幻想自己在天空自由自在的飞翔，我幻想自己作为生命种群的微小个体同大我一同跨越漫长的宇宙银河探索生命的意义，就在我对传统文明的野蛮归训的思考反叛中，就在我疯狂绚丽的精神世界里，我看着自己的人生理想不能实现，我不能接受自己的失败，我倒下了，我开始郁郁寡欢，最后我在高三时没去上学，我病了。\n在我病的期间我放纵自己，我忘却了一切，我还是去参加了那场可以改变命运的高考，但是它什么都没有改变，只是终结了我的命运。\n上了大学，浪费四年，找不到工作，破防准备自杀！\n下棋休刊！","slug":"求救信","published":0,"updated":"2025-08-12T15:41:44.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cme8ppti8001qbkbw37jycdqc","content":"<p>这其实是一封求救信，我写下这些文字时，是准备自杀的，我已经有了自杀的想法，但是最终如何实施我还没有想法。但我内心深处还是不想死的所以这是一封求救信，如果你看到了这份信我很抱歉，没给你带去好心情，不过如果你是个残酷的人以我的死亡为乐那么咱们想必也没什么好说的。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"序\">序</h1>\r\n<p>没怎么写过信，也不知道谁会看到，从哪里说起呢……既然我都要从这个世界离开了，那这应该是我最后一次的表达了吧，那我就说的详细一点吧，我还是希望你好好听的，因为你再想听我讲可能就听不到了。</p>\r\n<h1 id=\"我大概的一生\">我大概的一生</h1>\r\n<p>我和大多数人一样都是一个普通的人，生在一个普通的东北县城，一个普通的家庭，普通的爱我的父母，小学时候应该还是很快乐的吧，但是我已经记不起来了，从小我就是一个性格古怪的孩子，家里人都叫我倔驴，平常就爱争强好胜，什么都喜欢当第一，因为我是独生子女，在家里没有别的参赛选手只有我一个人所以我总是第一。说起性格的缺点嘛，小时候最不服训，是一个刺头，别人来训我，我总是不服的，至今还记得为了好玩躲在粮食垛下，听家长急慌慌的样子，最后过了好久才出来，家里人很是生气训了我一顿，但是那时候还小不理解所以完全不服呢，哈哈哈，现在回想起来真是很危险。总之就是一个性格乖张的小孩子，同时也有着刚正不阿，嫉恶如仇的缺点，看电视时看到坏蛋干坏事会很气愤呢，希望有人狠狠地惩罚他们，声张正义。总之就是这样一个普通的小孩吧，想来性格的这些都是家里人的宠爱和在幼儿园无法无天塑造的，真是个不怎么样的孩子。\r\n但是即便这样也还是能交到几个好朋友的，至少在我如今的心里，他们还是我童年的好友，可惜自我转学之后就没怎么见过他们了，希望他们过得还好吧。在县城的小学读了几年后，家里为了更好的教育条件就去了城里，我和那片我快乐成长的土地基本上就分离了。到了城里后就是普通的接受教育、接受生活，认识到了很多和乡下不同的地方，因为我个人很好强，所以一个人上下学，母亲还因为这个很自豪，夸过我。在小学里就平平常常的读书，看坏同学欺负别人然后在内心深处瞧不起他们，但是没有出手，现在想想根本不嫉恶如仇呢，应该出手呢！说起来，因为性格比较古怪，别人欺负我或者我朋友，我一定会当场打回去绝对不会吃一点亏，老师在同学面前还郑重其事的开会说：“你们能和xxx玩的就玩，不能和他玩的就不要玩。”，我还为此伤心了好久，而且还流泪了。对了，前面忘说了我不知怎么是一个天生很敏感很感性的人，但是我不知道怎么表达我的情绪我就只好哭，所以我经常哭鼻子……小孩子都会这样吧……但是我的哪些好朋友并没有抛弃我，其中有一个还和我说“没事的，xxx，他们不和你玩，我和你玩！”他还指着一群人说“我带他们一起和你玩”，真的很令我感动，我现在也很想他，他现在看见我这样消沉会和我说什么呢？我希望他和我说“没事的，xxx，来，我帮你”。虽然老师那样孤立我，但是大家还是和我一起玩，我想是因为小孩子都比较单纯，而且善良大家不会拒绝我，而且因为我会帮他们“声张正义”吧，这里就让我小小的骄傲一下吧，因为我实在没什么成就了。我觉得我还是交到了不错的好朋友，里面还有后来我的初中同学，我们应该是好朋友吧，那时候肯定是，现在我也希望是但是我不知道和他说什么了……但是在我心中他是我的朋友，因为我们两个是朋友，我们两个的妈妈也成为了朋友，我妈妈还认识了他妈妈的其他朋友(虽然只认识了那一个，应该是一个吧)，我妈妈还感谢了我。这么一回想我倒是不缺朋友的，哈哈哈，应该是随了我父亲的优良特质。\r\n后来就上了初中，我的快乐就逐渐减少了，我的烦恼就慢慢的增加了，在初中我就开始思考了一些问题，我就开始思考人生，我开始思考人生的意义，将来自己该怎么办，人类是不是全部毁灭了会好一点……总之就会胡思乱想了，上了初中也从为了和同学找共同话题才看火影的一个人变成了二次元，那时候的二次元真好啊，我还记得我看命运石之门的感觉，二次元真的很美好啊。因为初中的课程比较简单我从这时候就养成了分心的坏习惯，校内作业没什么压力，整天就想着怎么玩，所以就是个中不溜的水准，在初中也是认识新朋友，其中印象深刻就是刚才提到的“朋友-妈妈”，还有一个家境不错的朋友，他父母对他期待很高，因为他家里算是暴发户吧，他父亲希望他学业有成能靠自己的知识创造财富，我们俩时常一起讨论二次元，在初二初三还一起讨论学习，他十分喜欢泰拳，不过我很瘦弱，这方面就只有听他再给我科普一样的感觉，他现在的泰拳我看打的应该不错吧，前几年见他都是一身的腱子肉了，明明个子很矮却十分强壮！还有一位是在大家面前宣布我是他最好的朋友，从那时候开始他就在我心中是最好的朋友了，额，我到现在还是这样一个幼稚的人哦，不然也不会落得这样一个下场吧，哈哈哈。额，怎么全是在讲朋友啊！因为实在想不起别的什么了，每天都是很无聊，面对没有师德的班主任，对学生的人生毫不在意，甚至残害，所以我也不知道说什么好，后来初中毕业没有听从班主任的建议，顺着我自己的心意去了全市最好的高中，在初二的时候我的父母就会让我自己做决定了，上哪个高中，读文读理都是我自己选的，现在想来我一塌糊涂的人生都是我自命不凡的自大选择所造就的可笑悲剧罢了。\r\n然后就上了高中，在这样一个流水线上，只有沉闷的工厂气氛，我熬夜打游戏上午睡觉，上课走神，思考人生的哲学问题，人的目标，生命的意义，我一边是课业一边是自己的天马行空，因为我之前的人生没有什么失败，所以在高中是个骄兵，我分心的坏习惯也在这里得到了最大的放大，自高二以后我上课就总是不能专心，同时因为初中的启蒙，我是一个富有正义感的人，对自己和他人有着较高的道德标准要求，我总是以着这个标准来要求自己和别人而我自己那时候并不自知，这样的行为准则令我很痛苦，令我周围的人不满，但是这是我的理想状态，我在其中得到满足，后来我的语文老师发现了我的这一系列行为，并点醒了我，后来为了缓解自己的痛苦我开始试着放松对别人的要求，但我唯独不能放过自己，因为我不甘心做一个腐儒。我面对世界和社会常常处于一种悲观的思考，我审视自己，审视别人，从社会热点事件中进行自我反思，社会思考，但我只是臆想，我想和实际应该是大相径庭的。\r\n我整日在萎靡的精神状态和疲惫的身体条件下，进行着流水线的分神，陷入自责，然后进行天马行空不着边际的胡思乱想，我看着窗框仿佛铁窗，我幻想自己在天空自由自在的飞翔，我幻想自己作为生命种群的微小个体同大我一同跨越漫长的宇宙银河探索生命的意义，就在我对传统文明的野蛮归训的思考反叛中，就在我疯狂绚丽的精神世界里，我看着自己的人生理想不能实现，我不能接受自己的失败，我倒下了，我开始郁郁寡欢，最后我在高三时没去上学，我病了。\r\n在我病的期间我放纵自己，我忘却了一切，我还是去参加了那场可以改变命运的高考，但是它什么都没有改变，只是终结了我的命运。\r\n上了大学，浪费四年，找不到工作，破防准备自杀！ 下棋休刊！</p>\r\n","site":{"data":{}},"excerpt":"<p>这其实是一封求救信，我写下这些文字时，是准备自杀的，我已经有了自杀的想法，但是最终如何实施我还没有想法。但我内心深处还是不想死的所以这是一封求救信，如果你看到了这份信我很抱歉，没给你带去好心情，不过如果你是个残酷的人以我的死亡为乐那么咱们想必也没什么好说的。</p>","more":"<h1 id=\"序\">序</h1>\r\n<p>没怎么写过信，也不知道谁会看到，从哪里说起呢……既然我都要从这个世界离开了，那这应该是我最后一次的表达了吧，那我就说的详细一点吧，我还是希望你好好听的，因为你再想听我讲可能就听不到了。</p>\r\n<h1 id=\"我大概的一生\">我大概的一生</h1>\r\n<p>我和大多数人一样都是一个普通的人，生在一个普通的东北县城，一个普通的家庭，普通的爱我的父母，小学时候应该还是很快乐的吧，但是我已经记不起来了，从小我就是一个性格古怪的孩子，家里人都叫我倔驴，平常就爱争强好胜，什么都喜欢当第一，因为我是独生子女，在家里没有别的参赛选手只有我一个人所以我总是第一。说起性格的缺点嘛，小时候最不服训，是一个刺头，别人来训我，我总是不服的，至今还记得为了好玩躲在粮食垛下，听家长急慌慌的样子，最后过了好久才出来，家里人很是生气训了我一顿，但是那时候还小不理解所以完全不服呢，哈哈哈，现在回想起来真是很危险。总之就是一个性格乖张的小孩子，同时也有着刚正不阿，嫉恶如仇的缺点，看电视时看到坏蛋干坏事会很气愤呢，希望有人狠狠地惩罚他们，声张正义。总之就是这样一个普通的小孩吧，想来性格的这些都是家里人的宠爱和在幼儿园无法无天塑造的，真是个不怎么样的孩子。\r\n但是即便这样也还是能交到几个好朋友的，至少在我如今的心里，他们还是我童年的好友，可惜自我转学之后就没怎么见过他们了，希望他们过得还好吧。在县城的小学读了几年后，家里为了更好的教育条件就去了城里，我和那片我快乐成长的土地基本上就分离了。到了城里后就是普通的接受教育、接受生活，认识到了很多和乡下不同的地方，因为我个人很好强，所以一个人上下学，母亲还因为这个很自豪，夸过我。在小学里就平平常常的读书，看坏同学欺负别人然后在内心深处瞧不起他们，但是没有出手，现在想想根本不嫉恶如仇呢，应该出手呢！说起来，因为性格比较古怪，别人欺负我或者我朋友，我一定会当场打回去绝对不会吃一点亏，老师在同学面前还郑重其事的开会说：“你们能和xxx玩的就玩，不能和他玩的就不要玩。”，我还为此伤心了好久，而且还流泪了。对了，前面忘说了我不知怎么是一个天生很敏感很感性的人，但是我不知道怎么表达我的情绪我就只好哭，所以我经常哭鼻子……小孩子都会这样吧……但是我的哪些好朋友并没有抛弃我，其中有一个还和我说“没事的，xxx，他们不和你玩，我和你玩！”他还指着一群人说“我带他们一起和你玩”，真的很令我感动，我现在也很想他，他现在看见我这样消沉会和我说什么呢？我希望他和我说“没事的，xxx，来，我帮你”。虽然老师那样孤立我，但是大家还是和我一起玩，我想是因为小孩子都比较单纯，而且善良大家不会拒绝我，而且因为我会帮他们“声张正义”吧，这里就让我小小的骄傲一下吧，因为我实在没什么成就了。我觉得我还是交到了不错的好朋友，里面还有后来我的初中同学，我们应该是好朋友吧，那时候肯定是，现在我也希望是但是我不知道和他说什么了……但是在我心中他是我的朋友，因为我们两个是朋友，我们两个的妈妈也成为了朋友，我妈妈还认识了他妈妈的其他朋友(虽然只认识了那一个，应该是一个吧)，我妈妈还感谢了我。这么一回想我倒是不缺朋友的，哈哈哈，应该是随了我父亲的优良特质。\r\n后来就上了初中，我的快乐就逐渐减少了，我的烦恼就慢慢的增加了，在初中我就开始思考了一些问题，我就开始思考人生，我开始思考人生的意义，将来自己该怎么办，人类是不是全部毁灭了会好一点……总之就会胡思乱想了，上了初中也从为了和同学找共同话题才看火影的一个人变成了二次元，那时候的二次元真好啊，我还记得我看命运石之门的感觉，二次元真的很美好啊。因为初中的课程比较简单我从这时候就养成了分心的坏习惯，校内作业没什么压力，整天就想着怎么玩，所以就是个中不溜的水准，在初中也是认识新朋友，其中印象深刻就是刚才提到的“朋友-妈妈”，还有一个家境不错的朋友，他父母对他期待很高，因为他家里算是暴发户吧，他父亲希望他学业有成能靠自己的知识创造财富，我们俩时常一起讨论二次元，在初二初三还一起讨论学习，他十分喜欢泰拳，不过我很瘦弱，这方面就只有听他再给我科普一样的感觉，他现在的泰拳我看打的应该不错吧，前几年见他都是一身的腱子肉了，明明个子很矮却十分强壮！还有一位是在大家面前宣布我是他最好的朋友，从那时候开始他就在我心中是最好的朋友了，额，我到现在还是这样一个幼稚的人哦，不然也不会落得这样一个下场吧，哈哈哈。额，怎么全是在讲朋友啊！因为实在想不起别的什么了，每天都是很无聊，面对没有师德的班主任，对学生的人生毫不在意，甚至残害，所以我也不知道说什么好，后来初中毕业没有听从班主任的建议，顺着我自己的心意去了全市最好的高中，在初二的时候我的父母就会让我自己做决定了，上哪个高中，读文读理都是我自己选的，现在想来我一塌糊涂的人生都是我自命不凡的自大选择所造就的可笑悲剧罢了。\r\n然后就上了高中，在这样一个流水线上，只有沉闷的工厂气氛，我熬夜打游戏上午睡觉，上课走神，思考人生的哲学问题，人的目标，生命的意义，我一边是课业一边是自己的天马行空，因为我之前的人生没有什么失败，所以在高中是个骄兵，我分心的坏习惯也在这里得到了最大的放大，自高二以后我上课就总是不能专心，同时因为初中的启蒙，我是一个富有正义感的人，对自己和他人有着较高的道德标准要求，我总是以着这个标准来要求自己和别人而我自己那时候并不自知，这样的行为准则令我很痛苦，令我周围的人不满，但是这是我的理想状态，我在其中得到满足，后来我的语文老师发现了我的这一系列行为，并点醒了我，后来为了缓解自己的痛苦我开始试着放松对别人的要求，但我唯独不能放过自己，因为我不甘心做一个腐儒。我面对世界和社会常常处于一种悲观的思考，我审视自己，审视别人，从社会热点事件中进行自我反思，社会思考，但我只是臆想，我想和实际应该是大相径庭的。\r\n我整日在萎靡的精神状态和疲惫的身体条件下，进行着流水线的分神，陷入自责，然后进行天马行空不着边际的胡思乱想，我看着窗框仿佛铁窗，我幻想自己在天空自由自在的飞翔，我幻想自己作为生命种群的微小个体同大我一同跨越漫长的宇宙银河探索生命的意义，就在我对传统文明的野蛮归训的思考反叛中，就在我疯狂绚丽的精神世界里，我看着自己的人生理想不能实现，我不能接受自己的失败，我倒下了，我开始郁郁寡欢，最后我在高三时没去上学，我病了。\r\n在我病的期间我放纵自己，我忘却了一切，我还是去参加了那场可以改变命运的高考，但是它什么都没有改变，只是终结了我的命运。\r\n上了大学，浪费四年，找不到工作，破防准备自杀！ 下棋休刊！</p>"},{"title":"C++ Note 1","math":true,"index_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","banner_img":"/imgs/Hexo主题变更/Shiki&Tsukihime.png","date":"2025-08-15T18:03:13.000Z","typora-root-url":"../","_content":"# C++ Note 1\n\n重新学C++了家人们，自从2023年毕业之后就碰了三个月cpp，后面去做技术美术写了一年的Shader和C# URP，Render Pipeline，但是 C++ 是我的心病，就得学 C++，卧槽，拦不住的。\n\n## 什么是面向对象？\n\n面向对象是相对面对过程而言，通过类和对象的设计，封装、继承、多态的特性进行开发。  \n即以对象为核心，通过对象封装**数据**和**行为(函数)**。  \n其中核心特性：封装、继承、多态。  \n\n### 封装：   \n将**数据**和**函数**封存在类内，**隐藏内部细节**，只暴露出必要的部分，  \n尽量避免外部的直接修改。  \n通过public 方法尽量做到安全访问。  \n所有类的设计都应该是一个封装的过程。\n\n### 继承:  \n子类能够复用父类方法，实现代码复用。  \n继承的情况：  \n\n* 单一继承：子类只有一个父类\n\n* 多个继承：子类多个父类，如果父类有相同的成员，需要在子类中使用类名限定。  \n  ~~~c++\n  class A\n  {\n      public:\n      int age;\n      A()\n      {\n          age = 1;\n      }\n  };\n  \n  class B\n  {\n      public:\n      int age;\n      B()\n      {\n          age = 2;\n      }\n  };\n  \n  class C : public A, public B\n  {\n      public :\n      int age;\n      C()\n      {\n          age = 3;\n      }\n  };\n  \n  C c = C();\n  // c.age 3\n  // c.B::age 2\n  // c.A::age 1\n  ~~~\n\n* 菱形继承：1-n-1 的继承方式，通过使用虚函数进行虚继承来解决  \n  ~~~C++\n  // ERROR\n  class GrandFather\n  {\n      public:\n          int age;\n          GrandFather(){ age = 100; }\n  };\n  \n  class Father1 : public GrandFather{};\n  class Father2 : public GrandFather{};\n  class Son : public Father1, public Father2{}\n  \n  int main()\n  {\n      Son p;\n      p.age = 12;\n      cout << p.age << endl;\n      return 0;\n  }\n  ~~~\n\n  这个例子会报错，因为编译器不知道age是哪个作用域下的age，不知道是Father1还是Father2的，我们可以指定作用域。  \n  ~~~C++\n  int main()\n  {\n      Son p;\n      p.Father1::age = 12;\n      p.Father2::age = 23;\n      cout << p.Father1::age << endl;\n      cout << p.Father2::age << endl;\n      return 0;\n  }\n  ~~~\n\n  但是这种解决办法缺少实际意义，我们往往需要的是son只有一个age属性即可。\n  使用`virtual`  \n\n  ~~~C++\n  class GrandFather\n  {\n      public:\n          int age;\n          GrandFather(){ age = 100; }\n  };\n  \n  class Father1 : virtual public GrandFather{};\n  class Father2 : virtual public GrandFather{};\n  class Son : public Father1, public Father2{}\n  \n  int main()\n  {\n      Son p;\n      p.Father1::age = 12;\n      p.Father2::age = 22;\n      cout << p.age << endl;                // 22\n      cout << p.Father1::age << endl;        // 22\n      cout << p.Father2::age << endl;        // 22\n      return 0;\n  }\n  ~~~\n\n  结果会是三个`22`，因为son中只有一个age了。\n  [l菱形继承](https://zhuanlan.zhihu.com/p/395173418)  \n  通过在子类中vbptr指向**虚基类表**，通过读取**虚基类表存储的偏移量，计算目标地址**。  \n  ![](/imgs/C++/虚继承.jpg)  \n  虚基类表存储了内存偏移，使得有菱形继承的子类能够将爷爷的成员存储的相同地址。\n\n### 多态\n\n多态的核心思想就是为不同数据类型的实体提供统一的接口，  \n使得统一操作在面对不同类型的对象时采取不同的行为。  \n比如两个继承同一父类的子类对象，对父类的虚函数的可能有不同的实现方案。  \nC++ 中多态分为静态多态和动态多态。\n\n#### 静态多态\n\n通过**函数重载、运算符重载、模板**实现，可以在编译阶段确定函数调用。\n\n#### 动态多态\n\n通过**虚函数、继承、基类指针、引用**实现，在运行过程中动态绑定函数调用\n\n## 虚函数\n\n在基类中能够使用 `virtual` 修饰成员函数，允许子类重写该函数改变函数行为。\n\n在深入虚函数之前需要对 C++ 的 [内存布局](#内存布局) 有一定的了解。\n\n## 内存布局\n\n*代码段、数据段、BSS 段(Block Started by Symbol)、Heap、Stack*\n\n### 代码段\n\n- 存储程序编译后的机器指令（函数体二进制代码）\n- 特性：只读，防止指令被意外修改\n\n### 数据段\n\n- 存储**已初始化的全局变量、静态变量、常量字符串**\n\n### BSS 段(Block Started by Symbol)\n\n* **未初始化的全局变量、静态变量（C++ 中默认初始化为 0）**  \n\n* 不占用空间，程序加载到内存后，由操作系统自动初始化为0（清零）\n\n### Heap\n\n- 动态内存分配区域，通过 `new/malloc` 管理\n\n### Stack\n\n- 自动管理临时数据的区域，由编译器控制\n- 特性\n  - 地址**从高到低增长**\n  - 存储**局部变量、函数参数、返回地址、临时对象**\n  - 每个函数调用创建独立的**栈帧（Stack Frame）**\n  - 栈溢出（Stack Overflow）风险（如递归过深）\n\n### 关于对象的内存布局\n\n一不包含静态函数，只有普通成员函数的类：  \n~~~c++\nclass Base\n{\npublic:\n\tvoid fun_a()\n    {\n\t}\n    \n    void fun_b()\n    {\n    }\n    \n    int a;\n};\n~~~\n\n~~~mermaid\ngraph LR\nA[方形] -->B[\"fun_a()\nfun_b()\"]\nC[堆] --> D[a:int]\n~~~\n\n","source":"_posts/C++Note_1.md","raw":"---\ntitle: C++ Note 1\nmath: true\ntags: [C++]\nindex_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\nbanner_img: /imgs/Hexo主题变更/Shiki&Tsukihime.png\ndate: 2025-08-16 02:03:13\ntypora-root-url: ../\n---\n# C++ Note 1\n\n重新学C++了家人们，自从2023年毕业之后就碰了三个月cpp，后面去做技术美术写了一年的Shader和C# URP，Render Pipeline，但是 C++ 是我的心病，就得学 C++，卧槽，拦不住的。\n\n## 什么是面向对象？\n\n面向对象是相对面对过程而言，通过类和对象的设计，封装、继承、多态的特性进行开发。  \n即以对象为核心，通过对象封装**数据**和**行为(函数)**。  \n其中核心特性：封装、继承、多态。  \n\n### 封装：   \n将**数据**和**函数**封存在类内，**隐藏内部细节**，只暴露出必要的部分，  \n尽量避免外部的直接修改。  \n通过public 方法尽量做到安全访问。  \n所有类的设计都应该是一个封装的过程。\n\n### 继承:  \n子类能够复用父类方法，实现代码复用。  \n继承的情况：  \n\n* 单一继承：子类只有一个父类\n\n* 多个继承：子类多个父类，如果父类有相同的成员，需要在子类中使用类名限定。  \n  ~~~c++\n  class A\n  {\n      public:\n      int age;\n      A()\n      {\n          age = 1;\n      }\n  };\n  \n  class B\n  {\n      public:\n      int age;\n      B()\n      {\n          age = 2;\n      }\n  };\n  \n  class C : public A, public B\n  {\n      public :\n      int age;\n      C()\n      {\n          age = 3;\n      }\n  };\n  \n  C c = C();\n  // c.age 3\n  // c.B::age 2\n  // c.A::age 1\n  ~~~\n\n* 菱形继承：1-n-1 的继承方式，通过使用虚函数进行虚继承来解决  \n  ~~~C++\n  // ERROR\n  class GrandFather\n  {\n      public:\n          int age;\n          GrandFather(){ age = 100; }\n  };\n  \n  class Father1 : public GrandFather{};\n  class Father2 : public GrandFather{};\n  class Son : public Father1, public Father2{}\n  \n  int main()\n  {\n      Son p;\n      p.age = 12;\n      cout << p.age << endl;\n      return 0;\n  }\n  ~~~\n\n  这个例子会报错，因为编译器不知道age是哪个作用域下的age，不知道是Father1还是Father2的，我们可以指定作用域。  \n  ~~~C++\n  int main()\n  {\n      Son p;\n      p.Father1::age = 12;\n      p.Father2::age = 23;\n      cout << p.Father1::age << endl;\n      cout << p.Father2::age << endl;\n      return 0;\n  }\n  ~~~\n\n  但是这种解决办法缺少实际意义，我们往往需要的是son只有一个age属性即可。\n  使用`virtual`  \n\n  ~~~C++\n  class GrandFather\n  {\n      public:\n          int age;\n          GrandFather(){ age = 100; }\n  };\n  \n  class Father1 : virtual public GrandFather{};\n  class Father2 : virtual public GrandFather{};\n  class Son : public Father1, public Father2{}\n  \n  int main()\n  {\n      Son p;\n      p.Father1::age = 12;\n      p.Father2::age = 22;\n      cout << p.age << endl;                // 22\n      cout << p.Father1::age << endl;        // 22\n      cout << p.Father2::age << endl;        // 22\n      return 0;\n  }\n  ~~~\n\n  结果会是三个`22`，因为son中只有一个age了。\n  [l菱形继承](https://zhuanlan.zhihu.com/p/395173418)  \n  通过在子类中vbptr指向**虚基类表**，通过读取**虚基类表存储的偏移量，计算目标地址**。  \n  ![](/imgs/C++/虚继承.jpg)  \n  虚基类表存储了内存偏移，使得有菱形继承的子类能够将爷爷的成员存储的相同地址。\n\n### 多态\n\n多态的核心思想就是为不同数据类型的实体提供统一的接口，  \n使得统一操作在面对不同类型的对象时采取不同的行为。  \n比如两个继承同一父类的子类对象，对父类的虚函数的可能有不同的实现方案。  \nC++ 中多态分为静态多态和动态多态。\n\n#### 静态多态\n\n通过**函数重载、运算符重载、模板**实现，可以在编译阶段确定函数调用。\n\n#### 动态多态\n\n通过**虚函数、继承、基类指针、引用**实现，在运行过程中动态绑定函数调用\n\n## 虚函数\n\n在基类中能够使用 `virtual` 修饰成员函数，允许子类重写该函数改变函数行为。\n\n在深入虚函数之前需要对 C++ 的 [内存布局](#内存布局) 有一定的了解。\n\n## 内存布局\n\n*代码段、数据段、BSS 段(Block Started by Symbol)、Heap、Stack*\n\n### 代码段\n\n- 存储程序编译后的机器指令（函数体二进制代码）\n- 特性：只读，防止指令被意外修改\n\n### 数据段\n\n- 存储**已初始化的全局变量、静态变量、常量字符串**\n\n### BSS 段(Block Started by Symbol)\n\n* **未初始化的全局变量、静态变量（C++ 中默认初始化为 0）**  \n\n* 不占用空间，程序加载到内存后，由操作系统自动初始化为0（清零）\n\n### Heap\n\n- 动态内存分配区域，通过 `new/malloc` 管理\n\n### Stack\n\n- 自动管理临时数据的区域，由编译器控制\n- 特性\n  - 地址**从高到低增长**\n  - 存储**局部变量、函数参数、返回地址、临时对象**\n  - 每个函数调用创建独立的**栈帧（Stack Frame）**\n  - 栈溢出（Stack Overflow）风险（如递归过深）\n\n### 关于对象的内存布局\n\n一不包含静态函数，只有普通成员函数的类：  \n~~~c++\nclass Base\n{\npublic:\n\tvoid fun_a()\n    {\n\t}\n    \n    void fun_b()\n    {\n    }\n    \n    int a;\n};\n~~~\n\n~~~mermaid\ngraph LR\nA[方形] -->B[\"fun_a()\nfun_b()\"]\nC[堆] --> D[a:int]\n~~~\n\n","slug":"C++Note_1","published":1,"updated":"2025-08-17T17:28:55.569Z","_id":"cmed519pa00006sbw74ia3zg8","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"c-note-1\">C++ Note 1</h1>\r\n<p>重新学C++了家人们，自从2023年毕业之后就碰了三个月cpp，后面去做技术美术写了一年的Shader和C#\r\nURP，Render Pipeline，但是 C++ 是我的心病，就得学\r\nC++，卧槽，拦不住的。</p>\r\n<h2 id=\"什么是面向对象\">什么是面向对象？</h2>\r\n<p>面向对象是相对面对过程而言，通过类和对象的设计，封装、继承、多态的特性进行开发。<br />\r\n即以对象为核心，通过对象封装<strong>数据</strong>和<strong>行为(函数)</strong>。<br />\r\n其中核心特性：封装、继承、多态。</p>\r\n<h3 id=\"封装\">封装：</h3>\r\n<p>将<strong>数据</strong>和<strong>函数</strong>封存在类内，<strong>隐藏内部细节</strong>，只暴露出必要的部分，<br />\r\n尽量避免外部的直接修改。<br />\r\n通过public 方法尽量做到安全访问。<br />\r\n所有类的设计都应该是一个封装的过程。</p>\r\n<h3 id=\"继承\">继承:</h3>\r\n<p>子类能够复用父类方法，实现代码复用。<br />\r\n继承的情况：</p>\r\n<ul>\r\n<li><p>单一继承：子类只有一个父类</p></li>\r\n<li><p>多个继承：子类多个父类，如果父类有相同的成员，需要在子类中使用类名限定。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-type\">int</span> age;<br>    <span class=\"hljs-built_in\">A</span>()<br>    &#123;<br>        age = <span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-type\">int</span> age;<br>    <span class=\"hljs-built_in\">B</span>()<br>    &#123;<br>        age = <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">C</span> : <span class=\"hljs-keyword\">public</span> A, <span class=\"hljs-keyword\">public</span> B<br>&#123;<br>    <span class=\"hljs-keyword\">public</span> :<br>    <span class=\"hljs-type\">int</span> age;<br>    <span class=\"hljs-built_in\">C</span>()<br>    &#123;<br>        age = <span class=\"hljs-number\">3</span>;<br>    &#125;<br>&#125;;<br><br>C c = <span class=\"hljs-built_in\">C</span>();<br><span class=\"hljs-comment\">// c.age 3</span><br><span class=\"hljs-comment\">// c.B::age 2</span><br><span class=\"hljs-comment\">// c.A::age 1</span><br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>菱形继承：1-n-1 的继承方式，通过使用虚函数进行虚继承来解决<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// ERROR</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GrandFather</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-type\">int</span> age;<br>        <span class=\"hljs-built_in\">GrandFather</span>()&#123; age = <span class=\"hljs-number\">100</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Father1</span> : <span class=\"hljs-keyword\">public</span> GrandFather&#123;&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Father2</span> : <span class=\"hljs-keyword\">public</span> GrandFather&#123;&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Son</span> : <span class=\"hljs-keyword\">public</span> Father1, <span class=\"hljs-keyword\">public</span> Father2&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Son p;<br>    p.age = <span class=\"hljs-number\">12</span>;<br>    cout &lt;&lt; p.age &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>这个例子会报错，因为编译器不知道age是哪个作用域下的age，不知道是Father1还是Father2的，我们可以指定作用域。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Son p;<br>    p.Father1::age = <span class=\"hljs-number\">12</span>;<br>    p.Father2::age = <span class=\"hljs-number\">23</span>;<br>    cout &lt;&lt; p.Father1::age &lt;&lt; endl;<br>    cout &lt;&lt; p.Father2::age &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>但是这种解决办法缺少实际意义，我们往往需要的是son只有一个age属性即可。\r\n使用<code>virtual</code></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GrandFather</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-type\">int</span> age;<br>        <span class=\"hljs-built_in\">GrandFather</span>()&#123; age = <span class=\"hljs-number\">100</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Father1</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> GrandFather&#123;&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Father2</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> GrandFather&#123;&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Son</span> : <span class=\"hljs-keyword\">public</span> Father1, <span class=\"hljs-keyword\">public</span> Father2&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Son p;<br>    p.Father1::age = <span class=\"hljs-number\">12</span>;<br>    p.Father2::age = <span class=\"hljs-number\">22</span>;<br>    cout &lt;&lt; p.age &lt;&lt; endl;                <span class=\"hljs-comment\">// 22</span><br>    cout &lt;&lt; p.Father1::age &lt;&lt; endl;        <span class=\"hljs-comment\">// 22</span><br>    cout &lt;&lt; p.Father2::age &lt;&lt; endl;        <span class=\"hljs-comment\">// 22</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>结果会是三个<code>22</code>，因为son中只有一个age了。 <a\r\nhref=\"https://zhuanlan.zhihu.com/p/395173418\">l菱形继承</a><br />\r\n通过在子类中vbptr指向<strong>虚基类表</strong>，通过读取<strong>虚基类表存储的偏移量，计算目标地址</strong>。<br />\r\n<img src=\"/imgs/C++/虚继承.jpg\" /><br />\r\n虚基类表存储了内存偏移，使得有菱形继承的子类能够将爷爷的成员存储的相同地址。</p></li>\r\n</ul>\r\n<h3 id=\"多态\">多态</h3>\r\n<p>多态的核心思想就是为不同数据类型的实体提供统一的接口，<br />\r\n使得统一操作在面对不同类型的对象时采取不同的行为。<br />\r\n比如两个继承同一父类的子类对象，对父类的虚函数的可能有不同的实现方案。<br />\r\nC++ 中多态分为静态多态和动态多态。</p>\r\n<h4 id=\"静态多态\">静态多态</h4>\r\n<p>通过<strong>函数重载、运算符重载、模板</strong>实现，可以在编译阶段确定函数调用。</p>\r\n<h4 id=\"动态多态\">动态多态</h4>\r\n<p>通过<strong>虚函数、继承、基类指针、引用</strong>实现，在运行过程中动态绑定函数调用</p>\r\n<h2 id=\"虚函数\">虚函数</h2>\r\n<p>在基类中能够使用 <code>virtual</code>\r\n修饰成员函数，允许子类重写该函数改变函数行为。</p>\r\n<p>在深入虚函数之前需要对 C++ 的 <a href=\"#内存布局\">内存布局</a>\r\n有一定的了解。</p>\r\n<h2 id=\"内存布局\">内存布局</h2>\r\n<p><em>代码段、数据段、BSS 段(Block Started by\r\nSymbol)、Heap、Stack</em></p>\r\n<h3 id=\"代码段\">代码段</h3>\r\n<ul>\r\n<li>存储程序编译后的机器指令（函数体二进制代码）</li>\r\n<li>特性：只读，防止指令被意外修改</li>\r\n</ul>\r\n<h3 id=\"数据段\">数据段</h3>\r\n<ul>\r\n<li>存储<strong>已初始化的全局变量、静态变量、常量字符串</strong></li>\r\n</ul>\r\n<h3 id=\"bss-段block-started-by-symbol\">BSS 段(Block Started by\r\nSymbol)</h3>\r\n<ul>\r\n<li><p><strong>未初始化的全局变量、静态变量（C++ 中默认初始化为\r\n0）</strong></p></li>\r\n<li><p>不占用空间，程序加载到内存后，由操作系统自动初始化为0（清零）</p></li>\r\n</ul>\r\n<h3 id=\"heap\">Heap</h3>\r\n<ul>\r\n<li>动态内存分配区域，通过 <code>new/malloc</code> 管理</li>\r\n</ul>\r\n<h3 id=\"stack\">Stack</h3>\r\n<ul>\r\n<li>自动管理临时数据的区域，由编译器控制</li>\r\n<li>特性\r\n<ul>\r\n<li>地址<strong>从高到低增长</strong></li>\r\n<li>存储<strong>局部变量、函数参数、返回地址、临时对象</strong></li>\r\n<li>每个函数调用创建独立的<strong>栈帧（Stack Frame）</strong></li>\r\n<li>栈溢出（Stack Overflow）风险（如递归过深）</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"关于对象的内存布局\">关于对象的内存布局</h3>\r\n<p>一不包含静态函数，只有普通成员函数的类：<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fun_a</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>\t&#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fun_b</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>    &#125;<br>    <br>    <span class=\"hljs-type\">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<pre><code class=\" mermaid\">graph LR\nA[方形] --&gt;B[&quot;fun_a()\nfun_b()&quot;]\nC[堆] --&gt; D[a:int]\n</code></pre>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"c-note-1\">C++ Note 1</h1>\r\n<p>重新学C++了家人们，自从2023年毕业之后就碰了三个月cpp，后面去做技术美术写了一年的Shader和C#\r\nURP，Render Pipeline，但是 C++ 是我的心病，就得学\r\nC++，卧槽，拦不住的。</p>\r\n<h2 id=\"什么是面向对象\">什么是面向对象？</h2>\r\n<p>面向对象是相对面对过程而言，通过类和对象的设计，封装、继承、多态的特性进行开发。<br />\r\n即以对象为核心，通过对象封装<strong>数据</strong>和<strong>行为(函数)</strong>。<br />\r\n其中核心特性：封装、继承、多态。</p>\r\n<h3 id=\"封装\">封装：</h3>\r\n<p>将<strong>数据</strong>和<strong>函数</strong>封存在类内，<strong>隐藏内部细节</strong>，只暴露出必要的部分，<br />\r\n尽量避免外部的直接修改。<br />\r\n通过public 方法尽量做到安全访问。<br />\r\n所有类的设计都应该是一个封装的过程。</p>\r\n<h3 id=\"继承\">继承:</h3>\r\n<p>子类能够复用父类方法，实现代码复用。<br />\r\n继承的情况：</p>\r\n<ul>\r\n<li><p>单一继承：子类只有一个父类</p></li>\r\n<li><p>多个继承：子类多个父类，如果父类有相同的成员，需要在子类中使用类名限定。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-type\">int</span> age;<br>    <span class=\"hljs-built_in\">A</span>()<br>    &#123;<br>        age = <span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-type\">int</span> age;<br>    <span class=\"hljs-built_in\">B</span>()<br>    &#123;<br>        age = <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">C</span> : <span class=\"hljs-keyword\">public</span> A, <span class=\"hljs-keyword\">public</span> B<br>&#123;<br>    <span class=\"hljs-keyword\">public</span> :<br>    <span class=\"hljs-type\">int</span> age;<br>    <span class=\"hljs-built_in\">C</span>()<br>    &#123;<br>        age = <span class=\"hljs-number\">3</span>;<br>    &#125;<br>&#125;;<br><br>C c = <span class=\"hljs-built_in\">C</span>();<br><span class=\"hljs-comment\">// c.age 3</span><br><span class=\"hljs-comment\">// c.B::age 2</span><br><span class=\"hljs-comment\">// c.A::age 1</span><br></code></pre></td></tr></table></figure></p></li>\r\n<li><p>菱形继承：1-n-1 的继承方式，通过使用虚函数进行虚继承来解决<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// ERROR</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GrandFather</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-type\">int</span> age;<br>        <span class=\"hljs-built_in\">GrandFather</span>()&#123; age = <span class=\"hljs-number\">100</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Father1</span> : <span class=\"hljs-keyword\">public</span> GrandFather&#123;&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Father2</span> : <span class=\"hljs-keyword\">public</span> GrandFather&#123;&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Son</span> : <span class=\"hljs-keyword\">public</span> Father1, <span class=\"hljs-keyword\">public</span> Father2&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Son p;<br>    p.age = <span class=\"hljs-number\">12</span>;<br>    cout &lt;&lt; p.age &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>这个例子会报错，因为编译器不知道age是哪个作用域下的age，不知道是Father1还是Father2的，我们可以指定作用域。<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Son p;<br>    p.Father1::age = <span class=\"hljs-number\">12</span>;<br>    p.Father2::age = <span class=\"hljs-number\">23</span>;<br>    cout &lt;&lt; p.Father1::age &lt;&lt; endl;<br>    cout &lt;&lt; p.Father2::age &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\r\n<p>但是这种解决办法缺少实际意义，我们往往需要的是son只有一个age属性即可。\r\n使用<code>virtual</code></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GrandFather</span><br>&#123;<br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-type\">int</span> age;<br>        <span class=\"hljs-built_in\">GrandFather</span>()&#123; age = <span class=\"hljs-number\">100</span>; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Father1</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> GrandFather&#123;&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Father2</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> GrandFather&#123;&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Son</span> : <span class=\"hljs-keyword\">public</span> Father1, <span class=\"hljs-keyword\">public</span> Father2&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Son p;<br>    p.Father1::age = <span class=\"hljs-number\">12</span>;<br>    p.Father2::age = <span class=\"hljs-number\">22</span>;<br>    cout &lt;&lt; p.age &lt;&lt; endl;                <span class=\"hljs-comment\">// 22</span><br>    cout &lt;&lt; p.Father1::age &lt;&lt; endl;        <span class=\"hljs-comment\">// 22</span><br>    cout &lt;&lt; p.Father2::age &lt;&lt; endl;        <span class=\"hljs-comment\">// 22</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\r\n<p>结果会是三个<code>22</code>，因为son中只有一个age了。 <a\r\nhref=\"https://zhuanlan.zhihu.com/p/395173418\">l菱形继承</a><br />\r\n通过在子类中vbptr指向<strong>虚基类表</strong>，通过读取<strong>虚基类表存储的偏移量，计算目标地址</strong>。<br />\r\n<img src=\"/imgs/C++/虚继承.jpg\" /><br />\r\n虚基类表存储了内存偏移，使得有菱形继承的子类能够将爷爷的成员存储的相同地址。</p></li>\r\n</ul>\r\n<h3 id=\"多态\">多态</h3>\r\n<p>多态的核心思想就是为不同数据类型的实体提供统一的接口，<br />\r\n使得统一操作在面对不同类型的对象时采取不同的行为。<br />\r\n比如两个继承同一父类的子类对象，对父类的虚函数的可能有不同的实现方案。<br />\r\nC++ 中多态分为静态多态和动态多态。</p>\r\n<h4 id=\"静态多态\">静态多态</h4>\r\n<p>通过<strong>函数重载、运算符重载、模板</strong>实现，可以在编译阶段确定函数调用。</p>\r\n<h4 id=\"动态多态\">动态多态</h4>\r\n<p>通过<strong>虚函数、继承、基类指针、引用</strong>实现，在运行过程中动态绑定函数调用</p>\r\n<h2 id=\"虚函数\">虚函数</h2>\r\n<p>在基类中能够使用 <code>virtual</code>\r\n修饰成员函数，允许子类重写该函数改变函数行为。</p>\r\n<p>在深入虚函数之前需要对 C++ 的 <a href=\"#内存布局\">内存布局</a>\r\n有一定的了解。</p>\r\n<h2 id=\"内存布局\">内存布局</h2>\r\n<p><em>代码段、数据段、BSS 段(Block Started by\r\nSymbol)、Heap、Stack</em></p>\r\n<h3 id=\"代码段\">代码段</h3>\r\n<ul>\r\n<li>存储程序编译后的机器指令（函数体二进制代码）</li>\r\n<li>特性：只读，防止指令被意外修改</li>\r\n</ul>\r\n<h3 id=\"数据段\">数据段</h3>\r\n<ul>\r\n<li>存储<strong>已初始化的全局变量、静态变量、常量字符串</strong></li>\r\n</ul>\r\n<h3 id=\"bss-段block-started-by-symbol\">BSS 段(Block Started by\r\nSymbol)</h3>\r\n<ul>\r\n<li><p><strong>未初始化的全局变量、静态变量（C++ 中默认初始化为\r\n0）</strong></p></li>\r\n<li><p>不占用空间，程序加载到内存后，由操作系统自动初始化为0（清零）</p></li>\r\n</ul>\r\n<h3 id=\"heap\">Heap</h3>\r\n<ul>\r\n<li>动态内存分配区域，通过 <code>new/malloc</code> 管理</li>\r\n</ul>\r\n<h3 id=\"stack\">Stack</h3>\r\n<ul>\r\n<li>自动管理临时数据的区域，由编译器控制</li>\r\n<li>特性\r\n<ul>\r\n<li>地址<strong>从高到低增长</strong></li>\r\n<li>存储<strong>局部变量、函数参数、返回地址、临时对象</strong></li>\r\n<li>每个函数调用创建独立的<strong>栈帧（Stack Frame）</strong></li>\r\n<li>栈溢出（Stack Overflow）风险（如递归过深）</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"关于对象的内存布局\">关于对象的内存布局</h3>\r\n<p>一不包含静态函数，只有普通成员函数的类：<br />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fun_a</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>\t&#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fun_b</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>    &#125;<br>    <br>    <span class=\"hljs-type\">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph LR<br>A[方形] --&gt;B[&quot;fun_a()<br>fun_b()&quot;]<br>C[堆] --&gt; D[a:int]<br></code></pre></td></tr></table></figure>\r\n"},{"title":"何为犬儒主义","math":true,"index_img":null,"banner_img":null,"date":"2025-08-17T08:23:10.000Z","typora-root-url":"../","_content":"\n“我希望你闪到一边，不要挡住我的阳光。”\n\n“我若不是亚历山大，我愿是第欧根尼。”  \n<!--more-->\n\n# 何为犬儒主义\n\n## 安提斯泰尼、第欧根尼、犬儒主义\n\n安提斯泰尼 其实是犬儒主义的开山鼻祖，是苏格拉底的学生。  \n第欧根尼在旅行中遇到了安提斯泰尼，想拜他为师，但是安提斯泰尼不喜欢他，因为第欧根尼曾涂改货币导致第欧根尼的父亲入狱。  \n但是第欧根尼的倔强打动了他，安提斯泰尼提出了犬儒主义，第欧根尼则是有名的践行者。\n\n> 人的苦痛有两种，一种源于物质，一种源于精神。精神上的幸福快乐才是真正的快乐满足，人当摆脱世俗的利益去追求唯一值得拥有的善。\n>\n> 犬儒主义\n\n### 第欧根尼\n\n在公元前4世纪，一位银行家的儿子通过伪造硬币使锡诺佩市陷入丑闻。当尘埃落定之后，这位名叫第欧根尼的年轻人被剥夺了 国籍，钱和所有财产。  \n至少，故事就是这样发展的。尽管戴第欧根尼的许多细节鲜为人知，但因他的耻辱而产生的哲学思想在今天仍然存在。  \n在流放中，第欧根尼（Diogenes）相信通过拒绝他人的意见和社会衡量成功的标准，他可以真正获得自由。他将过着自给自足的生活，亲近大自然，不主张物质主义，没有虚荣心或顺从性。  \n在实践中，这意味着他在希腊的城市中流浪了很多年，除了斗篷，拐杖和面包袋外什么都没有，一年四季都在外，不使用技术，不洗澡也不吃熟食。他并没有悄悄地追求这种新的存在方式，据说他取笑路人，并在公共场合通过模仿 那些有权势的人吃饭，小便，甚至自慰来嘲笑他们。  \n市民称他为 kyôn——一种狂吠的狗。虽然是一种侮辱，但实际上狗是他哲学的一个很好的象征——它们是快乐的动物，不被财富或声誉之类的抽象概念束缚。  \n第欧根尼和他越来越多的追随者被称为“狗哲学家”或“ kynikoi”，这一称号最终成为“犬儒主义”一词。这些早期的犬儒主义者无拘无束，被流浪的生活方式所吸引。  \n随着戴奥真尼斯声誉的提高，其他人试图挑战他的信仰。亚历山大大帝向他提供了他想要的任何东西。  \n但是，第欧根尼（Diogenes）并没有要求任何物资，而是要求亚历山大闪到一边去，不要遮住他的阳光。第欧根尼死后，在接下来的900年，坚持他的哲学的人继续称自己为犬儒主义者，直到500 CE。  \n一些希腊哲学家，例如斯多葛派（Stoics），认为每个人都应该效法第欧根尼。他们还试图柔和他的哲学，使其更能被传统社会接受，这当然与他的作法根本背道而驰。  \n其他人则不那么乐于接受 犬儒主义者。讽刺作家卢西安（Lucian）在公元2世纪在罗马的叙利亚省中，将自己时代的犬儒主义者描述为无原则，唯物主义，自我推广的伪君子，他们只宣讲了第欧根尼曾经真正实践过的东西。  \n几个世纪后，文艺复兴与宗教改革派作家阅读卢西安的著作，称他们的竞争对手为犬儒主义作为侮辱，指那些用毫无价值的话来批评别人的人。这种用法最终为“cynic”一词的现代含义打下了基础：一个人认为其他人都是出于纯粹的个人利益行事，即使他们声称有更高尚的动机。  \n然而，犬儒主义的哲学仍然令人钦佩，尤其是那些希望质疑社会状况的人。18世纪的法国哲学家让·雅克·卢梭（Jean-Jacques Rousseau）称艺术，科学和技术使人们腐败，因此被称为“新的第欧根尼”。  \n1882年，尼采（Friedrich Nietzsche）重现了一个故事，第欧根尼（Diogenes）带着灯笼进入雅典市场，徒劳地寻找一个诚实的人。在尼采的版本中，一个所谓的疯子冲进了一个城市广场，宣称“上帝已经死了”。  \n这是尼采呼吁“价值重估”的方式，他反对基督教和柏拉图关于超越物质世界的普世的，关于精神见解的主导思想。尼采赞扬第欧根尼坚决坚持活在当下。  \n最近，人们将1960年代的嬉皮士与第欧根尼（Diogenes）作为反正统文化者进行了比较。第欧根尼的思想被一遍又一遍地重新构想。  \n最初的犬儒主义者可能不赞成这些新观点：他们认为反对惯例和亲近自然的价值观是唯一的真价值观。无论您是否同意这一点，或以后的任何化身，它们都具有共同点：他们质疑现状。  \n这是我们仍然可以遵循的一个例子：不要盲目地遵循传统或多数人的观点，而要认真思考哪些东西真的有价值。批判性地思考我们的机构和生活方式比以往任何时候都重要。  \n用这些视频的观点来阐释你新发现的怀疑主义。\n\n> In the 4th century BCE, a banker's son threw the city of Sinope into scandal by counterfeiting coins. When the dust finally settled, the young man, Diogenes of Sinope, had been stripped of his citizenship, his money, and all his possessions.  \n> At least, that's how the story goes. While many of the details of Diogenes' life are shadowy, the philosophical ideas born out of his disgrace survive today.  \n> In exile, Diogenes decided that by rejecting the opinions of others and societal measures of success, he could be truly free. He would live self-sufficiently, close to nature, without materialism, vanity, or conformity.  \n> In practice, this meant he spent years wandering around Greek cities with nothing but a cloak, staff, and knapsack— outdoors year-round, forgoing technology, baths, and cooked food. He didn't go about this new existence quietly, but is said to have teased passers-by and mocked the powerful, eating, urinating and even masturbating in public.  \n> The citizens called him a *kyôn*— a barking dog. Though meant as an insult, dogs were actually a good symbol for his philosophy — they're happy creatures, free from abstractions like wealth or reputation.  \n> Diogenes and his growing number of followers became known as \"dog philosophers,\" or *kynikoi*, a designation that eventually became the word \"Cynic.\" These early Cynics were a carefree bunch, drawn to the freedom of a wandering lifestyle.  \n> As Diogenes' reputation grew, others tried to challenge his commitment. Alexander the Great offered him anything he desired. But instead of asking for material goods, Diogenes only asked Alexander to get out of his sunshine. After Diogenes' death, adherents to his philosophy continued to call themselves Cynics for about 900 years, until 500 CE.  \n> Some Greek philosophers, like the Stoics, thought everyone should follow Diogenes' example. They also attempted to tone down his philosophy to be more acceptable to conventional society — which, of course, was fundamentally at odds with his approach.  \n> Others viewed the Cynics less charitably. In the Roman province of Syria in the 2nd century CE, the satirist Lucian described the Cynics of his own time as unprincipled, materialistic, self-promoting hypocrites, who only preached what Diogenes had once actually practiced.  \n> Reading Lucian's texts centuries later, Renaissance and Reformation writers called their rivals *cynics* as an insult — meaning people who criticized others without having anything worthwhile to say. This usage eventually laid the groundwork for the modern meaning of the word \"cynic\": a person who thinks everyone else is acting out of pure self-interest, even if they claim a higher motive.  \n> Still, the philosophy of cynicism had admirers, especially among those who wished to question the state of society. The 18th-century French philosopher Jean-Jacques Rousseau was called the \"new Diogenes\" when he argued that the arts, sciences, and technology, corrupt people.  \n> In 1882, Friedrich Nietzsche reimagined a story in which Diogenes went into the Athenian marketplace with a lantern, searching in vain for a single honest person. In Nietzsche's version, a so-called madman rushes into a town square to proclaim that \"God is dead.\" This was Nietzsche's way of calling for a \"revaluation of values,\" and rejecting the dominant Christian and Platonic idea of universal, spiritual insights beyond the physical world. Nietzsche admired Diogenes for sticking stubbornly to the here-and-now.  \n> More recently, the hippies of the 1960s have been compared with Diogenes as counter-cultural rebels. Diogenes' ideas have been adopted and reimagined over and over again.  \n> The original cynics might not have approved of these fresh takes: they believed that their values of rejecting custom and living closely with nature were the only true values. Whether or not you agree with that, or with any of the later incarnations, all have one thing in common: they questioned the status quo.  \n> And that's an example we can still follow: not to blindly follow conventional or majority views, but to think hard about what is truly valuable. Thinking critically about our institutions and way of life is more important than ever.  \n> Hone your new-found skepticism with these videos.\n\n## Reference\n\n[【Ted-ED】犬儒主义的哲学 The Philosophy Of Cynicism](https://www.bilibili.com/video/BV1T7411b76u)  \n[什么是犬儒主义？](https://www.bilibili.com/video/BV1du4y1L7z2)  \n[对犬儒主义的灵魂拷问](https://www.bilibili.com/video/BV11r4y1J7Jk)  \n[齐泽克为什么是错的？或犬儒为什么是一个糟糕的概念，和大露恶的赛博空间。](https://www.bilibili.com/video/BV1PU4y1Q7pi)  \n[到底什么是犬儒主义？ - 知乎](https://www.zhihu.com/question/48307164)  \n[犬儒主义者：“像狗一样活着” - 知乎](https://zhuanlan.zhihu.com/p/421933857)","source":"_posts/Dog Philosophers.md","raw":"---\ntitle: 何为犬儒主义\nmath: true\ntags: [哲学,犬儒主义]\nindex_img: \nbanner_img: \ndate: 2025-08-17 16:23:10\ntypora-root-url: ../\n---\n\n“我希望你闪到一边，不要挡住我的阳光。”\n\n“我若不是亚历山大，我愿是第欧根尼。”  \n<!--more-->\n\n# 何为犬儒主义\n\n## 安提斯泰尼、第欧根尼、犬儒主义\n\n安提斯泰尼 其实是犬儒主义的开山鼻祖，是苏格拉底的学生。  \n第欧根尼在旅行中遇到了安提斯泰尼，想拜他为师，但是安提斯泰尼不喜欢他，因为第欧根尼曾涂改货币导致第欧根尼的父亲入狱。  \n但是第欧根尼的倔强打动了他，安提斯泰尼提出了犬儒主义，第欧根尼则是有名的践行者。\n\n> 人的苦痛有两种，一种源于物质，一种源于精神。精神上的幸福快乐才是真正的快乐满足，人当摆脱世俗的利益去追求唯一值得拥有的善。\n>\n> 犬儒主义\n\n### 第欧根尼\n\n在公元前4世纪，一位银行家的儿子通过伪造硬币使锡诺佩市陷入丑闻。当尘埃落定之后，这位名叫第欧根尼的年轻人被剥夺了 国籍，钱和所有财产。  \n至少，故事就是这样发展的。尽管戴第欧根尼的许多细节鲜为人知，但因他的耻辱而产生的哲学思想在今天仍然存在。  \n在流放中，第欧根尼（Diogenes）相信通过拒绝他人的意见和社会衡量成功的标准，他可以真正获得自由。他将过着自给自足的生活，亲近大自然，不主张物质主义，没有虚荣心或顺从性。  \n在实践中，这意味着他在希腊的城市中流浪了很多年，除了斗篷，拐杖和面包袋外什么都没有，一年四季都在外，不使用技术，不洗澡也不吃熟食。他并没有悄悄地追求这种新的存在方式，据说他取笑路人，并在公共场合通过模仿 那些有权势的人吃饭，小便，甚至自慰来嘲笑他们。  \n市民称他为 kyôn——一种狂吠的狗。虽然是一种侮辱，但实际上狗是他哲学的一个很好的象征——它们是快乐的动物，不被财富或声誉之类的抽象概念束缚。  \n第欧根尼和他越来越多的追随者被称为“狗哲学家”或“ kynikoi”，这一称号最终成为“犬儒主义”一词。这些早期的犬儒主义者无拘无束，被流浪的生活方式所吸引。  \n随着戴奥真尼斯声誉的提高，其他人试图挑战他的信仰。亚历山大大帝向他提供了他想要的任何东西。  \n但是，第欧根尼（Diogenes）并没有要求任何物资，而是要求亚历山大闪到一边去，不要遮住他的阳光。第欧根尼死后，在接下来的900年，坚持他的哲学的人继续称自己为犬儒主义者，直到500 CE。  \n一些希腊哲学家，例如斯多葛派（Stoics），认为每个人都应该效法第欧根尼。他们还试图柔和他的哲学，使其更能被传统社会接受，这当然与他的作法根本背道而驰。  \n其他人则不那么乐于接受 犬儒主义者。讽刺作家卢西安（Lucian）在公元2世纪在罗马的叙利亚省中，将自己时代的犬儒主义者描述为无原则，唯物主义，自我推广的伪君子，他们只宣讲了第欧根尼曾经真正实践过的东西。  \n几个世纪后，文艺复兴与宗教改革派作家阅读卢西安的著作，称他们的竞争对手为犬儒主义作为侮辱，指那些用毫无价值的话来批评别人的人。这种用法最终为“cynic”一词的现代含义打下了基础：一个人认为其他人都是出于纯粹的个人利益行事，即使他们声称有更高尚的动机。  \n然而，犬儒主义的哲学仍然令人钦佩，尤其是那些希望质疑社会状况的人。18世纪的法国哲学家让·雅克·卢梭（Jean-Jacques Rousseau）称艺术，科学和技术使人们腐败，因此被称为“新的第欧根尼”。  \n1882年，尼采（Friedrich Nietzsche）重现了一个故事，第欧根尼（Diogenes）带着灯笼进入雅典市场，徒劳地寻找一个诚实的人。在尼采的版本中，一个所谓的疯子冲进了一个城市广场，宣称“上帝已经死了”。  \n这是尼采呼吁“价值重估”的方式，他反对基督教和柏拉图关于超越物质世界的普世的，关于精神见解的主导思想。尼采赞扬第欧根尼坚决坚持活在当下。  \n最近，人们将1960年代的嬉皮士与第欧根尼（Diogenes）作为反正统文化者进行了比较。第欧根尼的思想被一遍又一遍地重新构想。  \n最初的犬儒主义者可能不赞成这些新观点：他们认为反对惯例和亲近自然的价值观是唯一的真价值观。无论您是否同意这一点，或以后的任何化身，它们都具有共同点：他们质疑现状。  \n这是我们仍然可以遵循的一个例子：不要盲目地遵循传统或多数人的观点，而要认真思考哪些东西真的有价值。批判性地思考我们的机构和生活方式比以往任何时候都重要。  \n用这些视频的观点来阐释你新发现的怀疑主义。\n\n> In the 4th century BCE, a banker's son threw the city of Sinope into scandal by counterfeiting coins. When the dust finally settled, the young man, Diogenes of Sinope, had been stripped of his citizenship, his money, and all his possessions.  \n> At least, that's how the story goes. While many of the details of Diogenes' life are shadowy, the philosophical ideas born out of his disgrace survive today.  \n> In exile, Diogenes decided that by rejecting the opinions of others and societal measures of success, he could be truly free. He would live self-sufficiently, close to nature, without materialism, vanity, or conformity.  \n> In practice, this meant he spent years wandering around Greek cities with nothing but a cloak, staff, and knapsack— outdoors year-round, forgoing technology, baths, and cooked food. He didn't go about this new existence quietly, but is said to have teased passers-by and mocked the powerful, eating, urinating and even masturbating in public.  \n> The citizens called him a *kyôn*— a barking dog. Though meant as an insult, dogs were actually a good symbol for his philosophy — they're happy creatures, free from abstractions like wealth or reputation.  \n> Diogenes and his growing number of followers became known as \"dog philosophers,\" or *kynikoi*, a designation that eventually became the word \"Cynic.\" These early Cynics were a carefree bunch, drawn to the freedom of a wandering lifestyle.  \n> As Diogenes' reputation grew, others tried to challenge his commitment. Alexander the Great offered him anything he desired. But instead of asking for material goods, Diogenes only asked Alexander to get out of his sunshine. After Diogenes' death, adherents to his philosophy continued to call themselves Cynics for about 900 years, until 500 CE.  \n> Some Greek philosophers, like the Stoics, thought everyone should follow Diogenes' example. They also attempted to tone down his philosophy to be more acceptable to conventional society — which, of course, was fundamentally at odds with his approach.  \n> Others viewed the Cynics less charitably. In the Roman province of Syria in the 2nd century CE, the satirist Lucian described the Cynics of his own time as unprincipled, materialistic, self-promoting hypocrites, who only preached what Diogenes had once actually practiced.  \n> Reading Lucian's texts centuries later, Renaissance and Reformation writers called their rivals *cynics* as an insult — meaning people who criticized others without having anything worthwhile to say. This usage eventually laid the groundwork for the modern meaning of the word \"cynic\": a person who thinks everyone else is acting out of pure self-interest, even if they claim a higher motive.  \n> Still, the philosophy of cynicism had admirers, especially among those who wished to question the state of society. The 18th-century French philosopher Jean-Jacques Rousseau was called the \"new Diogenes\" when he argued that the arts, sciences, and technology, corrupt people.  \n> In 1882, Friedrich Nietzsche reimagined a story in which Diogenes went into the Athenian marketplace with a lantern, searching in vain for a single honest person. In Nietzsche's version, a so-called madman rushes into a town square to proclaim that \"God is dead.\" This was Nietzsche's way of calling for a \"revaluation of values,\" and rejecting the dominant Christian and Platonic idea of universal, spiritual insights beyond the physical world. Nietzsche admired Diogenes for sticking stubbornly to the here-and-now.  \n> More recently, the hippies of the 1960s have been compared with Diogenes as counter-cultural rebels. Diogenes' ideas have been adopted and reimagined over and over again.  \n> The original cynics might not have approved of these fresh takes: they believed that their values of rejecting custom and living closely with nature were the only true values. Whether or not you agree with that, or with any of the later incarnations, all have one thing in common: they questioned the status quo.  \n> And that's an example we can still follow: not to blindly follow conventional or majority views, but to think hard about what is truly valuable. Thinking critically about our institutions and way of life is more important than ever.  \n> Hone your new-found skepticism with these videos.\n\n## Reference\n\n[【Ted-ED】犬儒主义的哲学 The Philosophy Of Cynicism](https://www.bilibili.com/video/BV1T7411b76u)  \n[什么是犬儒主义？](https://www.bilibili.com/video/BV1du4y1L7z2)  \n[对犬儒主义的灵魂拷问](https://www.bilibili.com/video/BV11r4y1J7Jk)  \n[齐泽克为什么是错的？或犬儒为什么是一个糟糕的概念，和大露恶的赛博空间。](https://www.bilibili.com/video/BV1PU4y1Q7pi)  \n[到底什么是犬儒主义？ - 知乎](https://www.zhihu.com/question/48307164)  \n[犬儒主义者：“像狗一样活着” - 知乎](https://zhuanlan.zhihu.com/p/421933857)","slug":"Dog Philosophers","published":1,"updated":"2025-08-17T08:54:53.026Z","_id":"cmefg5veq000060bwg1ff97cy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>“我希望你闪到一边，不要挡住我的阳光。”</p>\r\n<p>“我若不是亚历山大，我愿是第欧根尼。”<br />\r\n<span id=\"more\"></span></p>\r\n<h1 id=\"何为犬儒主义\">何为犬儒主义</h1>\r\n<h2 id=\"安提斯泰尼第欧根尼犬儒主义\">安提斯泰尼、第欧根尼、犬儒主义</h2>\r\n<p>安提斯泰尼 其实是犬儒主义的开山鼻祖，是苏格拉底的学生。<br />\r\n第欧根尼在旅行中遇到了安提斯泰尼，想拜他为师，但是安提斯泰尼不喜欢他，因为第欧根尼曾涂改货币导致第欧根尼的父亲入狱。<br />\r\n但是第欧根尼的倔强打动了他，安提斯泰尼提出了犬儒主义，第欧根尼则是有名的践行者。</p>\r\n<blockquote>\r\n<p>人的苦痛有两种，一种源于物质，一种源于精神。精神上的幸福快乐才是真正的快乐满足，人当摆脱世俗的利益去追求唯一值得拥有的善。</p>\r\n<p>犬儒主义</p>\r\n</blockquote>\r\n<h3 id=\"第欧根尼\">第欧根尼</h3>\r\n<p>在公元前4世纪，一位银行家的儿子通过伪造硬币使锡诺佩市陷入丑闻。当尘埃落定之后，这位名叫第欧根尼的年轻人被剥夺了\r\n国籍，钱和所有财产。<br />\r\n至少，故事就是这样发展的。尽管戴第欧根尼的许多细节鲜为人知，但因他的耻辱而产生的哲学思想在今天仍然存在。<br />\r\n在流放中，第欧根尼（Diogenes）相信通过拒绝他人的意见和社会衡量成功的标准，他可以真正获得自由。他将过着自给自足的生活，亲近大自然，不主张物质主义，没有虚荣心或顺从性。<br />\r\n在实践中，这意味着他在希腊的城市中流浪了很多年，除了斗篷，拐杖和面包袋外什么都没有，一年四季都在外，不使用技术，不洗澡也不吃熟食。他并没有悄悄地追求这种新的存在方式，据说他取笑路人，并在公共场合通过模仿\r\n那些有权势的人吃饭，小便，甚至自慰来嘲笑他们。<br />\r\n市民称他为\r\nkyôn——一种狂吠的狗。虽然是一种侮辱，但实际上狗是他哲学的一个很好的象征——它们是快乐的动物，不被财富或声誉之类的抽象概念束缚。<br />\r\n第欧根尼和他越来越多的追随者被称为“狗哲学家”或“\r\nkynikoi”，这一称号最终成为“犬儒主义”一词。这些早期的犬儒主义者无拘无束，被流浪的生活方式所吸引。<br />\r\n随着戴奥真尼斯声誉的提高，其他人试图挑战他的信仰。亚历山大大帝向他提供了他想要的任何东西。<br />\r\n但是，第欧根尼（Diogenes）并没有要求任何物资，而是要求亚历山大闪到一边去，不要遮住他的阳光。第欧根尼死后，在接下来的900年，坚持他的哲学的人继续称自己为犬儒主义者，直到500\r\nCE。<br />\r\n一些希腊哲学家，例如斯多葛派（Stoics），认为每个人都应该效法第欧根尼。他们还试图柔和他的哲学，使其更能被传统社会接受，这当然与他的作法根本背道而驰。<br />\r\n其他人则不那么乐于接受\r\n犬儒主义者。讽刺作家卢西安（Lucian）在公元2世纪在罗马的叙利亚省中，将自己时代的犬儒主义者描述为无原则，唯物主义，自我推广的伪君子，他们只宣讲了第欧根尼曾经真正实践过的东西。<br />\r\n几个世纪后，文艺复兴与宗教改革派作家阅读卢西安的著作，称他们的竞争对手为犬儒主义作为侮辱，指那些用毫无价值的话来批评别人的人。这种用法最终为“cynic”一词的现代含义打下了基础：一个人认为其他人都是出于纯粹的个人利益行事，即使他们声称有更高尚的动机。<br />\r\n然而，犬儒主义的哲学仍然令人钦佩，尤其是那些希望质疑社会状况的人。18世纪的法国哲学家让·雅克·卢梭（Jean-Jacques\r\nRousseau）称艺术，科学和技术使人们腐败，因此被称为“新的第欧根尼”。<br />\r\n1882年，尼采（Friedrich\r\nNietzsche）重现了一个故事，第欧根尼（Diogenes）带着灯笼进入雅典市场，徒劳地寻找一个诚实的人。在尼采的版本中，一个所谓的疯子冲进了一个城市广场，宣称“上帝已经死了”。<br />\r\n这是尼采呼吁“价值重估”的方式，他反对基督教和柏拉图关于超越物质世界的普世的，关于精神见解的主导思想。尼采赞扬第欧根尼坚决坚持活在当下。<br />\r\n最近，人们将1960年代的嬉皮士与第欧根尼（Diogenes）作为反正统文化者进行了比较。第欧根尼的思想被一遍又一遍地重新构想。<br />\r\n最初的犬儒主义者可能不赞成这些新观点：他们认为反对惯例和亲近自然的价值观是唯一的真价值观。无论您是否同意这一点，或以后的任何化身，它们都具有共同点：他们质疑现状。<br />\r\n这是我们仍然可以遵循的一个例子：不要盲目地遵循传统或多数人的观点，而要认真思考哪些东西真的有价值。批判性地思考我们的机构和生活方式比以往任何时候都重要。<br />\r\n用这些视频的观点来阐释你新发现的怀疑主义。</p>\r\n<blockquote>\r\n<p>In the 4th century BCE, a banker's son threw the city of Sinope into\r\nscandal by counterfeiting coins. When the dust finally settled, the\r\nyoung man, Diogenes of Sinope, had been stripped of his citizenship, his\r\nmoney, and all his possessions.<br />\r\nAt least, that's how the story goes. While many of the details of\r\nDiogenes' life are shadowy, the philosophical ideas born out of his\r\ndisgrace survive today.<br />\r\nIn exile, Diogenes decided that by rejecting the opinions of others and\r\nsocietal measures of success, he could be truly free. He would live\r\nself-sufficiently, close to nature, without materialism, vanity, or\r\nconformity.<br />\r\nIn practice, this meant he spent years wandering around Greek cities\r\nwith nothing but a cloak, staff, and knapsack— outdoors year-round,\r\nforgoing technology, baths, and cooked food. He didn't go about this new\r\nexistence quietly, but is said to have teased passers-by and mocked the\r\npowerful, eating, urinating and even masturbating in public.<br />\r\nThe citizens called him a <em>kyôn</em>— a barking dog. Though meant as\r\nan insult, dogs were actually a good symbol for his philosophy — they're\r\nhappy creatures, free from abstractions like wealth or reputation.<br />\r\nDiogenes and his growing number of followers became known as \"dog\r\nphilosophers,\" or <em>kynikoi</em>, a designation that eventually became\r\nthe word \"Cynic.\" These early Cynics were a carefree bunch, drawn to the\r\nfreedom of a wandering lifestyle.<br />\r\nAs Diogenes' reputation grew, others tried to challenge his commitment.\r\nAlexander the Great offered him anything he desired. But instead of\r\nasking for material goods, Diogenes only asked Alexander to get out of\r\nhis sunshine. After Diogenes' death, adherents to his philosophy\r\ncontinued to call themselves Cynics for about 900 years, until 500\r\nCE.<br />\r\nSome Greek philosophers, like the Stoics, thought everyone should follow\r\nDiogenes' example. They also attempted to tone down his philosophy to be\r\nmore acceptable to conventional society — which, of course, was\r\nfundamentally at odds with his approach.<br />\r\nOthers viewed the Cynics less charitably. In the Roman province of Syria\r\nin the 2nd century CE, the satirist Lucian described the Cynics of his\r\nown time as unprincipled, materialistic, self-promoting hypocrites, who\r\nonly preached what Diogenes had once actually practiced.<br />\r\nReading Lucian's texts centuries later, Renaissance and Reformation\r\nwriters called their rivals <em>cynics</em> as an insult — meaning\r\npeople who criticized others without having anything worthwhile to say.\r\nThis usage eventually laid the groundwork for the modern meaning of the\r\nword \"cynic\": a person who thinks everyone else is acting out of pure\r\nself-interest, even if they claim a higher motive.<br />\r\nStill, the philosophy of cynicism had admirers, especially among those\r\nwho wished to question the state of society. The 18th-century French\r\nphilosopher Jean-Jacques Rousseau was called the \"new Diogenes\" when he\r\nargued that the arts, sciences, and technology, corrupt people.<br />\r\nIn 1882, Friedrich Nietzsche reimagined a story in which Diogenes went\r\ninto the Athenian marketplace with a lantern, searching in vain for a\r\nsingle honest person. In Nietzsche's version, a so-called madman rushes\r\ninto a town square to proclaim that \"God is dead.\" This was Nietzsche's\r\nway of calling for a \"revaluation of values,\" and rejecting the dominant\r\nChristian and Platonic idea of universal, spiritual insights beyond the\r\nphysical world. Nietzsche admired Diogenes for sticking stubbornly to\r\nthe here-and-now.<br />\r\nMore recently, the hippies of the 1960s have been compared with Diogenes\r\nas counter-cultural rebels. Diogenes' ideas have been adopted and\r\nreimagined over and over again.<br />\r\nThe original cynics might not have approved of these fresh takes: they\r\nbelieved that their values of rejecting custom and living closely with\r\nnature were the only true values. Whether or not you agree with that, or\r\nwith any of the later incarnations, all have one thing in common: they\r\nquestioned the status quo.<br />\r\nAnd that's an example we can still follow: not to blindly follow\r\nconventional or majority views, but to think hard about what is truly\r\nvaluable. Thinking critically about our institutions and way of life is\r\nmore important than ever.<br />\r\nHone your new-found skepticism with these videos.</p>\r\n</blockquote>\r\n<h2 id=\"reference\">Reference</h2>\r\n<p><a\r\nhref=\"https://www.bilibili.com/video/BV1T7411b76u\">【Ted-ED】犬儒主义的哲学\r\nThe Philosophy Of Cynicism</a><br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV1du4y1L7z2\">什么是犬儒主义？</a><br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV11r4y1J7Jk\">对犬儒主义的灵魂拷问</a><br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV1PU4y1Q7pi\">齐泽克为什么是错的？或犬儒为什么是一个糟糕的概念，和大露恶的赛博空间。</a><br />\r\n<a href=\"https://www.zhihu.com/question/48307164\">到底什么是犬儒主义？ -\r\n知乎</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/421933857\">犬儒主义者：“像狗一样活着”\r\n- 知乎</a></p>\r\n","site":{"data":{}},"excerpt":"<p>“我希望你闪到一边，不要挡住我的阳光。”</p>\r\n<p>“我若不是亚历山大，我愿是第欧根尼。”<br />","more":"</p>\r\n<h1 id=\"何为犬儒主义\">何为犬儒主义</h1>\r\n<h2 id=\"安提斯泰尼第欧根尼犬儒主义\">安提斯泰尼、第欧根尼、犬儒主义</h2>\r\n<p>安提斯泰尼 其实是犬儒主义的开山鼻祖，是苏格拉底的学生。<br />\r\n第欧根尼在旅行中遇到了安提斯泰尼，想拜他为师，但是安提斯泰尼不喜欢他，因为第欧根尼曾涂改货币导致第欧根尼的父亲入狱。<br />\r\n但是第欧根尼的倔强打动了他，安提斯泰尼提出了犬儒主义，第欧根尼则是有名的践行者。</p>\r\n<blockquote>\r\n<p>人的苦痛有两种，一种源于物质，一种源于精神。精神上的幸福快乐才是真正的快乐满足，人当摆脱世俗的利益去追求唯一值得拥有的善。</p>\r\n<p>犬儒主义</p>\r\n</blockquote>\r\n<h3 id=\"第欧根尼\">第欧根尼</h3>\r\n<p>在公元前4世纪，一位银行家的儿子通过伪造硬币使锡诺佩市陷入丑闻。当尘埃落定之后，这位名叫第欧根尼的年轻人被剥夺了\r\n国籍，钱和所有财产。<br />\r\n至少，故事就是这样发展的。尽管戴第欧根尼的许多细节鲜为人知，但因他的耻辱而产生的哲学思想在今天仍然存在。<br />\r\n在流放中，第欧根尼（Diogenes）相信通过拒绝他人的意见和社会衡量成功的标准，他可以真正获得自由。他将过着自给自足的生活，亲近大自然，不主张物质主义，没有虚荣心或顺从性。<br />\r\n在实践中，这意味着他在希腊的城市中流浪了很多年，除了斗篷，拐杖和面包袋外什么都没有，一年四季都在外，不使用技术，不洗澡也不吃熟食。他并没有悄悄地追求这种新的存在方式，据说他取笑路人，并在公共场合通过模仿\r\n那些有权势的人吃饭，小便，甚至自慰来嘲笑他们。<br />\r\n市民称他为\r\nkyôn——一种狂吠的狗。虽然是一种侮辱，但实际上狗是他哲学的一个很好的象征——它们是快乐的动物，不被财富或声誉之类的抽象概念束缚。<br />\r\n第欧根尼和他越来越多的追随者被称为“狗哲学家”或“\r\nkynikoi”，这一称号最终成为“犬儒主义”一词。这些早期的犬儒主义者无拘无束，被流浪的生活方式所吸引。<br />\r\n随着戴奥真尼斯声誉的提高，其他人试图挑战他的信仰。亚历山大大帝向他提供了他想要的任何东西。<br />\r\n但是，第欧根尼（Diogenes）并没有要求任何物资，而是要求亚历山大闪到一边去，不要遮住他的阳光。第欧根尼死后，在接下来的900年，坚持他的哲学的人继续称自己为犬儒主义者，直到500\r\nCE。<br />\r\n一些希腊哲学家，例如斯多葛派（Stoics），认为每个人都应该效法第欧根尼。他们还试图柔和他的哲学，使其更能被传统社会接受，这当然与他的作法根本背道而驰。<br />\r\n其他人则不那么乐于接受\r\n犬儒主义者。讽刺作家卢西安（Lucian）在公元2世纪在罗马的叙利亚省中，将自己时代的犬儒主义者描述为无原则，唯物主义，自我推广的伪君子，他们只宣讲了第欧根尼曾经真正实践过的东西。<br />\r\n几个世纪后，文艺复兴与宗教改革派作家阅读卢西安的著作，称他们的竞争对手为犬儒主义作为侮辱，指那些用毫无价值的话来批评别人的人。这种用法最终为“cynic”一词的现代含义打下了基础：一个人认为其他人都是出于纯粹的个人利益行事，即使他们声称有更高尚的动机。<br />\r\n然而，犬儒主义的哲学仍然令人钦佩，尤其是那些希望质疑社会状况的人。18世纪的法国哲学家让·雅克·卢梭（Jean-Jacques\r\nRousseau）称艺术，科学和技术使人们腐败，因此被称为“新的第欧根尼”。<br />\r\n1882年，尼采（Friedrich\r\nNietzsche）重现了一个故事，第欧根尼（Diogenes）带着灯笼进入雅典市场，徒劳地寻找一个诚实的人。在尼采的版本中，一个所谓的疯子冲进了一个城市广场，宣称“上帝已经死了”。<br />\r\n这是尼采呼吁“价值重估”的方式，他反对基督教和柏拉图关于超越物质世界的普世的，关于精神见解的主导思想。尼采赞扬第欧根尼坚决坚持活在当下。<br />\r\n最近，人们将1960年代的嬉皮士与第欧根尼（Diogenes）作为反正统文化者进行了比较。第欧根尼的思想被一遍又一遍地重新构想。<br />\r\n最初的犬儒主义者可能不赞成这些新观点：他们认为反对惯例和亲近自然的价值观是唯一的真价值观。无论您是否同意这一点，或以后的任何化身，它们都具有共同点：他们质疑现状。<br />\r\n这是我们仍然可以遵循的一个例子：不要盲目地遵循传统或多数人的观点，而要认真思考哪些东西真的有价值。批判性地思考我们的机构和生活方式比以往任何时候都重要。<br />\r\n用这些视频的观点来阐释你新发现的怀疑主义。</p>\r\n<blockquote>\r\n<p>In the 4th century BCE, a banker's son threw the city of Sinope into\r\nscandal by counterfeiting coins. When the dust finally settled, the\r\nyoung man, Diogenes of Sinope, had been stripped of his citizenship, his\r\nmoney, and all his possessions.<br />\r\nAt least, that's how the story goes. While many of the details of\r\nDiogenes' life are shadowy, the philosophical ideas born out of his\r\ndisgrace survive today.<br />\r\nIn exile, Diogenes decided that by rejecting the opinions of others and\r\nsocietal measures of success, he could be truly free. He would live\r\nself-sufficiently, close to nature, without materialism, vanity, or\r\nconformity.<br />\r\nIn practice, this meant he spent years wandering around Greek cities\r\nwith nothing but a cloak, staff, and knapsack— outdoors year-round,\r\nforgoing technology, baths, and cooked food. He didn't go about this new\r\nexistence quietly, but is said to have teased passers-by and mocked the\r\npowerful, eating, urinating and even masturbating in public.<br />\r\nThe citizens called him a <em>kyôn</em>— a barking dog. Though meant as\r\nan insult, dogs were actually a good symbol for his philosophy — they're\r\nhappy creatures, free from abstractions like wealth or reputation.<br />\r\nDiogenes and his growing number of followers became known as \"dog\r\nphilosophers,\" or <em>kynikoi</em>, a designation that eventually became\r\nthe word \"Cynic.\" These early Cynics were a carefree bunch, drawn to the\r\nfreedom of a wandering lifestyle.<br />\r\nAs Diogenes' reputation grew, others tried to challenge his commitment.\r\nAlexander the Great offered him anything he desired. But instead of\r\nasking for material goods, Diogenes only asked Alexander to get out of\r\nhis sunshine. After Diogenes' death, adherents to his philosophy\r\ncontinued to call themselves Cynics for about 900 years, until 500\r\nCE.<br />\r\nSome Greek philosophers, like the Stoics, thought everyone should follow\r\nDiogenes' example. They also attempted to tone down his philosophy to be\r\nmore acceptable to conventional society — which, of course, was\r\nfundamentally at odds with his approach.<br />\r\nOthers viewed the Cynics less charitably. In the Roman province of Syria\r\nin the 2nd century CE, the satirist Lucian described the Cynics of his\r\nown time as unprincipled, materialistic, self-promoting hypocrites, who\r\nonly preached what Diogenes had once actually practiced.<br />\r\nReading Lucian's texts centuries later, Renaissance and Reformation\r\nwriters called their rivals <em>cynics</em> as an insult — meaning\r\npeople who criticized others without having anything worthwhile to say.\r\nThis usage eventually laid the groundwork for the modern meaning of the\r\nword \"cynic\": a person who thinks everyone else is acting out of pure\r\nself-interest, even if they claim a higher motive.<br />\r\nStill, the philosophy of cynicism had admirers, especially among those\r\nwho wished to question the state of society. The 18th-century French\r\nphilosopher Jean-Jacques Rousseau was called the \"new Diogenes\" when he\r\nargued that the arts, sciences, and technology, corrupt people.<br />\r\nIn 1882, Friedrich Nietzsche reimagined a story in which Diogenes went\r\ninto the Athenian marketplace with a lantern, searching in vain for a\r\nsingle honest person. In Nietzsche's version, a so-called madman rushes\r\ninto a town square to proclaim that \"God is dead.\" This was Nietzsche's\r\nway of calling for a \"revaluation of values,\" and rejecting the dominant\r\nChristian and Platonic idea of universal, spiritual insights beyond the\r\nphysical world. Nietzsche admired Diogenes for sticking stubbornly to\r\nthe here-and-now.<br />\r\nMore recently, the hippies of the 1960s have been compared with Diogenes\r\nas counter-cultural rebels. Diogenes' ideas have been adopted and\r\nreimagined over and over again.<br />\r\nThe original cynics might not have approved of these fresh takes: they\r\nbelieved that their values of rejecting custom and living closely with\r\nnature were the only true values. Whether or not you agree with that, or\r\nwith any of the later incarnations, all have one thing in common: they\r\nquestioned the status quo.<br />\r\nAnd that's an example we can still follow: not to blindly follow\r\nconventional or majority views, but to think hard about what is truly\r\nvaluable. Thinking critically about our institutions and way of life is\r\nmore important than ever.<br />\r\nHone your new-found skepticism with these videos.</p>\r\n</blockquote>\r\n<h2 id=\"reference\">Reference</h2>\r\n<p><a\r\nhref=\"https://www.bilibili.com/video/BV1T7411b76u\">【Ted-ED】犬儒主义的哲学\r\nThe Philosophy Of Cynicism</a><br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV1du4y1L7z2\">什么是犬儒主义？</a><br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV11r4y1J7Jk\">对犬儒主义的灵魂拷问</a><br />\r\n<a\r\nhref=\"https://www.bilibili.com/video/BV1PU4y1Q7pi\">齐泽克为什么是错的？或犬儒为什么是一个糟糕的概念，和大露恶的赛博空间。</a><br />\r\n<a href=\"https://www.zhihu.com/question/48307164\">到底什么是犬儒主义？ -\r\n知乎</a><br />\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/421933857\">犬儒主义者：“像狗一样活着”\r\n- 知乎</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cme8ppthz0006bkbw8al1bmcm","tag_id":"cme8ppthz0008bkbwd3u52i5v","_id":"cme8ppti2000hbkbw5ux0fm2v"},{"post_id":"cme8ppthz0006bkbw8al1bmcm","tag_id":"cme8ppti1000cbkbwg61j1jwj","_id":"cme8ppti3000jbkbw2bnz7cev"},{"post_id":"cme8ppti3000lbkbwghf1bi6a","tag_id":"cme8ppthz0008bkbwd3u52i5v","_id":"cme8ppti3000nbkbw32u23hsh"},{"post_id":"cme8ppti00009bkbw43ov26em","tag_id":"cme8ppti2000fbkbw5g3wh7ct","_id":"cme8ppti3000pbkbwcidfewdj"},{"post_id":"cme8ppti00009bkbw43ov26em","tag_id":"cme8ppti3000kbkbwebg95cyu","_id":"cme8ppti4000sbkbw4mmocfyo"},{"post_id":"cme8ppti4000tbkbw8t92ge5a","tag_id":"cme8ppthz0008bkbwd3u52i5v","_id":"cme8ppti4000vbkbw4h32b95t"},{"post_id":"cme8ppti4000ubkbw623g8kvp","tag_id":"cme8ppthz0008bkbwd3u52i5v","_id":"cme8ppti5000ybkbw8nnu6khl"},{"post_id":"cme8ppti3000obkbw0gbbfhvp","tag_id":"cme8ppti4000rbkbw1ofbcaba","_id":"cme8ppti50010bkbwcgb48zre"},{"post_id":"cme8ppti3000obkbw0gbbfhvp","tag_id":"cme8ppti1000cbkbwg61j1jwj","_id":"cme8ppti50013bkbw4ftmdt0k"},{"post_id":"cme8ppti4000qbkbw5spvcs3l","tag_id":"cme8ppti4000xbkbw8dpx31hz","_id":"cme8ppti50015bkbwe1bab5hz"},{"post_id":"cme8ppti5000zbkbwgucg3w9i","tag_id":"cme8ppti50012bkbw8h4d9sz6","_id":"cme8ppti60018bkbw2ovm5wd2"},{"post_id":"cme8ppti6001abkbwbpuhgzjh","tag_id":"cme8ppti6001cbkbw383zavb0","_id":"cme8ppti7001gbkbwbr0s9h72"},{"post_id":"cme8ppti7001jbkbw9nqthfz5","tag_id":"cme8ppthz0008bkbwd3u52i5v","_id":"cme8ppti8001lbkbw55xi3xmq"},{"post_id":"cme8ppti7001kbkbwen6q1xbf","tag_id":"cme8ppti4000rbkbw1ofbcaba","_id":"cme8ppti8001mbkbw8etqbtjf"},{"post_id":"cme8ppti8001nbkbw6l697l0u","tag_id":"cme8ppti8001pbkbwgpabgzoz","_id":"cme8ppti9001sbkbwbmuifcff"},{"post_id":"cme8ppti8001obkbw735wb1ue","tag_id":"cme8ppti8001rbkbw2ow7ehyo","_id":"cme8ppti9001tbkbwdahs1lc8"},{"post_id":"cmed519pa00006sbw74ia3zg8","tag_id":"cmed519pc00016sbw2w0e15oy","_id":"cmed519pf00026sbw8kqh9uyp"},{"post_id":"cmefg5veq000060bwg1ff97cy","tag_id":"cmefg9xz30000y4bwegzwbaof","_id":"cmefg9xz40002y4bwfufrd3so"},{"post_id":"cmefg5veq000060bwg1ff97cy","tag_id":"cmefg9xz40001y4bwaxtsa3l3","_id":"cmefg9xz40003y4bwghpn563f"}],"Tag":[{"name":"图形学","_id":"cme8ppthz0008bkbwd3u52i5v"},{"name":"渲染","_id":"cme8ppti1000cbkbwg61j1jwj"},{"name":"Hexo","_id":"cme8ppti2000fbkbw5g3wh7ct"},{"name":"主题变更","_id":"cme8ppti3000kbkbwebg95cyu"},{"name":"Unity","_id":"cme8ppti4000rbkbw1ofbcaba"},{"name":"特效","_id":"cme8ppti4000xbkbw8dpx31hz"},{"name":"算法","_id":"cme8ppti50012bkbw8h4d9sz6"},{"name":"文学","_id":"cme8ppti6001cbkbw383zavb0"},{"name":"图形学, unity, C++","_id":"cme8ppti8001pbkbwgpabgzoz"},{"name":"图形学, unity","_id":"cme8ppti8001rbkbw2ow7ehyo"},{"name":"C++","_id":"cmed519pc00016sbw2w0e15oy"},{"name":"哲学","_id":"cmefg9xz30000y4bwegzwbaof"},{"name":"犬儒主义","_id":"cmefg9xz40001y4bwaxtsa3l3"}]}}